<!DOCTYPE html><html><head><meta http-equiv=Content-Type content="text/html; charset=utf-8"><title>Arbitrary-Precision Samplers for the Sum of Uniform Random Numbers</title><meta name="viewport" content="width=device-width"><link rel=stylesheet type="text/css" href="/style.css"></head><body>  <div class="header">
<nav><p><a href="#navigation">Menu</a> - <a href="#top">Top</a> - <a href="/">Home</a></nav></nav></div>
<div class="mainarea" id="top">
<h1>Arbitrary-Precision Samplers for the Sum of Uniform Random Numbers</h1>

<p><a href="mailto:poccil14@gmail.com"><strong>Peter Occil</strong></a></p>

<p>This page presents new algorithms to sample the sum of uniform(0, 1) random numbers, with the help of <a href="https://peteroupc.github.io/exporand.html"><strong>partially-sampled random numbers</strong></a>, with arbitrary precision and without relying on floating-point arithmetic.  See that page for more information on some of the algorithms made use of here, including <strong>SampleGeometricBag</strong> and <strong>FillGeometricBag</strong>.</p>

<p><a id=About_the_Uniform_Sum_Distribution></a></p>

<h2>About the Uniform Sum Distribution</h2>

<p>The sum of <em>n</em> uniform(0, 1) random numbers has the following density function (see <a href="https://mathworld.wolfram.com/UniformSumDistribution.html"><strong>MathWorld</strong></a>):</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;<em>f</em>(<em>x</em>) = (&Sigma;<sub><em>k</em> = 0, ..., <em>n</em></sub> (&minus;1)<sup><em>k</em></sup> * choose(<em>n</em>, <em>k</em>) * (<em>x</em> &minus; <em>k</em>)<sup><em>n</em> &minus; 1</sup> * sign(<em>x</em> &minus; <em>k</em>)) / (2*(n&minus;1)!).</p>

<p>For <em>n</em> uniform numbers, the distribution can take on values in the interval [0, <em>n</em>].  Note also that the density expresses a polynomial of degree <em>n</em> &minus; 1.</p>

<p>The samplers given below for the uniform sum logically work as follows:</p>

<ol>
<li>The distribution is divided into pieces that are each 1 unit wide (thus, for example, if <em>n</em> is 4, there will be four pieces).</li>
<li>An integer in [0, <em>n</em>) is chosen uniformly at random, call it <em>i</em>, then the piece identified by <em>i</em> is chosen.  There are <a href="https://peteroupc.github.io/randomnotes.html#A_Note_on_Integer_Generation_Algorithms"><strong>many algorithms to choose an integer</strong></a> this way, but an algorithm that is &quot;optimal&quot; in terms of the number of bits it uses, as well as unbiased, should be chosen.</li>
<li><p>The density function at [<em>i</em>, <em>i</em> + 1] is simulated.  This is done by shifting the density so the desired piece of the density is at [0, 1] rather than its usual place.  More specifically, the density is now as follows:</p>

<ul>
<li><em>f</em>&prime;(<em>x</em>) = (&Sigma;<sub><em>k</em> = 0, ..., <em>n</em></sub> (&minus;1)<sup><em>k</em></sup> * choose(<em>n</em>, <em>k</em>) * ((<em>x</em> + <em>i</em>) &minus; <em>k</em>)<sup><em>n</em> &minus; 1</sup> * sign(<em>i</em> &minus; <em>k</em>)) / (2*(n&minus;1)!),</li>
</ul>

<p>where <em>x</em> is a real number in [0, 1].  Since <em>f</em>&prime; is a polynomial, it can be converted to a Bernstein polynomial whose control points describe the shape of the curve drawn out by <em>f</em>&prime;.  A Bernstein polynomial has the form&mdash;</p>

<ul>
<li>&Sigma;<sub><em>k</em> = 0, ..., <em>m</em></sub> choose(<em>m</em>, <em>k</em>) * <em>x</em><sup><em>k</em></sup> * (1 &minus; <em>x</em>)<sup><em>m</em> &minus; <em>k</em></sup> * <em>a</em>[<em>k</em>],</li>
</ul>

<p>where <em>a</em>[<em>k</em>] are the control points and <em>m</em> is the polynomial&#39;s degree (here, <em>n</em> &minus; 1). In this case, there will be <em>n</em> control points, which together trace out a 1-dimensional Bézier curve.  Moreover, this polynomial can be simulated because it is continuous, returns only numbers in [0, 1], and doesn&#39;t touch 0 or 1 anywhere inside the domain (except possibly at 0 and/or 1) (Keane and O&#39;Brien 1994)<sup><a href="#Note1"><strong>(1)</strong></a></sup>.</p></li>
<li>The sampler creates a &quot;coin&quot; made up of a uniform partially-sampled random number (PSRN) whose contents are built up on demand using an algorithm called <strong>SampleGeometricBag</strong>.  It flips this &quot;coin&quot; <em>n</em> &minus; 1 times and counts the number of times the coin returned 1 this way, call it <em>j</em>. (The &quot;coin&quot; will return 1 with probability equal to the to-be-determined uniform random number.  See (Goyal and Sigman 2012)<sup><a href="#Note2"><strong>(2)</strong></a></sup>.)</li>
<li>Based on <em>j</em>, the sampler accepts the PSRN with probability equal to the control point <em>a</em>[<em>j</em>].</li>
<li>If the PSRN is accepted, it fills it up with uniform random digits, and returns <em>i</em> plus the finished PSRN.  If the PSRN is not accepted, the sampler starts over from step 2.</li>
</ol>

<p><a id=Finding_Parameters></a></p>

<h2>Finding Parameters</h2>

<p>Using this sampler for an arbitrary <em>n</em> requires finding the Bernstein control points for each of the <em>n</em> pieces of the uniform sum density.  This can be found, for example, with the Python code below, which uses the SymPy computer algebra library.  In the code:</p>

<ul>
<li><code>unifsum(x,n,v)</code> calculates the density function of the sum of <code>n</code> uniform random numbers when the variable <code>x</code> is shifted by <code>v</code> units.</li>
<li><code>find_control_points</code> prints out the control points for each piece of the density for the sum of <code>n</code> uniform random numbers, starting with piece 0.</li>
<li><code>find_areas</code> prints out the areas for each piece of that density.  This can be useful to implement a variant of the sampler above, as detailed later in this section.</li>
</ul>

<pre>def unifsum(x,n,v):
    # Builds up the density at x (with offset v)
    # of the sum of n uniform random numbers
    ret=0
    x=x+v # v is an offset
    for k in range(n+1):
           s=(-1)**k*binomial(n,k)*(x-k)**(n-1)
           if k&gt;v: ret-=s
           else: ret+=s
    return ret/(2*factorial(n-1))

def find_areas(n):
  x=symbols(&#39;x&#39;, real=True)
  areas=[integrate(unifsum(x,n,i),(x,0,1)) for i in range(n)]
  print(areas)

def find_control_points(n):
 x=symbols(&#39;x&#39;, real=True)
 for i in range(n):
  # Find the &quot;usual&quot; coefficients of the uniform
  # sum polynomial at offset i.
  poly=Poly(unifsum(x, n, i))
  coeffs=[poly.coeff_monomial(x**i) for i in range(n)]
  # Build coefficient vector
  coeffs=Matrix(coeffs)
  # Build power-to-Bernstein basis matrix
  mat=[[0 for _ in range(n)] for _ in range(n)]
  for j in range(n):
    for k in range(n):
       if k==0 or j==n-1:
         mat[j][k]=1
       elif k&lt;=j:
         mat[j][k]=binomial(j, j-k) / binomial(n-1, k)
       else:
         mat[j][k]=0
  mat=Matrix(mat)
  # Print out the Bernstein control points
  print(mat*coeffs)

</pre>

<p>The basis matrix is found, for example, as Equation 42 of (Ray and Nataraj 2012)<sup><a href="#Note3"><strong>(3)</strong></a></sup>.</p>

<p>For example, if <em>n</em> = 4 (so a sum of four uniform random numbers is desired), the following control points are used for each piece of the density function:</p>

<table><thead>
<tr>
<th>Piece</th>
<th>Control Points</th>
</tr>
</thead><tbody>
<tr>
<td>0</td>
<td>0, 0, 0, 1/6</td>
</tr>
<tr>
<td>1</td>
<td>1/6, 1/3, 2/3, 2/3</td>
</tr>
<tr>
<td>2</td>
<td>2/3, 2/3, 1/3, 1/6</td>
</tr>
<tr>
<td>3</td>
<td>1/6, 0, 0, 0</td>
</tr>
</tbody></table>

<p>For more efficient results, all these control points could be scaled so that the highest control point is equal to 1. In the example above, after multiplying by 3/2 (the reciprocal of the highest control point, which is 2/3), the table would now look like this:</p>

<table><thead>
<tr>
<th>Piece</th>
<th>Control Points</th>
</tr>
</thead><tbody>
<tr>
<td>0</td>
<td>0, 0, 0, 1/4</td>
</tr>
<tr>
<td>1</td>
<td>1/4, 1/2, 1, 1</td>
</tr>
<tr>
<td>2</td>
<td>1, 1, 1/2, 1/4</td>
</tr>
<tr>
<td>3</td>
<td>1/4, 0, 0, 0</td>
</tr>
</tbody></table>

<p>Notice that all these control points are rational numbers, and the sampler may have to determine whether an event is true with probability equal to a control point.  For rational numbers like these, it is possible to determine this exactly (using only random bits), using the <strong>ZeroOrOne</strong> method given in my <a href="https://peteroupc.github.io/randomfunc.html#Boolean_True_False_Conditions"><strong>article on randomization and sampling methods</strong></a>.</p>

<p>If the areas of the density&#39;s pieces are known in advance (and SymPy makes them easy to find as the <code>find_areas</code> method shows), then the sampler could be modified as follows, since each piece is now chosen with probability proportional to the chance that a random number there will be sampled:</p>

<ul>
<li>Step 2 is changed to read: &quot;An integer in [0, <em>n</em>) is chosen with probability proportional to the corresponding piece&#39;s area, call the integer <em>i</em>, then the piece identified by <em>i</em> is chosen.  There are many <a href="https://peteroupc.github.io/randomnotes.html#A_Note_on_Weighted_Choice_Algorithms"><strong>algorithms to choose an integer</strong></a> this way, but it&#39;s recommended to use one that takes integers rather than floating-point numbers as weights, and perhaps one that is economical in terms of the number of random bits it uses.  In this sense, the Fast Loaded Dice Roller (Saad et al. 2020)<sup><a href="#Note4"><strong>(4)</strong></a></sup> comes within 6 bits of the optimal number of random bits used on average.&quot;</li>
<li>The last sentence in step 6 is changed to read: &quot;If the PSRN is not accepted, the sampler starts over from step 3.&quot;  With this, the same piece is sampled again.</li>
</ul>

<p>If the sampler is modified this way, then the control points should be scaled so that the highest control point of <em>each</em> piece is equal to 1.  However, not doing this additional step does not affect the sampler&#39;s correctness.  The following table is an example:</p>

<table><thead>
<tr>
<th>Piece</th>
<th>Control Points</th>
</tr>
</thead><tbody>
<tr>
<td>0</td>
<td>0, 0, 0, 1</td>
</tr>
<tr>
<td>1</td>
<td>1/4, 1/2, 1, 1</td>
</tr>
<tr>
<td>2</td>
<td>1, 1, 1/2, 1/4</td>
</tr>
<tr>
<td>3</td>
<td>1, 0, 0, 0</td>
</tr>
</tbody></table>

<p><a id=Sum_of_Two_Uniform_Random_Numbers></a></p>

<h2>Sum of Two Uniform Random Numbers</h2>

<p>The following algorithm samples the sum of two uniform random numbers.</p>

<ol>
<li>Create an empty uniform PSRN (partially-sampled random number), call it <em>ret</em>.</li>
<li>Generate an unbiased random bit.</li>
<li>Remove all digits from <em>ret</em>.  (This algorithm, and others on this page, works for digits of any base, including base 10 or decimal, or base 2 or binary.)</li>
<li>Call the <strong>SampleGeometricBag</strong> algorithm on <em>ret</em>, then generate an unbiased random bit.</li>
<li>If the bit generated in step 2 is 1 and the result of <strong>SampleGeometricBag</strong> is 1, fill <em>ret</em> with uniform random digits as necessary to give its fractional part the desired number of digits (similarly to <strong>FillGeometricBag</strong>), and return <em>ret</em>.</li>
<li>If the bit generated in step 2 is 0 and the result of <strong>SampleGeometricBag</strong> is 0, fill <em>ret</em> as in step 4, and return 1 + <em>ret</em>.</li>
<li>Go to step 3.</li>
</ol>

<p>And here is Python code that implements this algorithm. It uses floating-point arithmetic only at the end, to convert the result to a convenient form, and that it relies on methods from <em>randomgen.py</em> and <em>bernoulli.py</em>.</p>

<pre>def sum_of_uniform(bern, precision=53):
    &quot;&quot;&quot; Exact simulation of the sum of two uniform
          random numbers. &quot;&quot;&quot;
    bag=[]
    rb=bern.randbit()
    while True:
       bag.clear()
       if rb==1:
          # 0 to 1
          if bern.geometric_bag(bag)==1:
             return bern.fill_geometric_bag(bag, precision)
       else:
          # 1 to 2
          if bern.geometric_bag(bag)==0:
             return 1.0 + bern.fill_geometric_bag(bag, precision)
</pre>

<p><a id=Sum_of_Three_Uniform_Random_Numbers></a></p>

<h2>Sum of Three Uniform Random Numbers</h2>

<p>The following algorithm samples the sum of three uniform random numbers.</p>

<ol>
<li>Create an empty uniform PSRN, call it <em>ret</em>.</li>
<li>Choose an integer in [0, 6), uniformly at random. (With this, the left piece is chosen at a 1/3 chance, the right piece at 1/6 and the middle piece at 2/3, corresponding to the relative areas occupied by the three pieces.)</li>
<li>Remove all digits from <em>ret</em>.</li>
<li>If 0 was chosen by step 2, we will sample from the left piece of the function for the sum of three uniform random numbers.  This piece runs along the interval [0, 1) and is a Bernstein polynomial with control points (0, 0, 1/2).  (Bernstein polynomials are the backbone of the well-known Bézier curve. In this case, the density&#39;s value at 0 is 0, or the first control point, and its value at 1 is 1/2, or the third control point.)  Thus, we can simulate this polynomial with the algorithm of Goyal and Sigman (2012)<sup><a href="#Note2"><strong>(2)</strong></a></sup>, using a partially-sampled uniform random number, as follows: Call the <strong>SampleGeometricBag</strong> algorithm twice on <em>ret</em>.  If both of these calls return 1, then accept <em>ret</em>. (Alternatively, &quot;...accept <em>ret</em> with probability 1/2&quot;, since 1/2 is the third control point and corresponds to both calls returning 1, but the step as given is still correct since it merely moves the upper bound closer to the top of the left piece.)  If <em>ret</em> was accepted, fill <em>ret</em> with uniform random digits as necessary to give its fractional part the desired number of digits (similarly to <strong>FillGeometricBag</strong>), and return <em>ret</em>.</li>
<li>If 2, 3, 4, or 5 was chosen by step 2, we will sample from the middle piece of the density, which runs along the interval [1, 2) and is a Bernstein polynomial with control points (1/2, 1, 1/2).  Call the <strong>SampleGeometricBag</strong> algorithm twice on <em>ret</em>.  If neither or both of these calls return 1, then accept <em>ret</em>.  Otherwise, if one of these calls returns 1 and the other 0, then accept <em>ret</em> with probability 1/2.  If <em>ret</em> was accepted, fill <em>ret</em> as given in step 4 and return 1 + <em>ret</em>.</li>
<li>If 1 was chosen by step 2, we will sample from the right piece of the density, which runs along the interval [2, 1) and is a Bernstein polynomial with control points (1/2, 0, 0).  Call the <strong>SampleGeometricBag</strong> algorithm twice on <em>ret</em>.  If both of these calls return 0, then accept <em>ret</em>. (Alternatively, &quot;...accept <em>ret</em> with probability 1/2&quot;, 1/2 is the first control point and corresponds to both calls returning 0, but the step is given is still correct.)  If <em>ret</em> was accepted, fill <em>ret</em> as given in step 4 and return 2 + <em>ret</em>.</li>
<li>Go to step 3.</li>
</ol>

<p>And here is Python code that implements this algorithm.</p>

<pre>def sum_of_uniform3(bern):
    &quot;&quot;&quot; Exact simulation of the sum of three uniform
          random numbers. &quot;&quot;&quot;
    r=6
    while r&gt;=6:
       r=bern.randbit() + bern.randbit() * 2 + bern.randbit() * 4
    while True:
       # Choose a piece of the PDF uniformly (but
       # not by area).
       bag=[]
       if r==0:
          # Left piece
          if bern.geometric_bag(bag) == 1 and \
             bern.geometric_bag(bag) == 1:
              # Accepted
             return bern.fill_geometric_bag(bag)
       elif r&lt;=4:
          # Middle piece
          ones=bern.geometric_bag(bag) + bern.geometric_bag(bag)
          if (ones == 0 or ones == 2) and bern.randbit() == 0:
              # Accepted
             return 1.0 + bern.fill_geometric_bag(bag)
          if ones == 1:
              # Accepted
             return 1.0 + bern.fill_geometric_bag(bag)
       else:
          # Right piece
          if bern.randbit() == 0 and \
             bern.geometric_bag(bag) == 0 and \
             bern.geometric_bag(bag) == 0:
              # Accepted
             return 2.0 + bern.fill_geometric_bag(bag)
</pre>

<p><a id=Notes></a></p>

<h2>Notes</h2>

<p><small><sup id=Note1>(1)</sup> Keane,  M.  S.,  and  O&#39;Brien,  G.  L., &quot;A Bernoulli factory&quot;, <em>ACM Transactions on Modeling and Computer Simulation</em> 4(2), 1994</small></p>

<p><small><sup id=Note2>(2)</sup> Goyal, V. and Sigman, K., 2012. On simulating a class of Bernstein polynomials. ACM Transactions on Modeling and Computer Simulation (TOMACS), 22(2), pp.1-5.</small></p>

<p><small><sup id=Note3>(3)</sup> S. Ray, P.S.V. Nataraj, &quot;A Matrix Method for Efficient Computation of Bernstein Coefficients&quot;, <em>Reliable Computing</em> 17(1), 2012.</small></p>

<p><small><sup id=Note4>(4)</sup> Saad, F.A., Freer C.E., et al., &quot;<a href="https://arxiv.org/abs/2003.03830v2">The Fast Loaded Dice Roller: A Near-Optimal Exact Sampler for Discrete Probability Distributions</a>&quot;, arXiv:2003.03830v2 [stat.CO], also in AISTATS 2020: Proceedings of the 23rd International Conference on Artificial Intelligence and Statistics, Proceedings of Machine Learning Research 108, Palermo, Sicily, Italy, 2020.</small></p>

<p><a id=License></a></p>

<h2>License</h2>

<p>Any copyright to this page is released to the Public Domain.  In case this is not possible, this page is also licensed under <a href="https://creativecommons.org/publicdomain/zero/1.0/"><strong>Creative Commons Zero</strong></a>.</p>
</div><nav id="navigation"><ul>
<li><a href="/">Back to start site.</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io">This site's repository (source code)</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io/issues">Post an issue or comment</a></ul>
<p>
If you like this software, you should consider donating to me, Peter O., at the link below:</p>
<p class="printonly"><b>peteroupc.github.io</b></p>
<div class="noprint">
<a href="https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=56E5T4FH7KD2S">
<img src="https://www.paypalobjects.com/en_US/i/btn/btn_donateCC_LG.gif"
name="submit" border="2" alt="PayPal - The safer, easier way to pay online!"></a>
<p>
<a href="//twitter.com/share">Share via Twitter</a>, <a href="//www.facebook.com/sharer/sharer.php" id="sharer">Share via Facebook</a>
</p>
</div>
</nav><script>
if("share" in navigator){
 document.getElementById("sharer").href="javascript:void(null)";
 document.getElementById("sharer").innerHTML="Share This Page";
 navigator.share({title:document.title,url:document.location.href}).then(
   function(){});
} else {
 document.getElementById("sharer").href="//www.facebook.com/sharer/sharer.php?u="+
    encodeURIComponent(document.location.href)
}
</script>
</body></html>
