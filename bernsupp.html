<!DOCTYPE html><html xmlns:dc="http://purl.org/dc/terms/" itemscope itemtype="http://schema.org/Article"><head><meta http-equiv=Content-Type content="text/html; charset=utf-8"><meta name="citation_pdf_url" content="https://peteroupc.github.io/bernsupp.pdf"><meta name="citation_url" content="https://peteroupc.github.io/bernsupp.html"><meta name="citation_date" content="2024/08/15"><meta name="citation_online_date" content="2024/08/15"><meta name="og:type" content="article"><meta name="og:url" content="https://peteroupc.github.io/bernsupp.html"><meta name="og:site_name" content="peteroupc.github.io"><meta name="author" content="Peter Occil"/><meta name="citation_author" content="Peter Occil"/><meta name="viewport" content="width=device-width"><link rel=stylesheet type="text/css" href="/style.css">
            <script type="text/x-mathjax-config"> MathJax.Hub.Config({"HTML-CSS": { availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, preferredFont: "TeX" },
                    tex2jax: { displayMath: [ ["$$","$$"], ["\\[", "\\]"] ], inlineMath: [ ["$", "$"], ["\\\\(","\\\\)"] ], processEscapes: true } });
            </script><script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"></script></head><body>  <div class="header">
<nav><p><a href="#navigation">Menu</a> - <a href="#top">Top</a> - <a href="/">Home</a></nav></div>
<div class="mainarea" id="top">
<h1 id="supplemental-notes-for-bernoulli-factory-algorithms">Supplemental Notes for Bernoulli Factory Algorithms</h1>

<p><a href="mailto:poccil14@gmail.com"><strong>Peter Occil</strong></a></p>

<p><a id="Contents"></a></p>

<h2 id="contents">Contents</h2>

<ul>
  <li><a href="#Contents"><strong>Contents</strong></a></li>
  <li><a href="#About_This_Document"><strong>About This Document</strong></a></li>
  <li><a href="#Definitions"><strong>Definitions</strong></a></li>
  <li><a href="#General_Factory_Functions"><strong>General Factory Functions</strong></a>
    <ul>
      <li><a href="#Building_the_Lower_and_Upper_Polynomials"><strong>Building the Lower and Upper Polynomials</strong></a></li>
      <li><a href="#Another_General_Algorithm"><strong>Another General Algorithm</strong></a></li>
      <li><a href="#Request_for_Additional_Methods"><strong>Request for Additional Methods</strong></a></li>
    </ul>
  </li>
  <li><a href="#Approximate_Bernoulli_Factories"><strong>Approximate Bernoulli Factories</strong></a></li>
  <li><a href="#Achievable_Simulation_Rates"><strong>Achievable Simulation Rates</strong></a></li>
  <li><a href="#Notes"><strong>Notes</strong></a></li>
  <li><a href="#Appendix"><strong>Appendix</strong></a>
    <ul>
      <li><a href="#Examples_of_Well_Behaved_Functions"><strong>Examples of Well-Behaved Functions</strong></a></li>
      <li><a href="#Results_Used_in_Approximate_Bernoulli_Factories"><strong>Results Used in Approximate Bernoulli Factories</strong></a></li>
      <li><a href="#How_Many_Coin_Flips_Are_Needed_to_Simulate_a_Polynomial"><strong>How Many Coin Flips Are Needed to Simulate a Polynomial?</strong></a></li>
      <li><a href="#Proofs_for_Polynomial_Building_Schemes"><strong>Proofs for Polynomial-Building Schemes</strong></a>
        <ul>
          <li><a href="#A_Conjecture_on_Polynomial_Approximation"><strong>A Conjecture on Polynomial Approximation</strong></a></li>
          <li><a href="#Example_of_Polynomial_Building_Scheme"><strong>Example of Polynomial-Building Scheme</strong></a></li>
        </ul>
      </li>
      <li><a href="#Which_functions_don_t_require_outside_randomness_to_simulate"><strong>Which functions don’t require outside randomness to simulate?</strong></a></li>
      <li><a href="#Multiple_Output_Bernoulli_Factory"><strong>Multiple-Output Bernoulli Factory</strong></a></li>
      <li><a href="#Pushdown_Automata_and_Algebraic_Functions"><strong>Pushdown Automata and Algebraic Functions</strong></a>
        <ul>
          <li><a href="#Finite_State_and_Pushdown_Generators"><strong>Finite-State and Pushdown Generators</strong></a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#License"><strong>License</strong></a></li>
</ul>

<p><a id="About_This_Document"></a></p>

<h2 id="about-this-document">About This Document</h2>

<p><strong>This is an open-source document; for an updated version, see the</strong> <a href="https://github.com/peteroupc/peteroupc.github.io/raw/master/bernsupp.md"><strong>source code</strong></a> <strong>or its</strong> <a href="https://github.com/peteroupc/peteroupc.github.io/blob/master/bernsupp.md"><strong>rendering on GitHub</strong></a><strong>.  You can send comments on this document on the</strong> <a href="https://github.com/peteroupc/peteroupc.github.io/issues"><strong>GitHub issues page</strong></a><strong>.  See</strong> “<a href="https://peteroupc.github.io/bernreq.html"><strong>Open Questions on the Bernoulli Factory Problem</strong></a>” <strong>for a list of things about this document that I seek answers to.</strong></p>

<p>My audience for this article is <strong>computer programmers with mathematics knowledge, but little or no familiarity with calculus</strong>.  It should be read in conjunction with the article “<a href="https://peteroupc.github.io/bernoulli.html"><strong>Bernoulli Factory Algorithms</strong></a>”.</p>

<p>I encourage readers to implement any of the algorithms given in this page, and report their implementation experiences.  In particular, <a href="https://github.com/peteroupc/peteroupc.github.io/issues/18"><strong>I seek comments on the following aspects</strong></a>:</p>

<ul>
  <li>Are the algorithms in this article (in conjunction with “Bernoulli Factory Algorithms”) easy to implement? Is each algorithm written so that someone could write code for that algorithm after reading the article?</li>
  <li>Does this article have errors that should be corrected?</li>
  <li>Are there ways to make this article more useful to the target audience?</li>
</ul>

<p>Comments on other aspects of this document are welcome.</p>

<p><a id="Definitions"></a></p>

<h2 id="definitions">Definitions</h2>

<p>This section describes certain math terms used on this page for programmers to understand.</p>

<p>The <em>closed unit interval</em> (written as [0, 1]) means the set consisting of 0, 1, and every real number in between.</p>

<p>The following terms can describe a function $f(x)$, specifically how “well-behaved” $f$ is.</p>

<ul>
  <li>A <em>continuous</em> function $f$ has the property that there is a function $h(x, \epsilon)$ (where $x$ is in $f$’s domain and $\epsilon&gt;0$), such that $f(x)$ and $f(y)$ are less than $\epsilon$ apart whenever $x$ and $y$ are in $f$’s domain and less than $h(x, \epsilon)$ apart.<br />Roughly speaking, for each $x$ in $f$’s domain, $f(x)$ and $f(y)$ are “close” if $x$ and $y$ are “close” and belong in the domain.</li>
  <li>If $f$ is continuous, its <em>derivative</em> is, roughly speaking, its “slope” function or “velocity” function or “instantaneous-rate-of-change” function.  The derivative (or <em>first derivative</em>) is denoted $f’$ or $f^{(1)}$.  The <em>second derivative</em> (“slope-of-slope”) of $f$, denoted $f’’$ or $f^{(2)}$, is the derivative of $f’$; the <em>third derivative</em>, denoted $f^{(3)}$, is the derivative of $f’’$; and so on.  The <em>0-th derivative</em> of a function $f$ is $f$ itself and denoted $f^{(0)}$.</li>
  <li>A <a href="https://en.wikipedia.org/wiki/Hölder_condition"><strong><em>Hölder continuous</em></strong></a> function  (with <em>M</em> being the <em>Hölder constant</em> and <em>α</em> being the <em>Hölder exponent</em>) is a continuous function <em>f</em> such that <em>f</em>(<em>x</em>) and <em>f</em>(<em>y</em>) are no more than <em>M</em>*<em>δ</em><sup><em>α</em></sup> apart whenever <em>x</em> and <em>y</em> are in the function’s domain and no more than <em>δ</em> apart.<br />Here, <em>α</em> satisfies 0 &lt; <em>α</em> ≤ 1.<br />Roughly speaking, the function’s “steepness” is no greater than that of <em>M</em>*<em>x</em><sup><em>α</em></sup>.</li>
  <li>A <em>Lipschitz continuous</em> function with constant <em>L</em> (the <em>Lipschitz constant</em>) is Hölder continuous with Hölder exponent 1 and Hölder constant <em>L</em>.<br />Roughly speaking, the function’s “steepness” is no greater than that of <em>L</em>*<em>x</em>.<br />If the function has a derivative on its domain, <em>L</em> can be the maximum of the absolute value of that derivative.</li>
  <li>A <em>convex</em> function $f$ has the property that $f((x+y)/2) \le (f(x)+f(y))/2$ whenever $x$, $y$, and $(x+y)/2$ are in the function’s domain.<br />Roughly speaking, if the function’s “slope” never goes down, then it’s convex.</li>
  <li>A <em>concave</em> function $f$ has the property that $f((x+y)/2) \ge (f(x)+f(y))/2$ whenever $x$, $y$, and $(x+y)/2$ are in the function’s domain.<br />Roughly speaking, if the function’s “slope” never goes up, then it’s concave.</li>
  <li>The function $f$ is <em>bounded</em> if there are two numbers $a$ and $b$ such that $a\le f(x)\le b$ whenever $x$ is in the function’s domain.</li>
</ul>

<blockquote>
  <p><strong>Note</strong>: The “good behavior” of a function can be important when designing Bernoulli factory algorithms.  This page mostly cares how $f$ behaves when its domain is the closed unit interval, that is, when $0 \le x \le 1$.</p>
</blockquote>

<p><a id="General_Factory_Functions"></a></p>

<h2 id="general-factory-functions">General Factory Functions</h2>

<p>As a reminder, the <em>Bernoulli factory problem</em> is: Suppose there is a coin that shows heads with an unknown probability, <em>λ</em>, and the goal is to use that coin (and possibly also a fair coin) to build a “new” coin that shows heads with a probability that depends on <em>λ</em>, call it <em>f</em>(<em>λ</em>).</p>

<p>The algorithm for <a href="https://peteroupc.github.io/bernoulli.html#General_Factory_Functions"><strong>general factory functions</strong></a>, described in my main article on Bernoulli factory algorithms, works by building randomized upper and lower bounds for a function <em>f</em>(<em>λ</em>), based on flips of the input coin.  Roughly speaking, the algorithm works as follows:</p>

<ol>
  <li>Generate a random variate, <em>U</em>, uniformly distributed, greater than 0 and less than 1.</li>
  <li>Flip the input coin, then build an upper and lower bound for <em>f</em>(<em>λ</em>), based on the outcomes of the flips so far.</li>
  <li>If <em>U</em> is less than or equal to the lower bound, return 1. If <em>U</em> is greater than the upper bound, return 0.  Otherwise, go to step 2.</li>
</ol>

<p>These randomized upper and lower bounds come from two sequences of polynomials as follows:</p>

<ol>
  <li>One sequence approaches the function <em>f</em>(<em>λ</em>) from above, the other from below, and both sequences must converge to <em>f</em>.</li>
  <li>For each sequence, the first polynomial has degree 1 (so is a linear function), and each other polynomial’s degree is 1 higher than the previous.</li>
  <li>The <em>consistency requirement</em> must be met, namely—
    <ul>
      <li>the difference between the degree-(<em>n</em>−1) upper polynomial and the degree-_n_ upper polynomial, and</li>
      <li>the difference between the degree-_n_ lower polynomial and the degree-(<em>n</em>−1) lower polynomial,</li>
    </ul>

    <p>must have nonnegative Bernstein coefficients, once each of these differences is rewritten as a polynomial of degree exactly <em>n</em>.  (For more on Bernstein coefficients and the Bernstein form of polynomials, see “<a href="https://peteroupc.github.io/bernoulli.html#Certain_Polynomials"><strong>Certain Polynomials</strong></a>” in the main article.)</p>
  </li>
</ol>

<p>The consistency requirement ensures that the upper polynomials “decrease” and the lower polynomials “increase”.  Unfortunately, the reverse is not true in general; even if the upper polynomials “decrease” and the lower polynomials “increase” to <em>f</em>, this does not ensure the consistency requirement by itself.</p>

<blockquote>
  <p><strong>Example (Nacu &amp; Peres [2005]<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>):</strong> The polynomial $x^2+(1-x)^2$ is of degree 2 with Bernstein coefficients [1, 0, 1].  The polynomial $x(1-x)$ is of degree 2 with Bernstein coefficients [0, 1/2, 0]. Although $(x^2+(1-x)^2)$ minus $(x(1-x))$ is non-negative, this difference’s Bernstein coefficients of degree 2 are not always non-negative, namely, the Bernstein coefficients are [1, -1/2, 1].</p>
</blockquote>

<p>In this document, <strong>fbelow</strong>(<em>n</em>, <em>k</em>) and <strong>fabove</strong>(<em>n</em>, <em>k</em>) mean the <em>k</em><sup>th</sup> Bernstein coefficient for the lower or upper degree-_n_ polynomial, respectively, where 0 ≤ <em>k</em> ≤ <em>n</em> is an integer.</p>

<p>The section “Building the Lower and Upper Polynomials” are ways to build sequences of polynomials that appropriately converge to a factory function if that function meets certain conditions.</p>

<p>To determine if the methods are right for <em>f</em>(<em>λ</em>), a deep mathematical analysis of <em>f</em> is required; it would be helpful to plot that function using a computer algebra system to see if it is described in the next section.</p>

<p><a id="Building_the_Lower_and_Upper_Polynomials"></a></p>

<h3 id="building-the-lower-and-upper-polynomials">Building the Lower and Upper Polynomials</h3>

<p>The rest of this section assumes <em>f</em>(<em>λ</em>) is not a constant.  For examples of functions, see “<a href="#Examples_of_Well_Behaved_Functions"><strong>Examples of Well-Behaved Functions</strong></a>”, in the appendix.</p>

<p><strong>Concave functions.</strong> If <em>f</em> is concave, then <strong>fbelow</strong>(<em>n</em>, <em>k</em>) can equal <em>f</em>(<em>k</em>/<em>n</em>), thanks to Jensen’s inequality.</p>

<p><strong>Convex functions.</strong> If <em>f</em> is convex, then <strong>fabove</strong>(<em>n</em>, <em>k</em>) can equal <em>f</em>(<em>k</em>/<em>n</em>), thanks to Jensen’s inequality.</p>

<p><strong>Hölder and Lipschitz continuous functions.</strong> I have found a way to extend the results of Nacu and Peres (2005)<sup id="fnref:1:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup> to certain functions with a slope that tends to a vertical slope.  The following scheme, proved in the appendix, implements <strong>fabove</strong> and <strong>fbelow</strong> if <em>f</em>(<em>λ</em>)—</p>

<ul>
  <li>is <a href="https://en.wikipedia.org/wiki/Hölder_condition"><strong><em>Hölder continuous</em></strong></a> on the closed unit interval, with Hölder constant <em>m</em> or less and Hölder exponent <em>α</em> (see “<a href="#Definitions"><strong>Definitions</strong></a>” as well as “<a href="#Examples_of_Well_Behaved_Functions"><strong>Examples of Well-Behaved Functions</strong></a>”, in the appendix), and</li>
  <li>on the closed unit interval—
    <ul>
      <li>has a minimum of greater than 0 and a maximum of less than 1, or</li>
      <li>is convex and has a minimum of greater than 0, or</li>
      <li>is concave and has a maximum of less than 1.</li>
    </ul>
  </li>
</ul>

<p>For every integer <em>n</em> that’s a power of 2:</p>

<ul>
  <li><em>D</em>(<em>n</em>) = <em>m</em>*(2/7)<sup><em>α</em>/2</sup>/((2<sup><em>α</em>/2</sup>−1)*<em>n</em><sup><em>α</em>/2</sup>).</li>
  <li><strong>fbelow</strong>(<em>n</em>, <em>k</em>) = <em>f</em>(<em>k</em>/<em>n</em>) if <em>f</em> is concave; otherwise, min(<strong>fbelow</strong>(4,0), <strong>fbelow</strong>(4,1), …, <strong>fbelow</strong>(4,4)) if <em>n</em> &lt; 4; otherwise, <em>f</em>(<em>k</em>/<em>n</em>) − <em>D</em>(<em>n</em>).</li>
  <li><strong>fabove</strong>(<em>n</em>, <em>k</em>) = <em>f</em>(<em>k</em>/<em>n</em>) if <em>f</em> is convex; otherwise, max(<strong>fabove</strong>(4,0), <strong>fabove</strong>(4,1), …, <strong>fabove</strong>(4,4)) if <em>n</em> &lt; 4; otherwise, <em>f</em>(<em>k</em>/<em>n</em>) + <em>D</em>(<em>n</em>).</li>
</ul>

<blockquote>
  <p><strong>Notes:</strong></p>

  <ol>
    <li>If <em>α</em> is 1, <em>D</em>(<em>n</em>) can be <em>m</em>*322613/(250000*sqrt(<em>n</em>)), which is an upper bound.  If <em>α</em> is 1/2, <em>D</em>(<em>n</em>) can be <em>m</em>*154563/(40000*<em>n</em><sup>1/4</sup>), which is an upper bound.</li>
    <li>The function $f(x)=\min(\lambda t, 1-\epsilon)$, where $\epsilon\ge 0$ and $t\ge 1$, is Lipschitz continuous with Lipschitz constant <em>t</em>.  Because $f$ is linear between 0 and 1/<em>t</em>, ways to build polynomials that converge to this kind of function were discussed by Thomas and Blanchet (2012)<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup> <sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup> and Nacu &amp; Peres (2005)<sup id="fnref:1:2" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup> <sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">4</a></sup>.</li>
  </ol>
</blockquote>

<p><strong>Functions with a Lipschitz continuous derivative.</strong> The following method, proved in the appendix, implements <strong>fabove</strong> and <strong>fbelow</strong> if <em>f</em>(<em>λ</em>)—</p>

<ul>
  <li>has a Lipschitz continuous derivative (see “<a href="#Definitions"><strong>Definitions</strong></a>” as well as “<a href="#Examples_of_Well_Behaved_Functions"><strong>Examples of Well-Behaved Functions</strong></a>”, in the appendix), and</li>
  <li>in the closed unit interval—
    <ul>
      <li>has a minimum of greater than 0 and a maximum of less than 1, or</li>
      <li>is convex and has a minimum of greater than 0, or</li>
      <li>is concave and has a maximum of less than 1.</li>
    </ul>
  </li>
</ul>

<p>Let <em>m</em> be the Lipschitz constant of <em>f</em>’s derivative, or a greater number than that constant.  Then for every integer <em>n</em> that’s a power of 2:</p>

<ul>
  <li>For every $n$ such that <strong>fbelow</strong>(<em>n</em>,<em>k</em>) is 0 or greater for every <em>k</em>, <strong>fbelow</strong>(<em>n</em>, <em>k</em>) = <em>f</em>(<em>k</em>/<em>n</em>) if <em>f</em> is concave; otherwise, min(<strong>fbelow</strong>(4,0), <strong>fbelow</strong>(4,1), …, <strong>fbelow</strong>(4,4)) if <em>n</em> &lt; 4; otherwise,  <em>f</em>(<em>k</em>/<em>n</em>) − <em>m</em>/(7*<em>n</em>).  For every other $n$, <strong>fbelow</strong>(<em>n</em>,<em>k</em>) = 0.</li>
  <li>For every $n$ such that <strong>fabove</strong>(<em>n</em>,<em>k</em>) is 1 or less for every <em>k</em>, <strong>fabove</strong>(<em>n</em>, <em>k</em>) = <em>f</em>(<em>k</em>/<em>n</em>) if <em>f</em> is convex; otherwise, max(<strong>fabove</strong>(4,0), <strong>fabove</strong>(4,1), …, <strong>fabove</strong>(4,4)) if <em>n</em> &lt; 4; otherwise, <em>f</em>(<em>k</em>/<em>n</em>) + <em>m</em>/(7*<em>n</em>).  For every other $n$, <strong>fabove</strong>(<em>n</em>,<em>k</em>) = 1.</li>
</ul>

<p><strong>Certain functions that equal 0 at 0.</strong> This approach involves transforming the function <em>f</em> so that it no longer equals 0 at the point 0.  This can be done by dividing <em>f</em> by a function (<code>High</code>(<em>λ</em>)) that “dominates” <em>f</em> everywhere on the closed unit interval.  Unlike for the original function, there might be a polynomial-building scheme described earlier in this section for the transformed function.</p>

<p>More specifically, <code>High</code>(<em>λ</em>) must meet the following requirements:</p>

<ul>
  <li><code>High</code>(<em>λ</em>) is continuous on the closed unit interval.</li>
  <li><code>High</code>(0) = 0. (This is required to ensure correctness in case <em>λ</em> is 0.)</li>
  <li>1 ≥ <code>High</code>(1) ≥ <em>f</em>(1) ≥ 0.</li>
  <li>1 &gt; <code>High</code>(<em>λ</em>) &gt; <em>f</em>(<em>λ</em>) &gt; 0 whenever 0 &lt; <em>λ</em> &lt; 1.</li>
  <li>If <em>f</em>(1) = 0, then <code>High</code>(1) = 0. (This is required to ensure correctness in case <em>λ</em> is 1.)</li>
</ul>

<p>Also, <code>High</code> is a Bernoulli factory function that should admit a simple Bernoulli factory algorithm.  For example, <code>High</code> can be the following degree-_n_ polynomial: 1−(1−<em>λ</em>)<sup><em>n</em></sup>, where <em>n</em>≥1 is an integer.<sup id="fnref:5" role="doc-noteref"><a href="#fn:5" class="footnote" rel="footnote">5</a></sup></p>

<p>The algorithm is now described.</p>

<p>Let <em>g</em>(<em>λ</em>) = lim<sub><em>ν</em>→<em>λ</em></sub> <em>f</em>(<em>ν</em>)/<code>High</code>(<em>ν</em>) (roughly speaking, the value that <em>f</em>(<em>ν</em>)/<code>High</code>(<em>ν</em>) approaches as <em>ν</em> approaches <em>λ</em>.) If—</p>

<ul>
  <li><em>f</em>(0) = 0 and <em>f</em>(1) &lt; 1, and</li>
  <li><em>g</em>(<em>λ</em>) is continuous on the closed unit interval and belongs in one of the classes of functions given earlier,</li>
</ul>

<p>then <em>f</em> can be simulated using the following algorithm:</p>

<ol>
  <li>Run a Bernoulli factory algorithm for <code>High</code>.  If the call returns 0, return 0. (For example, if <code>High</code>(<em>λ</em>) = <em>λ</em>, then this step amounts to the following: “Flip the input coin.  If it returns 0, return 0.”)</li>
  <li>Run a Bernoulli factory algorithm for <em>g</em>(.) and return the result of that algorithm.  This can be one of the <a href="https://peteroupc.github.io/bernoulli.html#General_Factory_Functions"><strong>general factory function algorithms</strong></a> if there is a way to calculate polynomials that converge to <em>g</em>(.) in a manner needed for that algorithm (for example, if <em>g</em> is described earlier in this section).</li>
</ol>

<blockquote>
  <p><strong>Notes:</strong></p>

  <ol>
    <li>It may happen that <em>g</em>(0) = 0.  In this case, step 2 of this algorithm can involve running this algorithm again, but with new <em>g</em> and <code>High</code> functions that are found based on the current <em>g</em> function. (This will eventually result in <em>g</em>(0) being nonzero if <em>f</em> is a nonconstant Bernoulli factory function.)   See the second example below.</li>
    <li><code>High</code>(<em>λ</em>) can also equal 1 instead of be described in this section.  That leads to the original Bernoulli factory algorithm for <em>f</em>(<em>λ</em>).</li>
  </ol>

  <p><strong>Examples:</strong></p>

  <ol>
    <li>If <em>f</em>(<em>λ</em>) = (sinh(<em>λ</em>)+cosh(<em>λ</em>)−1)/4, then <em>f</em> is less than or equal to <code>High</code>(<em>λ</em>) = <em>λ</em>, so <em>g</em>(<em>λ</em>) is 1/4 if <em>λ</em> = 0, and (exp(<em>λ</em>) − 1)/(4*<em>λ</em>) otherwise.  The following code in Python that uses the SymPy computer algebra library computes this example: <code>fx = (sinh(x)+cosh(x)-1)/4; h = x; pprint(Piecewise((limit(fx/h,x,0), Eq(x,0)), ((fx/h).simplify(), True)))</code>.</li>
    <li>
      <p>If <em>f</em>(<em>λ</em>) = cosh(<em>λ</em>) − 1, then <em>f</em> is less than or equal to <code>High</code>(<em>λ</em>) = <em>λ</em>, so <em>g</em>(<em>λ</em>) is 0 if <em>λ</em> = 0, and (cosh(<em>λ</em>)−1)/<em>λ</em> otherwise.  Now, since <em>g</em>(0) = 0, find new functions <em>g</em> and <code>High</code> based on the current <em>g</em>.  The current <em>g</em> is less than or equal to <code>High</code>(<em>λ</em>) = <em>λ</em>*3*(2−<em>λ</em>)/5 (a degree-2 polynomial that has Bernstein coefficients [0, 6/10, 6/10]), so <em>G</em>(<em>λ</em>) = 5/12 if <em>λ</em> = 0, and −(5*cosh(<em>λ</em>) − 5)/(3*<em>λ</em><sup>2</sup>*(<em>λ</em>−2)) otherwise. <em>G</em> is bounded away from 0 and 1, resulting in the following algorithm:</p>

      <ol>
        <li>(Simulate <code>High</code>.) Flip the input coin.  If it returns 0, return 0.</li>
        <li>(Simulate <code>High</code>.) Flip the input coin twice.  If both flips return 0, return 0.  Otherwise, with probability 4/10 (that is, 1 minus 6/10), return 0.</li>
        <li>Run a Bernoulli factory algorithm for <em>G</em> (which might involve building polynomials that converge to <em>G</em>, noticing that <em>G</em>’s derivative is Lipschitz continuous) and return the result of that algorithm.</li>
      </ol>
    </li>
  </ol>
</blockquote>

<p><strong>Certain functions that equal 0 at 0 and 1 at 1.</strong>  Let <em>f</em>, <em>g</em>, and <code>High</code> be functions as defined earlier, except that <em>f</em>(0) = 0 and <em>f</em>(1) = 1.  Define the following additional functions:</p>

<ul>
  <li><code>Low</code>(<em>λ</em>) is a function that meets the following requirements:
    <ul>
      <li><code>Low</code>(<em>λ</em>) is continuous on the closed unit interval.</li>
      <li><code>Low</code>(0) = 0 and <code>Low</code>(1) = 1.</li>
      <li>1 &gt; <em>f</em>(<em>λ</em>) &gt; <code>Low</code>(<em>λ</em>) &gt; 0 whenever 0 &lt; <em>λ</em> &lt; 1.</li>
    </ul>
  </li>
  <li><em>q</em>(<em>λ</em>) = lim<sub><em>ν</em>→<em>λ</em></sub> <code>Low</code>(<em>ν</em>)/<code>High</code>(<em>ν</em>).</li>
  <li><em>r</em>(<em>λ</em>) = lim<sub><em>ν</em>→<em>λ</em></sub> (1−<em>g</em>(<em>ν</em>))/(1−<em>q</em>(<em>ν</em>)).</li>
</ul>

<p>Roughly speaking, <code>Low</code> is a function that bounds <em>f</em> from below, just as <code>High</code> bounds <em>f</em> from above. <code>Low</code> is a Bernoulli factory function that should admit a simple Bernoulli factory algorithm; one example is the polynomial <em>λ</em><sup><em>n</em></sup> where <em>n</em>≥1 is an integer.  If both <code>Low</code> and <code>High</code> are polynomials of the same degree, <em>q</em> will be a ratio of polynomials with a relatively simple Bernoulli factory algorithm (see “<a href="https://peteroupc.github.io/bernoulli.html#Certain_Rational_Functions"><strong>Certain Rational Functions</strong></a>”).</p>

<p>Now, if <em>r</em>(<em>λ</em>) is continuous on the closed unit interval, then <em>f</em> can be simulated using the following algorithm:</p>

<ol>
  <li>Run a Bernoulli factory algorithm for <code>High</code>.  If the call returns 0, return 0. (For example, if <code>High</code>(<em>λ</em>) = <em>λ</em>, then this step amounts to the following: “Flip the input coin.  If it returns 0, return 0.”)</li>
  <li>Run a Bernoulli factory algorithm for <em>q</em>(.).  If the call returns 1, return 1.</li>
  <li>Run a Bernoulli factory algorithm for <em>r</em>(.), and return 1 minus the result of that call.  The Bernoulli factory algorithm can be one of the <a href="https://peteroupc.github.io/bernoulli.html#General_Factory_Functions"><strong>general factory function algorithms</strong></a> if there is a way to calculate polynomials that converge to <em>r</em>(.) in a manner needed for that algorithm (for example, if <em>r</em> is described earlier in this section).</li>
</ol>

<blockquote>
  <p><strong>Notes:</strong></p>

  <ol>
    <li>Quick proof: Rewrite $f=\text{High}\cdot(q\cdot1+(1-q)\cdot(1-r))+(1-\text{High})\cdot0$.</li>
    <li><code>High</code>(<em>λ</em>) is allowed to equal 1 if the <em>r</em>(.) in step 3 is allowed to equal 0 at 0.</li>
  </ol>

  <p><strong>Example:</strong> If <em>f</em>(<em>λ</em>) = (1−exp(<em>λ</em>))/(1−exp(1)), then <em>f</em> is less than or equal to <code>High</code>(<em>λ</em>) = <em>λ</em>, and greater than or equal to <code>Low</code>(<em>λ</em>) = <em>λ</em><sup>2</sup>.  As a result, <em>q</em>(<em>λ</em>) = <em>λ</em>, and <em>r</em>(<em>λ</em>) = (2 − exp(1))/(1 − exp(1)) if <em>λ</em> = 0; 1/(exp(1)−1) if <em>λ</em> = 1; and (−<em>λ</em>*(1 − exp(1)) − exp(<em>λ</em>) + 1)/(<em>λ</em>*(1 − exp(1))*(<em>λ</em> − 1)) otherwise.  This can be computed using the following code in Python that uses the SymPy computer algebra library: <code>fx=(1-exp(x))/(1-exp(1)); high=x; low=x**2; q=(low/high); r=(1-fx/high)/(1-q); r=Piecewise((limit(r, x, 0), Eq(x,0)), (limit(r,x,1),Eq(x,1)), (r,True)).simplify(); pprint(r)</code>.</p>
</blockquote>

<p><strong>Other functions that equal 0 or 1 at the endpoint 0, 1, or both.</strong> The table below accounts for these Bernoulli factory functions:</p>

<table>
  <thead>
    <tr>
      <th>If <em>f</em>(0) =</th>
      <th>And <em>f</em>(1) =</th>
      <th>Method</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>&gt; 0 and &lt; 1</td>
      <td>1</td>
      <td>Use the algorithm for <strong>certain functions that equal 0 at 0</strong>, but with <em>f</em>(<em>λ</em>) = 1 − <em>f</em>(1−<em>λ</em>).<br /><em>Inverted coin</em>: Instead of the usual input coin, use a coin that does the following: “Flip the input coin and return 1 minus the result.”<br /><em>Inverted result:</em> If the overall algorithm would return 0, it returns 1 instead, and vice versa.</td>
    </tr>
    <tr>
      <td>&gt; 0 and &lt; 1</td>
      <td>0</td>
      <td>Algorithm for <strong>certain functions that equal 0 at 0</strong>, but with <em>f</em>(<em>λ</em>) = <em>f</em>(1−<em>λ</em>).  (For example, cosh(<em>λ</em>)−1 becomes cosh(1−<em>λ</em>)−1.)<br />Inverted coin.</td>
    </tr>
    <tr>
      <td>1</td>
      <td>0</td>
      <td>Algorithm for <strong>certain functions that equal 0 at 0 and 1 at 1</strong>, but with <em>f</em>(<em>λ</em>) = 1−<em>f</em>(<em>λ</em>).<br />Inverted result.</td>
    </tr>
    <tr>
      <td>1</td>
      <td>&gt; 0 and ≤ 1</td>
      <td>Algorithm for <strong>certain functions that equal 0 at 0</strong>, but with <em>f</em>(<em>λ</em>) = 1−<em>f</em>(<em>λ</em>).<br />Inverted result.</td>
    </tr>
  </tbody>
</table>

<p><a id="Another_General_Algorithm"></a></p>

<h3 id="another-general-algorithm">Another General Algorithm</h3>

<p>The algorithm I’ve developed in this section simulates $f(\lambda)$ when $f$ belongs in a large class of functions, as long as the following is known:</p>

<ul>
  <li>$f$ is continuous and has a minimum of greater than 0 and a maximum of less than 1.</li>
  <li>There is a family of polynomials ($L_{1}(f)$, $L_{2}(f)$, $L_{4}(f)$, $L_{8}(f)$, …) that come close to $f$ with a known error bound, where the number after $L$ is the degree of the polynomial.</li>
  <li>There is a way to find the <em>Bernstein coefficients</em> of each polynomial $L_{n}(f)$ in the family of polynomials.</li>
</ul>

<p>For examples of suitable polynomials, see <a href="https://peteroupc.github.io/bernapprox.html"><strong>“Approximations in Bernstein Form”</strong></a>.</p>

<p>In effect, the algorithm writes $f$ as an infinite sum of polynomials, whose maximums must sum to 1 or less (called <em>T</em> in the algorithm below), then simulates an appropriate <a href="https://peteroupc.github.io/bernoulli.html#Convex_Combinations"><strong>convex combination</strong></a> (weighted sum) of these polynomials.  To build the convex combination, each polynomial in the infinite sum is divided by an upper bound on its maximum (which is why error bounds on $L_{n}(f)$ are crucial here).<sup id="fnref:6" role="doc-noteref"><a href="#fn:6" class="footnote" rel="footnote">6</a></sup> To simulate $f$, the algorithm—</p>

<ul>
  <li>selects a polynomial in the convex combination with probability proportional to its upper bound, or a “leftover” zero polynomial with probability <em>T</em>, then</li>
  <li>simulates the chosen polynomial (which is easy to do; see Goyal and Sigman (2012)<sup id="fnref:7" role="doc-noteref"><a href="#fn:7" class="footnote" rel="footnote">7</a></sup>).</li>
</ul>

<hr />

<ul>
  <li>In the algorithm, denote:
    <ul>
      <li>$\epsilon(f, n)$ as an upper bound on the absolute value of the difference between $f$ and the degree-$n$ polynomial $L_{n}(f)$. $\epsilon(f, n)$ must increase nowhere as $n$ increases, and must converge to 0.
        <ul>
          <li>For best results, this should be written as $\epsilon(f, n) = C/n^r$, where $C$ is a constant and $r&gt;0$ is a multiple of 1/2, since then it’s easy to find the value of ErrShift(f, n), below.  In this case, the algorithm should be limited to functions with a continuous $(2r)$-th derivative or a Lipschitz continuous $(2r-1)$-th derivative (see “<a href="#Achievable_Simulation_Rates"><strong>Achievable Simulation Rates</strong></a>”, later).  (For example, if the error bound is $C/n^2$, the function $f$ should have a continuous fourth derivative or a Lipschitz continuous third derivative.)</li>
          <li>For examples of error bounds, see <a href="https://peteroupc.github.io/bernapprox.html"><strong>“Approximations in Bernstein Form”</strong></a>.</li>
        </ul>
      </li>
      <li>ErrShift($f, m$) as 1.01 $\cdot\sum_{i\ge m} \epsilon(f, 2^i)$.  The factor 1.01 is needed to ensure each difference polynomial is strictly between 0 and 1.
        <ul>
          <li><strong>Example:</strong> If $\epsilon(f, n) = C/n^r$, then ErrShift($f, m)$ = $1.01\cdot C\cdot 2^r/(((2^r)-1)\cdot 2^{rm})$.</li>
        </ul>
      </li>
      <li>DiffWidth($f, m$) as 1.01 $\cdot 2 (\epsilon(f, 2^m)$ + $\epsilon(f, 2^{m+1}))$.  This is an upper bound on the maximum difference between the shifted degree-$2^m$ and the shifted degree-$(2^{m+1})$ polynomial.</li>
    </ul>
  </li>
  <li>The technique breaks $f$ into a <strong>starting polynomial</strong> and a family of <strong>difference polynomials</strong>.<br />To find the <strong>starting polynomial</strong>:
    <ol>
      <li>Set $m$ to 0.</li>
      <li>Find the Bernstein coefficients of $L_{2^m}$, then subtract ErrShift($f, m$) from them.  If those coefficients now all lie in the closed unit interval, go to the next step.  Otherwise, add 1 to <em>m</em> and repeat this step.</li>
      <li>Calculate <strong>StartWidth</strong> as ceil($c\cdot 65536$)/65536, where $c$ is the maximum Bernstein coefficient from step 2, then divide each Bernstein coefficient by <strong>StartWidth</strong>. (65536 is arbitrary and ensures <strong>StartWidth</strong> is a rational number that is close to, but no lower than, the maximum Bernstein coefficient, for convenience.)</li>
      <li>The <strong>starting polynomial</strong> now has Bernstein coefficients found in step 3.  Set <strong>StartOrder</strong> to <em>m</em>.</li>
    </ol>
  </li>
  <li>To find the <strong>difference polynomial</strong> of order $m$:
    <ol>
      <li>Find the Bernstein coefficients of $L_{2^m}$, then subtract ErrShift($f, m$) from them.  Rewrite them to Bernstein coefficients of degree $2^{m+1}$.  Call the coefficients <strong>LowerCoeffs</strong>.</li>
      <li>Find the Bernstein coefficients of $L_{2^{m+1}}$, then subtract ErrShift($f, m+1$) from them.  Call the resulting values <strong>UpperCoeffs</strong>.</li>
      <li>Subtract <strong>UpperCoeffs</strong> from <strong>LowerCoeffs</strong>, and call the result <strong>DiffCoeffs</strong>.  Divide each coefficient in <strong>DiffCoeffs</strong> by DiffWidth($f, m$).  The result is the Bernstein coefficients of a positive polynomial of degree $2^{m+1}$ bounded by 0 and 1, but these coefficients are not necessarily bounded by 0 and 1.  Thus, if any coefficient in <strong>DiffCoeffs</strong> is less than 0 or greater than 1, add 1 to <em>m</em> and rewrite <strong>DiffCoeffs</strong> to Bernstein coefficients of degree $2^{m+1}$ until no coefficient is less than 0 or greater than 1 anymore.</li>
      <li>The <strong>difference polynomial</strong> now has Bernstein coefficients given by <strong>DiffCoeffs</strong>.</li>
    </ol>
  </li>
  <li>The probabilities for <em>X</em> are as follows:
    <ul>
      <li>First, find the <strong>starting polynomial</strong>, then calculate <em>T</em> as <strong>StartWidth</strong> + $\sum_{i\ge 0}$ DiffWidth($f$, <strong>StartOrder</strong>+<em>i</em>).  If <em>T</em> is greater than 1, this algorithm can’t be used.
        <ul>
          <li><strong>Example:</strong> If $\epsilon(f, n) = C/n^r$, then <em>T</em> = <strong>StartWidth</strong> + 1.01 $\cdot(2 \cdot 2^{-r\cdot\text{StartOrder}} C (1 + 2^{- r}))/(1 - 2^{- r})$.</li>
        </ul>
      </li>
      <li><em>X</em> is 0 with probability 1 − <em>T</em>.</li>
      <li><em>X</em> is 1 with probability equal to <strong>StartWidth</strong>.</li>
      <li>For each <em>m</em> ≥ 2, <em>X</em> is <em>m</em> with probability equal to DiffWidth($f$,<strong>StartOrder</strong> + <em>m</em> − 2).</li>
    </ul>
  </li>
</ul>

<p>Then an algorithm to toss heads with probability equal to $f$ would be:</p>

<ol>
  <li>Generate <em>X</em> at random with the probabilities given above.</li>
  <li>If <em>X</em> is 0, return 0.  Otherwise, if <em>X</em> is 1, find the <strong>starting polynomial</strong> and its Bernstein coefficients.  Otherwise (if <em>X</em> is 2 or greater), find the <strong>difference polynomial</strong> of order <em>m</em> and its Bernstein coefficients, where <em>m</em> = (<em>X</em>−2) + <strong>StartOrder</strong>.</li>
  <li>Flip the input coin (with probability of heads $\lambda$), $n - 1$ times, where $n$ is the number of Bernstein coefficients in the polynomial found in step 2 (its degree plus one), and let $j$ be the number of heads.</li>
  <li>Return 1 with probability equal to the polynomial’s $j$th Bernstein coefficient ($j$ starts at 0), or 0 otherwise (see also Goyal and Sigman 2012 for an algorithm to simulate polynomials).</li>
</ol>

<p>If <em>T</em> turns out to be greater than 1 in this algorithm, but still finite, one way to simulate $f$ is to create a coin that simulates $f(\lambda)/T$ instead, and use that coin as the input to a <a href="https://peteroupc.github.io/bernoulli.html#Linear_Bernoulli_Factories"><strong><em>linear Bernoulli factory</em></strong></a> that simulates $T\cdot (f(\lambda)/T)$.  (This is possible especially because $f(\lambda)$ is assumed to have a maximum of less than 1.)</p>

<blockquote>
  <p><strong>Example</strong>: The following parameters allow this algorithm to work if $f$ is concave, has a maximum of less than 1, and has a Lipschitz-continuous derivative with Lipschitz constant <em>M</em> or less.  In this case, it is allowed that $f(0)=0$, $f(1)=0$, or both.</p>

  <ul>
    <li>The family of polynomials $L_n(f)$ is simply the family of Bernstein polynomials of $f$.  The Bernstein coefficients of $L_n(f)$ are $f(0/n), f(1/n), …, f(n/n)$.</li>
    <li>The error bound is $\epsilon(f, n) = M/(8n)$ (Lorentz 1963)<sup id="fnref:8" role="doc-noteref"><a href="#fn:8" class="footnote" rel="footnote">8</a></sup>.</li>
    <li>The <strong>starting polynomial</strong> is found as follows. Let <em>c</em> = max($f(0), f(1)$).  Then the starting polynomial has two Bernstein coefficients both equal to $c$; <strong>StartWidth</strong> is equal to ceil($c\cdot 65536$)/65536, and <strong>StartOrder</strong> is equal to 0.</li>
    <li>ErrShift($f,m$) = 0. The reason for 0 is that $f$ is concave, so its Bernstein polynomials naturally “increase” with increasing degree (Temple 1954)<sup id="fnref:9" role="doc-noteref"><a href="#fn:9" class="footnote" rel="footnote">9</a></sup>, (Moldovan 1962)<sup id="fnref:10" role="doc-noteref"><a href="#fn:10" class="footnote" rel="footnote">10</a></sup>.</li>
    <li>DiffWidth($f,m$) = $1.01\cdot 3 M/(8\cdot 2^m)$.  For the same reason as the previous point, and because the Bernstein polynomials are always “below” $f$, DiffWidth($f,m$) can also equal 1.01 $\cdot \epsilon(f, 2^{m})$ = $1.01\cdot M/(8\cdot 2^m)$.  This is what is used to calculate <em>T</em>, below.</li>
    <li><em>T</em> is calculated as <strong>StartWidth</strong> + $1.01\cdot M/4$.</li>
  </ul>
</blockquote>

<p><a id="Request_for_Additional_Methods"></a></p>

<h3 id="request-for-additional-methods">Request for Additional Methods</h3>

<p>Readers are requested to let me know of additional solutions to the following problem:</p>

<p><em>Let $f(\lambda)$ be continuous and satisfy $0\lt f(\lambda)\lt 1$ whenever $0\le\lambda\le 1$.  Given that $f(\lambda)$ belongs to a large class of functions (for example, it has a continuous, Lipschitz continuous, concave, or nowhere decreasing $k$-th derivative for some integer $k$, or any combination of these), compute the Bernstein coefficients for two sequences of polynomials as follows: one of them approaches $f(\lambda)$ from above, the other from below, and the consistency requirement must be met (see “<a href="#General_Factory_Functions"><strong>General Factory Functions</strong></a>”).</em></p>

<p><em>The polynomials need to be computed only for degrees 2, 4, 8, 16, and higher powers of 2.</em></p>

<p><em>The rate of convergence must be no slower than $1/n^{r/2}$ if the given class has only functions with continuous $r$-th derivative.</em></p>

<p><em>Methods that use only integer arithmetic and addition and multiplication of rational numbers are preferred (thus, methods that involve cosines, sines, $\pi$, $\exp$, and $\ln$ are not preferred).</em></p>

<p>See also the <a href="https://peteroupc.github.io/bernreq.html#Polynomials_that_approach_a_factory_function_fast"><strong>open questions</strong></a>.</p>

<p><a id="Approximate_Bernoulli_Factories"></a></p>

<h2 id="approximate-bernoulli-factories">Approximate Bernoulli Factories</h2>

<p>An <strong>approximate Bernoulli factory</strong> for a function <em>f</em>(<em>λ</em>) is a Bernoulli factory algorithm that simulates another function, <em>g</em>(<em>λ</em>), that approximates <em>f</em> in some sense.</p>

<p>Usually <em>g</em> is a polynomial, but can also be a rational function (ratio of polynomials) or another function with an easy-to-implement Bernoulli factory algorithm.</p>

<p>Meanwhile, <em>f</em>(<em>λ</em>) can be any function that maps the closed unit interval to itself, even if it isn’t continuous or a factory function (examples include the “step function” 0 if <em>λ</em> &lt; 1/2 and 1 otherwise, or the function 2*min(<em>λ</em>, 1 − <em>λ</em>)).  If the function is continuous, it can be approximated arbitrarily well by an approximate Bernoulli factory (as a result of the so-called “Weierstrass approximation theorem”), but generally not if the function is discontinuous.</p>

<p>To build an approximate Bernoulli factory with a polynomial:</p>

<ol>
  <li>
    <p>First, find a polynomial in Bernstein form of degree <em>n</em> that is close enough to the desired function <em>f</em>(<em>λ</em>).</p>

    <p>The simplest choice for this polynomial, known simply as a <em>Bernstein polynomial</em>, has <em>n</em>+1 Bernstein coefficients and its <em>j</em><sup>th</sup> coefficient (starting at 0) is found as <em>f</em>(<em>j</em>/<em>n</em>).  For this choice, if <em>f</em> is continuous, the polynomial can be brought arbitrarily close to <em>f</em> by choosing <em>n</em> high enough.</p>

    <p>Other choices for this polynomial are given in the page <a href="https://peteroupc.github.io/bernapprox.html"><strong>“Approximations in Bernstein Form”</strong></a>.</p>

    <p>Whatever polynomial is used, the polynomial’s Bernstein coefficients must all lie on the closed unit interval.</p>

    <p>The polynomial can be in <em>homogeneous form</em> (also known as <em>scaled Bernstein</em> form (Farouki and Rajan 1988)<sup id="fnref:11" role="doc-noteref"><a href="#fn:11" class="footnote" rel="footnote">11</a></sup>) instead of in Bernstein form, with <em>scaled Bernstein coefficients</em> $s_0, …, s_n$, as long as $0\le s_i\le{n\choose i}$ where $0\le i\le n$.</p>
  </li>
  <li>
    <p>The rest of the process is to toss heads with probability equal to that polynomial, given its Bernstein coefficients.  To do this, first flip the input coin <em>n</em> times, and let <em>j</em> be the number of times the coin returned 1 this way.</p>
  </li>
  <li>
    <p>Then, with probability equal to—</p>

    <ul>
      <li>the polynomial’s Bernstein coefficient at position <em>j</em> (which will be $f(j/n)$ in the case of the Bernstein polynomial $B_n(f)$), or</li>
      <li>the polynomial’s scaled Bernstein coefficient at position <em>j</em>, divided by choose(<em>n</em>, <em>j</em>),</li>
    </ul>

    <p>return 1.  Otherwise, return 0. Here, 0≤<em>j</em>≤<em>n</em>.</p>

    <p>If the probability can be an irrational number, see “<a href="https://peteroupc.github.io/bernoulli.html#Algorithms_for_General_Irrational_Constants"><strong>Algorithms for General Irrational Constants</strong></a>” for ways to exactly sample a probability equal to that irrational number.</p>
  </li>
</ol>

<blockquote>
  <p><strong>Notes:</strong></p>

  <ol>
    <li>More sophisticated ways to implement steps 2 and 3 are found in the section “<a href="https://peteroupc.github.io/bernoulli.html"><strong>Certain Polynomials</strong></a>” in the main article “Bernoulli Factory Algorithms”.</li>
    <li>There are other kinds of functions, besides polynomials and rational functions, that serve to approximate continuous functions.  But many of them work poorly as approximate Bernoulli factory functions because their lack of “smoothness” means there is no simple Bernoulli factory for them.  For example, a <em>spline</em>, which is a continuous function made up of a finite number of polynomial pieces, is generally not “smooth” at the points where the spline’s pieces meet.</li>
    <li>Bias and variance are the two sources of error in a randomized estimation algorithm.  Let <em>g</em>(<em>λ</em>) be an approximation of <em>f</em>(<em>λ</em>). The original Bernoulli factory for <em>f</em>, if it exists, has bias 0 and variance <em>f</em>(<em>λ</em>)*(1−<em>f</em>(<em>λ</em>)), but the approximate Bernoulli factory has bias <em>g</em>(<em>λ</em>) − <em>f</em>(<em>λ</em>) and variance <em>g</em>(<em>λ</em>)*(1−<em>g</em>(<em>λ</em>)). (“Variance reduction” methods are outside the scope of this document.)  An estimation algorithm’s <em>mean squared error</em> equals variance plus square of bias.</li>
    <li>There are two known approximations to the linear function $f(\lambda) = 2\lambda$ using a polynomial in Bernstein form of degree $n$ that maps the open interval (0, 1) to itself.  In each case, if <em>g</em>(<em>λ</em>) is that polynomial and if $0\le\lambda\le 1/2$, then the error in approximating <em>f</em>(<em>λ</em>) is no greater than 1−<em>g</em>(1/2).
      <ul>
        <li>In Henderson and Glynn (2003, Remark 4)<sup id="fnref:12" role="doc-noteref"><a href="#fn:12" class="footnote" rel="footnote">12</a></sup>, the polynomial’s <em>j</em><sup>th</sup> Bernstein coefficient (starting at 0) is min((<em>j</em>/<em>n</em>)*2, 1−1/<em>n</em>).  The polynomial <em>g</em> can be computed with the SymPy computer algebra library as follows: <code>from sympy.stats import *; g=2*E( Min(sum(Bernoulli(("B%d" % (i)),z) for i in range(n))/n,(S(1)-S(1)/n)/2))</code>.</li>
        <li>In Nacu and Peres (2005, section 6)<sup id="fnref:1:3" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>, the polynomial’s <em>j</em><sup>th</sup> Bernstein coefficient (starting at 0) is min((<em>j</em>/<em>i</em>)*2, 1). It corresponds to the following algorithm: Flip the input coin <em>n</em> times or until the ratio of “heads” to “flips” becomes at least 1/2, whichever comes first, then if <em>n</em> flips were made without the ratio becoming at least 1/2, return 0; otherwise, return 1.</li>
      </ul>
    </li>
  </ol>
</blockquote>

<p><a id="Achievable_Simulation_Rates"></a></p>

<h2 id="achievable-simulation-rates">Achievable Simulation Rates</h2>

<p>In general, the number of input coin flips needed by any Bernoulli factory algorithm for a factory function <em>f</em>(<em>λ</em>) depends on how “smooth” the function <em>f</em> is.</p>

<p>The following table summarizes the rate of simulation (in terms of the number of input coin flips needed) that can be achieved <em>in theory</em> depending on <em>f</em>(<em>λ</em>), assuming the input coin’s probability of heads is unknown.  In the table below:</p>

<ul>
  <li><em>λ</em>, the unknown probability of heads, is <em>ε</em> or greater and (1−<em>ε</em>) or less for some <em>ε</em> &gt; 0.</li>
  <li>The simulation makes use of a <em>fair coin</em> (a coin that shows 1 or 0 with equal probability) in addition to input coin flips.</li>
  <li><em>Δ</em>(<em>n</em>, <em>r</em>, <em>λ</em>) = max(sqrt(<em>λ</em>*(1−<em>λ</em>)/<em>n</em>),1/<em>n</em>)<sup><em>r</em></sup>.</li>
</ul>

<table>
  <thead>
    <tr>
      <th>Property of simulation</th>
      <th>Property of <em>f</em></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Requires no more than <em>n</em> input coin flips.</td>
      <td>If and only if <em>f</em> can be written as a polynomial of degree <em>n</em> with Bernstein coefficients in the closed unit interval (Goyal and Sigman 2012)<sup id="fnref:7:1" role="doc-noteref"><a href="#fn:7" class="footnote" rel="footnote">7</a></sup>.</td>
    </tr>
    <tr>
      <td>Requires a finite number of flips on average. Also known as “realizable” by Flajolet et al. (2010)<sup id="fnref:13" role="doc-noteref"><a href="#fn:13" class="footnote" rel="footnote">13</a></sup>.</td>
      <td>Only if <em>f</em> is Lipschitz continuous (Nacu and Peres 2005)<sup id="fnref:1:4" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>.<br />Whenever <em>f</em> admits a fast simulation (Mendo 2019)<sup id="fnref:14" role="doc-noteref"><a href="#fn:14" class="footnote" rel="footnote">14</a></sup>.</td>
    </tr>
    <tr>
      <td>Number of flips required, raised to power of <em>r</em>, is bounded by a finite number on average and has a tail that drops off uniformly over <em>f</em>’s domain.</td>
      <td>Only if <em>f</em> has continuous <em>r</em>-th derivative (Nacu and Peres 2005)<sup id="fnref:1:5" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>.</td>
    </tr>
    <tr>
      <td>Requires more than <em>n</em> flips with at most a probability proportional to <em>Δ</em>(<em>n</em>, <em>r</em> + 1, <em>λ</em>), for integer <em>r</em> ≥ 0 and every <em>λ</em>, and for large enough <em>n</em>. (The greater <em>r</em> is, the faster the simulation.)</td>
      <td>Only if <em>f</em> has an <em>r</em>-th derivative that is continuous and in the Zygmund class (see note below) (Holtz et al. 2011, Theorem 13)<sup id="fnref:15" role="doc-noteref"><a href="#fn:15" class="footnote" rel="footnote">15</a></sup>.</td>
    </tr>
    <tr>
      <td>Requires more than <em>n</em> flips with at most a probability proportional to <em>Δ</em>(<em>n</em>, <em>α</em>, <em>λ</em>), for non-integer <em>α</em> &gt; 0 and every <em>λ</em>, and for large enough <em>n</em>. (The greater <em>α</em> is, the faster the simulation.)</td>
      <td>If and only if <em>f</em> has an <em>r</em>-th derivative that is Hölder continuous with Hölder exponent (<em>α</em> − <em>r</em>) or greater, where <em>r</em> = floor(<em>α</em>) (Holtz et al. 2011, Theorem 8)<sup id="fnref:15:1" role="doc-noteref"><a href="#fn:15" class="footnote" rel="footnote">15</a></sup>. Assumes <em>f</em> is bounded away from 0 and 1.</td>
    </tr>
    <tr>
      <td>“Fast simulation” (requires more than <em>n</em> flips with a probability that decays exponentially or faster as <em>n</em> gets large).  Also known as “strongly realizable” by Flajolet et al. (2010)<sup id="fnref:13:1" role="doc-noteref"><a href="#fn:13" class="footnote" rel="footnote">13</a></sup>.</td>
      <td>If and only if <em>f</em> is analytic at every point in its domain (see note below) (Nacu and Peres 2005)<sup id="fnref:1:6" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>.</td>
    </tr>
    <tr>
      <td>Average number of flips greater than or equal to (<em>f′</em>(<em>λ</em>))<sup>2</sup>*<em>λ</em>*(1−<em>λ</em>)/(<em>f</em>(<em>λ</em>)*(1−<em>f</em>(<em>λ</em>))), where <em>f′</em> is the first derivative of <em>f</em>.</td>
      <td>Whenever <em>f</em> admits a fast simulation (Mendo 2019)<sup id="fnref:14:1" role="doc-noteref"><a href="#fn:14" class="footnote" rel="footnote">14</a></sup>.</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p><strong>Note:</strong> A function $f(\lambda)$ is:</p>

  <ul>
    <li>
      <p><em>Analytic</em> at a point $z$ if there is a positive number $r$ such that $f$ is writable as—</p>

\[f(\lambda)=f(z)+f^{(1)}(z)(\lambda-z)^1/1! + f^{(2)}(z)(\lambda-z)^2/2! + ...,\]

      <p>for every point $\lambda$ satisfying abs($\lambda-z$) &lt; $r$, where $f^{(i)}$ is the $i$-th derivative of $f$.</p>
    </li>
    <li>
      <p>In the <em>Zygmund class</em> if it is continuous and there is a positive number $D$ with the following property: For each step size $\epsilon&gt;0$, abs($f(x-h) + f(x+h) - 2f(x)$) $\le D\times\epsilon$ wherever the left-hand side is defined and $0\lt h\le\epsilon$. The Zygmund class includes the two “smaller” classes of Lipschitz continuous functions (see “Definitions”) and functions with a continuous derivative.</p>
    </li>
  </ul>
</blockquote>

<p><a id="Notes"></a></p>

<h2 id="notes">Notes</h2>

<p><a id="Appendix"></a></p>

<h2 id="appendix">Appendix</h2>

<p><a id="Examples_of_Well_Behaved_Functions"></a></p>

<h3 id="examples-of-well-behaved-functions">Examples of Well-Behaved Functions</h3>

<p>In the examples given in this section, <em>f</em>(<em>λ</em>) is a function defined on the closed unit interval.</p>

<p>Generally, how well-behaved a function is depends on how many continuous derivatives it has, and whether those derivatives are Lipschitz continuous or Hölder continuous, among other things.  The following lists several classes of functions, from worst to best behaved and from “largest” to “smallest”:</p>

<p>Functions continuous except possibly at one point → Continuous functions → Hölder continuous functions → Lipschitz continuous functions → With continuous first derivative → With Hölder continuous first derivative →  With Lipschitz continuous first derivative → With continuous second derivative → With infinitely many derivatives → Analytic functions.</p>

<p><strong>Concave and convex functions.</strong>  The following table shows examples of functions that are convex, concave, or neither.  All these functions are continuous.  Also, review the <a href="#Definitions"><strong>definitions</strong></a>.</p>

<table>
  <thead>
    <tr>
      <th>Function <em>f</em>(<em>λ</em>)</th>
      <th>Convex or concave?</th>
      <th>Notes</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1− <em>λ</em><sup>2</sup>.</td>
      <td>Concave.</td>
      <td> </td>
    </tr>
    <tr>
      <td><em>λ</em><sup>2</sup>.</td>
      <td>Convex.</td>
      <td> </td>
    </tr>
    <tr>
      <td><em>λ</em><sup>2</sup> − <em>λ</em><sup>3</sup>.</td>
      <td>Neither.</td>
      <td> </td>
    </tr>
    <tr>
      <td><em>λ</em><sup><em>z</em></sup>, where 0&lt; <em>z</em>≤ 1.</td>
      <td>Concave.</td>
      <td> </td>
    </tr>
    <tr>
      <td><em>λ</em><sup><em>z</em></sup>, where <em>z</em>≥ 1.</td>
      <td>Convex.</td>
      <td> </td>
    </tr>
    <tr>
      <td>exp(−<em>λ</em>/4).</td>
      <td>Concave.</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p><strong>Hölder and Lipschitz continuous functions.</strong> The following table shows some functions that are Hölder continuous and some that are not.  Also, review the <a href="#Definitions"><strong>definitions</strong></a>.</p>

<table>
  <thead>
    <tr>
      <th>Function <em>f</em>(<em>λ</em>):</th>
      <th>Hölder exponent (<em>α</em>) and an upper bound of the Hölder constant (<em>H</em>):</th>
      <th>Notes</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>$\lambda^z\cdot t$.</td>
      <td><em>α</em>=<em>z</em>.<br /><em>L</em>=abs(<em>t</em>).</td>
      <td>$0\lt z\le 1$, $t\ne 0$.</td>
    </tr>
    <tr>
      <td>$\lambda^z\cdot t$.</td>
      <td><em>α</em>=1 (Lipschitz continuous).<br /><em>L</em>=<em>z</em>*abs(<em>t</em>).</td>
      <td>$z\ge 1$, $t$ is a real number.</td>
    </tr>
    <tr>
      <td>$\lambda^{1/3}/4 + \lambda^{2/3}$/5.</td>
      <td><em>α</em>=1/3.<br /><em>L</em>=9/20.</td>
      <td><em>α</em> is the minimum of Hölder exponents, min(1/3, 2/3), and <em>L</em> is the sum of Hölder constants, 1/4+1/5.</td>
    </tr>
    <tr>
      <td>$1/2-(1-2\lambda)^{z}/2$ if $\lambda&lt;1/2$ and $1/2+(2\lambda-1)^{z}/2$ otherwise.</td>
      <td><em>α</em>=<em>z</em>.<br /><em>L</em>=$2^z/2$.</td>
      <td>$0\lt z\le 1$.  In this example, $f$ has a “vertical” slope at 1/2, unless <em>z</em> is 1.</td>
    </tr>
    <tr>
      <td>$3/4-\sqrt{\lambda(1-\lambda)}$.</td>
      <td><em>α</em>=1/2.<br /><em>L</em>=1.</td>
      <td>Has a “vertical” slope at 0 and 1.</td>
    </tr>
    <tr>
      <td>Continuous and <strong>piecewise linear</strong>.</td>
      <td><em>α</em>=1.<br /><em>L</em> is the greatest absolute value of the slope among all pieces’ slopes.</td>
      <td><em>f</em>(<em>λ</em>) is <em>piecewise linear</em> if it’s made up of multiple linear functions defined on a finite number of “pieces”, or non-empty subintervals, that together make up $f$’s domain (in this case, the closed unit interval).</td>
    </tr>
    <tr>
      <td>Piecewise linear; equals 0 at 0, 3/4 at 2/3 and 1/4 at 1, and these points are connected by linear functions.</td>
      <td><em>α</em>=1.<br /><em>L</em> = 1.5.</td>
      <td><em>L</em> = $\max(\text{abs}((3/4-0)/(2/3))$, $\text{abs}((1/4-3/4)/(1/3)))$.<br />Concave because the first piece’s slope is greater than the second piece’s.</td>
    </tr>
    <tr>
      <td>min(<em>λ</em>*<em>mult</em>, 1−<em>ε</em>).</td>
      <td><em>α</em>=1.<br /><em>L</em> = <em>mult</em>.</td>
      <td><em>mult</em> &gt; 0, <em>ε</em> &gt; 0.  Piecewise linear; equals 0 at 0, 1−<em>ε</em> at (1−<em>ε</em>)/<em>mult</em>, and 1−<em>ε</em> at 1.<br /><em>L</em>=max(<em>mult</em>, 0).<br />Concave.</td>
    </tr>
    <tr>
      <td>1/10 if <em>λ</em> is 0; −1/(2*ln(<em>λ</em>/2)) + 1/10 otherwise.</td>
      <td>Not Hölder continuous.</td>
      <td>Has a slope near 0 that’s steeper than every “nth” root.</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p><strong>Note:</strong> A Hölder continuous function with Hölder exponent <em>α</em> and Hölder constant <em>L</em> is also Hölder continuous with Hölder exponent <em>β</em> and Hölder constant bounded above by <em>L</em>, where 0 &lt; <em>β</em> &lt; <em>α</em>.</p>
</blockquote>

<p><strong>Finding parameters <em>α</em> and <em>L</em> for Hölder continuous functions.</strong> If $f(\lambda)$ is continuous, the following is one way to find the Hölder exponent (<em>α</em>) and Hölder constant (<em>L</em>) of $f$, to determine whether $f$ is Hölder continuous, not just continuous.</p>

<p>First, if $f$ has a bounded and continuous first derivative on its domain, then <em>α</em> is 1 ($f$ is <strong>Lipschitz continuous</strong>) and <em>L</em> is the maximum of the absolute value of that derivative.</p>

<p>Otherwise, consider the function $h(\lambda, c)=\text{abs}(f(\lambda)-f(c))/((\text{abs}(\lambda-c))^\alpha)$, or 0 if $\lambda=c$, where $0\lt\alpha\le 1$ is a Hölder exponent to test. For a given $\alpha$, let $g(\lambda)$ be the maximum of $h(\lambda,c)$ over all points $c$ where $f$ has a “vertical slope” or the “steepest slope exhibited”.  If $g(\lambda)$ is bounded for a given $\alpha$ on $f$’s domain (in this case, the closed unit interval), then $f$ is Hölder continuous with Hölder exponent $\alpha$ and Hölder constant (<em>L</em>) equal to or greater than the maximum value of $g(\lambda)$ on its domain.</p>

<p>The following example, which uses the SymPy computer algebra library, plots $\max(h(\lambda,0),h(\lambda,1))$ when $f=\sqrt{\lambda(1-\lambda)}$ and $\alpha=1/2$: <code>lamda,c=symbols('lamda c'); func=sqrt(lamda*(1-lamda)); alpha=S(1)/2; h=Abs(func-func.subs(lamda,c))/Abs(lamda-c)**alpha; plot(Max(h.subs(c, 0), h.subs(c,1)), (lamda, 0, 1))</code>.</p>

<p><strong>Functions with a Hölder continuous or Lipschitz continuous derivative.</strong> The following table shows some functions whose derivatives are Hölder continuous, and others where that is not the case. (In the SymPy library, a function’s derivative can be found using the <code>diff</code> method.) In the table below, if $f$ has a bounded and continuous <em>second</em> derivative on its domain, then <em>α</em> is 1 (the first derivative is Lipschitz continuous) and <em>L</em> is the maximum of the absolute value of that <em>second</em> derivative.</p>

<table>
  <thead>
    <tr>
      <th>Function $f(\lambda)$</th>
      <th>Derivative’s Hölder exponent (<em>α</em>) and an upper bound of the derivative’s Hölder constant (<em>L</em>):</th>
      <th>Notes</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><em>λ</em><sup>1+<em>β</em></sup></td>
      <td><em>α</em>=<em>β</em>.<br /><em>L</em> = 1+<em>β</em>.</td>
      <td>0 &lt; <em>β</em> ≤ 1.</td>
    </tr>
    <tr>
      <td>$3/4-\sqrt{\lambda(1-\lambda)}$.</td>
      <td>Derivative is not Hölder continuous.</td>
      <td>Derivative is not Hölder continuous because $f$ is not Lipschitz continuous.</td>
    </tr>
    <tr>
      <td>cosh(<em>λ</em>) − 3/4.</td>
      <td><em>α</em>=1 (derivative is Lipschitz continuous).<br /><em>L</em> = cosh(1).</td>
      <td>Continuous second derivative, namely cosh(<em>λ</em>).  Convex. <code>cosh</code> is the hyperbolic cosine function.</td>
    </tr>
    <tr>
      <td>$\lambda\cdot\sin(z\lambda)/4+1/2$.</td>
      <td><em>α</em>=1.<br /><em>L</em> = $z(2+z\lambda)/4$.</td>
      <td>Continuous second derivative. <em>L</em> is an upper bound of its absolute value. $z&gt;0$.</td>
    </tr>
    <tr>
      <td>$\sin(z\lambda)/4+1/2$.</td>
      <td><em>α</em>=1.<br /><em>L</em> = $(z^2)/4$.</td>
      <td>Continuous second derivative; <em>L</em> is an upper bound of its absolute value, namely abs($-\sin(z\lambda)\cdot z^2/4$). $z&gt;0$.</td>
    </tr>
    <tr>
      <td><em>λ</em><sup>2</sup>/2 + 1/10 if <em>λ</em> ≤ 1/2; <em>λ</em>/2 − 1/40 otherwise.</td>
      <td><em>α</em>=1.<br /><em>L</em> = 1.</td>
      <td>Lipschitz continuous derivative, with Lipschitz constant 1.</td>
    </tr>
    <tr>
      <td>exp(−<em>λ</em>).</td>
      <td><em>α</em>=1.<br /><em>L</em> = 1.</td>
      <td>Lipschitz continuous derivative, with Lipschitz constant 1.<sup id="fnref:16" role="doc-noteref"><a href="#fn:16" class="footnote" rel="footnote">16</a></sup></td>
    </tr>
    <tr>
      <td><em>λ</em>/2 if <em>λ</em> ≤ 1/2; (4*<em>λ</em> − 1)/(8*<em>λ</em>) otherwise.</td>
      <td><em>α</em>=1.<br /><em>L</em>=1.</td>
      <td>Concave. Lipschitz continuous derivative with Lipschitz constant 2.</td>
    </tr>
  </tbody>
</table>

<p><a id="Results_Used_in_Approximate_Bernoulli_Factories"></a></p>

<h3 id="results-used-in-approximate-bernoulli-factories">Results Used in Approximate Bernoulli Factories</h3>

<p>See the appendix of the page <a href="https://peteroupc.github.io/bernapprox.html"><strong>“Approximations in Bernstein Form”</strong></a>.</p>

<p><a id="How_Many_Coin_Flips_Are_Needed_to_Simulate_a_Polynomial"></a></p>

<h3 id="how-many-coin-flips-are-needed-to-simulate-a-polynomial">How Many Coin Flips Are Needed to Simulate a Polynomial?</h3>

<p>Let $p(\lambda)$ be a polynomial that maps the closed unit interval to itself and satisfies $0\lt p(\lambda)\lt 1$ whenever $0\lt\lambda\lt 1$.</p>

<p>Then $p$’s <em>coin-flipping degree</em> (Wästlund 1999)<sup id="fnref:17" role="doc-noteref"><a href="#fn:17" class="footnote" rel="footnote">17</a></sup> is the smallest value of $n$ such that $p$’s Bernstein coefficients of degree $n$ lie in the closed unit interval. <sup id="fnref:18" role="doc-noteref"><a href="#fn:18" class="footnote" rel="footnote">18</a></sup>  (This is broader than the use of the term in Wästlund, where a polynomial can have a coin-flipping degree only if its “power” coefficients are integers.)  The coin-flipping degree is the smallest value of $n$ such that the algorithm of Goyal and Sigman (2012)<sup id="fnref:7:2" role="doc-noteref"><a href="#fn:7" class="footnote" rel="footnote">7</a></sup> can toss heads with probability $p(\lambda)$ using exactly $n$ biased coin flips (in addition to a fair coin).</p>

<p>The following results give upper bounds on $p$’s coin-flipping degree.</p>

<p>Suppose $p$ is in Bernstein form of degree $m$ with Bernstein coefficients $b_0, …, b_m$.  Then:</p>

<ul>
  <li>If $0\le\min(b_0, …, b_m)\le\max(b_0, …, b_m)\le 1$, then the coin-flipping degree is bounded above by $m$.</li>
  <li>
    <p>If $0\le\min(b_0, …, b_m)$ and $\max(b_0, …, b_m)\gt 1$, then the coin-flipping degree is bounded above by—</p>

\[m+\text{iceil}\left(\frac{m(m-1)}{2}\frac{\max(1-b_0, ..., 1-b_m)}{1-\text{Pmax}} - m\right),\]

    <p>where iceil($x$) is $x+1$ if $x$ is an integer, or ceil($x$) otherwise, and where $\text{Pmax}$ is the maximum value of $p(\lambda)$ on the closed unit interval (Powers and Reznick 2001)<sup id="fnref:19" role="doc-noteref"><a href="#fn:19" class="footnote" rel="footnote">19</a></sup>.</p>
  </li>
  <li>
    <p>If $\min(b_0, …, b_m)\lt 0$ and $\max(b_0, …, b_m)\le 1$, then the coin-flipping degree is bounded above by—</p>

\[m+\text{iceil}\left(\frac{m(m-1)}{2}\frac{\max(b_0, ..., b_m)}{\text{Pmin}} - m\right),\]

    <p>where $\text{Pmin}$ is the <em>minimum</em> value of $p(\lambda)$ on the closed unit interval (Powers and Reznick 2001)<sup id="fnref:19:1" role="doc-noteref"><a href="#fn:19" class="footnote" rel="footnote">19</a></sup>.</p>
  </li>
  <li>
    <p>Suppose $m\ge 2$, that $b_0=0$ or $b_m=0$ or both, and that the following necessary conditions are satisfied (Mok and To 2008; Theorem 1 and Corollary 3)<sup id="fnref:20" role="doc-noteref"><a href="#fn:20" class="footnote" rel="footnote">20</a></sup>:</p>

    <ul>
      <li>For every $i$ such that $b_i\lt 0$, if $b_m=0$, there must be $j\gt i$ such that $b_j\gt 0$.</li>
      <li>For every $i$ such that $b_i\lt 0$, if $b_0=0$, there must be $j\lt i$ such that $b_j\gt 0$.</li>
      <li>For every $i$ such that $b_i\gt 1$, if $b_m=1$, there must be $j\gt i$ such that $b_j\lt 1$.</li>
      <li>For every $i$ such that $b_i\gt 1$, if $b_0=1$, there must be $j\lt i$ such that $b_j\lt 1$.</li>
    </ul>

    <p>Then the coin-flipping degree is bounded above by—</p>

\[\max(M(b_0, ..., b_m), M(1-b_0, ..., 1-b_m)),\]

    <p>where—</p>

\[M(\beta_0, ..., \beta_m) = \text{ceil}\left(\max\left(2m, \frac{m(m-1)}{2(1-c)}\frac{a_{\max}}{a_{\min}}\right)\right),\]

    <p>and where:</p>

    <ul>
      <li>$a_{\max} = \max(\max(0,\beta_0),  …, \max(0, \beta_m))$.</li>
      <li>$a_{\min}$ is the minimum of $(\beta_i{m\choose i})$ over all values of $i$ such that $\beta_i&gt;0$.</li>
      <li>$c$ is the smallest number $r$ that satisfies $FN(\lambda)/FP(\lambda)\le r$ where $0\lt\lambda\lt 1$.  $c$ can also be a greater number but less than 1.</li>
      <li>$FP(\lambda) = \sum_{k=0}^m \max(0,\beta_k){m\choose k}\lambda^k(1-\lambda)^{m-k}$.</li>
      <li>$FN(\lambda) = \sum_{k=0}^m \text{abs}(\min(0,\beta_k)){m\choose k}\lambda^k(1-\lambda)^{m-k}$.</li>
    </ul>

    <p>(Mok and To 2008; Theorem 2 and remark 1.5(v))<sup id="fnref:20:1" role="doc-noteref"><a href="#fn:20" class="footnote" rel="footnote">20</a></sup>.</p>
  </li>
</ul>

<blockquote>
  <p><strong>Examples:</strong></p>

  <ol>
    <li>
      <p>Let $p(\lambda)=1 -8\lambda +20\lambda^2 -13\lambda^3$, a polynomial of degree $m=3$.  $p$’s Bernstein coefficients are $b_0=1, b_1=-5/3, b_2=7/3, b_3=0$, and its coin-flipping degree is 46 (Wästlund 1999, Example 4.4)<sup id="fnref:17:1" role="doc-noteref"><a href="#fn:17" class="footnote" rel="footnote">17</a></sup>.  $p$ meets the conditions to use the coin-flipping degree derived from Mok and To (2008)<sup id="fnref:20:2" role="doc-noteref"><a href="#fn:20" class="footnote" rel="footnote">20</a></sup>.  In this case, after some calculations, the coin-flipping degree is bounded above by—</p>

\[\text{ceil}\left(\max\left(\max\left(2\cdot 3, \frac{3(3-1)}{2(1-0.94492)}\frac{7/3}{1}\right), \max\left(2\cdot 3, \frac{3(3-1)}{2(1-0.70711)}\frac{8/3}{1}\right)\right)\right)\le 128.\]
    </li>
    <li>An exhaustive search shows that 46 is the highest possible coin-flipping degree for a degree-3 polynomial whose “power” coefficients are integers.</li>
    <li>The degree-4 polynomial $-43\lambda^4 + 81\lambda^3 - 47\lambda^2 + 9\lambda$ has a coin-flipping degree of 5284.</li>
  </ol>

  <p><strong>Note:</strong> If a polynomial’s “power” coefficients can be rational numbers (ratios of two integers), even a degree-2 polynomial can have an arbitrarily high coin-flipping degree.  An example is the family of degree-2 polynomials $r\lambda-r\lambda^2$, where $r$ is a rational number greater than 0 and less than 4.</p>
</blockquote>

<p><strong>Lemma:</strong> Let $p(\lambda)=a_0 \lambda^0 + … + a_n \lambda^n$ be a polynomial that maps the closed unit interval to itself.  Then the values $a_0, …, a_n$ must sum to a value that is 0 or greater and 1 or less.</p>

<p><em>Proof</em>:  This can be seen by evaluating $p(1) = a_0 + … + a_n$.  If $p(1)$ is less than 0 or greater than 1, then $p$ does not meet the hypothesis of the lemma. □</p>

<p>In the following lemmas, let $p(\lambda)=a_0 \lambda^0 + … + a_n \lambda^n$ be a polynomial that maps the closed unit interval to itself and satisfies $0\lt p(\lambda)\lt 1$ whenever $0\lt\lambda\lt 1$.</p>

<p><strong>Lemma:</strong> If $p$’s coin-flipping degree is $n$, then $\text{abs}(a_i)\le 2^i {n\choose i}$.</p>

<p><em>Proof</em>: Consider the matrix that transforms a polynomial’s Bernstein coefficients to “power” coefficients, which is $n\times n$ if the polynomial’s degree is $n$ (Ray and Nataraj 2012, eq. (8))<sup id="fnref:21" role="doc-noteref"><a href="#fn:21" class="footnote" rel="footnote">21</a></sup>.  Given the hypothesis of the lemma, each Bernstein coefficient must lie in the closed unit interval and the required matrix size is $n$, which is $p$’s coin-flipping degree.  For each row of the matrix ($0\le i\le n$), the corresponding “power” coefficient of the polynomial equals a linear combination of that row with a vector of Bernstein coefficients.  Thus, the $i$-th power coefficient equals $a_i$ and its absolute value is bounded above by $\sum_{m=0}^i {n\choose m}{n-m\choose i-m} = 2^i {n\choose i}$.  □</p>

<p><strong>Lemma:</strong>  $\text{abs}(a_i)\le \text{abs}(b_i)$, where $b_i$ is the corresponding power coefficient of the following polynomial:</p>

\[q(\lambda) = b_0 \lambda^0 + ... + b_n\lambda^n = (T_n(1-2\lambda)+1)/2,\]

<p>and where $T_n(x)$ is the <a href="https://mathworld.wolfram.com/ChebyshevPolynomialoftheFirstKind.html"><strong>Chebyshev polynomial of the first kind</strong></a> of degree $n$.</p>

<p>See <em>MathOverflow</em> for a <a href="https://mathoverflow.net/questions/449135"><strong>proof of this lemma</strong></a> by Fedor Petrov.</p>

<p><a id="Proofs_for_Polynomial_Building_Schemes"></a></p>

<h3 id="proofs-for-polynomial-building-schemes">Proofs for Polynomial-Building Schemes</h3>

<p>This section shows mathematical proofs for some of the polynomial-building schemes of this page.</p>

<p>In the following results:</p>

<ul>
  <li>A <em>strictly bounded factory function</em> means a continuous function on the closed unit interval, with a minimum of greater than 0 and a maximum of less than 1.</li>
  <li>A function <em>f</em>(<em>λ</em>) is <em>polynomially bounded</em> if both <em>f</em>(<em>λ</em>) and 1−<em>f</em>(<em>λ</em>) are greater than or equal to min(<em>λ</em><sup><em>n</em></sup>, (1−<em>λ</em>)<sup><em>n</em></sup>) for some integer <em>n</em> (Keane and O’Brien 1994)<sup id="fnref:22" role="doc-noteref"><a href="#fn:22" class="footnote" rel="footnote">22</a></sup>.  For examples, see “<a href="https://peteroupc.github.io/bernoulli.html#About_Bernoulli_Factories"><strong>About Bernoulli Factories</strong></a>”.</li>
  <li>A <em>modulus of continuity</em> of a function <em>f</em> means a nonnegative and nowhere decreasing function <em>ω</em> on the closed unit interval, for which <em>ω</em>(0) = 0, and for which abs(f(<em>x</em>) − f(<em>y</em>)) ≤ <em>ω</em>(abs(<em>x</em>−<em>y</em>)) whenever <em>x</em> and <em>y</em> are in <em>f</em>’s domain.  Loosely speaking, a modulus of continuity <em>ω</em>(<em>δ</em>) is greater than or equal to <em>f</em>’s maximum range in a window of size <em>δ</em>.</li>
</ul>

<p><strong>Lemma 1.</strong> Omitted.</p>

<p>Lemma 6(i) of Nacu and Peres (2005)<sup id="fnref:1:7" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup> can be applied to continuous functions beyond just Lipschitz continuous functions.  This includes the larger class of <em>Hölder continuous</em> functions (see “<a href="#Definitions"><strong>Definitions</strong></a>”).</p>

<p><strong>Lemma 2.</strong> <em>Let f(λ) be a continuous function that maps the closed unit interval to itself, let X be a hypergeometric(2*n, k, n) random variable, and let $n\ge 1$ be an integer.</em></p>

<ol>
  <li><em>Let ω(x) be a modulus of continuity of f.  If ω is continuous and concave, then the expression—<br />abs(<strong>E</strong>[f(X/n)] − f(k/(2*n))),   (1)<br />is less than or equal to each of the following:</em>
    <ul>
      <li><em>ω(sqrt(1/(8*n−4))).</em></li>
      <li><em>ω(sqrt(1/(7*n))) if n≥4.</em></li>
      <li><em>ω(sqrt(1/(2*n))).</em></li>
      <li><em>ω(sqrt( (k/(2*n)) * (1−k/(2*n)) / (2*n−1) )).</em></li>
    </ul>
  </li>
  <li><em>If f is Hölder continuous with Hölder constant M and with Hölder exponent α such that 0 &lt; α ≤ 1, then the expression (1) is less than or equal to—</em>
    <ul>
      <li><em>M*(1/(2*n))$\alpha/2$,</em></li>
      <li><em>M*(1/(7*n))$\alpha/2$ if n≥4, and</em></li>
      <li><em>M*(1/(8*n−4))$\alpha/2$.</em></li>
    </ul>
  </li>
  <li><em>If f has a Lipschitz continuous derivative with Lipschitz constant M, then the expression (1) is less than or equal to—</em>
    <ul>
      <li><em>(M/2)*(1/(7*n)) if n≥4, and</em></li>
      <li><em>(M/2)*(1/(8*n−4)).</em></li>
    </ul>
  </li>
</ol>

<p><em>Proof.</em></p>

<ol>
  <li><em>ω</em> is assumed to be nonnegative because absolute values are nonnegative.  To prove the first and second bounds: abs(<strong>E</strong>[<em>f</em>(<em>X</em>/<em>n</em>)] − <em>f</em>(<em>k</em>/(2 * <em>n</em>))) ≤ <strong>E</strong>[abs(<em>f</em>(<em>X</em>/<em>n</em>) − <em>f</em>(<em>k</em>/(2 * <em>n</em>))] ≤ <strong>E</strong>[<em>ω</em>(abs(<em>X</em>/<em>n</em> − <em>k</em>/(2 * <em>n</em>))] (by the definition of <em>ω</em>) ≤ <em>ω</em>(<strong>E</strong>[abs(<em>X</em>/<em>n</em> − <em>k</em>/(2 * <em>n</em>))]) (by Jensen’s inequality and because <em>ω</em> is concave) ≤ <em>ω</em>(sqrt(<strong>E</strong>[abs(<em>X</em>/<em>n</em> − <em>k</em>/(2 * <em>n</em>))]<sup>2</sup>)) = <em>ω</em>(sqrt(<strong>Var</strong>[<em>X</em>/<em>n</em>])) = <em>ω</em>(sqrt((<em>k</em>*(2 * <em>n</em>−<em>k</em>)/(4*(2 * <em>n</em>−1)*<em>n</em><sup>2</sup>)))) ≤ <em>ω</em>(sqrt((<em>n</em><sup>2</sup>/(4*(2 * <em>n</em>−1)*<em>n</em><sup>2</sup>)))) = <em>ω</em>(sqrt((1/(8*<em>n</em>−4)))) = <em>ρ</em>, and for every integer <em>n</em>≥4, <em>ρ</em> ≤ <em>ω</em>(sqrt(1/(7*<em>n</em>))).  To prove the third bound: abs(<strong>E</strong>[<em>f</em>(<em>X</em>/<em>n</em>)] − <em>f</em>(<em>k</em>/(2 * <em>n</em>))) ≤ <em>ω</em>(sqrt(<strong>Var</strong>[<em>X</em>/<em>n</em>])) ≤ <em>ω</em>(sqrt(1/(2*n))).  To prove the fourth bound: abs(<strong>E</strong>[<em>f</em>(<em>X</em>/<em>n</em>)] − <em>f</em>(<em>k</em>/(2 * <em>n</em>))) ≤ <em>ω</em>(sqrt((<em>n</em><sup>2</sup>/(4*(2 * <em>n</em>−1)*<em>n</em><sup>2</sup>)))) = <em>ω</em>(sqrt( (<em>k</em>/(2*<em>n</em>)) * (1−<em>k</em>/(2*<em>n</em>)) / (2*<em>n</em>−1) )).</li>
  <li>By the definition of Hölder continuous functions, take <em>ω</em>(<em>x</em>) = <em>M</em>*<em>x</em><sup><em>α</em></sup>.  Because <em>ω</em> is a concave modulus of continuity on the closed unit interval, the result follows from part 1.</li>
  <li>
    <p>(Much of this proof builds on Nacu and Peres 2005, Proposition 6(ii)<sup id="fnref:1:8" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>.) The expected value (see note 1) of $X$ is $E[X/n]=k/(2n)$. Since $E[X/n-k/(2n)] = 0$, it follows that $f’(X/n) E(X/n-k/(2n)) = 0$.  Moreover, $\text{abs}(f(x)-f(s)-f’(x)(x-s))\le (M/2)(x-s)^2$ (see Micchelli 1973, Theorem 3.2)<sup id="fnref:23" role="doc-noteref"><a href="#fn:23" class="footnote" rel="footnote">23</a></sup>, so—</p>

    <p>\(E[\text{abs}(f(X/n)-f(k/(2n)))]=\text{abs}(E[f(X/n)-f(k/(2n))-f'(k/(2n))(X/n-k/(2n))])\) \(\le (M/2)(X/n-k/(2n))^2 \le (M/2) Var(X/n).\)</p>

    <p>By part 1’s proof, it follows that (<em>M</em>/2)*<strong>Var</strong>[<em>X</em>/<em>n</em>] = (<em>M</em>/2)*(<em>k</em>*(2 * <em>n</em>−<em>k</em>)/(4*(2 * <em>n</em>−1)*<em>n</em><sup>2</sup>)) ≤ (<em>M</em>/2)*(<em>n</em><sup>2</sup>/(4*(2 * <em>n</em>−1)*<em>n</em><sup>2</sup>)) = (<em>M</em>/2)*(1/(8*<em>n</em>−4)) = <em>ρ</em>.  For every integer <em>n</em>≥4, <em>ρ</em> ≤  (<em>M</em>/2)*(1/(7*<em>n</em>)). □</p>
  </li>
</ol>

<blockquote>
  <p><strong>Notes:</strong></p>

  <ol>
    <li><strong>E</strong>[.] means expected value (“long-run average”), and <strong>Var</strong>[.] means variance.  A hypergeometric(2 * <em>n</em>, <em>k</em>, <em>n</em>) random variable is the number of “good” balls out of <em>n</em> balls taken uniformly at random, all at once, from a bag containing 2 * <em>n</em> balls, <em>k</em> of which are “good”.</li>
    <li>Parts 1 through 3 exploit a tighter bound on <strong>Var</strong>[<em>X</em>/<em>n</em>] than the bound given in Nacu and Peres (2005, Lemma 6(i) and 6(ii), respectively)<sup id="fnref:1:9" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>.  However, for technical reasons, different bounds are proved for different ranges of integers <em>n</em>.</li>
    <li>All continuous functions that map the closed unit interval to itself, including all of them that admit a Bernoulli factory, have a modulus of continuity.  The proof of part 1 remains valid even if <em>ω</em>(0) &gt; 0, because the bounds proved remain correct even if <em>ω</em> is overestimated.  The following functions have a simple modulus of continuity that satisfies the lemma:
      <ol>
        <li>If <em>f</em> is strictly increasing and convex, <em>ω</em>(<em>x</em>) can equal <em>f</em>(1) − <em>f</em>(1−<em>x</em>) (Gal 1990)<sup id="fnref:24" role="doc-noteref"><a href="#fn:24" class="footnote" rel="footnote">24</a></sup>; (Gal 1995)<sup id="fnref:25" role="doc-noteref"><a href="#fn:25" class="footnote" rel="footnote">25</a></sup>.</li>
        <li>If <em>f</em> is strictly decreasing and convex, <em>ω</em>(<em>x</em>) can equal <em>f</em>(0) − <em>f</em>(<em>x</em>) (Gal 1990)<sup id="fnref:24:1" role="doc-noteref"><a href="#fn:24" class="footnote" rel="footnote">24</a></sup>; (Gal 1995)<sup id="fnref:25:1" role="doc-noteref"><a href="#fn:25" class="footnote" rel="footnote">25</a></sup>.</li>
        <li>If <em>f</em> is strictly increasing and concave, <em>ω</em>(<em>x</em>) can equal <em>f</em>(<em>x</em>) − <em>f</em>(0) (by symmetry with 2).</li>
        <li>If <em>f</em> is strictly decreasing and concave, <em>ω</em>(<em>x</em>) can equal <em>f</em>(1−<em>x</em>) − <em>f</em>(1) (by symmetry with 1).</li>
        <li>If <em>f</em> is concave and is strictly increasing then strictly decreasing, then <em>ω</em>(<em>h</em>) can equal (<em>f</em>(min(<em>h</em>, <em>σ</em>))+(<em>f</em>(1−min(<em>h</em>, 1−<em>σ</em>))−<em>f</em>(1)), where <em>σ</em> is the point where <em>f</em> stops increasing and starts decreasing (Anastassiou and Gal 2012)<sup id="fnref:26" role="doc-noteref"><a href="#fn:26" class="footnote" rel="footnote">26</a></sup>.</li>
      </ol>
    </li>
  </ol>
</blockquote>

<p>There are weaker bounds for Lemma 2, part 1, which work even if $f$’s modulus of continuity $\omega$ is not concave. According to Pascu et al. (2017, Lemma 5.1)<sup id="fnref:27" role="doc-noteref"><a href="#fn:27" class="footnote" rel="footnote">27</a></sup>:</p>

\[\text{abs}(\mathbb{E}[f(Y)] - f(\mathbb{E}[Y])) \le \omega(\delta) + \omega(\delta)\text{Var}[Y]/\delta^2,\]

<p>where $f$ is a continuous function, $Y$ is a discrete random variable on a closed interval, and $\delta&gt;0$.  Given that $Y = X/n$ (where $X$ is as in Lemma 2), taking $\delta=1/n^{1/2}$ leads to:</p>

\[\text{abs}(\mathbb{E}[f(Y)]-f(\mathbb{E}[Y]))=\text{abs}(\mathbb{E}[f(Y)]-f(k/(2n)))\le\omega(1/n^{1/2}) (1+n\cdot\text{Var}[Y]),\]

<p>and in turn, plugging in bounds for $\text{Var}[Y]$ leads to the following bounds for Lemma 2, part 1:</p>

<ul>
  <li>$\omega(1/n^{1/2}) (1+n/(8n-4))$.</li>
  <li>$\omega(1/n^{1/2}) (1+n/(7n)) = \frac{8}{7}\omega(1/n^{1/2})$ if n≥4.</li>
  <li>$\omega(1/n^{1/2}) (1+n/(2n)) = \frac{3}{2}\omega(1/n^{1/2})$.</li>
</ul>

<p><strong>Lemma 2A.</strong>  _Let f(λ) map the closed unit interval to itself, and let $C=15$.  Suppose $f$ is in the Zygmund class with constant $D$ or less.  Then, for every integer $n$ ≥ 1, the expression (1) in Lemma 2 is less than or equal to $(C/2) D\sqrt{1/(8n-4)}$.</p>

<p><em>Proof.</em> Strukov and Timan (1977)<sup id="fnref:28" role="doc-noteref"><a href="#fn:28" class="footnote" rel="footnote">28</a></sup> proved the following bound:</p>

\[\\text{abs}(\mathbb{E}[f(Y)]-f(\mathbb{E}[Y]))\le C\omega_2((\text{Var}[Y])^{1/2}/2),\]

<p>where <em>Y</em> is a random variable and ω<sub>2</sub>(.) is a <em>second-order modulus of continuity</em> of <em>f</em> (see note below), and where $C$ is 3 if $Y$ takes on any value in the real line, or 15 if $Y$ takes on only values in a closed interval, such as the closed unit interval in this case.</p>

<p>Suppose <em>Y</em> = <em>X</em>/<em>n</em>, where <em>X</em> is as in Lemma 2.  Then <em>Y</em>’s variance (<strong>Var</strong>[<em>Y</em>]) is less than or equal to 1/(8*<em>n</em>− 4), and the left-hand side of Strukov and Timan’s bound is the same as the expression (1).</p>

<p>Since <em>f</em> is in the Zygmund class, there is an $\omega_2$ for it such that $\omega_{2}(h)\le D h$.  Therefore, applying Strukov and Timan’s bound and the bound on <em>Y</em>’s variance leads to—</p>

<p>\(\text{abs}(\mathbb{E}[f(Y)]-f(\mathbb{E}[Y]))\le C\omega_2((\text{Var}[Y])^{1/2}/2)\) \(\le CD ((\text{Var}[Y])^{1/2}/2) = CD\sqrt{1/(8n-4)}/2.\)</p>

<p>□</p>

<blockquote>
  <p><strong>Note:</strong> A <em>second-order modulus of continuity</em> is a nonnegative and nowhere decreasing function <em>ω</em><sub>2</sub>(<em>h</em>) with <em>h</em> ≥ 0, for which <em>ω<sub>2</sub></em>(0) = 0, and for which abs($f(x)+f(y)-2 f((x+y)/2)$) ≤ $\omega_2(\text{abs}((y-x)/2))$ whenever <em>f</em> is continuous and <em>x</em> and <em>y</em> are in <em>f</em>’s domain.</p>
</blockquote>

<p><strong>Theorem 1.</strong> <em>Let $f$ be a strictly bounded factory function, let $n_0\ge 1$ be an integer, and let $\phi(n)$ be a function that takes on a nonnegative value.  Suppose $f$ is such that the expression (1) in Lemma 2 is less than or equal to $\phi(n)$ whenever $n\ge n_0$ is an integer power of 2.  Let—</em></p>

\[\eta(n)=\sum_{k\ge \log_2(n)} \phi(2^k),\]

<p><em>for every integer n≥1 that’s a power of 2.  If the series η(n) converges to a finite value for each such $n$, and if it converges to 0 as $n$ gets large, then the following scheme for f(λ) is valid in the following sense:</em></p>

<p><em>There are polynomials $g_n$ and $h_n$ (where $n\ge 1$ is an integer power of 2) as follows. The $k$-th Bernstein coefficient of $g_n$ and $h_n$ is <strong>fbelow</strong>(n, k) and <strong>fabove</strong>(n, k), respectively (where $0\le k\le n$), where:</em></p>

<p><em>If $n_0 = 1$:</em></p>

<ul>
  <li><em><strong>fbelow</strong>(n, k) =</em> $f(k/n)-\eta(n)$.</li>
  <li><em><strong>fabove</strong>(n, k) =</em> $f(k/n)+\eta(n)$.</li>
</ul>

<p><em>If $n_0 &gt; 1$:</em></p>

<ul>
  <li><em><strong>fbelow</strong>(n, k) =</em> min(<strong>fbelow</strong>($n_0$,0), <strong>fbelow</strong>($n_0$,1), …, <strong>fbelow</strong>($n_0$,$n_0$)) <em>if</em> $n &lt; n_0$; $f(k/n)-\eta(n)$ <em>otherwise.</em></li>
  <li><em><strong>fabove</strong>(n, k) =</em> max(<strong>fabove</strong>($n_0$,0), <strong>fabove</strong>($n_0$,1), …, <strong>fbelow</strong>($n_0$,$n_0$)) <em>if</em> $n &lt; n_0$; $f(k/n)+\eta(n)$ <em>otherwise.</em></li>
</ul>

<p><em>The polynomials $g_n$ and $h_n$ satisfy:</em></p>

<ol>
  <li><em>$g_n \le h_n$.</em></li>
  <li><em>$g_n$ and $h_n$ converge to $f$ as $n$ gets large.</em></li>
  <li>$(g_{n+1}-g_n)$ <em>and</em> $(h_{n}-h_{n+1})$ <em>are polynomials with nonnegative Bernstein coefficients once they are rewritten to polynomials in Bernstein form of degree exactly $n+1$.</em></li>
</ol>

<p><em>Proof.</em> For simplicity, this proof assumes first that $n_0 = 1$.</p>

<p>For the series <em>η</em>(<em>n</em>) in the theorem, because $\phi(n)$ is nonnegative, each term of the series is nonnegative making the series nonnegative and, by the assumption that the series converges, <em>η</em>(<em>n</em>) is nowhere increasing with increasing <em>n</em>.</p>

<p>Item 1 is trivial.  If $n\ge n_0$, $g_n$ is simply the Bernstein polynomial of $f$ minus a nonnegative value, and $h_n$ is the Bernstein polynomial of $f$ plus that same value, and if $n$ is less than $n_0$, $g_n$ is a constant value not less than the lowest point reachable by the lower polynomials, and $h_n$ is a constant value not less than the highest point reachable by the upper polynomials.</p>

<p>Item 2 is likewise trivial. A well known result is that the Bernstein polynomials of $f$ converge to $f$ as their degree $n$ gets large.  And because the series <em>η</em> (in Theorem 1) sums to a finite value that goes to 0 as $n$ increases, the upper and lower shifts will converge to 0 so that $g_n$ and $h_n$ converge to the degree-$n$ Bernstein polynomials and thus to $f$.</p>

<p>Item 3 is the <em>consistency requirement</em> described earlier in this page. This is ensured as in Proposition 10 of Nacu and Peres (2005)<sup id="fnref:1:10" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup> by bounding, from below, the offset by which to shift the approximating polynomials.  This lower bound is <em>η</em>(<em>n</em>), a solution to the equation 0 = <em>η</em>(<em>n</em>) − <em>η</em>(2 * <em>n</em>) − <em>φ</em>(<em>n</em>) (see note below), where <em>φ</em>(<em>n</em>) is a function that takes on a nonnegative value.</p>

<p><em>φ</em>(<em>n</em>) is, roughly speaking, the minimum distance between one polynomial and the next so that the consistency requirement is met between those two polynomials.  Compare the assumptions on <em>φ</em> in Theorem 1 with equations (10) and (11) in Nacu and Peres (2005).</p>

<p>The solution for $\eta(n)$ given in the statement of the theorem is easy to prove by noting that this is a recursive process: we start by calculating the series for <em>n</em> = 2*<em>n</em>, then adding <em>φ</em>(<em>n</em>) to it (which will be positive), in effect working backwards and recursively, and we can easily see that we can calculate the series for <em>n</em> = 2*<em>n</em> only if the series converges, hence the assumption of a converging series.</p>

<p>Now to prove the result assuming that $n_0 &gt; 1$.</p>

<p>Doing this involves taking advantage of the observation in Remark B of Nacu and Peres (2005)<sup id="fnref:1:11" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup> that we can start defining the polynomials at any $n$ greater than 0, including $n = n_0$; in that case, the upper and lower polynomials of degree 1 or greater, but less than $n_0$, would be constant functions, so that the Bernstein coefficients of each polynomial would be equal. The lower constants are no greater than $g_{n_0}$’s lowest Bernstein coefficient, and the upper constants are no less than $g_{n_0}$’s highest Bernstein coefficients; they meet Item 3 because these lower and upper constants, when rewritten as polynomials in Bernstein form of degree $n_0$, have Bernstein coefficients that are still no greater or no less, respectively, than the corresponding degree-$n_0$ polynomial. With the <em>φ</em> given in this theorem, the series <em>η</em>(<em>n</em>) in the theorem remains nonnegative.  Moreover, since <em>η</em> is assumed to converge, <em>η</em>(<em>n</em>) still decreases with increasing <em>n</em>. □</p>

<blockquote>
  <p><strong>Notes:</strong></p>

  <ol>
    <li>There is only one solution <em>η</em>(<em>n</em>) in the case at hand.  Unlike so-called <a href="https://math.stackexchange.com/questions/3993739"><strong><em>functional equations</em></strong></a> and linear recurrences, with a solution that varies depending on the starting value, there is only one solution in the case at hand, namely the solution that makes the series converge, if it exists at all.  Alternatively, the equation can be expanded to 0 = <em>η</em>(<em>n</em>) − <em>η</em>(4 * <em>n</em>) − <em>φ</em>(2*<em>n</em>) − <em>φ</em>(<em>n</em>) = <em>η</em>(<em>n</em>) − <em>η</em>(8 * <em>n</em>) − <em>φ</em>(4*<em>n</em>) − <em>φ</em>(2*<em>n</em>) − <em>φ</em>(<em>n</em>) = …</li>
    <li>$\log_2(n)$ is the number $x$ such that $2^x = n$.</li>
  </ol>
</blockquote>

<p><strong>Proposition 1A.</strong> <em>If a scheme satisfies Theorem 1, the polynomials $g_n$ and $h_n$ in the scheme can be made to satisfy conditions (i), (iii), and (iv) of Proposition 3 of Nacu and Peres (2005)<sup id="fnref:1:12" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup> as follows:</em></p>

<ul>
  <li>$g_n$ = $g_{n-1}$ <em>and</em> $h_n$ = $h_{n-1}$ <em>whenever $n$ is an integer greater than 1 and not a power of 2.</em></li>
  <li><em>If <strong>fabove</strong>(n, k) &gt; 1 for a given $n$ and some $k$, the Bernstein coefficients of $h_n$ (the upper polynomial) are all 1.</em></li>
  <li><em>If <strong>fbelow</strong>(n, k) &lt; 0 for a given $n$ and some $k$, the Bernstein coefficients of $g_n$ (the lower polynomial) are all 0.</em></li>
</ul>

<p><em>Proof:</em> Condition (i) of Proposition 3 says that each Bernstein coefficient of the polynomials must be 0 or greater and 1 or less.  This is ensured starting with a large enough value of <em>n</em> greater than 0 that’s a power of 2, call it <em>n</em><sub>1</sub>, as shown next.</p>

<p>Let <em>ε</em> be a positive distance between 0 and the minimum or between 1 and the maximum of <em>f</em>, whichever is smaller.  This <em>ε</em> exists by the assumption that <em>f</em> is bounded away from 0 and 1. Because the series <em>η</em> (in Theorem 1) sums to a finite value that goes to 0 as $n$ increases, <em>η</em>(<em>n</em>) will eventually stay less than <em>ε</em>.  And if $n\ge n_0$ is a power of 2 (where $n_0$ is as in Theorem 1), the <code>f(k/n)</code> term is bounded by the minimum and maximum of <em>f</em> by construction. This combined means that the lower and upper polynomials’ Bernstein coefficients will eventually be bounded by 0 and 1 for every integer <em>n</em> starting with <em>n</em><sub>1</sub>.</p>

<p>For <em>n</em> less than <em>n</em><sub>1</sub>, condition (i) is ensured by setting the lower or upper polynomial’s Bernstein coefficient to 0 or 1, respectively, whenever a Bernstein coefficient of the degree-_n_ polynomial would otherwise be less than 0 or greater than 1, respectively.</p>

<p>Condition (iii) of Proposition 3 is mostly ensured by item 2 of Theorem 1.  The only thing to add is that for $n$ less than <em>n</em><sub>1</sub>, the lower and upper polynomials $g_n$ and $h_n$ can be treated as 0 or 1, respectively, without affecting convergence, and that for $n$ other than a power of 2, defining $g_n = g_{n-1}$ and $h_n = h_{n-1}$ maintains condition (iii) by Remark B of Nacu and Peres (2005)<sup id="fnref:1:13" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>.</p>

<p>Condition (iv) of Proposition 3 is mostly ensured by item 3 of Theorem 1.  For <em>n</em>=<em>n</em><sub>1</sub>, condition (iv) is maintained by noting that the degree-_n_<sub>1</sub> polynomial’s Bernstein coefficients must be bounded by 0 and 1 by condition (i) so they will likewise be bounded by those of the lower and upper polynomials of degree less than <em>n</em><sub>1</sub>, and those polynomials are the constant 0 and the constant 1, respectively, as are their Bernstein coefficients. Finally, for $n$ other than a power of 2, defining $g_n = g_{n-1}$ and $h_n = h_{n-1}$ maintains condition (iv) by Remark B of Nacu and Peres (2005)<sup id="fnref:1:14" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>.  □</p>

<blockquote>
  <p><strong>Note:</strong> The last condition of Proposition 3, condition (ii), says <strong>fabove</strong>(<em>n</em>, <em>k</em>)*choose(<em>n</em>,<em>k</em>) and <strong>fbelow</strong>(<em>n</em>, <em>k</em>)*choose(<em>n</em>,<em>k</em>) must be integers. <sup id="fnref:29" role="doc-noteref"><a href="#fn:29" class="footnote" rel="footnote">29</a></sup> But Proposition 3 assumes only the biased coin and no other randomness is used, and that the coin doesn’t show heads every time or tails every time.  Therefore, <em>f</em>(0), if it exists, must be an integer, and the same is true for <em>f</em>(1), so that condition (ii) is redundant with condition (iii) due to a result that goes back to Kantorovich (1931)<sup id="fnref:30" role="doc-noteref"><a href="#fn:30" class="footnote" rel="footnote">30</a></sup>; see also Remark C of Nacu and Peres (2005)<sup id="fnref:1:15" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>.</p>
</blockquote>

<p><strong>Corollary 1.</strong> <em>Let f(λ) be a strictly bounded factory function. If that function is Hölder continuous with Hölder constant M and Hölder exponent $\alpha$, then the following scheme determined by <strong>fbelow</strong> and <strong>fabove</strong> is valid in the sense of Theorem 1:</em></p>

<ul>
  <li><em><strong>fbelow</strong>(n, k) = f(k/n) − D(n).</em></li>
  <li><em><strong>fabove</strong>(n, k) = f(k/n) + D(n).</em></li>
</ul>

<p><em>Where</em> $D(n)=\frac{M}{((2^{\alpha/2}-1) n^{\alpha/2}}$.</p>

<p><em>Or:</em></p>

<ul>
  <li><em><strong>fbelow</strong>(n, k) = min(<strong>fbelow</strong>(4,0), <strong>fbelow</strong>(4,1), …, <strong>fbelow</strong>(4,4)) if n &lt; 4; otherwise, f(k/n) − η(n).</em></li>
  <li><em><strong>fabove</strong>(n, k) = max(<strong>fabove</strong>(4,0), <strong>fabove</strong>(4,1), …, <strong>fabove</strong>(4,4)) if n &lt; 4; otherwise, f(k/n) + η(n).</em></li>
</ul>

<p><em>Where $\eta(n)=M(2/7)^{\alpha-2}/((2^{\alpha/2}-1)n^{\alpha/2})$.</em></p>

<p><em>Proof.</em> Because $f$ is Hölder continuous, it admits the modulus of continuity $\omega(x)=Mx^{\alpha}$.  By part 1 of lemma 2:</p>

<ul>
  <li>For each integer $n\ge 1$ that’s a power of 2 ($n_0=1$ in Theorem 1), $\phi(n)=\omega(\sqrt{1/(2n)})=M (1/(2n))^{\alpha/2}$ can be taken for each such integer $n$, and thus $\eta(n)=D(n)=\frac{M}{((2^{\alpha/2}-1) n^{\alpha/2}}$ (where $\eta(n)$ is as in Theorem 1).</li>
  <li>For each integer $n\ge 4$ that’s a power of 2 ($n_0=4$ in Theorem 1), $\phi(n)=\omega(\sqrt{1/(2n)})=M (1/(7n))^{\alpha/2}$ can be taken for each such integer $n$, and thus $\eta(n)=$ M*(2/7)$^{\alpha/2}$/((2$^{\alpha/2}$−1)*n$^{\alpha/2}$).</li>
</ul>

<p>In both cases $\eta(n)$ is finite and converges to 0 as $n$ increases.</p>

<p>The result then follows from Theorem 1. □</p>

<blockquote>
  <p><strong>Note:</strong> For specific values of <em>α</em>, the equation <em>D</em>(<em>n</em>) = <em>D</em>(2 * <em>n</em>) + <em>φ</em>(<em>n</em>) can be solved via linear recurrences; an example for <em>α</em> = 1/2 is the following code in Python that uses the SymPy computer algebra library: <code>alpha=(S(1)/2); rsolve(Eq(f(n), f(n+1)+z*(1/(2*2**n))**(alpha/2)), f(n)).subs(n,ln(n,2)).simplify()</code>.  Trying different values of <em>α</em> suggested the following formula for Hölder continuous functions with <em>α</em> of 1/<em>j</em> or greater: (<em>M</em>* $\sum_{i=0}^{2j-1} 2^{i/(2j)}$)/<em>n</em><sup>1/(2*<em>j</em>)</sup> = <em>M</em> / ((2<sup>1/(2*<em>j</em>)</sup>−1)*<em>n</em><sup>1/(2*<em>j</em>)</sup>); and generalizing the latter expression led to the term in the theorem.</p>
</blockquote>

<p><strong>Corollary 2.</strong> <em>Let f(λ) be a strictly bounded factory function.  If that function is Lipschitz continuous with Lipschitz constant M, then the following scheme determined by <strong>fbelow</strong> and <strong>fabove</strong> is valid in the sense of Theorem 1:</em></p>

<ul>
  <li><em><strong>fbelow</strong>(n, k) = f(k/n) − M/((sqrt(2)−1)*sqrt(n)).</em></li>
  <li><em><strong>fabove</strong>(n, k) = f(k/n) + M/((sqrt(2)−1)*sqrt(n)).</em></li>
</ul>

<p><em>Or:</em></p>

<ul>
  <li><em><strong>fbelow</strong>(n, k) = min(<strong>fbelow</strong>(4,0), <strong>fbelow</strong>(4,1), …, <strong>fbelow</strong>(4,4)) if n &lt; 4; otherwise, f(k/n) − M*sqrt(2/7)/((sqrt(2)−1)*sqrt(n)).</em></li>
  <li><em><strong>fabove</strong>(n, k) = max(<strong>fabove</strong>(4,0), <strong>fabove</strong>(4,1), …, <strong>fabove</strong>(4,4)) if n &lt; 4; otherwise, f(k/n) + M*sqrt(2/7)/((sqrt(2)−1)*sqrt(n)).</em></li>
</ul>

<p><em>Proof.</em> Because Lipschitz continuous functions are Hölder continuous with Hölder constant <em>M</em> and exponent 1, the result follows from Corollary 1. □</p>

<blockquote>
  <p><strong>Note:</strong> The first scheme given here is a special case of Theorem 1 that was already found by Nacu and Peres (2005)<sup id="fnref:1:16" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>.</p>
</blockquote>

<p><strong>Corollary 3.</strong> <em>Let f(λ) be a strictly bounded factory function. If that function has a Lipschitz continuous derivative with Lipschitz constant L, then the following scheme determined by <strong>fbelow</strong> and <strong>fabove</strong> is valid in the sense of Theorem 1:</em></p>

<ul>
  <li><em><strong>fbelow</strong>(n, k) = min(<strong>fbelow</strong>(4,0), <strong>fbelow</strong>(4,1), …, <strong>fbelow</strong>(4,4)) if n &lt; 4; otherwise, f(k/n) − L/(7*n).</em></li>
  <li><em><strong>fabove</strong>(n, k) = max(<strong>fabove</strong>(4,0), <strong>fabove</strong>(4,1), …, <strong>fabove</strong>(4,4)) if n &lt; 4; otherwise, f(k/n) + L/(7*n).</em></li>
</ul>

<p><em>Proof.</em> By part 3 of lemma 2, for each integer $n\ge 4$ that’s a power of 2 ($n_0=4$ in Theorem 1), $\phi(n)=(L/2) (1/(7n))$ can be taken for each such integer $n$, and thus $\eta(n)=L/(7n)$ (where $\eta(n)$ is as in Theorem 1). $\eta(n)$ is finite and converges to 0 as $n$ increases. The result then follows from Theorem 1. □</p>

<blockquote>
  <p><strong>Note:</strong> Nacu and Peres (2005)<sup id="fnref:1:17" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup> already proved a looser scheme in the case when $f$ has a second derivative on the closed unit interval that is not greater than a constant (a slightly stronger condition than having a Lipschitz continuous derivative on that domain).</p>
</blockquote>

<p><strong>Theorem 2.</strong> <em>Let f(λ) be a strictly bounded factory function.  If that function is convex and nowhere decreasing, then Theorem 1 remains valid with φ(n) = <strong>E</strong>[f(Y/n)] (where Y is a hypergeometric(2*n, n, n) random variable), rather than as given in that theorem.</em></p>

<p><em>Proof.</em>  Follows from Theorem 1 and part 4 of Lemma 2 above. With the <em>φ</em> given in this theorem, the series <em>η</em>(<em>n</em>) in Theorem 1 remains nonnegative; also, this theorem adopts Theorem 1’s assumption that the series converges, so that <em>η</em>(<em>n</em>) still decreases with increasing <em>n</em>. □</p>

<p><strong>Proposition 1.</strong></p>

<ol>
  <li><em>Let f be as given in Theorem 1 or 2 or Corollary 1 to 3, except that f must be concave and polynomially bounded and may have a minimum of 0. Then the schemes of those results remain valid if <strong>fbelow</strong>(n, k) = f(k/n), rather than as given in those results.</em></li>
  <li><em>Let f be as given in Theorem 1 or 2 or Corollary 1 to 3, except that f must be convex and polynomially bounded and may have a maximum of 1.  Then the schemes of those results remain valid if <strong>fabove</strong>(n, k) = f(k/n), rather than as given in those results.</em></li>
  <li>
    <p><em>Theorems 1 and 2 and Corollaries 1 to 3 can be extended to all integers n≥1, not just those that are powers of 2, by defining—</em></p>

    <ul>
      <li><em><strong>fbelow</strong>(n, k) = (k/n)*<strong>fbelow</strong>(n−1, max(0, k−1)) + ((n−k)/n)*<strong>fbelow</strong>(n−1, min(n−1, k)), and</em></li>
      <li><em><strong>fabove</strong>(n, k) = (k/n)*<strong>fabove</strong>(n−1, max(0, k−1)) + ((n−k)/n)*<strong>fabove</strong>(n−1, min(n−1, k)),</em></li>
    </ul>

    <p><em>for every integer n≥1 other than a power of 2. Parts 1 and 2 of this proposition still apply to the modified scheme.</em></p>
  </li>
</ol>

<p><em>Proof.</em> Parts 1 and 2 follow from Theorem 1 or 2 or Corollary 1 to 3, as the case may be.  For part 1, the lower polynomials are replaced by the degree-_n_ Bernstein polynomials of <em>f</em>, and they meet the conditions in those theorems by Jensen’s inequality.  For part 2, the upper polynomials are involved instead of the lower polynomials.  Part 3 also follows from Remark B of Nacu and Peres (2005)<sup id="fnref:1:18" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>. □</p>

<p>The following lemma shows that if a scheme for $f(\lambda)$ shifts polynomials upward and downward, the pre-shifted polynomials are close to $f(\lambda)$ by the amount of the shift.</p>

<p><strong>Lemma 3.</strong> <em>Let $f$ be a strictly bounded factory function. Let $S$ be an infinite set of positive integers.  For each integer $n\ge 1$, let $W_n(\lambda)$ be a function, and let $\epsilon_n(f)$ be a nonnegative constant that depends on $f$ and $n$.  Suppose that there are polynomials $g_n$ and $h_n$ (for each $n$ in $S$) as follows:</em></p>

<ol>
  <li><em>$g_n$ and $h_n$ have Bernstein coefficients $W_n(k/n) - \epsilon_n(f)$ and $W_n(k/n) + \epsilon_n(f)$, respectively ($0\le k\le n$).</em></li>
  <li><em>$g_n \le h_n$.</em></li>
  <li><em>$g_n$ and $h_n$ converge to $f$ as $n$ gets large.</em></li>
  <li>$(g_{m}-g_n)$ <em>and</em> $(h_{n}-h_{m})$ <em>are polynomials with nonnegative Bernstein coefficients once they are rewritten to polynomials in Bernstein form of degree exactly $m$, where $m$ is the smallest number greater than $n$ in $S$.</em></li>
</ol>

<p><em>Then for each $n$ in $S$, $\text{abs}(f(\lambda) - B_n(W_n(\lambda))) \le \epsilon_n(f)$ whenever $0\le \lambda\le 1$, where $B_n(W_n(\lambda))$ is the Bernstein polynomial of degree $n$ of the function $W_n(\lambda)$.</em></p>

<p><em>Proof:</em> $W_n(k/n)$ is the $k$-th Bernstein coefficient of $B_n(W_n(\lambda))$, which is $g_n$ and $h_n$ before they are shifted downward and upward, respectively, by $\epsilon_n(f)$.  Moreover, property 4 in the lemma corresponds to condition (iv) of Nacu and Peres (2005)<sup id="fnref:1:19" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>, which implies that, for every $m&gt;n$, $g_{n}(\lambda)\le g_{m}(\lambda)\le f(\lambda)$ (the lower polynomials “increase”) and $h_{n}(\lambda)\ge h_{m}(\lambda)\ge f(\lambda)$ (the upper polynomials “decrease”) for every $n\ge 1$ (Nacu and Peres 2005, Remark A)<sup id="fnref:1:20" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>.</p>

<p>Then if $B_n(W_n(\lambda)) &lt; f(\lambda)$ for some $\lambda$ in the closed unit interval, shifting the left-hand side upward by $\epsilon_n(f)$ (a nonnegative constant) means that $h_n = B_n(W_n(\lambda))+\epsilon_n(f) \ge f(\lambda)$, and rearranging this expression leads to $f(\lambda) - B_n(W_n(\lambda)) \le \epsilon_n(f)$.</p>

<p>Likewise, if $B_n(W_n(\lambda)) &gt; f(\lambda)$ for some $\lambda$ in the closed unit interval, shifting the left-hand side downward by $\epsilon_n(f)$ means that $g_n = B_n(W_n(\lambda))-\epsilon_n(f) \le f(\lambda)$, and rearranging this expression leads to $B_n(W_n(\lambda)) - f(\lambda) \le \epsilon_n(f)$.</p>

<p>This combined means that $\text{abs}(f(x) - B_n(W_n(\lambda))) \le \epsilon_n(f)$ whenever $0\le \lambda\le 1$.  □</p>

<p><strong>Corollary 4</strong>.  <em>If $f(\lambda)$ satisfies a scheme given in Theorem 1 with $n_0\ge 1$, then $B_n(f(\lambda))$ comes within $\eta(n)$ of $f$ for every integer $n\ge n_0$ that’s a power of 2; that is, $\text{abs}(B_n(f(\lambda))) \le \eta(n)$ for every such $n$.</em></p>

<p><strong>Lemma 5</strong>. Let $n\ge 1$ be an integer.  Suppose $g_{2n}$ and $g_{n}$ are polynomials in Bernstein form of degree $2n$ and $n$, respectively, and their domain is the closed unit interval. Suppose $g_{2n}$ and $g_n$ satisfy the property:</p>

<ul>
  <li>$(g_{2n}-g_n)$ is a polynomial with nonnegative Bernstein coefficients once it is rewritten to a polynomial in Bernstein form of degree exactly $2n$.</li>
</ul>

<p>Then for every $x\ge 0$, $g_{2n}+x$ and $g_n$ satisfy that property, and for every $x\ge 1$, $g_{2n}\cdot x$ and $g_n$ do as well.</p>

<p>The proof follows from two well-known properties of polynomials in Bernstein form: adding $x$ to $g_{2n}$ amounts to adding $x$ to its Bernstein coefficients, and multiplying $g_{2n}$ by $x$ amounts to multiplying its Bernstein coefficients by $x$.  In either case, $g_{2n}$’s Bernstein coefficients become no less than they otherwise would, so that $(g_{2n}-g_n)$ continues to have non-negative Bernstein coefficients as required by the property.</p>

<p>It is also true that, for every $x\ge 0$, $g_{2n}\cdot x$ and $g_n\cdot x$ satisfy the same property, but a detailed proof of this is left as an exercise to anyone interested. (If $x=0$, $g_n\cdot x=g_{2n}\cdot x=0$, so that the property is trivially satisfied.)</p>

<p>Finally, it is true that, for every real number $x$, $g_{2n}+x$ and $g_n+x$ satisfy the same property, but, again, a detailed proof of this is left as an exercise to anyone interested. (If $x=0$, $g_n+x=g_n$ and $g_{2n}+x=g_{2n}$, so that the property is trivially satisfied.)</p>

<p><a id="A_Conjecture_on_Polynomial_Approximation"></a></p>

<h4 id="a-conjecture-on-polynomial-approximation">A Conjecture on Polynomial Approximation</h4>

<p>The following conjecture suggests there may be a way to easily adapt other approximating polynomials, besides the ordinary Bernstein polynomials, to the Bernoulli factory problem.</p>

<p><strong>Conjecture.</strong></p>

<p>Let $r\ge 1$, and let $f$ be a strictly bounded factory function whose $r$-th derivative is continuous.  Let $M$ be the maximum of the absolute value of $f$ and its derivatives up to the $r$-th derivative. Let $W_{2^0}(\lambda), W_{2^1}(\lambda), …, W_{2^n}(\lambda),…$ be functions on the closed unit interval that converge uniformly to $f$ (that is, for every tolerance level, all $W_{2^i}$ after some value $i$ are within that tolerance level of $f$ at all points on the closed unit interval).</p>

<p>For each integer $n\ge1$ that’s a power of 2, suppose that there is $D&gt;0$ such that—</p>

<p>\(\text{abs}(f(\lambda)-B_n(W_n(\lambda))) \le DM/n^{r/2},\) whenever $0\le \lambda\le 1$, where $B_n(W_n(\lambda))$ is the degree-$n$ Bernstein polynomial of $W_n(\lambda)$.</p>

<p>Then there is $C_0\ge D$ such that for every $C\ge C_0$, there are polynomials $g_n$ (for each $n\ge 1$) as follows:</p>

<ol>
  <li>$g_n$ has Bernstein coefficients $W_n(k/n) - CM/n^{r/2}$ ($0\le k\le n$), if $n$ is a power of 2, and $g_n=g_{n-1}$ otherwise.</li>
  <li>$g_n$ converges to $f$ as $n$ gets large.</li>
  <li>$(g_{n+1}-g_{n})$ is a polynomial with nonnegative Bernstein coefficients once it is rewritten to a polynomial in Bernstein form of degree exactly $n+1$.</li>
</ol>

<p>Equivalently (see also Nacu and Peres 2005), there is $C_1&gt;0$ such that, for each integer $n\ge 1$ that’s a power of 2—</p>

<p>\(\left\text{abs}(\left(\sum_{i=0}^k W_n\left(\frac{i}{n}\right) \sigma_{n,k,i}\right)-W_{2n}\left(\frac{k}{2n}\right)\right)\le \frac{C_1 M}{n^{r/2}},\tag{PB}\) whenever $0\le k\le 2n$, so that $C=\frac{C_1}{1-\sqrt{2/2^{r+1}}}$.  Here, $\sigma_{n,k,i} = {n\choose i}{n\choose {k-i}}/{2n \choose k}$ is the probability that a hypergeometric(2*<em>n</em>, <em>k</em>, <em>n</em>) random variable equals <em>i</em>.</p>

<p>It is further conjectured that the same value of $C_0$ (or $C_1$) suffices when $f$ has a Lipschitz continuous $(r-1)$-th derivative and $M$ is the maximum of the absolute value of $f$ and the Lipschitz constants of $f$ and its derivatives up to the $(r-1)$-th derivative.</p>

<blockquote>
  <p><strong>Notes:</strong></p>

  <ol>
    <li>If $W_n(0)=f(0)$ and $W_n(1)=f(1)$ for every $n$, then (PB) is automatically true when $k=0$ and $k=2n$, so that the statement has to be checked only for $0\lt k\lt 2n$.  If, in addition, $W_n$ is symmetric about 1/2, so that $W_n(\lambda)=W_n(1-\lambda)$ whenever $0\le \lambda\le 1$, then the statement has to be checked only for $0\lt k\le n$ (since the values $\sigma_{n,k,i}$ are symmetric in that they satisfy $\sigma_{n,k,i}=\sigma_{n,k,k-i}$).</li>
    <li>If $W_n$ is a “linear operator”, the left-hand side of (PB) is not greater than $\text{abs}((\sum_{i=0}^k (W_n(\frac{i}{n}))\sigma_{n,k,i})-W_{n}(k/(2n)))$ + $\text{abs}(W_n(k/(2n))-f(k/(2n)))$  + $\text{abs}(W_{2n}(k/(2n))-f(k/(2n)))$.</li>
    <li>If $W_n$ is a “linear operator” and satisfies $\text{abs}(f(\lambda)-W_n(\lambda))\le DM/n^{r/2}$, then the left-hand side of (PB) is not greater than $\text{abs}((\sum_{i=0}^k (W_n(\frac{i}{n}))\sigma_{n,k,i})-W_{n}(k/(2n)))$ + $\frac{DM(2^{r/2}+1)}{2^{r/2}}\frac{1}{n^{r/2}}$.</li>
    <li>By Lemma 3, $B_n(W_n(f(\lambda)))$ would be close to $f(\lambda)$ by at most $C_0 M/n^{r/2}$.  Properties 2 and 3 above correspond to (iii) and (iv) in Nacu and Peres (2005, Proposition 3)<sup id="fnref:1:21" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>.</li>
  </ol>
</blockquote>

<hr />

<p>The following lower bounds on $C_0$, given certain polynomials, can be shown.  In the table:</p>

<ul>
  <li>$M_{r}$ is the maximum of the absolute value of $f(\lambda)$ and its derivatives up to the $r$-th derivative.</li>
  <li>The bounds are valid only if $n$ is a power-of-two integer and, unless otherwise specified, only if $n\ge 1$.</li>
</ul>

<p>For a description of the polynomials in the third column, see <a href="https://peteroupc.github.io/bernapprox.html"><strong>“Approximations in Bernstein Form”</strong></a>.</p>

<table>
  <thead>
    <tr>
      <th>If $r$ is…</th>
      <th>And…</th>
      <th>With the following polynomial’s Bernstein coefficients:</th>
      <th>Then $C_0$ must be greater than:</th>
      <th>And $C_0$ is conjectured to be:</th>
      <th>Because of this counterexample:</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>3</td>
      <td>$M=M_{3}$</td>
      <td>$U_{n,2}$</td>
      <td>0.29004</td>
      <td>$\frac{3}{16-4 \sqrt{2}}$ &lt; 0.29005.</td>
      <td>$2 \lambda \left(1 - \lambda\right)$</td>
    </tr>
    <tr>
      <td>3</td>
      <td>$M=M_{3}$, $n\ge 4$</td>
      <td>$U_{n,2}$</td>
      <td>0.08287</td>
      <td>0.09</td>
      <td>$2 \lambda \left(1 - \lambda\right)$</td>
    </tr>
    <tr>
      <td>4</td>
      <td>$M=M_{4}$</td>
      <td>$U_{n,2}$</td>
      <td>0.24999</td>
      <td>0.25</td>
      <td>$2 \lambda \left(1 - \lambda\right)$</td>
    </tr>
    <tr>
      <td>4</td>
      <td>$M=M_{4}$, $n\ge 4$</td>
      <td>$U_{n,2}$</td>
      <td>0.14</td>
      <td>0.15</td>
      <td>$2 \lambda \left(1 - \lambda\right)$</td>
    </tr>
    <tr>
      <td>5</td>
      <td>$M=M_{5}$</td>
      <td>$U_{n,3}$</td>
      <td>0.26</td>
      <td>0.27</td>
      <td>$2 \lambda \left(1 - \lambda\right)$</td>
    </tr>
    <tr>
      <td>5</td>
      <td>$M=M_{5}$, $n\ge 4$</td>
      <td>$U_{n,3}$</td>
      <td>0.1226</td>
      <td>0.13</td>
      <td>$\lambda^{3}$</td>
    </tr>
    <tr>
      <td>6</td>
      <td>$M=M_{6}$</td>
      <td>$U_{n,3}$</td>
      <td>0.25</td>
      <td>0.26</td>
      <td>$\lambda^{3}$</td>
    </tr>
    <tr>
      <td>6</td>
      <td>$M=M_{6}$, $n\ge 4$</td>
      <td>$U_{n,3}$</td>
      <td>0.25</td>
      <td>0.26</td>
      <td>$\lambda^{3}$</td>
    </tr>
    <tr>
      <td>3</td>
      <td>$M=M_{3}$, $n\ge 8$</td>
      <td>$L_{2,n/2}$</td>
      <td>0.0414</td>
      <td>0.08</td>
      <td>$\frac{1}{2} - \left(1 - 2 \lambda\right)^{3.00001}/2$ if <em>λ</em> &lt; 1/2; $\frac{1}{2} - \left(2 \lambda - 1\right)^{3.00001}/2$ otherwise.</td>
    </tr>
  </tbody>
</table>

<p><a id="Example_of_Polynomial_Building_Scheme"></a></p>

<h4 id="example-of-polynomial-building-scheme">Example of Polynomial-Building Scheme</h4>

<p>The following example uses the results above to build a polynomial-building scheme for a factory function.</p>

<p>Let <em>f</em>(<em>λ</em>) = 0 if <em>λ</em> is 0, and (ln(<em>λ</em>/exp(3)))<sup>−2</sup> otherwise. (This function is not Hölder continuous; its slope is exponentially steep at the point 0.)  Then the following scheme is valid in the sense of Theorem 1:</p>

<ul>
  <li><em>η</em>(<em>k</em>) = Φ(1, 2, (ln(<em>k</em>)+ln(7)+6)/ln(2))*4/ln(2)<sup>2</sup>.</li>
  <li><strong>fbelow</strong>(n, k) = f(<em>k</em>/<em>n</em>).</li>
  <li><strong>fabove</strong>(n, k) = max(<strong>fabove</strong>(4,0), <strong>fabove</strong>(4,1), …, <strong>fabove</strong>(4,4)) if n &lt; 4; otherwise, f(<em>k</em>/<em>n</em>) +  <em>η</em>(<em>n</em>).</li>
</ul>

<p>Where Φ(.) is a function called the <em>Lerch transcendent</em>.</p>

<p>The first step is to find a concave modulus of continuity of <em>f</em> (called <em>ω</em>(<em>h</em>)).  Because <em>f</em> is strictly increasing and concave, and because <em>f</em>(0) = 0, <em>ω</em>(<em>h</em>) = <em>f</em>(<em>h</em>) can be taken for <em>ω</em>.</p>

<p>Now, plugging sqrt(1/(7*<em>n</em>)) into <em>ω</em> leads to the following for Theorem 2 (assuming <em>n</em>≥0):</p>

<ul>
  <li><em>φ</em>(<em>n</em>) = 1/(ln(sqrt(7/<em>n</em>)/7)−3)<sup>2</sup>.</li>
</ul>

<p>Now, by applying Theorem 1, compute <em>η</em>(<em>k</em>) by substituting <em>n</em> with 2<sup><em>n</em></sup>, summing over [<em>k</em>, ∞), and substituting <em>k</em> with ln(<em>k</em>)/ln(2).  <em>η</em> converges, resulting in:</p>

<ul>
  <li><em>η</em>(<em>k</em>) = Φ(1, 2, (ln(<em>k</em>)+ln(7)+6)/ln(2))*4/ln(2)<sup>2</sup>,</li>
</ul>

<p>where Φ(.) is the Lerch transcendent.  This <em>η</em> matches the <em>η</em> given in the scheme above.  That scheme then follows from Theorems 1 and 2, as well as from part 1 of Proposition 1 because <em>f</em> is concave.</p>

<p>the following code in Python that uses the SymPy computer algebra library is an example of finding the parameters for this polynomial-building scheme.</p>

<p><code>
px=Piecewise((0,Eq(x,0)),((ln(x/exp(3))**-2),True))
# omega is modulus of continuity.  Since
# px is strictly increasing, concave, and px(0)=0,
# take omega as px
omega=px
omega=piecewise_fold(omega.rewrite(Piecewise)).simplify()
# compute omega
phi=omega.subs(x,sqrt(1/(7*n)))
pprint(phi)
# compute eta
eta=summation(phi.subs(n,2**n),(n,k,oo)).simplify()
eta=eta.subs(k,log(k,2)) # Replace k with ln(k)/ln(2)
pprint(eta)
for i in range(20):
  # Calculate upper bounds for eta at certain points.
  try:
    print("eta(2^%d) ~= %s" % (i,ceiling(eta.subs(k,2**i)*10000000).n()/10000000))
  except:
    print("eta(2^%d) ~= [FAILED]" % (i))
</code></p>

<p><a id="Which_functions_don_t_require_outside_randomness_to_simulate"></a></p>

<h3 id="which-functions-dont-require-outside-randomness-to-simulate">Which functions don’t require outside randomness to simulate?</h3>

<p>The function <em>f</em>(<em>λ</em>) is <em>strongly simulable</em> if it admits a Bernoulli factory algorithm that uses nothing but the input coin as a source of randomness (Keane and O’Brien 1994)<sup id="fnref:22:1" role="doc-noteref"><a href="#fn:22" class="footnote" rel="footnote">22</a></sup>.  See “<a href="https://peteroupc.github.io/bernoulli.html#Randomized_vs_Non_Randomized_Algorithms"><strong>Randomized vs. Non-Randomized Algorithms</strong></a>”.</p>

<p><strong>Strong Simulability Statement.</strong> A function <em>f</em>(<em>λ</em>) is strongly simulable only if—</p>

<ol>
  <li><em>f</em> is constant on its domain, or is continuous and polynomially bounded on its domain, and</li>
  <li><em>f</em> maps the closed unit interval or a subset of it to the closed unit interval, and</li>
  <li><em>f</em>(0) equals 0 or 1 whenever 0 is in the domain of <em>f</em>, and</li>
  <li><em>f</em>(1) equals 0 or 1 whenever 1 is in the domain of <em>f</em>.</li>
</ol>

<p>Keane and O’Brien already showed that <em>f</em> is strongly simulable if conditions 1 and 2 are true and neither 0 nor 1 are included in the domain of <em>f</em>.  Conditions 3 and 4 are required because <em>λ</em> (the probability of heads) can be 0 or 1 so that the input coin returns 0 or 1, respectively, every time.  This is called a “degenerate” coin.  When given just a degenerate coin, no algorithm can produce one value with probability greater than 0, and another value with the opposite probability.  Rather, the algorithm can only produce a constant value with probability 1.  In the Bernoulli factory problem, that constant is either 0 or 1, so a Bernoulli factory algorithm for <em>f</em> must return 1 with probability 1, or 0 with probability 1, when given just a degenerate coin and no outside randomness, resulting in conditions 3 and 4.</p>

<p>To show that <em>f</em> is strongly simulable, it’s enough to show that there is a Bernoulli factory for <em>f</em> that must flip the input coin and get 0 and 1 before it uses any outside randomness.</p>

<p><strong>Proposition 1.</strong> <em>If f(λ) is described in the strong simulability statement and is a polynomial with computable Bernstein coefficients, it is strongly simulable.</em></p>

<p><em>Proof:</em> If <em>f</em> is the constant 0 or 1, the proof is trivial: simply return 0 or 1, respectively.</p>

<p>Otherwise: Let <em>a</em>[<em>j</em>] be the <em>j</em><sup>th</sup> Bernstein coefficient of the polynomial in Bernstein form.  Consider the following algorithm, modified from (Goyal and Sigman 2012)<sup id="fnref:7:3" role="doc-noteref"><a href="#fn:7" class="footnote" rel="footnote">7</a></sup>.</p>

<ol>
  <li>Flip the input coin <em>n</em> times, and let <em>j</em> be the number of times the coin returned 1 this way.</li>
  <li>If 0 is in the domain of <em>f</em> and if <em>j</em> is 0, return <em>f</em>(0). (By condition 3, <em>f</em>(0) must be either 0 or 1.)</li>
  <li>If 1 is in the domain of <em>f</em> and if <em>j</em> is <em>n</em>, return <em>f</em>(1). (By condition 4, <em>f</em>(1) must be either 0 or 1.)</li>
  <li>With probability <em>a</em>[<em>j</em>], return 1.  Otherwise, return 0. (For example, generate a uniformly distributed random variate, greater than 0 and less than 1, then return 1 if that variate is less than <em>a</em>[<em>j</em>], or 0 otherwise.  <em>a</em>[<em>j</em>] is the Bernstein coefficient <em>j</em> of the polynomial written in Bernstein form), or 0 otherwise.</li>
</ol>

<p>(By the properties of the Bernstein form, <em>a</em>[0] will equal <em>f</em>(0) and <em>a</em>[<em>n</em>] will equal <em>f</em>(1) whenever 0 or 1 is in the domain of <em>f</em>, respectively.)</p>

<p>Step 4 is done by first generating fair coin flips (such as with the von Neumann trick of flipping the input coin twice until the flip returns 0 then 1 or 1 then 0 this way, then taking the result as 0 or 1, respectively (von Neumann 1951)<sup id="fnref:31" role="doc-noteref"><a href="#fn:31" class="footnote" rel="footnote">31</a></sup>), then using the algorithm in “<a href="https://peteroupc.github.io/bernoulli.html#Digit_Expansion"><strong>Digit Expansions</strong></a>” to produce the probability <em>a</em>[<em>j</em>].  The algorithm computes <em>a</em>[<em>j</em>] bit by bit and compares the computed value with the generated bits.  Since the coin returned both 0 and 1 in step 1 earlier in the algorithm, we know the coin isn’t degenerate, so that step 4 will finish with probability 1.  Now, since the Bernoulli factory used only the input coin for randomness, this shows that <em>f</em> is strongly simulable. □</p>

<p><strong>Proposition 2.</strong> <em>If f(λ) is described in the strong simulability statement, and if either f is constant on its domain or f meets the additional conditions below, then f is strongly simulable.</em></p>

<ol>
  <li><em>If f(0) = 0 or f(1) = 0 or both, then there is a polynomial g(λ) whose Bernstein coefficients are computable and in the closed unit interval, such that g(0) = f(0) and g(1) = f(1) whenever 0 or 1, respectively, is in the domain of f, and such that g(λ) &gt; f(λ) for every λ in the domain of f, except at 0 and 1.</em></li>
  <li><em>If f(0) = 1 or f(1) = 1 or both, then there is a polynomial h(λ) whose Bernstein coefficients are computable and in the closed unit interval, such that h(0) = f(0) and h(1) = f(1) whenever 0 or 1, respectively, is in the domain of f, and such that h(λ) &lt; f(λ) for every λ in the domain of f, except at 0 and 1.</em></li>
</ol>

<p><strong>Lemma 1.</strong> <em>If f(λ) is described in the strong simulability statement and meets the additional condition below, then f is strongly simulable.</em></p>

<ul>
  <li><em>There is a polynomial g(λ) whose Bernstein coefficients are computable and in the closed unit interval, such that g(0) = f(0) and g(1) = f(1) whenever 0 or 1, respectively, is in the domain of f, and such that g(λ) &gt; f(λ) for every λ in the domain of f, except at 0 and 1.</em></li>
</ul>

<p><em>Proof:</em>  Consider the following algorithm.</p>

<ol>
  <li>If <em>f</em> is 0 everywhere in its domain or 1 everywhere in its domain, return 0 or 1, respectively.</li>
  <li>
    <p>Otherwise, use the algorithm given in Proposition 1 to simulate <em>g</em>(<em>λ</em>).  If the algorithm returns 0, return 0. By the additional condition in the lemma, 0 will be returned if <em>λ</em> is either 0 or 1.</p>

    <p>Now, we know that the input coin’s probability of heads is neither 0 nor 1.</p>

    <p>By the conditions in the lemma, both <em>f</em>(<em>λ</em>)&gt;0 and <em>g</em>(<em>λ</em>)&gt;0 whenever 0 &lt; <em>λ</em> &lt; 1 and <em>λ</em> is in <em>f</em>’s domain.</p>

    <p>Now let <em>h</em>(<em>λ</em>) = <em>f</em>(<em>λ</em>)/<em>g</em>(<em>λ</em>).  By the conditions in the lemma, <em>h</em> will be positive everywhere in that interval.</p>
  </li>
  <li>Return 1 if <em>h</em> has the following property: <em>h</em>(<em>λ</em>) = 0 whenever 0 &lt; <em>λ</em> &lt; 1 and <em>λ</em> is in <em>f</em>’s domain.</li>
  <li>Otherwise, we run a Bernoulli factory algorithm for <em>h</em>(<em>λ</em>) that uses the input coin (and possibly outside randomness).  Since <em>h</em> is continuous and polynomially bounded and the input coin’s probability of heads is neither 0 nor 1, <em>h</em> is strongly simulable; the von Neumann trick lets the input coin serve as a fair coin, thus doing away with outside randomness in the algorithm.</li>
</ol>

<p>Thus, <em>f</em> admits an algorithm that uses nothing but the input coin as a source of randomness, and so is strongly simulable. □</p>

<p><strong>Lemma 2.</strong> <em>If f(λ) is described in the strong simulability statement and meets the additional conditions below, then f is strongly simulable.</em></p>

<ol>
  <li><em>There are two polynomials g(λ) and ω(λ) such that both polynomials’ Bernstein coefficients are computable and all in the closed unit interval.</em></li>
  <li><em>g(0) = ω(0) = f(0) = 0 (so that 0 is in the domain of f).</em></li>
  <li><em>g(1) = ω(1) = f(1) = 1 (so that 1 is in the domain of f).</em></li>
  <li><em>For every λ in the domain of f, except at 0 and 1, g(λ) &gt; f(λ).</em></li>
  <li><em>For every λ in the domain of f, except at 0 and 1, ω(λ) &lt; f(λ).</em></li>
</ol>

<p><em>Proof:</em> First, assume <em>g</em> and <em>ω</em> have the same degree.  If not, rewrite the the polynomial with lesser degree to a polynomial in Bernstein form with the same degree as the other polynomial.</p>

<p>Now, let <em>g</em>[<em>j</em>] and <em>ω</em>[<em>j</em>] be the <em>j</em><sup>th</sup> Bernstein coefficient of the polynomial <em>g</em> or <em>ω</em>, respectively.  Consider the following algorithm, which is similar to the algorithm in Proposition 1.</p>

<ol>
  <li>Flip the input coin <em>n</em> times, and let <em>j</em> be the number of times the coin returned 1 this way.</li>
  <li>If 0 is in the domain of <em>f</em> and if <em>j</em> is 0, return <em>g</em>(0) = <em>ω</em>(0) = 0.</li>
  <li>If 1 is in the domain of <em>f</em> and if <em>j</em> is <em>n</em>, return <em>g</em>(1) = <em>ω</em>(1) = 0.</li>
  <li>Generate a uniformly distributed random variate, greater than 0 and less than 1, then return 1 if that variate is less than <em>ω</em>[<em>j</em>], or return 0 if that variate is greater than <em>g</em>[<em>j</em>].  This step is carried out via the von Neumann method, as in Proposition 1.</li>
</ol>

<p>If the algorithm didn’t return a value, then by now we know that the input coin’s probability of heads is neither 0 nor 1, since step 2 returned a value (either 0 or 1), which can only happen if the input coin didn’t return all zeros or all ones.</p>

<p>Now let <em>r</em>(<em>λ</em>) = (<em>f</em>(<em>λ</em>) − <em>ω</em>(<em>λ</em>)) / (<em>g</em>(<em>λ</em>) − <em>ω</em>(<em>λ</em>)).  By the conditions in the lemma, <em>h</em>(<em>λ</em>) will be positive wherever 0 &lt; <em>λ</em> &lt; 1 and <em>λ</em> is in the domain of <em>f</em>.</p>

<p>Now, run a Bernoulli factory algorithm for <em>r</em>(<em>λ</em>) that uses the input coin (and possibly outside randomness).  Since <em>r</em> is continuous and polynomially bounded and the input coin’s probability of heads is neither 0 nor 1, <em>r</em> is strongly simulable; the von Neumann trick lets the input coin serve as a fair coin, thus doing away with outside randomness in the algorithm.</p>

<p>Thus, <em>f</em> admits an algorithm that uses nothing but the input coin as a source of randomness, and so is strongly simulable. □</p>

<p><em>Proof of Proposition 2:</em>  The following cases can occur:</p>

<ol>
  <li>If neither 0 nor 1 are in the domain of <em>f</em>, then <em>f</em> is strongly simulable by the discussion above.</li>
  <li>If <em>f</em> is 0 everywhere in its domain or 1 everywhere in its domain: Return 0 or 1, respectively.</li>
  <li>If 0 but not 1 is in the domain of <em>f</em>: If <em>f</em>(0) = 0, apply Lemma 1.  If <em>f</em>(0) = 1, apply Lemma 1, but take <em>f</em> = 1 − <em>f</em> and return 1 minus the output of the lemma’s algorithm (this will bring <em>f</em>(0) = 0 and satisfy the lemma.)</li>
  <li>If 1 but not 0 is in the domain of <em>f</em>: If <em>f</em>(1) = 0, apply Lemma 1.  If <em>f</em>(1) = 1, apply Lemma 1, but take <em>f</em> = 1 − <em>f</em> and return 1 minus the output of the lemma’s algorithm (this will bring <em>f</em>(1) = 0 and satisfy the lemma.)</li>
  <li><em>f</em>(0) = <em>f</em>(1) = 0: Apply Lemma 1.</li>
  <li><em>f</em>(0) = <em>f</em>(1) = 1: Apply Lemma 1, but take <em>f</em> = 1 − <em>f</em> and return 1 minus the output of the lemma’s algorithm.</li>
  <li><em>f</em>(0) = 0 and <em>f</em>(1) = 1: Apply Lemma 2.</li>
  <li><em>f</em>(0) = 1 and <em>f</em>(1) = 0: Apply Lemma 2, but take <em>f</em> = 1 − <em>f</em> and return 1 minus the output of the lemma’s algorithm.</li>
</ol>

<p>□</p>

<p><strong>Proposition 3.</strong> <em>If f(λ) is described in the strong simulability statement and is Lipschitz continuous, then f is strongly simulable.</em></p>

<p><strong>Lemma 3.</strong> <em>If f(λ) is described in the strong simulability statement, is Lipschitz continuous, and is such that f(0) = 0 and f(1) = 0 whenever 0 or 1, respectively, is in the domain of f, then f is strongly simulable.</em></p>

<p><em>Proof:</em> If <em>f</em> is 0 everywhere in its domain or 1 everywhere in its domain: Return 0 or 1, respectively.  Otherwise, let—</p>

<ul>
  <li>
    <p><em>M</em> be the Lipschitz constant of <em>f</em> (its derivative’s maximum of the absolute value if <em>f</em> is continuous), or a computable number greater than this.</p>
  </li>
  <li><em>l</em> be either 0 if 0 is in the domain of <em>f</em>, or 1 otherwise, and</li>
  <li><em>u</em> be either 0 if 1 is in the domain of <em>f</em>, or 1 otherwise.</li>
</ul>

<p>To build <em>g</em>, take its degree as ceil(<em>M</em>)+1 or greater (so that <em>g</em>’s Lipschitz constant is greater than <em>M</em> and <em>g</em> has ceil(<em>M</em>) + 2 Bernstein coefficients), then set the first Bernstein coefficient as <em>l</em>, the last one as <em>u</em>, and the remaining ones as 1. (As a result, the polynomial <em>g</em> will have computable Bernstein coefficients.) Then <em>g</em> will meet the additional condition for Lemma 1 and the result follows from that lemma. □</p>

<p><strong>Lemma 4.</strong> <em>If f(λ) is described in the strong simulability statement, is Lipschitz continuous, and is such that f(0) = 0 and f(1) = 1 (so that 0 and 1 are in the domain of f), then f is strongly simulable.</em></p>

<p><em>Proof:</em> Let <em>M</em> and <em>l</em> be as in Lemma 3.</p>

<p>To build <em>g</em> and <em>ω</em>, take their degree as ceil(<em>M</em>)+1 or greater (so that their Lipschitz constant is greater than <em>M</em> and each polynomial has ceil(<em>M</em>) + 2 Bernstein coefficients), then for each polynomial, set its first Bernstein coefficient as <em>l</em> and its last as 1. The remaining Bernstein coefficients of <em>g</em> are set as 1 and the remaining ones of <em>ω</em> are set as 0.  (As a result, the polynomial <em>g</em> will have computable Bernstein coefficients.)  Then <em>g</em> and <em>ω</em> will meet the additional conditions for Lemma 2 and the result follows from that lemma. □</p>

<p><em>Proof of Proposition 3:</em> In the proof of proposition 2, replace Lemma 1 and Lemma 2 with Lemma 3 and Lemma 4, respectively. □</p>

<p><strong>Conjecture 1</strong>. <em>The conditions of Proposition 2 are necessary for $f(\lambda)$ to be strongly simulable.</em></p>

<p>A condition such as “0 is not in the domain of $f$, or there is a number $\epsilon&gt;0$ and a Lipschitz continuous function $g(x)$ on the interval $0\le x \lt \epsilon$ such that $g(x)=f(x)$ whenever $x$ is in both $g$’s and $f$’s domains” does not work.  An example that shows this is $f(x)=(\sin(1/x)/4+1/2)\cdot(1-(1-x)^n)$ for $n\ge 1$ (and $f(0)=0$), which is strongly simulable at 0 even though the condition just quoted is not satisfied for $f$.  ($(1-x)^n$ is the probability of the biased coin showing zero $n$ times in a row.)</p>

<p><a id="Multiple_Output_Bernoulli_Factory"></a></p>

<h3 id="multiple-output-bernoulli-factory">Multiple-Output Bernoulli Factory</h3>

<p>A related topic is a Bernoulli factory that takes a coin with unknown probability of heads <em>λ</em> and produces one or more samples of the probability <em>f</em>(<em>λ</em>).  This section calls it a <em>multiple-output Bernoulli factory</em>.</p>

<p>Obviously, any single-output Bernoulli factory can produce multiple outputs by running itself multiple times.  But for some functions <em>f</em>, it may be that producing multiple outputs at a time may use fewer input coin flips than producing one output multiple times.</p>

<p>Let <em>a</em> and <em>b</em> be real numbers satisfying 0 &lt; <em>a</em> &lt; <em>b</em> &lt; 1, such as <em>a</em>=1/100, <em>b</em>=99/100.  Define the <em>entropy bound</em> as <em>h</em>(<em>f</em>(<em>λ</em>))/<em>h</em>(<em>λ</em>) where <em>h</em>(<em>x</em>) = −<em>x</em>*ln(<em>x</em>)−(1−<em>x</em>)*ln(1−<em>x</em>) is related to the Shannon entropy function.  The question is:</p>

<p><em>When the probability λ is such that a ≤ λ ≤ b, is there a multiple-output Bernoulli factory for f(λ) with an expected (“long-run average”) number of input coin flips per sample that is arbitrarily close to the entropy bound?  Call such a Bernoulli factory an <strong>optimal factory</strong>.</em></p>

<p>(See Nacu and Peres (2005, Question 2)<sup id="fnref:1:22" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>.)</p>

<p>So far, the following functions do admit an <em>optimal factory</em>:</p>

<ul>
  <li>The functions <em>λ</em> and 1 − <em>λ</em>.</li>
  <li>Constants <em>c</em> satisfying 0 ≤ <em>c</em> ≤ 1.  As Nacu and Peres (2005)<sup id="fnref:1:23" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup> already showed, any such constant admits an optimal factory: turn flips of the input coin into <em>fair coin flips</em> (numbers that each equal 1 or 0 with equal probability) using Peres’s iterated von Neumann extractor (Peres 1992)<sup id="fnref:32" role="doc-noteref"><a href="#fn:32" class="footnote" rel="footnote">32</a></sup>, then build a binary tree that generates 1 with probability <em>c</em> and 0 otherwise (Knuth and Yao 1976)<sup id="fnref:33" role="doc-noteref"><a href="#fn:33" class="footnote" rel="footnote">33</a></sup>.</li>
</ul>

<p>It is easy to see that if an <em>optimal factory</em> exists for <em>f</em>(<em>λ</em>), then one also exists for 1 − <em>f</em>(<em>λ</em>): simply change all ones returned by the <em>f</em>(<em>λ</em>) factory into zeros and vice versa.</p>

<p>Also, as Yuval Peres (Jun. 24, 2021) told me, there is an efficient multiple-output Bernoulli factory for <em>f</em>(<em>λ</em>) = <em>λ</em>/2: the key is to flip the input coin enough times to produce fair coin flips using his extractor (Peres 1992)<sup id="fnref:14:2" role="doc-noteref"><a href="#fn:14" class="footnote" rel="footnote">14</a></sup>, then multiply each fair coin flip with another input coin flip to get a sample from <em>λ</em>/2.  Given that the sample is equal to 0, there are three possibilities that can “be extracted to produce more fair bits”: either the fair coin flip is 0, or the coin flip is 0, or both are 0.</p>

<p>This algorithm, though, doesn’t count as an <em>optimal factory</em>, and Peres described this algorithm only incompletely.  By simulation and trial and error I found an improved version of the algorithm.  It uses two randomness extractors (extractor 1 and extractor 2) that produce fair coin flips from bits that are not necessarily from fair coin flips (which is done using a method given later in this section).  The extractors must be asymptotically optimal (they must approach the entropy limit as closely as desired); one example is the iterated von Neumann construction in Peres (1992)<sup id="fnref:32:1" role="doc-noteref"><a href="#fn:32" class="footnote" rel="footnote">32</a></sup>.  The algorithm consists of doing the following in a loop until the desired number of outputs is generated.</p>

<ol>
  <li>If the number of outputs generated so far is divisible by 20, do the following:
    <ul>
      <li>Generate a fair coin using the method given later in this section.  If that bit is zero, output 0, then repeat this step unless the desired number of outputs has been generated.  If the bit is 1, flip the input coin and output the result.</li>
    </ul>
  </li>
  <li>Otherwise, do the following:
    <ol>
      <li>Generate a fair coin using the method given later in this section, call it <em>fc</em>.  Then flip the input coin and call the result <em>bc</em>.</li>
      <li>Output <em>fc</em>*<em>bc</em>.</li>
      <li>(The following steps pass “unused” randomness to the extractor in a specific way to ensure correctness.) If <em>fc</em> is 0, and <em>bc</em> is 1, append 0 to extractor 2’s input bits.</li>
      <li>If <em>fc</em> and <em>bc</em> are both 0, append 1 then 1 to extractor 2’s input bits.</li>
      <li>If <em>fc</em> is 1 and <em>bc</em> is 0, append 1 then 0 to extractor 2’s input bits.</li>
    </ol>
  </li>
</ol>

<p>Inspired by Peres’s result with <em>λ</em>/2, the following algorithm is proposed.  It works for every function writable as <em>D</em>(<em>λ</em>)/<em>E</em>(<em>λ</em>), where—</p>

<ul>
  <li>$D$ is the polynomial $D(\lambda)=\sum_{i=0}^k \lambda^i (1-\lambda)^{k-i} d[i]$,</li>
  <li>$E$ is the polynomial $E(\lambda)=\sum_{i=0}^k \lambda^i (1-\lambda)^{k-i} e[i]$,</li>
  <li>every <em>d</em>[<em>i</em>] is less than or equal to the corresponding <em>e</em>[<em>i</em>], and</li>
  <li>each <em>d</em>[<em>i</em>] and each <em>e</em>[<em>i</em>] is a nonnegative integer.</li>
</ul>

<p>The algorithm is a modified version of the “block simulation” in Mossel and Peres (2005, Proposition 2.5)<sup id="fnref:34" role="doc-noteref"><a href="#fn:34" class="footnote" rel="footnote">34</a></sup>, which also “extracts” residual randomness with the help of six asymptotically optimal randomness extractors.  In the algorithm, let <em>r</em> be an integer such that, for every integer <em>i</em> in [0, <em>k</em>], <em>e</em>[<em>i</em>] &lt; choose(<em>k</em>, <em>i</em>)*choose(2*<em>r</em>, <em>r</em>).</p>

<ol>
  <li>Set <em>iter</em> to 0.</li>
  <li>Flip the input coin <em>k</em> times.  Then build a bitstring <em>B1</em> consisting of the coin flip results in the order they occurred.  Let <em>i</em> be the number of ones in <em>B1</em>.</li>
  <li>Generate 2*<em>r</em> a fair coin using the method given later in this section.  (Rather than flipping the input coin 2*<em>r</em> times, as in the algorithm of Proposition 2.5.)  Then build a bitstring <em>B2</em> consisting of the coin flip results in the order they occurred.</li>
  <li>If the number of ones in <em>B2</em> is other than <em>r</em>: Translate <em>B1</em> + <em>B2</em> to an integer under mapping 1, then pass that number to extractor 2 (†), then add 1 to <em>iter</em>, then go to step 2.</li>
  <li>Translate <em>B1</em> + <em>B2</em> to an integer under mapping 2, call the integer <em>β</em>.  If <em>β</em> &lt; <em>d</em>[<em>i</em>], pass <em>β</em> to extractor 3, then pass <em>iter</em> to extractor 6, then output a 1.  Otherwise, if <em>β</em> &lt; <em>e</em>[<em>i</em>], pass <em>β</em> − <em>d</em>[<em>i</em>] to extractor 4, then pass <em>iter</em> to extractor 6, then output a 0.  Otherwise, pass <em>β</em> − <em>e</em>[<em>i</em>] to extractor 5, then add 1 to <em>iter</em>, then go to step 2.</li>
</ol>

<p>The mappings used in this algorithm are as follows:</p>

<ol>
  <li>A one-to-one mapping between—
    <ul>
      <li>bitstrings of length <em>k</em> + 2*<em>r</em> with fewer or greater than <em>r</em> ones among the last 2*<em>r</em> bits, and</li>
      <li>the integers in [0, 2<sup><em>k</em></sup> * (2<sup>2*<em>r</em></sup> − choose(2*<em>r</em>, <em>r</em>))).</li>
    </ul>
  </li>
  <li>A one-to-one mapping between—
    <ul>
      <li>bitstrings of length <em>k</em> + 2*<em>r</em> with exactly <em>i</em> ones among the first <em>k</em> bits and exactly <em>r</em> ones among the remaining bits, and</li>
      <li>the integers in [0, choose(<em>k</em>, <em>i</em>)*choose(2*<em>r</em>, <em>r</em>)).</li>
    </ul>
  </li>
</ol>

<p>In this algorithm, a fair coin flip is generated as follows.  Let <em>m</em> be an even integer that is 32 or greater (in general, the greater <em>m</em> is, the more efficient the overall algorithm is in terms of coin flips).</p>

<ol>
  <li>Use extractor 1 to extract outputs from floor(<em>n</em>/<em>m</em>)*<em>m</em> inputs, where <em>n</em> is the number of input bits available to that extractor.  Do the same for the remaining extractors.</li>
  <li>If extractor 2 has at least one unused output bit, take an output and stop.  Otherwise, repeat this step for the remaining extractors.</li>
  <li>Flip the input coin at least <em>m</em> times, append the coin results to extractor 1’s inputs, and go to step 1.</li>
</ol>

<p>Now consider the last paragraph of Proposition 2.5.  If the input coin were flipped in step 2, the probability of—</p>

<ul>
  <li>outputting 1 in the algorithm’s last step would be <em>P1</em> = <em>λ</em><sup><em>r</em></sup>*(1−<em>λ</em>)<sup><em>r</em></sup>*<em>D</em>(<em>λ</em>), and</li>
  <li>outputting either 0 or 1 in that step would be <em>P01</em> = <em>λ</em><sup><em>r</em></sup>*(1−<em>λ</em>)<sup><em>r</em></sup>*<em>E</em>(<em>λ</em>),</li>
</ul>

<p>so that the algorithm would simulate <em>f</em>(<em>λ</em>) = <em>P1</em> / <em>P01</em>.  Observe that the <em>λ</em><sup><em>r</em></sup>*(1−<em>λ</em>)<sup><em>r</em></sup> cancels out in the division.  Thus, we could replace flips of the input coin with fair coin flips and still simulate <em>f</em>(<em>λ</em>); the <em>λ</em><sup><em>r</em></sup>*(1−<em>λ</em>)<sup><em>r</em></sup> above would then be (1/2)<sup>2*<em>r</em></sup>.</p>

<p>While this algorithm is coin-flip-efficient, it is not believed to be an optimal factory, at least not without more work.  In particular, a bigger savings of input coin flips could occur if <em>f</em>(<em>λ</em>) maps each value <em>a</em> or greater and <em>b</em> or less to a small range of values, so that the algorithm could, for example, generate a uniform random variate between 0 and 1 using fair coin flips and see whether that variate lies outside that range of values — and thus produce a sample from <em>f</em>(<em>λ</em>) without flipping the input coin again.</p>

<p><small>(†) For example, by translating the number to input bits via Pae’s entropy-preserving binarization (Pae 2018)<sup id="fnref:35" role="doc-noteref"><a href="#fn:35" class="footnote" rel="footnote">35</a></sup>.  But correctness might depend on how this is done; after all, the number of coin flips per sample must equal or exceed the entropy bound for every <em>λ</em>.</small></p>

<p><a id="Pushdown_Automata_and_Algebraic_Functions"></a></p>

<h3 id="pushdown-automata-and-algebraic-functions">Pushdown Automata and Algebraic Functions</h3>

<p>This section has mathematical proofs showing which kinds of algebraic functions (functions that can be a solution of a nonzero polynomial equation) can be simulated with a pushdown automaton (a state machine with a stack).</p>

<p>The following summarizes what can be established about these algebraic functions:</p>

<ul>
  <li>sqrt(<em>λ</em>) can be simulated.</li>
  <li>Every rational function with rational Bernstein coefficients that maps the open interval (0, 1) to itself can be simulated.</li>
  <li>If <em>f</em>(<em>λ</em>) can be simulated, so can any Bernstein-form polynomial in the variable <em>f</em>(<em>λ</em>) with Bernstein coefficients that can be simulated.</li>
  <li>If <em>f</em>(<em>λ</em>) and <em>g</em>(<em>λ</em>) can be simulated, so can <em>f</em>(<em>λ</em>)*<em>g</em>(<em>λ</em>), <em>f</em>(<em>g</em>(<em>λ</em>)), and <em>g</em>(<em>f</em>(<em>λ</em>)).</li>
  <li>If a full-domain pushdown automaton (defined later) can generate words of a given length with a given probability (a <em>probability distribution</em> of word lengths), then the probability generating function for that distribution can be simulated, as well as for that distribution conditioned on a finite set or periodic infinite set of word lengths (for example, all odd word lengths only).</li>
  <li>If a stochastic context-free grammar (defined later) can generate a probability distribution of word lengths, and terminates with probability 1, then the probability generating function for that distribution can be simulated.</li>
  <li>Every quadratic irrational number between 0 and 1 can be simulated.</li>
</ul>

<p>It is not yet known whether the following functions can be simulated:</p>

<ul>
  <li><em>λ</em><sup>1/<em>p</em></sup> for prime numbers <em>p</em> greater than 2. The answer may be no; Banderier and Drmota (2015)<sup id="fnref:36" role="doc-noteref"><a href="#fn:36" class="footnote" rel="footnote">36</a></sup> proved results that show, among other things, that $\lambda^{1/p}$, where $p$ is not a power of 2, is not a possible solution to $P(\lambda) = 0$, where $P(\lambda)$ is a polynomial whose “power” coefficients are non-negative real numbers.</li>
  <li>min(<em>λ</em>, 1−<em>λ</em>).</li>
</ul>

<hr />

<p>The following definitions are used in this section:</p>

<ol>
  <li>A <em>pushdown automaton</em> has a finite set of <em>states</em> and a finite set of <em>stack symbols</em>, one of which is called EMPTY, and takes a coin that shows heads with an unknown probability. It starts at a given state and its stack starts with EMPTY.  On each iteration:
    <ul>
      <li>The automaton flips the coin.</li>
      <li>Based on the coin flip (HEADS or TAILS), the current state, and the top stack symbol, it moves to a new state (or keeps it unchanged) and replaces the top stack symbol with zero, one or two symbols.  Thus, there are three kinds of <em>transition rules</em>:
        <ul>
          <li>(<em>state</em>, <em>flip</em>, <em>symbol</em>) → (<em>state2</em>, {<em>symbol2</em>}): move to <em>state2</em>, replace top stack symbol with same or different one.</li>
          <li>(<em>state</em>, <em>flip</em>, <em>symbol</em>) → (<em>state2</em>, {<em>symbol2</em>, <em>new</em>}): move to <em>state2</em>, replace top stack symbol with <em>symbol2</em>, then <em>push</em> a new symbol (<em>new</em>) onto the stack.</li>
          <li>(<em>state</em>, <em>flip</em>, <em>symbol</em>) → (<em>state2</em>, {}): move to <em>state2</em>, <em>pop</em> the top symbol from the stack.</li>
        </ul>
      </li>
    </ul>

    <p>When the stack is empty, the machine stops, and returns either 0 or 1 depending on the state it ends up at.  (Because each left-hand side has no more than one possible transition, the automaton is <em>deterministic</em>.)</p>
  </li>
  <li>A <em>full-domain pushdown automaton</em> means a pushdown automaton that terminates with probability 1 given a coin with probability of heads <em>λ</em>, for every <em>λ</em> greater than 0 and less than 1.</li>
  <li><strong>PDA</strong> is the class of functions <em>f</em>(<em>λ</em>) that satisfy 0&lt;<em>f</em>(<em>λ</em>)&lt;1 whenever 0&lt;<em>λ</em>&lt;1, and can be simulated by a full-domain pushdown automaton.  <strong>PDA</strong> also includes the constant functions 0 and 1.</li>
  <li><strong>ALGRAT</strong> is the class of functions that satisfy 0&lt;<em>f</em>(<em>λ</em>)&lt;1 whenever 0&lt;<em>λ</em>&lt;1, are continuous, and are algebraic over the rational numbers (they satisfy a nonzero polynomial system whose “power” coefficients are rational numbers; specifically, there is a nonzero polynomial <em>P</em>(<em>x</em>, <em>y</em>) in two variables and whose “power” coefficients are rational numbers, such that <em>P</em>(<em>x</em>, <em>f</em>(<em>x</em>)) = 0 for every <em>x</em> in the domain of <em>f</em>). <strong>ALGRAT</strong> also includes the constant functions 0 and 1.</li>
  <li>A <em>probability generating function</em> has the form <em>p</em><sub>0</sub>*<em>λ</em><sup>0</sup> + <em>p</em><sub>1</sub>*<em>λ</em><sup>1</sup> + …, where <em>p</em><sub><em>i</em></sub> is the probability of getting <em>i</em>.</li>
</ol>

<blockquote>
  <p><strong>Notes:</strong></p>

  <ol>
    <li>Mossel and Peres (2005)<sup id="fnref:34:1" role="doc-noteref"><a href="#fn:34" class="footnote" rel="footnote">34</a></sup> defined pushdown automata to start with a non-empty stack of <em>arbitrary</em> size, and to allow each rule to replace the top symbol with an <em>arbitrary</em> number of symbols.  Both cases can be reduced to the definition in this section.</li>
    <li>Pushdown automata, as defined here, are very similar to so-called <em>probabilistic right-linear indexed grammars</em> (Icard 2020)<sup id="fnref:37" role="doc-noteref"><a href="#fn:37" class="footnote" rel="footnote">37</a></sup> and can be translated to those grammars as well as to <em>probabilistic pushdown systems</em> (Etessami and Yannakakis 2009)<sup id="fnref:37:1" role="doc-noteref"><a href="#fn:37" class="footnote" rel="footnote">37</a></sup>, as long as those grammars and systems use only transition probabilities that are rational numbers.</li>
  </ol>
</blockquote>

<p><strong>Proposition 0</strong> (Mossel and Peres 2005<sup id="fnref:34:2" role="doc-noteref"><a href="#fn:34" class="footnote" rel="footnote">34</a></sup>, Theorem 1.2): <em>A full-domain pushdown automaton can simulate a function that maps (0, 1) to itself only if the function is in class <strong>ALGRAT</strong>.</em></p>

<p>It is not known whether <strong>ALGRAT</strong> and <strong>PDA</strong> are equal, but the following can be established about <strong>PDA</strong>:</p>

<p><strong>Lemma 1A:</strong> <em>Let g(λ) be a function in the class <strong>PDA</strong>, and suppose a pushdown automaton F has two rules of the form (<code>state</code>, HEADS, <code>stacksymbol</code>) → RHS1 and (<code>state</code>, TAILS, <code>stacksymbol</code>) → RHS2, where <code>state</code> and <code>stacksymbol</code> are a specific state/symbol pair among the left-hand sides of F’s rules.  Then there is a pushdown automaton that transitions to RHS1 with probability g(λ) and to RHS2 with probability 1−g(λ) instead.</em></p>

<p><em>Proof:</em> If RHS1 and RHS2 are the same, then the conclusion holds and nothing has to be done.  Thus assume RHS1 and RHS2 are different.</p>

<p>Let <em>G</em> be the full-domain pushdown automaton for <em>g</em>. Assume that machines <em>F</em> and <em>G</em> stop when they pop EMPTY from the stack. If this is not the case, transform both machines by renaming the symbol EMPTY to EMPTY′′, adding a new symbol EMPTY′′ and new starting state X0, and adding rules (X0, <em>flip</em>, EMPTY) → (<em>start</em>, {EMPTY′′}) and rule (<em>state</em>, <em>flip</em>, EMPTY) → (<em>state</em>, {}) for all states other than X0, where <em>start</em> is the starting state of <em>F</em> or <em>G</em>, as the case may be.</p>

<p>Now, rename each state of <em>G</em> as necessary so that the sets of states of <em>F</em> and of <em>G</em> are disjoint (mutually exclusive).  Then, add to <em>F</em> a new stack symbol EMPTY′ (or a name not found in the stack symbols of G, as the case may be).  Then, for the following two pairs of rules in <em>F</em>, namely—</p>

<p>(<em>state</em>, HEADS, <em>stacksymbol</em>) → (<em>state2heads</em>, <em>stackheads</em>), and<br />
(<em>state</em>, TAILS, <em>stacksymbol</em>) → (<em>state2tails</em>, <em>stacktails</em>),</p>

<p>add two new states <em>state</em><sub>0</sub> and <em>state</em><sub>1</sub> that correspond to <em>state</em> and have names different from all other states, and replace that rule with the following rules:</p>

<p>(<em>state</em>, HEADS, <em>stacksymbol</em>) → (<em>gstart</em>, {<em>stacksymbol</em>, EMPTY′}),<br />
(<em>state</em>, TAILS, <em>stacksymbol</em>) → (<em>gstart</em>, {<em>stacksymbol</em>, EMPTY′}),<br />
(<em>state</em><sub>0</sub>, HEADS, <em>stacksymbol</em>) → (<em>state2heads</em>, <em>stackheads</em>),<br />
(<em>state</em><sub>0</sub>, TAILS, <em>stacksymbol</em>) → (<em>state2heads</em>, <em>stackheads</em>),<br />
(<em>state</em><sub>1</sub>, HEADS, <em>stacksymbol</em>) → (<em>state2tails</em>, <em>stacktails</em>), and<br />
(<em>state</em><sub>1</sub>, TAILS, <em>stacksymbol</em>) → (<em>state2tails</em>, <em>stacktails</em>),<br /></p>

<p>where <em>gstart</em> is the starting state for <em>G</em>, and copy the rules of the automaton for <em>G</em> onto <em>F</em>, but with the following modifications:</p>

<ul>
  <li>Replace the symbol EMPTY in <em>G</em> with EMPTY′.</li>
  <li>Replace each state in <em>G</em> with a name distinct from all other states in <em>F</em>.</li>
  <li>Replace each rule in <em>G</em> of the form (<em>state</em>, <em>flip</em>, EMPTY′) → (<em>state2</em>, {}), where <em>state2</em> is a final state of <em>G</em> associated with output 1, with the rule (<em>state</em>, <em>flip</em>, EMPTY′) → ( <em>state</em><sub>1</sub>, {}).</li>
  <li>Replace each rule in <em>G</em> of the form (<em>state</em>, <em>flip</em>, EMPTY′) → (<em>state2</em>, {}), where <em>state2</em> is a final state of <em>G</em> associated with output 0, with the rule (<em>state</em>, <em>flip</em>, EMPTY′) → ( <em>state</em><sub>0</sub>, {}).</li>
</ul>

<p>Then, the final states of the new machine are the same as those for the original machine <em>F</em>. □</p>

<p><strong>Lemma 1B:</strong>  <em>There are pushdown automata that simulate the probabilities 0 and 1.</em></p>

<p><em>Proof:</em> The probability 0 automaton has the rules (START, HEADS, EMPTY) → (START, {}) and (START, TAILS, EMPTY) → (START, {}), and its only state START is associated with output 0. The probability 1 automaton is the same, except START is associated with output 1.  Both automata obviously terminate with probability 1. □</p>

<p>Because of Lemma 1A, it’s possible to label each left-hand side of a pushdown automaton’s rules with not just HEADS or TAILS, but also a rational number or another function in <strong>PDA</strong>, as long as for each state/symbol pair, the probabilities for that pair sum to 1.  For example, rules like the following are now allowed:</p>

<p>(START, 1/2, EMPTY) → …, (START, sqrt(<em>λ</em>)/2, EMPTY) → …, (START, (1 − sqrt(<em>λ</em>))/2, EMPTY) → ….</p>

<p><strong>Proposition 1A:</strong> <em>If f(λ) is in the class <strong>PDA</strong>, then so is every polynomial written as—</em></p>

\[{n\choose 0}f(\lambda)^0 (1-f(\lambda))^{n-0} a[0] + {n\choose 1}f(\lambda)^1 (1-f(\lambda))^{n-1} a[1] + ... + {n\choose n}f(\lambda)^n (1-f(\lambda))^{n-n} a[n],\]

<p><em>where n is the polynomial’s degree and a[0], a[1], …, a[n] are functions in the class <strong>PDA</strong>.</em></p>

<p><em>Proof Sketch</em>: This corresponds to a two-stage pushdown automaton that follows the algorithm of Goyal and Sigman (2012)<sup id="fnref:7:4" role="doc-noteref"><a href="#fn:7" class="footnote" rel="footnote">7</a></sup>: The first stage counts the number of “heads” shown when flipping the f(λ) coin, and the second stage flips another coin that has success probability <em>a</em>[<em>i</em>], where <em>i</em> is the number of “heads”. The automaton’s transitions take advantage of Lemma 1A.  □</p>

<p><strong>Proposition 1:</strong> <em>If f(λ) and g(λ) are functions in the class <strong>PDA</strong>, then so is their product, namely f(λ)*g(λ).</em></p>

<p><em>Proof:</em> Special case of Proposition 1A with <em>n</em>=1, <em>f</em>(<em>λ</em>)=<em>f</em>(<em>λ</em>), <em>a</em>[0]=0 (using Lemma 1B), and <em>a</em>[1]=<em>g</em>(<em>λ</em>).  □</p>

<p><strong>Corollary 1A:</strong> <em>If f(λ), g(λ), and h(λ) are functions in the class <strong>PDA</strong>, then so is f(λ)*g(λ) + (1−f(λ))*h(λ).</em></p>

<p><em>Proof:</em> Special case of Proposition 1A with <em>n</em>=1, <em>f</em>(<em>λ</em>)=<em>f</em>(<em>λ</em>), <em>a</em>[0]=<em>h</em>(<em>λ</em>), and <em>a</em>[1]=<em>g</em>(<em>λ</em>).  □</p>

<p><strong>Proposition 2:</strong> <em>If f(λ) and g(λ) are functions in the class <strong>PDA</strong>, then so is their composition, namely f(g(λ)) or (f∘g)(λ).</em></p>

<p><em>Proof:</em> Let <em>F</em> be the full-domain pushdown automaton for <em>f</em>. For each state/symbol pair among the left-hand sides of <em>F</em>’s rules, apply Lemma 1A to the automaton <em>F</em>, using the function <em>g</em>.  Then the new machine <em>F</em> terminates with probability 1 because the original <em>F</em> and the original automaton for <em>g</em> do for every <em>λ</em> greater than 0 and less than 1, and because the automaton for <em>g</em> never outputs the same value with probability 0 or 1 for any <em>λ</em> greater than 0 or less than 1.  Moreover, <em>f</em> is in class <strong>PDA</strong> by Theorem 1.2 of (Mossel and Peres 2005)<sup id="fnref:34:3" role="doc-noteref"><a href="#fn:34" class="footnote" rel="footnote">34</a></sup> because the machine is a full-domain pushdown automaton.  □</p>

<p><strong>Proposition 3:</strong> <em>Every rational function with rational Bernstein coefficients that maps the open interval (0, 1) to itself is in class <strong>PDA</strong>.</em></p>

<p><em>Proof:</em> These functions can be simulated by a finite-state machine (Mossel and Peres 2005)<sup id="fnref:34:4" role="doc-noteref"><a href="#fn:34" class="footnote" rel="footnote">34</a></sup>.  This corresponds to a full-domain pushdown automaton that has no stack symbols other than EMPTY, never pushes symbols onto the stack, and pops the only symbol EMPTY from the stack whenever it transitions to a final state of the finite-state machine. □</p>

<blockquote>
  <p><strong>Note:</strong> An unbounded stack size is necessary for a pushdown automaton to simulate functions that a finite-state machine can’t.  With a bounded stack size, there is a finite-state machine where each state not only holds the pushdown automaton’s original state, but also encodes the contents of the stack (which is possible because the stack’s size is bounded); each operation that would push, pop, or change the top symbol transitions to a state with the appropriate encoding of the stack instead.</p>
</blockquote>

<p><strong>Proposition 4:</strong> <em>If a full-domain pushdown automaton can generate words with the same letter such that the length of each word follows a probability distribution, then that distribution’s probability generating function is in class <strong>PDA</strong>.</em></p>

<p><em>Proof:</em> Let <em>F</em> be a full-domain pushdown automaton.  Add one state FAILURE, then augment <em>F</em> with a special “letter-generating” operation as follows.  Add the following rule that pops all symbols from the stack:</p>

<p>(FAILURE, <em>flip</em>, <em>stacksymbol</em>) → (FAILURE, {}),</p>

<p>and for each rule of the following form that transitions to a letter-generating operation (where S and T are arbitrary states):</p>

<p>(S, <em>flip</em>, <em>stacksymbol</em>) → (T, <em>newstack</em>),</p>

<p>add another state S′ (with a name that differs from all other states) and replace that rule with the following rules:</p>

<p>(S, <em>flip</em>, <em>stacksymbol</em>) → (S′, {<em>stacksymbol</em>}),<br />
(S′, HEADS, <em>stacksymbol</em>) → (T, <em>newstack</em>), and<br />
(S′, TAILS, <em>stacksymbol</em>) → (FAILURE, {}).</p>

<p>Then if the stack is empty upon reaching the FAILURE state, the result is 0, and if the stack is empty upon reaching any other state, the result is 1.  By Dughmi et al. (2021)<sup id="fnref:38" role="doc-noteref"><a href="#fn:38" class="footnote" rel="footnote">38</a></sup>, the machine now simulates the distribution’s probability generating function.  Moreover, the function is in class <strong>PDA</strong> by Theorem 1.2 of Mossel and Peres (2005)<sup id="fnref:34:5" role="doc-noteref"><a href="#fn:34" class="footnote" rel="footnote">34</a></sup> because the machine is a full-domain pushdown automaton.  □</p>

<p>Define a <em>stochastic context-free grammar</em> as follows.  The grammar consists of a finite set of <em>nonterminals</em> and a finite set of <em>letters</em>, and rewrites one nonterminal (the starting nonterminal) into a word.  The grammar has three kinds of rules (in generalized Chomsky normal form (Etessami and Yannakakis 2009)<sup id="fnref:39" role="doc-noteref"><a href="#fn:39" class="footnote" rel="footnote">39</a></sup>):</p>

<ul>
  <li><em>X</em> → <em>a</em> (rewrite <em>X</em> to the letter <em>a</em>).</li>
  <li><em>X</em> →<sub><em>p</em></sub> (<em>a</em>, <em>Y</em>) (with rational probability <em>p</em>, rewrite <em>X</em> to the letter <em>a</em> followed by the nonterminal <em>Y</em>).  For the same left-hand side, all the <em>p</em> values must sum to 1.</li>
  <li><em>X</em> → (<em>Y</em>, <em>Z</em>) (rewrite <em>X</em> to the nonterminals <em>Y</em> and <em>Z</em> in that order).</li>
</ul>

<p>Instead of a letter (such as <em>a</em>), a rule can use <em>ε</em> (the empty string). (The grammar is <em>context-free</em> because the left-hand side has only a single nonterminal, so that no context from the word is needed to parse it.)</p>

<p><strong>Proposition 5:</strong> <em>Every stochastic context-free grammar can be transformed into a pushdown automaton.  If the automaton is a full-domain pushdown automaton and the grammar has a one-letter alphabet, the automaton can generate words such that the length of each word follows the same distribution as the grammar, and that distribution’s probability generating function is in class <strong>PDA</strong>.</em></p>

<p><em>Proof Sketch:</em> In the equivalent pushdown automaton:</p>

<ul>
  <li><em>X</em> → <em>a</em> becomes the two rules—<br />(START, HEADS, <em>X</em>) → (<em>letter</em>, {}), and<br />(START, TAILS, <em>X</em>) → (<em>letter</em>, {}).<br />Here, <em>letter</em> is either START or a unique state in <em>F</em> that “detours” to a letter-generating operation for <em>a</em> and sets the state back to START when finished (see Proposition 4).  If <em>a</em> is <em>ε</em>, <em>letter</em> is START and no letter-generating operation is done.</li>
  <li><em>X</em> →<sub><em>p</em><sub><em>i</em></sub></sub> (<em>a</em><sub><em>i</em></sub>, <em>Y</em><sub><em>i</em></sub>) (all rules with the same nonterminal <em>X</em>) are rewritten to enough rules to transition to a letter-generating operation for <em>a</em><sub><em>i</em></sub>, and swap the top stack symbol with <em>Y</em><sub><em>i</em></sub>, with probability <em>p</em><sub><em>i</em></sub>, which is possible with just a finite-state machine (see Proposition 4) because all the probabilities are rational numbers (Mossel and Peres 2005)<sup id="fnref:34:6" role="doc-noteref"><a href="#fn:34" class="footnote" rel="footnote">34</a></sup>.  If <em>a</em><sub><em>i</em></sub> is <em>ε</em>, no letter-generating operation is done.</li>
  <li><em>X</em> → (<em>Y</em>, <em>Z</em>) becomes the two rules—<br />(START, HEADS, <em>X</em>) → (START, {<em>Z</em>, <em>Y</em>}), and<br />(START, TAILS, <em>X</em>) → (START, {<em>Z</em>, <em>Y</em>}).</li>
</ul>

<p>Here, <em>X</em> is the stack symbol EMPTY if <em>X</em> is the grammar’s starting nonterminal. Now, assuming the automaton is full-domain, the rest of the result follows easily.   For a single-letter alphabet, the grammar corresponds to a system of polynomial equations, one for each rule in the grammar, as follows:</p>

<ul>
  <li><em>X</em> → <em>a</em> becomes <em>X</em> = 1 if <em>a</em> is the empty string (<em>ε</em>), or <em>X</em> =  <em>λ</em> otherwise.</li>
  <li>For each nonterminal <em>X</em>, all <em>n</em> rules of the form <em>X</em> →<sub><em>p</em><sub><em>i</em></sub></sub> (<em>a</em><sub><em>i</em></sub>, <em>Y</em><sub><em>i</em></sub>) become the equation <em>X</em> = <em>p</em><sub>1</sub>*<em>λ</em><sub>1</sub>*<em>Y</em><sub>1</sub> + <em>p</em><sub>2</sub>*<em>λ</em><sub>2</sub>*<em>Y</em><sub>2</sub> + … + <em>p</em><sub><em>n</em></sub>*<em>λ</em><sub><em>n</em></sub>*<em>Y</em><sub><em>n</em></sub>, where <em>λ</em><sub><em>i</em></sub> is either 1 if <em>a</em><sub><em>i</em></sub> is <em>ε</em>, or <em>λ</em> otherwise.</li>
  <li><em>X</em> → (<em>Y</em>, <em>Z</em>) becomes <em>X</em> = <em>Y</em>*<em>Z</em>.</li>
</ul>

<p>Solving this system for the grammar’s starting nonterminal, and applying Proposition 4, leads to the <em>probability generating function</em> for the grammar’s word distribution.  (See also Flajolet et al. 2010<sup id="fnref:40" role="doc-noteref"><a href="#fn:40" class="footnote" rel="footnote">40</a></sup>, Icard 2020<sup id="fnref:41" role="doc-noteref"><a href="#fn:41" class="footnote" rel="footnote">41</a></sup>.) □</p>

<blockquote>
  <p><strong>Example:</strong> The stochastic context-free grammar—<br /><em>X</em> →<sub>1/2</sub> (<em>a</em>, <em>X1</em>),<br /><em>X1</em> → (<em>X</em>, <em>X2</em>),<br /><em>X2</em> → (<em>X</em>, <em>X</em>),<br /><em>X</em> →<sub>1/2</sub> (<em>a</em>, <em>X3</em>),<br /><em>X3</em> → <em>ε</em>,<br />which encodes ternary trees (Flajolet et al. 2010)<sup id="fnref:40:1" role="doc-noteref"><a href="#fn:40" class="footnote" rel="footnote">40</a></sup>, corresponds to the equation <em>X</em> = (1/2) * <em>λ</em>*<em>X</em>*<em>X</em>*<em>X</em> + (1/2)*<em>λ</em>*1, and solving this equation for <em>X</em> leads to the probability generating function for such trees, which is a complicated expression.</p>

  <p><strong>Notes:</strong></p>

  <ol>
    <li>
      <p>A stochastic context-free grammar in which all the probabilities are 1/2 is called a <em>binary stochastic grammar</em> (Flajolet et al. 2010)<sup id="fnref:40:2" role="doc-noteref"><a href="#fn:40" class="footnote" rel="footnote">40</a></sup>.  If every probability is a multiple of 1/<em>n</em>, then the grammar can be called an “<em>n</em>-ary stochastic grammar”.  It is even possible for a nonterminal to have two rules of probability <em>λ</em> and (1− <em>λ</em>), which are used when the input coin returns 1 (HEADS) or 0 (TAILS), respectively.</p>
    </li>
    <li>
      <p>If a pushdown automaton simulates the function <em>f</em>(<em>λ</em>), then <em>f</em> corresponds to a special system of equations, built as follows (Mossel and Peres 2005)<sup id="fnref:34:7" role="doc-noteref"><a href="#fn:34" class="footnote" rel="footnote">34</a></sup>; see also Esparza et al. (2004)<sup id="fnref:42" role="doc-noteref"><a href="#fn:42" class="footnote" rel="footnote">42</a></sup>.  For each state of the automaton (call the state <em>en</em>), include the following equations in the system based on the automaton’s transition rules:</p>

      <ul>
        <li>(<em>st</em>, <em>p</em>, <em>sy</em>) → (<em>s2</em>, {}) becomes either <em>α</em><sub><em>st</em>,<em>sy</em>,<em>en</em></sub> = <em>p</em> if <em>s2</em> is <em>en</em>, or <em>α</em><sub><em>st</em>,<em>sy</em>,<em>en</em></sub> = 0 otherwise.</li>
        <li>(<em>st</em>, <em>p</em>, <em>sy</em>) → (<em>s2</em>, {<em>sy1</em>}) becomes <em>α</em><sub><em>st</em>,<em>sy</em>,<em>en</em></sub> = <em>p</em> * <em>α</em><sub><em>s2</em>,<em>sy1</em>,<em>en</em></sub>.</li>
        <li>(<em>st</em>, <em>p</em>, <em>sy</em>) → (<em>s2</em>, {<em>sy1</em>, <em>sy2</em>}) becomes <em>α</em><sub><em>st</em>,<em>sy</em>,<em>en</em></sub> = <em>p</em>*<em>α</em><sub><em>s2</em>,<em>sy2</em>,<em>σ[1]</em></sub>*<em>α</em><sub><em>σ[1]</em>,<em>sy1</em>,<em>en</em></sub> + … + <em>p</em>*<em>α</em><sub><em>s2</em>,<em>sy2</em>,<em>σ[n]</em></sub>*<em>α</em><sub><em>σ[n]</em>,<em>sy1</em>,<em>en</em></sub>, where <em>σ[i]</em> is one of the machine’s <em>n</em> states.</li>
      </ul>

      <p>(Here, <em>p</em> is the probability of using the given transition rule; the special value HEADS becomes <em>λ</em>, and the special value TAILS becomes 1−<em>λ</em>.)  Now, each time multiple equations have the same left-hand side, combine them into one equation with the same left-hand side, but with the sum of their right-hand sides.  Then, for every variable of the form <em>α</em><sub><em>a</em>,<em>b</em>,<em>c</em></sub> not yet present in the system, include the equation <em>α</em><sub><em>a</em>,<em>b</em>,<em>c</em></sub> = 0.  Then, for each final state <em>fs</em> that returns 1, solve the system for the variable <em>α</em><sub>START,EMPTY,<em>fs</em></sub> (where START is the automaton’s starting state) to get a solution (a function) that maps the open interval (0, 1) to itself. (Each solve can produce multiple solutions, but only one of them will map that open interval to itself assuming every <em>p</em> is either HEADS or TAILS.) Finally, add all the solutions to get <em>f</em>(<em>λ</em>).</p>
    </li>
    <li>
      <p>Assume there is a pushdown automaton (<em>F</em>) that follows Definition 1 except it uses a set of <em>N</em> input letters (and not simply HEADS or TAILS), accepts an input word if the stack is empty, and rejects the word if the machine reaches a configuration without a transition rule.  Then a pushdown automaton in the full sense of Definition 1 (<em>G</em>) can be built.  In essence:</p>
      <ol>
        <li>Add a new FAILURE state, which when reached, pops all symbols from the stack.</li>
        <li>For each pair (<em>state</em>, <em>stacksymbol</em>) for <em>F</em>, add a set of rules that generate one of the input letters (each letter <em>i</em> generated with probability <em>f</em><sub> <em>i</em></sub>(<em>λ</em>), which must be a function in <strong>PDA</strong>), then use the generated letter to perform the transition stated in the corresponding rule for <em>F</em>.  If there is no such transition, transition to the FAILURE state instead.</li>
        <li>When the stack is empty, output 0 if <em>G</em> is in the FAILURE state, or 1 otherwise.</li>
      </ol>

      <p>Then <em>G</em> returns 1 with the same probability as <em>F</em> accepts an input word with letters randomly generated as in the second step.  Also, one of the <em>N</em> letters can be a so-called “end-of-string” symbol, so that a pushdown automaton can be built that accepts “empty strings”; an example is Elder et al. (2015)<sup id="fnref:43" role="doc-noteref"><a href="#fn:43" class="footnote" rel="footnote">43</a></sup>.</p>
    </li>
  </ol>
</blockquote>

<p><strong>Proposition 6:</strong> <em>If a full-domain pushdown automaton can generate a distribution of words with the same letter, there is a full-domain pushdown automaton that can generate a distribution of such words conditioned on—</em></p>

<ol>
  <li><em>a finite set of word lengths, or</em></li>
  <li><em>a periodic infinite set of word lengths.</em></li>
</ol>

<p>One example of a finite set of word lengths is {1, 3, 5, 6}, where only words of length 1, 3, 5, or 6 are allowed.  A <em>periodic infinite set</em> is defined by a finite set of integers such as {1}, as well as an integer modulus such as 2, so that in this example, all integers congruent to 1 modulo 2 (that is, all odd integers) are allowed word lengths and belong to the set.</p>

<p><em>Proof Sketch:</em></p>

<ol>
  <li>
    <p>As in Lemma 1A, assume that the automaton stops when it pops EMPTY from the stack.  Let <em>S</em> be the finite set (for example, {1, 3, 5, 6}), and let <em>M</em> be the maximum value in the finite set.  For each integer <em>i</em> in [0, <em>M</em>], make a copy of the automaton and append the integer <em>i</em> to the name of each of its states.  Combine the copies into a new automaton <em>F</em>, and let its start state be the start state for copy 0.  Now, whenever <em>F</em> generates a letter, instead of transitioning to the next state after the letter-generating operation (see Proposition 4), transition to the corresponding state for the next copy (for example, if the operation would transition to copy 2’s version of “XYZ”, namely “2_XYZ”, transition to “3_XYZ” instead), or if the last copy is reached, transition to the last copy’s FAILURE state.  If <em>F</em> would transition to a failure state corresponding to a copy not in <em>S</em> (for example, “0_FAILURE”, “2_FAILURE”, “3_FAILURE” in this example), first all symbols other than EMPTY are popped from the stack and then <em>F</em> transitions to its start state (this is a so-called “rejection” operation).  Now, all the final states (except FAILURE states) for the copies corresponding to the values in <em>S</em> (for example, copies 1, 3, 5, 6 in the example) are treated as returning 1, and all other states are treated as returning 0.</p>
  </li>
  <li>
    <p>Follow (1), except as follows: (A) <em>M</em> is equal to the integer modulus minus 1.  (B) For the last copy of the automaton, instead of transitioning to the next state after the letter-generating operation (see Proposition 4), transition to the corresponding state for copy 0 of the automaton.  □</p>
  </li>
</ol>

<p><strong>Proposition 7:</strong> <em>Every constant function equal to a quadratic irrational number between 0 and 1 is in class <strong>PDA</strong>.</em></p>

<p>A <em>continued fraction</em> is one way to write a real number.  For purposes of the following proof, every real number greater than 0 and less than 1 has the following <em>continued fraction expansion</em>: 0 + 1 / (<em>a</em>[1] + 1 / (<em>a</em>[2] + 1 / (<em>a</em>[3] + … ))), where each <em>a</em>[<em>i</em>], a <em>partial denominator</em>, is an integer greater than 0.  A <em>quadratic irrational number</em> is an irrational number that can be written as (<em>b</em>+sqrt(<em>c</em>))/<em>d</em>, where <em>b</em>, <em>c</em>, and <em>d</em> are rational numbers.</p>

<p><em>Proof:</em>  By Lagrange’s continued fraction theorem, every quadratic irrational number has a continued fraction expansion that is eventually periodic; the expansion can be described using a finite number of partial denominators, the last “few” of which repeat forever.  The following example describes a periodic continued fraction expansion: [0; 1, 2, (5, 4, 3)], which is the same as [0; 1, 2, 5, 4, 3, 5, 4, 3, 5, 4, 3, …].  In this example, the partial denominators are the numbers after the semicolon; the size of the period (<code>(5, 4, 3)</code>) is 3; and the size of the non-period (<code>1, 2</code>) is 2.</p>

<p>Given a periodic expansion, and with the aid of an algorithm for simulating <a href="https://peteroupc.github.io/bernoulli.html#Continued_Fractions"><strong>continued fractions</strong></a>, a recursive Markov chain for the expansion (Etessami and Yannakakis 2009)<sup id="fnref:39:1" role="doc-noteref"><a href="#fn:39" class="footnote" rel="footnote">39</a></sup> can be described as follows.  The chain’s components are all built on the following template.  The template component has one entry E, one inner node N, one box, and two exits X0 and X1.  The box has one <em>call port</em> as well as two <em>return ports</em> B0 and B1.</p>

<ul>
  <li>From E: Go to N with probability <em>x</em>, or to the box’s call port with probability 1 − <em>x</em>.</li>
  <li>From N: Go to X1 with probability <em>y</em>, or to X0 with probability 1 − <em>y</em>.</li>
  <li>From B0: Go to E with probability 1.</li>
  <li>From B1: Go to X0 with probability 1.</li>
</ul>

<p>Let <em>p</em> be the period size, and let <em>n</em> be the non-period size.  Now the recursive Markov chain to be built has <em>n</em>+<em>p</em> components:</p>

<ul>
  <li>For each <em>i</em> in [1, <em>n</em>+1], there is a component labeled <em>i</em>.  It is the same as the template component, except <em>x</em> = <em>a</em>[<em>i</em>]/(1 + <em>a</em>[<em>i</em>]), and <em>y</em> = 1/<em>a</em>[<em>i</em>].  The component’s single box goes to the component labeled <em>i</em>+1, <em>except</em> that for component <em>n</em>+<em>p</em>, the component’s single box goes to the component labeled <em>n</em>+1.</li>
</ul>

<p>According to Etessami and Yannakakis (2009)<sup id="fnref:39:2" role="doc-noteref"><a href="#fn:39" class="footnote" rel="footnote">39</a></sup>, the recursive Markov chain can be translated to a pushdown automaton of the kind used in this section. Now all that’s left is to argue that the recursive Markov chain terminates with probability 1.  For every component in the chain, it goes from its entry to its box with probability 1/2 or less (because each partial numerator must be 1 or greater).  Thus, the component recurses with no greater probability than not, and there are otherwise no probability-1 loops in each component, so the overall chain terminates with probability 1. □</p>

<p><strong>Lemma 1:</strong> <em>The square root function sqrt(λ) is in class <strong>PDA</strong>.</em></p>

<p><em>Proof:</em> See Mossel and Peres (2005)<sup id="fnref:34:8" role="doc-noteref"><a href="#fn:34" class="footnote" rel="footnote">34</a></sup>. □</p>

<p><strong>Corollary 1:</strong> <em>The function f(λ) = λ<sup>m/(2<sup>n</sup>)</sup>, where n ≥ 1 is an integer and where m ≥ 1 is an integer, is in class <strong>PDA</strong>.</em></p>

<p><em>Proof:</em> Start with the case <em>m</em>=1.  If <em>n</em> is 1, write <em>f</em> as sqrt(<em>λ</em>); if <em>n</em> is 2, write <em>f</em> as (sqrt∘sqrt)(<em>λ</em>); and for general <em>n</em>, write <em>f</em> as (sqrt∘sqrt∘…∘sqrt)(<em>λ</em>), with <em>n</em> instances of sqrt.  Because this is a composition and sqrt can be simulated by a full-domain pushdown automaton, so can <em>f</em>.</p>

<p>For general <em>m</em> and <em>n</em>, write <em>f</em> as ((sqrt∘sqrt∘…∘sqrt)(<em>λ</em>))<sup><em>m</em></sup>, with <em>n</em> instances of sqrt.  This involves doing <em>m</em> multiplications of sqrt∘sqrt∘…∘sqrt, and because this is an integer power of a function that can be simulated by a full-domain pushdown automaton, so can <em>f</em>.</p>

<p>Moreover, <em>f</em> is in class <strong>PDA</strong> by Theorem 1.2 of (Mossel and Peres 2005)<sup id="fnref:34:9" role="doc-noteref"><a href="#fn:34" class="footnote" rel="footnote">34</a></sup> because the machine is a full-domain pushdown automaton. □</p>

<p><a id="Finite_State_and_Pushdown_Generators"></a></p>

<h4 id="finite-state-and-pushdown-generators">Finite-State and Pushdown Generators</h4>

<p>Another interesting class of machines (called <em>pushdown generators</em> here) are similar to pushdown automata (see above), with the following exceptions:</p>

<ol>
  <li>Each transition rule can also, optionally, output a base-_N_ digit in its right-hand side.  An example is: (<em>state</em>, <em>flip</em>, <em>sy</em>) → (<em>digit</em>, <em>state2</em>, {<em>sy2</em>}).</li>
  <li>The machine must output infinitely many digits if allowed to run forever.</li>
  <li>Rules that would pop the last symbol from the stack are not allowed.</li>
</ol>

<p>The “output” of the machine is now a real number <em>X</em> in the form of the base-_N_ digit expansion <code>0.dddddd...</code>, where <code>dddddd...</code> are the digits produced by the machine from left to right.  In the rest of this section:</p>

<ul>
  <li><code>CDF(z)</code> is the cumulative distribution function of <em>X</em>, or the probability that <em>X</em> is <em>z</em> or less.</li>
  <li><code>PDF(z)</code> is the probability density function of <em>X</em>, or the derivative of <code>CDF(z)</code>, or the relative probability of choosing a number “close” to <em>z</em> at random.</li>
</ul>

<p>A <em>finite-state generator</em> (Knuth and Yao 1976)<sup id="fnref:33:1" role="doc-noteref"><a href="#fn:33" class="footnote" rel="footnote">33</a></sup> is the special case where the probability of heads is 1/2, each digit is either 0 or 1, rules can’t push stack symbols, and only one stack symbol is used.  Then if <code>PDF(z)</code> has infinitely many derivatives on the open interval (0, 1), it must be a polynomial with rational Bernstein coefficients and satisfy <code>PDF(z) &gt; 0</code> whenever 0 ≤ <code>z</code> ≤ 1 is irrational (Vatan 2001)<sup id="fnref:44" role="doc-noteref"><a href="#fn:44" class="footnote" rel="footnote">44</a></sup>, (Kindler and Romik 2004)<sup id="fnref:45" role="doc-noteref"><a href="#fn:45" class="footnote" rel="footnote">45</a></sup>, and it can be shown that the expected value (mean or “long-run average”) of <em>X</em> must be a rational number. <sup id="fnref:46" role="doc-noteref"><a href="#fn:46" class="footnote" rel="footnote">46</a></sup></p>

<p><strong>Proposition 8.</strong> <em>Suppose a finite-state generator can generate a probability distribution that takes on finitely many values.  Then:</em></p>

<ol>
  <li><em>Each value occurs with a rational probability.</em></li>
  <li><em>Each value is either rational or transcendental.</em></li>
</ol>

<p>A real number is <em>transcendental</em> if it can’t be a root of a nonzero polynomial with integer “power” coefficients.  Thus, part 2 means, for example, that irrational, non-transcendental numbers such as 1/sqrt(2) and the golden ratio minus 1 can’t be generated exactly.</p>

<p>Proving this proposition involves the following lemma, which shows that a finite-state generator is related to a machine with a one-way read-only input and a one-way write-only output:</p>

<p><strong>Lemma 2.</strong> <em>A finite-state generator can fit the model of a one-way transducer-like k-machine (as defined in Adamczewski et al. (2020)<sup id="fnref:47" role="doc-noteref"><a href="#fn:47" class="footnote" rel="footnote">47</a></sup> section 5.3), for some k equal to 2 or greater.</em></p>

<p><em>Proof Sketch:</em> There are two cases.</p>

<p>Case 1: If every transition rule of the generator outputs a digit, then <em>k</em> is the number of unique inputs among the generator’s transition rules (usually, there are two unique inputs, namely HEADS and TAILS), and the model of a finite-state generator is modified as follows:</p>

<ol>
  <li>A <em>configuration</em> of the finite-state generator consists of its current state together with either the last coin flip result or, if the coin wasn’t flipped yet, the empty string.</li>
  <li>The <em>output function</em> takes a configuration described above and returns a digit.  If the coin wasn’t flipped yet, the function returns an arbitrary digit (which is not used in proposition 4.6 of the Adamczewski paper).</li>
</ol>

<p>Case 2: If at least one transition rule does not output a digit, then the finite-state generator can be transformed to a machine where HEADS/TAILS is replaced with 50% probabilities, then transformed to an equivalent machine whose rules always output one or more digits, as claimed in Lemma 5.2 of Vatan (2001)<sup id="fnref:44:1" role="doc-noteref"><a href="#fn:44" class="footnote" rel="footnote">44</a></sup>.  In case the resulting generator has rules that output more than one digit, additional states and rules can be added so that the generator’s rules output only one digit as desired.  Now at this point the generator’s probabilities will be rational numbers. Now transform the generator from probabilities to inputs of size <em>k</em>, where <em>k</em> is the product of those probabilities, by adding additional rules as desired.  □</p>

<p><em>Proof of Proposition 8:</em> Let <em>n</em> be an integer greater than 0. Take a finite-state generator that starts at state START and branches to one of <em>n</em> finite-state generators (sub-generators) with some probability, which must be rational because the overall generator is a finite-state machine (Icard 2020, Proposition 13)<sup id="fnref:37:2" role="doc-noteref"><a href="#fn:37" class="footnote" rel="footnote">37</a></sup>.  The branching process outputs no digit, and part 3 of the proposition follows from Corollary 9 of Icard (2020)<sup id="fnref:37:3" role="doc-noteref"><a href="#fn:37" class="footnote" rel="footnote">37</a></sup>.  The <em>n</em> sub-generators are special; each of them generates the binary expansion of a single real number in the closed unit interval with probability 1.</p>

<p>To prove part 2 of the proposition, translate an arbitrary finite-state generator to a machine described in Lemma 2.  Once that is done, all that must be shown is that there are two different non-empty sequences of coin flips that end up at the same configuration. This is easy using the pigeonhole principle, since the finite-state generator has a finite number of configurations. Thus, by propositions 5.11, 4.6, and AB of Adamczewski et al. (2020)<sup id="fnref:47:1" role="doc-noteref"><a href="#fn:47" class="footnote" rel="footnote">47</a></sup>, the generator can generate a real number’s binary expansion only if that number is rational or transcendental (see also Cobham (1968)<sup id="fnref:48" role="doc-noteref"><a href="#fn:48" class="footnote" rel="footnote">48</a></sup>; Adamczewski and Bugeaud (2007)<sup id="fnref:49" role="doc-noteref"><a href="#fn:49" class="footnote" rel="footnote">49</a></sup>).  □</p>

<p><strong>Proposition 9.</strong> <em>If the distribution function generated by a finite-state generator is continuous and algebraic on the open interval (0, 1), then that function is a piecewise polynomial function on that interval.</em></p>

<p>The proof follows from combining Kindler and Romik (2004, Theorem 2)<sup id="fnref:45:1" role="doc-noteref"><a href="#fn:45" class="footnote" rel="footnote">45</a></sup> and Knuth and Yao (1976)<sup id="fnref:33:2" role="doc-noteref"><a href="#fn:33" class="footnote" rel="footnote">33</a></sup> with Richman (2012)<sup id="fnref:50" role="doc-noteref"><a href="#fn:50" class="footnote" rel="footnote">50</a></sup>, who proved that a continuous algebraic function on an open interval is piecewise analytic; that is, each piece is analytic at every point except possibly at the endpoints.</p>

<p><a id="License"></a></p>

<h2 id="license">License</h2>

<p>Any copyright to this page is released to the Public Domain.  In case this is not possible, this page is also licensed under <a href="https://creativecommons.org/publicdomain/zero/1.0/"><strong>Creative Commons Zero</strong></a>.</p>
<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>Nacu, Şerban, and Yuval Peres. “<a href="https://projecteuclid.org/euclid.aoap/1106922322"><strong>Fast simulation of new coins from old</strong></a>”, The Annals of Applied Probability 15, no. 1A (2005): 93-115. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:1:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a> <a href="#fnref:1:2" class="reversefootnote" role="doc-backlink">&#8617;<sup>3</sup></a> <a href="#fnref:1:3" class="reversefootnote" role="doc-backlink">&#8617;<sup>4</sup></a> <a href="#fnref:1:4" class="reversefootnote" role="doc-backlink">&#8617;<sup>5</sup></a> <a href="#fnref:1:5" class="reversefootnote" role="doc-backlink">&#8617;<sup>6</sup></a> <a href="#fnref:1:6" class="reversefootnote" role="doc-backlink">&#8617;<sup>7</sup></a> <a href="#fnref:1:7" class="reversefootnote" role="doc-backlink">&#8617;<sup>8</sup></a> <a href="#fnref:1:8" class="reversefootnote" role="doc-backlink">&#8617;<sup>9</sup></a> <a href="#fnref:1:9" class="reversefootnote" role="doc-backlink">&#8617;<sup>10</sup></a> <a href="#fnref:1:10" class="reversefootnote" role="doc-backlink">&#8617;<sup>11</sup></a> <a href="#fnref:1:11" class="reversefootnote" role="doc-backlink">&#8617;<sup>12</sup></a> <a href="#fnref:1:12" class="reversefootnote" role="doc-backlink">&#8617;<sup>13</sup></a> <a href="#fnref:1:13" class="reversefootnote" role="doc-backlink">&#8617;<sup>14</sup></a> <a href="#fnref:1:14" class="reversefootnote" role="doc-backlink">&#8617;<sup>15</sup></a> <a href="#fnref:1:15" class="reversefootnote" role="doc-backlink">&#8617;<sup>16</sup></a> <a href="#fnref:1:16" class="reversefootnote" role="doc-backlink">&#8617;<sup>17</sup></a> <a href="#fnref:1:17" class="reversefootnote" role="doc-backlink">&#8617;<sup>18</sup></a> <a href="#fnref:1:18" class="reversefootnote" role="doc-backlink">&#8617;<sup>19</sup></a> <a href="#fnref:1:19" class="reversefootnote" role="doc-backlink">&#8617;<sup>20</sup></a> <a href="#fnref:1:20" class="reversefootnote" role="doc-backlink">&#8617;<sup>21</sup></a> <a href="#fnref:1:21" class="reversefootnote" role="doc-backlink">&#8617;<sup>22</sup></a> <a href="#fnref:1:22" class="reversefootnote" role="doc-backlink">&#8617;<sup>23</sup></a> <a href="#fnref:1:23" class="reversefootnote" role="doc-backlink">&#8617;<sup>24</sup></a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>Thomas, A.C., Blanchet, J., “<a href="https://arxiv.org/abs/1106.2508v3"><strong>A Practical Implementation of the Bernoulli Factory</strong></a>”, arXiv:1106.2508v3  [stat.AP], 2012. <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>Thomas and Blanchet (2012) dealt with building polynomials that approach piecewise linear functions “fast”.  Their strategy for $f(\lambda)=\min(mult\times\lambda, 1-2\varepsilon)$ is to first compute a low-degree polynomial $P$ satisfying $P(0)=0$ and otherwise greater than $f$, and then compute further polynomials of increasing degree that each come between $f$ and the previous polynomial and satisfy the consistency requirement. These polynomials approach $f$ rapidly when $\lambda$ is near 0, and extremely slowly when $\lambda$ is near 1. In their strategy, <strong>fbelow(<em>n</em>, <em>k</em>)</strong> is min((<em>k</em>/<em>n</em>)*<em>mult</em>, 1−<em>ε</em>), and <strong>fabove(<em>n</em>, <em>k</em>)</strong> is min((<em>k</em>/<em>n</em>)*<em>y</em>/<em>x</em>,<em>y</em>), where:<br /><em>x</em> = −((<em>y</em>−(1−<em>ε</em>))/<em>ε</em>)<sup>5</sup>/<em>mult</em> + <em>y</em>/<em>mult</em>. (This formula doesn’t appear in their paper, but in the <a href="https://github.com/acthomasca/rberfac/blob/main/rberfac-public-2.R"><strong>supplemental source code</strong></a> uploaded by A. C. Thomas at my request.)<br /><em>y</em> satisfies 0&lt;<em>y</em>&lt;1 and is chosen so that the degree-_n_ polynomial is between $f$ and the previous polynomial and meets the consistency requirement. The supplemental source code seems to choose <em>y</em> in an <em>ad hoc</em> manner.<br /><em>n</em> is the polynomial’s degree. <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p>In Nacu and Peres (2005), the following polynomial sequences were suggested to simulate $\min(2\lambda, 1-2\varepsilon)$ (using the algorithms from the section “General Factory Functions” in “<a href="https://peteroupc.github.io/bernoulli.html"><strong>Bernoulli Factory Algorithms</strong></a>”), provided $\varepsilon \lt 1/8$, where <em>n</em> is a power of 2.  However, with these sequences, each simulation will require an extraordinary number of input coin flips. <strong>fbelow(<em>n</em>, <em>k</em>)</strong> = $\min(2(k/n), 1-2\varepsilon)$. <strong>fabove(<em>n</em>, <em>k</em>)</strong> = $\min(2(k/n), 1-2\varepsilon)$ + $\frac{2\times\max(0, k/n+3\varepsilon - 1/2)}{\varepsilon(2-\sqrt{2})}$ $\sqrt{2/n}$ + $\frac{72\times\max(0,k/n-1/9)}{1-\exp(-2\times\varepsilon^2)} \exp(-2n\times\varepsilon^2)$. <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:5" role="doc-endnote">
      <p>In this case, an algorithm to simulate <code>High</code>(<em>λ</em>) is: Flip the input coin <em>n</em> times or until a flip returns 1, whichever comes first, then output the last coin flip result. <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:6" role="doc-endnote">
      <p>With this infinite sum and these upper bounds, Lemma 4 of Holtz et al. (2011) says that a Bernoulli factory algorithm for $f(\lambda)$ is possible. <a href="#fnref:6" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:7" role="doc-endnote">
      <p>Goyal, V. and Sigman, K., 2012. On simulating a class of Bernstein polynomials. ACM Transactions on Modeling and Computer Simulation (TOMACS), 22(2), pp.1-5. <a href="#fnref:7" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:7:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a> <a href="#fnref:7:2" class="reversefootnote" role="doc-backlink">&#8617;<sup>3</sup></a> <a href="#fnref:7:3" class="reversefootnote" role="doc-backlink">&#8617;<sup>4</sup></a> <a href="#fnref:7:4" class="reversefootnote" role="doc-backlink">&#8617;<sup>5</sup></a></p>
    </li>
    <li id="fn:8" role="doc-endnote">
      <p>G.G. Lorentz, “Inequalities and saturation classes for Bernstein polynomials”, 1963. <a href="#fnref:8" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:9" role="doc-endnote">
      <p>Temple, W.B., “Steltjes integral representation of convex functions”, 1954. <a href="#fnref:9" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:10" role="doc-endnote">
      <p>Moldovan, E., “Observations sur la suite des polynômes de S. N. Bernstein d’une fonction continue”, 1962. <a href="#fnref:10" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:11" role="doc-endnote">
      <p>Farouki, Rida T., and V. T. Rajan. “<a href="https://www.sciencedirect.com/science/article/pii/0167839688900167"><strong>Algorithms for polynomials in Bernstein form</strong></a>”. Computer Aided Geometric Design 5, no. 1 (1988): 1-26. <a href="#fnref:11" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:12" role="doc-endnote">
      <p>Henderson, S.G., Glynn, P.W., “Nonexistence of a class of variate generation schemes”, <em>Operations Research Letters</em> 31 (2003). <a href="#fnref:12" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:13" role="doc-endnote">
      <p>Flajolet, P., Pelletier, M., Soria, M., “<a href="https://arxiv.org/abs/0906.5560"><strong>On Buffon machines and numbers</strong></a>”, arXiv:0906.5560 [math.PR], 2010. <a href="#fnref:13" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:13:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a></p>
    </li>
    <li id="fn:14" role="doc-endnote">
      <p>Mendo, Luis. “An asymptotically optimal Bernoulli factory for certain functions that can be expressed as power series.” Stochastic Processes and their Applications 129, no. 11 (2019): 4366-4384. <a href="#fnref:14" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:14:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a> <a href="#fnref:14:2" class="reversefootnote" role="doc-backlink">&#8617;<sup>3</sup></a></p>
    </li>
    <li id="fn:15" role="doc-endnote">
      <p>Holtz, O., Nazarov, F., Peres, Y., “<a href="https://link.springer.com/content/pdf/10.1007/s00365-010-9108-5.pdf"><strong>New Coins from Old, Smoothly</strong></a>”, <em>Constructive Approximation</em> 33 (2011). <a href="#fnref:15" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:15:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a></p>
    </li>
    <li id="fn:16" role="doc-endnote">
      <p>This function’s second derivative’s absolute value can be plotted using the SymPy library as follows: <code>plot(diff(Abs(exp(-x)),(x,2)),(x,0,1))</code>.  In this plot, the maximum is 1, the same as the first derivative’s Lipschitz constant. <a href="#fnref:16" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:17" role="doc-endnote">
      <p>Wästlund, J., “<a href="http://www.math.chalmers.se/~wastlund/coinFlip.pdf"><strong>Functions arising by coin flipping</strong></a>”, 1999. <a href="#fnref:17" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:17:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a></p>
    </li>
    <li id="fn:18" role="doc-endnote">
      <p>The coin-flipping degree is very similar to the so-called <em>Bernstein degree</em> or <em>Lorentz degree</em>, which is the smallest integer $n$ such that $p$’s Bernstein coefficients of degree $n$ are all non-negative, assuming that $p$ is non-negative. <a href="#fnref:18" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:19" role="doc-endnote">
      <p>Powers, V., Reznick, B., “<a href="https://www.sciencedirect.com/science/article/pii/S0022404900001559"><strong>A new bound for Pólya’s Theorem with applications to polynomials positive on polyhedra</strong></a>”, <em>Journal of Pure and Applied Algebra</em> 164 (24 October 2001). <a href="#fnref:19" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:19:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a></p>
    </li>
    <li id="fn:20" role="doc-endnote">
      <p>Mok, H-N., To, W-K., “<a href="https://doi.org/10.1016/j.jco.2008.01.003"><strong>Effective Pólya semi-positivity for non-negative polynomials on the simplex</strong></a>”, <em>Journal of Complexity</em> 24 (2008). <a href="#fnref:20" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:20:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a> <a href="#fnref:20:2" class="reversefootnote" role="doc-backlink">&#8617;<sup>3</sup></a></p>
    </li>
    <li id="fn:21" role="doc-endnote">
      <p>S. Ray, P.S.V. Nataraj, “<a href="https://interval.louisiana.edu/reliable-computing-journal/volume-17/reliable-computing-17-pp-40-71.pdf"><strong>A Matrix Method for Efficient Computation of Bernstein Coefficients</strong></a>”, Reliable Computing 17(1), 2012. <a href="#fnref:21" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:22" role="doc-endnote">
      <p>Keane,  M.  S.,  and  O’Brien,  G.  L., “A Bernoulli factory”, <em>ACM Transactions on Modeling and Computer Simulation</em> 4(2), 1994. <a href="#fnref:22" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:22:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a></p>
    </li>
    <li id="fn:23" role="doc-endnote">
      <p>Micchelli, Charles. “The saturation class and iterates of the Bernstein polynomials.” Journal of Approximation Theory 8, no. 1 (1973): 1-18. <a href="#fnref:23" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:24" role="doc-endnote">
      <p>Gal, S.G., “Calculus of the modulus of continuity for nonconcave functions and applications”, <em>Calcolo</em> 27 (1990) <a href="#fnref:24" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:24:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a></p>
    </li>
    <li id="fn:25" role="doc-endnote">
      <p>Gal, S.G., 1995. Properties of the modulus of continuity for monotonous convex functions and applications. <em>International Journal of Mathematics and Mathematical Sciences</em> 18(3), pp.443-446. <a href="#fnref:25" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:25:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a></p>
    </li>
    <li id="fn:26" role="doc-endnote">
      <p>Anastassiou, G.A., Gal, S.G., <em>Approximation Theory: Moduli of Continuity and Global Smoothness Preservation</em>, Birkhäuser, 2012. <a href="#fnref:26" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:27" role="doc-endnote">
      <p>Pascu, M.N., Pascu, N.R., Tripşa, F., “<a href="https://arxiv.org/abs/1710.08818"><strong>A new Bernstein-type operator based on Pólya’s urn model with negative replacement</strong></a>”, arXiv:1710.08818 [math.CA], 2017. <a href="#fnref:27" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:28" role="doc-endnote">
      <p>Strukov, L.I., Timan, A.F., “Mathematical expectation of continuous functions of random variables. Smoothness and variance”, <em>Siberian Mathematical Journal</em> 18 (1977). <a href="#fnref:28" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:29" role="doc-endnote">
      <p>choose(<em>n</em>, <em>k</em>) = (1*2*3*…*<em>n</em>)/((1*…*<em>k</em>)*(1*…*(<em>n</em>−<em>k</em>))) =  <em>n</em>!/(<em>k</em>! * (<em>n</em> − <em>k</em>)!) $={n \choose k}$ is a <em>binomial coefficient</em>, or the number of ways to choose <em>k</em> out of <em>n</em> labeled items.  It can be calculated, for example, by calculating <em>i</em>/(<em>n</em>−<em>i</em>+1) for each integer <em>i</em> satisfying <em>n</em>−<em>k</em>+1 ≤ <em>i</em> ≤ <em>n</em>, then multiplying the results (Yannis Manolopoulos. 2002. “Binomial coefficient computation: recursion or iteration?”, SIGCSE Bull. 34, 4 (December 2002), 65–67. DOI: <a href="https://doi.org/10.1145/820127.820168"><strong>https://doi.org/10.1145/820127.820168</strong></a>).  For every <em>m</em>&gt;0, choose(<em>m</em>, 0) = choose(<em>m</em>, <em>m</em>) = 1 and choose(<em>m</em>, 1) = choose(<em>m</em>, <em>m</em>−1) = <em>m</em>; also, in this document, choose(<em>n</em>, <em>k</em>) is 0 when <em>k</em> is less than 0 or greater than <em>n</em>.<br /><em>n</em>! = 1*2*3*…*<em>n</em> is also known as <em>n</em> factorial; in this document, (0!) = 1. <a href="#fnref:29" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:30" role="doc-endnote">
      <p>Kantorovich, L.V., “Some remarks on the approximation of functions by means of polynomials with integer coefficients”, 1931. <a href="#fnref:30" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:31" role="doc-endnote">
      <p>von Neumann, J., “Various techniques used in connection with random digits”, 1951. <a href="#fnref:31" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:32" role="doc-endnote">
      <p>Peres, Y., “<a href="https://projecteuclid.org/euclid.aos/1176348543"><strong>Iterating von Neumann’s procedure for extracting random bits</strong></a>”, Annals of Statistics 1992,20,1, p. 590-597. <a href="#fnref:32" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:32:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a></p>
    </li>
    <li id="fn:33" role="doc-endnote">
      <p>Knuth, Donald E. and Andrew Chi-Chih Yao. “The complexity of nonuniform random number generation”, in <em>Algorithms and Complexity: New Directions and Recent Results</em>, 1976. <a href="#fnref:33" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:33:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a> <a href="#fnref:33:2" class="reversefootnote" role="doc-backlink">&#8617;<sup>3</sup></a></p>
    </li>
    <li id="fn:34" role="doc-endnote">
      <p>Mossel, Elchanan, and Yuval Peres. New coins from old: computing with unknown bias. Combinatorica, 25(6), pp.707-724, 2005. <a href="#fnref:34" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:34:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a> <a href="#fnref:34:2" class="reversefootnote" role="doc-backlink">&#8617;<sup>3</sup></a> <a href="#fnref:34:3" class="reversefootnote" role="doc-backlink">&#8617;<sup>4</sup></a> <a href="#fnref:34:4" class="reversefootnote" role="doc-backlink">&#8617;<sup>5</sup></a> <a href="#fnref:34:5" class="reversefootnote" role="doc-backlink">&#8617;<sup>6</sup></a> <a href="#fnref:34:6" class="reversefootnote" role="doc-backlink">&#8617;<sup>7</sup></a> <a href="#fnref:34:7" class="reversefootnote" role="doc-backlink">&#8617;<sup>8</sup></a> <a href="#fnref:34:8" class="reversefootnote" role="doc-backlink">&#8617;<sup>9</sup></a> <a href="#fnref:34:9" class="reversefootnote" role="doc-backlink">&#8617;<sup>10</sup></a></p>
    </li>
    <li id="fn:35" role="doc-endnote">
      <p>S. Pae, “<a href="https://arxiv.org/abs/1602.06058v2"><strong>Binarization Trees and Random Number Generation</strong></a>”, arXiv:1602.06058v2 [cs.DS], 2018. <a href="#fnref:35" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:36" role="doc-endnote">
      <p>Banderier, C. And Drmota, M., 2015. Formulae and asymptotics for coefficients of algebraic functions. Combinatorics, Probability and Computing, 24(1), pp.1-53. <a href="#fnref:36" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:37" role="doc-endnote">
      <p>Icard, Thomas F., “Calibrating generative models: The probabilistic Chomsky–Schützenberger hierarchy”, <em>Journal of Mathematical Psychology</em> 95 (2020): 102308. <a href="#fnref:37" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:37:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a> <a href="#fnref:37:2" class="reversefootnote" role="doc-backlink">&#8617;<sup>3</sup></a> <a href="#fnref:37:3" class="reversefootnote" role="doc-backlink">&#8617;<sup>4</sup></a></p>
    </li>
    <li id="fn:38" role="doc-endnote">
      <p>Dughmi, Shaddin, Jason Hartline, Robert D. Kleinberg, and Rad Niazadeh. “Bernoulli Factories and Black-box Reductions in Mechanism Design.” Journal of the ACM (JACM) 68, no. 2 (2021): 1-30. <a href="#fnref:38" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:39" role="doc-endnote">
      <p>Etessami, K. and Yannakakis, M., “Recursive Markov chains, stochastic grammars, and monotone systems of nonlinear equations”, <em>Journal of the ACM</em> 56(1), pp.1-66, 2009. <a href="#fnref:39" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:39:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a> <a href="#fnref:39:2" class="reversefootnote" role="doc-backlink">&#8617;<sup>3</sup></a></p>
    </li>
    <li id="fn:40" role="doc-endnote">
      <p>Flajolet, P., Pelletier, M., Soria, M., “<a href="https://arxiv.org/abs/0906.5560"><strong>On Buffon machines and numbers</strong></a>”, arXiv:0906.5560  [math.PR], 2010 <a href="#fnref:40" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:40:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a> <a href="#fnref:40:2" class="reversefootnote" role="doc-backlink">&#8617;<sup>3</sup></a></p>
    </li>
    <li id="fn:41" role="doc-endnote">
      <p>Levy, H., <em>Stochastic dominance</em>, 1998. <a href="#fnref:41" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:42" role="doc-endnote">
      <p>Esparza, J., Kučera, A. and Mayr, R., 2004, July. Model checking probabilistic pushdown automata. In <em>Proceedings of the 19th Annual IEEE Symposium on Logic in Computer Science</em>, 2004. (pp. 12-21). IEEE. <a href="#fnref:42" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:43" role="doc-endnote">
      <p>Elder, Murray, Geoffrey Lee, and Andrew Rechnitzer. “Permutations generated by a depth 2 stack and an infinite stack in series are algebraic.” <em>Electronic Journal of Combinatorics</em> 22(1), 2015. <a href="#fnref:43" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:44" role="doc-endnote">
      <p>Vatan, F., “Distribution functions of probabilistic automata”, in <em>Proceedings of the thirty-third annual ACM symposium on Theory of computing (STOC ‘01)</em>, pp. 684-693, 2001. <a href="#fnref:44" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:44:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a></p>
    </li>
    <li id="fn:45" role="doc-endnote">
      <p>Kindler, Guy and D. Romik, “On distributions computable by random walks on graphs,” <em>SIAM Journal on Discrete Mathematics</em> 17 (2004): 624-633. <a href="#fnref:45" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:45:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a></p>
    </li>
    <li id="fn:46" role="doc-endnote">
      <p>Vatan (2001) claims that a finite-state generator has a continuous <code>CDF</code> (unless it produces a single value with probability 1), but this is not necessarily true if the generator has a state that outputs 0 forever. <a href="#fnref:46" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:47" role="doc-endnote">
      <p>Adamczewski, B., Cassaigne, J. and Le Gonidec, M., 2020. On the computational complexity of algebraic numbers: the Hartmanis–Stearns problem revisited. Transactions of the American Mathematical Society, 373(5), pp.3085-3115. <a href="#fnref:47" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:47:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a></p>
    </li>
    <li id="fn:48" role="doc-endnote">
      <p>Cobham, A., “On the Hartmanis-Stearns problem for a class of tag machines”, in <em>IEEE Conference Record of 1968 Ninth Annual Symposium on Switching and Automata Theory</em> 1968. <a href="#fnref:48" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:49" role="doc-endnote">
      <p>Adamczewski, B., Bugeaud, Y., “On the complexity of algebraic numbers I. Expansions in integer bases”, <em>Annals of Mathematics</em> 165 (2007). <a href="#fnref:49" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:50" role="doc-endnote">
      <p>Richman, F. (2012). Algebraic functions, calculus style. Communications in Algebra, 40(7), 2671-2683. <a href="#fnref:50" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>
</div><nav id="navigation"><ul>
<li><a href="/">Back to start site.</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io">This site's repository (source code)</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io/issues">Post an issue or comment</a></ul>

<div class="noprint">
<p>
<a href="//twitter.com/intent/tweet">Share via Twitter</a>, <a href="//www.facebook.com/sharer/sharer.php" id="sharer">Share via Facebook</a>
</p>
</div>
<p style='font-size:120%;font-weight:bold'><a href='https://peteroupc.github.io/bernsupp.pdf'>Download a PDF of this page</a></p></nav></body></html>
