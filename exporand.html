<!DOCTYPE html><html xmlns:dc="http://purl.org/dc/terms/" itemscope itemtype="http://schema.org/Article"><head><meta http-equiv=Content-Type content="text/html; charset=utf-8"><title>Partially-Sampled Random Numbers for Accurate Sampling of Continuous Distributions</title><meta name="citation_title" content="Partially-Sampled Random Numbers for Accurate Sampling of Continuous Distributions"><meta name="citation_pdf_url" content="https://peteroupc.github.io/exporand.pdf"><meta name="citation_url" content="https://peteroupc.github.io/exporand.html"><meta name="citation_date" content="2023/03/09"><meta name="citation_online_date" content="2023/03/09"><meta name="og:title" content="Partially-Sampled Random Numbers for Accurate Sampling of Continuous Distributions"><meta name="og:type" content="article"><meta name="og:url" content="https://peteroupc.github.io/exporand.html"><meta name="og:site_name" content="peteroupc.github.io"><meta name="twitter:title" content="Partially-Sampled Random Numbers for Accurate Sampling of Continuous Distributions"><meta name="author" content="Peter Occil"/><meta name="citation_author" content="Peter Occil"/><meta name="viewport" content="width=device-width"><link rel=stylesheet type="text/css" href="/style.css">
            <script type="text/x-mathjax-config"> MathJax.Hub.Config({"HTML-CSS": { availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, preferredFont: "TeX" },
                    tex2jax: { displayMath: [ ["$$","$$"], ["\\[", "\\]"] ], inlineMath: [ ["$", "$"], ["\\\\(","\\\\)"] ], processEscapes: true } });
            </script><script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"></script></head><body>  <div class="header">
<nav><p><a href="#navigation">Menu</a> - <a href="#top">Top</a> - <a href="/">Home</a></nav></div>
<div class="mainarea" id="top">
<h1>Partially-Sampled Random Numbers for Accurate Sampling of Continuous Distributions</h1>

<p><a href="mailto:poccil14@gmail.com"><strong>Peter Occil</strong></a></p>

<p><strong>2020 Mathematics Subject Classification:</strong> 68W20, 60-08, 60-04.</p>

<p><a id=Introduction></a></p>

<h2>Introduction</h2>

<p>This page introduces a Python implementation of <em>partially-sampled random numbers</em> (PSRNs).  Although structures for PSRNs were largely described before this work, this document unifies the concepts for these kinds of numbers from prior works and shows how they can be used to sample the beta distribution (for most sets of parameters), the exponential distribution (with an arbitrary rate parameter), and many other continuous distributions&mdash;</p>

<ul>
<li>while avoiding floating-point arithmetic, and</li>
<li>to an arbitrary precision and with user-specified error bounds (and thus in an &quot;exact&quot; manner in the sense defined in (Karney 2016)[^1]).</li>
</ul>

<p>For instance, these two points distinguish the beta sampler in this document from any other specially-designed beta sampler I am aware of.  As for the exponential distribution, there are papers that discuss generating exponential random variates using random bits (Flajolet and Saheb 1982)[^2], (Karney 2016)[^1], (Devroye and Gravel 2020)[^3], (Thomas and Luk 2008)[^4], but most if not all of them don&#39;t deal with generating exponential PSRNs using an arbitrary rate, not just 1.  (Habibizad Navin et al., 2010)[^5] is perhaps an exception; however the approach appears to involve pregenerated tables of digit probabilities.</p>

<p>The samplers discussed here also draw on work dealing with a construct called the <em>Bernoulli factory</em> (Keane and O&#39;Brien 1994)[^6] (Flajolet et al., 2010)[^7], which can simulate a new probability given a coin that shows heads with an unknown probability.  One important feature of Bernoulli factories is that they can simulate a given probability <em>exactly</em>, without having to calculate that probability manually, which is important if the probability can be an irrational number that no computer can compute exactly (such as <code>pow(p, 1/2)</code> or <code>exp(-2)</code>).</p>

<p>This page shows <a href="#Sampler_Code"><strong>Python code</strong></a> for these samplers.</p>

<p><a id=About_This_Document></a></p>

<h3>About This Document</h3>

<p><strong>This is an open-source document; for an updated version, see the</strong> <a href="https://github.com/peteroupc/peteroupc.github.io/raw/master/exporand.md"><strong>source code</strong></a> <strong>or its</strong> <a href="https://github.com/peteroupc/peteroupc.github.io/blob/master/exporand.md"><strong>rendering on GitHub</strong></a><strong>.  You can send comments on this document either on</strong> <a href="https://www.codeproject.com/Articles/5272482/Partially-Sampled-Random-Numbers-for-Accurate-Samp"><strong>CodeProject</strong></a> <strong>or on the</strong> <a href="https://github.com/peteroupc/peteroupc.github.io/issues"><strong>GitHub issues page</strong></a><strong>.</strong></p>

<p>My audience for this article is <strong>computer programmers with mathematics knowledge, but little or no familiarity with calculus</strong>.</p>

<p>I encourage readers to implement any of the algorithms given in this page, and report their implementation experiences.  In particular, <a href="https://github.com/peteroupc/peteroupc.github.io/issues/18"><strong>I seek comments on the following aspects</strong></a>:</p>

<ul>
<li>Are the algorithms in this article easy to implement? Is each algorithm written so that someone could write code for that algorithm after reading the article?</li>
<li>Does this article have errors that should be corrected?</li>
<li>Are there ways to make this article more useful to the target audience?</li>
</ul>

<p>Comments on other aspects of this document are welcome.</p>

<p><a id=Contents></a></p>

<h2>Contents</h2>

<ul>
<li><a href="#Introduction"><strong>Introduction</strong></a>

<ul>
<li><a href="#About_This_Document"><strong>About This Document</strong></a></li>
</ul></li>
<li><a href="#Contents"><strong>Contents</strong></a></li>
<li><a href="#About_the_Beta_Distribution"><strong>About the Beta Distribution</strong></a></li>
<li><a href="#About_the_Exponential_Distribution"><strong>About the Exponential Distribution</strong></a></li>
<li><a href="#About_Partially_Sampled_Random_Numbers"><strong>About Partially-Sampled Random Numbers</strong></a>

<ul>
<li><a href="#Uniform_Partially_Sampled_Random_Numbers"><strong>Uniform Partially-Sampled Random Numbers</strong></a></li>
<li><a href="#Exponential_Partially_Sampled_Random_Numbers"><strong>Exponential Partially-Sampled Random Numbers</strong></a></li>
<li><a href="#Other_Distributions"><strong>Other Distributions</strong></a></li>
<li><a href="#Properties"><strong>Properties</strong></a></li>
<li><a href="#Limitations"><strong>Limitations</strong></a></li>
<li><a href="#Relation_to_Constructive_Reals"><strong>Relation to Constructive Reals</strong></a></li>
</ul></li>
<li><a href="#Sampling_Uniform_and_Exponential_PSRNs"><strong>Sampling Uniform and Exponential PSRNs</strong></a>

<ul>
<li><a href="#Sampling_Uniform_PSRNs"><strong>Sampling Uniform PSRNs</strong></a></li>
<li><a href="#Sampling_E_rands"><strong>Sampling E-rands</strong></a></li>
</ul></li>
<li><a href="#Arithmetic_and_Comparisons_with_PSRNs"><strong>Arithmetic and Comparisons with PSRNs</strong></a>

<ul>
<li><a href="#Addition_and_Subtraction"><strong>Addition and Subtraction</strong></a></li>
<li><a href="#Multiplication"><strong>Multiplication</strong></a></li>
<li><a href="#Reciprocal_and_Division"><strong>Reciprocal and Division</strong></a></li>
<li><a href="#Using_the_Arithmetic_Algorithms"><strong>Using the Arithmetic Algorithms</strong></a></li>
<li><a href="#Comparisons"><strong>Comparisons</strong></a></li>
<li><a href="#Discussion"><strong>Discussion</strong></a></li>
</ul></li>
<li><a href="#Building_Blocks"><strong>Building Blocks</strong></a>

<ul>
<li><a href="#SampleGeometricBag"><strong>SampleGeometricBag</strong></a></li>
<li><a href="#FillGeometricBag"><strong>FillGeometricBag</strong></a></li>
<li><a href="#kthsmallest"><strong>kthsmallest</strong></a></li>
<li><a href="#Power_of_Uniform_Sub_Algorithm"><strong>Power-of-Uniform Sub-Algorithm</strong></a></li>
</ul></li>
<li><a href="#Algorithms_for_the_Beta_and_Exponential_Distributions"><strong>Algorithms for the Beta and Exponential Distributions</strong></a>

<ul>
<li><a href="#Beta_Distribution"><strong>Beta Distribution</strong></a></li>
<li><a href="#Exponential_Distribution"><strong>Exponential Distribution</strong></a></li>
</ul></li>
<li><a href="#Sampler_Code"><strong>Sampler Code</strong></a></li>
<li><a href="#Correctness_Testing"><strong>Correctness Testing</strong></a>

<ul>
<li><a href="#Beta_Sampler"><strong>Beta Sampler</strong></a></li>
<li><a href="#ExpRandFill"><strong>ExpRandFill</strong></a></li>
<li><a href="#ExpRandLess"><strong>ExpRandLess</strong></a></li>
</ul></li>
<li><a href="#Accurate_Simulation_of_Continuous_Distributions_Supported_on_0_to_1"><strong>Accurate Simulation of Continuous Distributions Supported on 0 to 1</strong></a>

<ul>
<li><a href="#An_Example_The_Continuous_Bernoulli_Distribution"><strong>An Example: The Continuous Bernoulli Distribution</strong></a></li>
</ul></li>
<li><a href="#Complexity"><strong>Complexity</strong></a>

<ul>
<li><a href="#General_Principles"><strong>General Principles</strong></a></li>
<li><a href="#Complexity_of_Specific_Algorithms"><strong>Complexity of Specific Algorithms</strong></a></li>
</ul></li>
<li><a href="#Application_to_Weighted_Reservoir_Sampling"><strong>Application to Weighted Reservoir Sampling</strong></a></li>
<li><a href="#Acknowledgments"><strong>Acknowledgments</strong></a></li>
<li><a href="#Other_Documents"><strong>Other Documents</strong></a></li>
<li><a href="#Notes"><strong>Notes</strong></a></li>
<li><a href="#Appendix"><strong>Appendix</strong></a>

<ul>
<li><a href="#Equivalence_of_SampleGeometricBag_Algorithms"><strong>Equivalence of SampleGeometricBag Algorithms</strong></a></li>
<li><a href="#UniformMultiply_Algorithm"><strong>UniformMultiply Algorithm</strong></a></li>
<li><a href="#Uniform_of_Uniforms_Produces_a_Product_of_Uniforms"><strong>Uniform of Uniforms Produces a Product of Uniforms</strong></a></li>
<li><a href="#Oberhoff_s_Exact_Rejection_Sampling_Method"><strong>Oberhoff&#39;s &quot;Exact Rejection Sampling&quot; Method</strong></a></li>
<li><a href="#Setting_Digits_by_Digit_Probabilities"><strong>Setting Digits by Digit Probabilities</strong></a></li>
</ul></li>
<li><a href="#License"><strong>License</strong></a></li>
</ul>

<p><a id=About_the_Beta_Distribution></a></p>

<h2>About the Beta Distribution</h2>

<p>The <a href="https://en.wikipedia.org/wiki/Beta_distribution"><strong>beta distribution</strong></a> is a bounded-domain probability distribution; its two parameters, <code>alpha</code> and <code>beta</code>, are both greater than 0 and describe the distribution&#39;s shape.  Depending on <code>alpha</code> and <code>beta</code>, the shape can be a smooth peak or a smooth valley.  The beta distribution can take on values in the interval [0, 1].  Any value in this interval (<code>x</code>) can occur with a probability proportional to&mdash;</p>

<pre>pow(x, alpha - 1) * pow(1 - x, beta - 1).               (1)
</pre>

<p>Although <code>alpha</code> and <code>beta</code> can each be greater than 0, the sampler presented in this document only works if&mdash;</p>

<ul>
<li>both parameters are 1 or greater, or</li>
<li>in the case of base-2 numbers, one parameter equals 1 and the other is greater than 0.</li>
</ul>

<p><a id=About_the_Exponential_Distribution></a></p>

<h2>About the Exponential Distribution</h2>

<p>The <em>exponential distribution</em> takes a parameter <em>&lambda;</em>.  Informally speaking, a random variate that follows an exponential distribution is the number of units of time between one event and the next, and <em>&lambda;</em> is the expected average number of events per unit of time.  Usually, <em>&lambda;</em> is equal to 1.</p>

<p>An exponential random variate is commonly generated as follows: <code>-ln(1 - X) / lamda</code>, where <code>X</code> is a uniformly-distributed random real number in the interval (0, 1).  (This particular algorithm, however, is not robust in practice, for reasons that are outside the scope of this document, but see (Pedersen 2018)[^8].)  This page presents an alternative way to sample exponential random variates.</p>

<p><a id=About_Partially_Sampled_Random_Numbers></a></p>

<h2>About Partially-Sampled Random Numbers</h2>

<p>In this document, a <em>partially-sampled random number</em> (PSRN) is a data structure that stores a real number of unlimited precision, but whose contents are sampled only when necessary. PSRNs open the door to algorithms that sample a random variate that &quot;exactly&quot; follows a probability distribution, <em>with arbitrary precision</em>, and <em>without floating-point arithmetic</em> (see &quot;Properties&quot; later in this section).</p>

<p>PSRNs specified here consist of the following three things:</p>

<ul>
<li><p>A <em>fractional part</em> with an arbitrary number of digits.  This can be implemented as an array of digits or as a packed integer containing all the digits.  Some algorithms care whether those digits were <em>sampled</em> or <em>unsampled</em>; in that case, if a digit is unsampled, its unsampled status can be noted in a way that distinguishes it from sampled digits (for example, by using the <code>None</code> keyword in Python, or the number &minus;1, or by storing a separate bit array indicating which bits are sampled and unsampled).  The base in which all the digits are stored (such as base 10 for decimal or base 2 for binary) is arbitrary.  The fractional part&#39;s digits form a so-called <em>digit expansion</em> (for example, <em>binary expansion</em> in the case of binary or base-2 digits).  Digits beyond those stored in the fractional part are unsampled.</p>

<p>For example, if the fractional part stores the base-10 digits [1, 3, 5], in that order, then it represents a random variate in the interval [0.135, 0.136], reflecting the fact that the digits between 0.135 and 0.136 are unknown.</p></li>
<li>An optional <em>integer part</em> (more specifically, the integer part of the number&#39;s absolute value, that is, <code>floor(abs(x))</code>).</li>
<li>An optional <em>sign</em> (positive or negative).</li>
</ul>

<p>If the integer part is not stored, it&#39;s assumed to be 0.  If the sign is not stored, it&#39;s assumed to be positive.  For example, an implementation can care only about PSRNs in the interval [0, 1] by storing only a fractional part.</p>

<p>PSRNs ultimately represent a random variate between two other numbers; one of the variate&#39;s two bounds has the following form: sign * (integer part + fractional part), which is a lower bound if the PSRN is positive, or an upper bound if it&#39;s negative. For example, if the PSRN stores a positive sign, the integer 3, and the fractional part [3, 5, 6] (in base 10), then the PSRN represents a random variate in the interval [3.356, 3.357].  Here, one of the bounds is built using the PSRN&#39;s sign, integer part, and fractional part, and because the PSRN is positive, this is a lower bound.</p>

<p>This section specifies two kinds of PSRNs: uniform and exponential.</p>

<p><a id=Uniform_Partially_Sampled_Random_Numbers></a></p>

<h3>Uniform Partially-Sampled Random Numbers</h3>

<p>The most trivial example of a PSRN is that of the uniform distribution.</p>

<ul>
<li>Flajolet et al. (2010)[^7] use the term <em>geometric bag</em> to refer to a uniform PSRN in the interval [0, 1] that stores binary (base-2) digits, some of which may be unsampled.  In this case, the PSRN can consist of just a fractional part, which can be implemented as described earlier.</li>
<li>(Karney 2016)[^1] uses the term <em>u-rand</em> to refer to uniform PSRNs that can store a sign, integer part, and a fractional part, where the base of the fractional part&#39;s digits is arbitrary, but Karney&#39;s concept only contemplates sampling digits from left to right without any gaps.</li>
</ul>

<p>Each additional digit of a uniform PSRN&#39;s fractional part is sampled simply by setting it to an independent uniform random digit, an observation that dates from von Neumann (1951)[^9] in the binary case.[^10]  A PSRN with this property is called a <strong>uniform PSRN</strong> in this document, even if it was generated using a non-uniform random sampling algorithm (such as Karney&#39;s algorithm for the normal distribution). (This is notably because, in general, this kind of PSRN represents a uniform random variate in a given interval.  For example, if the PSRN is 3.356..., then it represents a uniformly distributed random variate in the interval [3.356, 3.357].)</p>

<p><a id=Exponential_Partially_Sampled_Random_Numbers></a></p>

<h3>Exponential Partially-Sampled Random Numbers</h3>

<p>In this document, an <strong>exponential PSRN</strong> (or <strong><em>e-rand</em></strong>, named similarly to Karney&#39;s &quot;u-rands&quot; for partially-sampled uniform random variates (Karney 2016)[^1]) samples each bit that, when combined with the existing bits, results in an exponentially-distributed random variate of the given rate.  Also, because <code>-ln(1 - X)</code>, where <code>X</code> is a uniform random variate in the interval [0, 1], is exponentially distributed, e-rands can also represent the natural logarithm of a partially-sampled uniform random variate in (0, 1].  The difference here is that additional bits are sampled not as unbiased random bits, but rather as bits with a vanishing bias.   (More specifically, an exponential PSRN generally represents an exponentially-distributed random variate in a given interval.)</p>

<p>Algorithms for sampling e-rands are given in the section &quot;Algorithms for the Beta and Exponential Distributions&quot;.</p>

<p><a id=Other_Distributions></a></p>

<h3>Other Distributions</h3>

<p>PSRNs of other distributions can be implemented via rejection from the uniform distribution. Examples include the following:</p>

<ul>
<li>The beta and continuous Bernoulli distributions, as discussed later in this document.</li>
<li>The standard normal distribution, as shown in (Karney 2016)[^1] by running Karney&#39;s Algorithm N and filling unsampled digits uniformly at random, or as shown in an improved version of that algorithm by Du et al. (2020)[^11].</li>
<li>Sampling uniform distributions in [0, <em>n</em>) (not just [0, 1]), is described later in &quot;<a href="#Sampling_Uniform_PSRNs"><strong>Sampling Uniform PSRNs</strong></a>&quot;.)</li>
</ul>

<p>For all these distributions, the PSRN&#39;s unsampled trailing digits converge to the uniform distribution, and this also applies to any continuous distribution with a continuous probability density function (or more generally, to so-called &quot;absolutely continuous&quot;[^12] distributions) (Oberhoff 2018)[^13], (Hill and Sch√ºrger 2005, Corollary 4.4)[^14].</p>

<p>PSRNs could also be implemented via rejection from the exponential distribution, although no concrete examples are presented here.</p>

<p><a id=Properties></a></p>

<h3>Properties</h3>

<p>An algorithm that samples from a non-discrete distribution using PSRNs has the following properties:</p>

<ol>
<li>The algorithm relies only on a source of independent and unbiased random bits for randomness.</li>
<li>The algorithm does not rely on floating-point arithmetic or fixed-precision approximations of irrational or transcendental numbers. (The algorithm may calculate approximations that converge to an irrational number, as long as those approximations use arbitrary precision.)</li>
<li>The algorithm may use rational arithmetic (such as <code>Fraction</code> in Python or <code>Rational</code> in Ruby), as long as the arithmetic is exact.</li>
<li>If the algorithm outputs a PSRN, the number represented by the sampled digits must follow a distribution that is close to the ideal distribution by a distance of not more than <em>b</em><sup>&minus;<em>m</em></sup>, where <em>b</em> is the PSRN&#39;s base, or radix (such as 2 for binary), and <em>m</em> is the position, starting from 1, of the rightmost sampled digit of the PSRN&#39;s fractional part.  ((Devroye and Gravel 2020)[^3] suggests Wasserstein distance, or &quot;earth-mover distance&quot;, as the distance to use for this purpose.) The number has to be close this way even if the algorithm&#39;s caller later samples unsampled digits of that PSRN at random (for example, uniformly at random in the case of a uniform PSRN).</li>
<li>If the algorithm fills a PSRN&#39;s unsampled fractional digits at random (for example, uniformly at random in the case of a uniform PSRN), so that the number&#39;s fractional part has <em>m</em> digits, the number&#39;s distribution must remain close to the ideal distribution by a distance of not more than <em>b</em><sup>&minus;<em>m</em></sup>.</li>
</ol>

<blockquote>
<p><strong>Notes:</strong></p>

<ol>
<li>It is not easy to turn a sampler for a non-discrete distribution into an algorithm that meets these properties.  Some reasons for this are given in the section &quot;<a href="#Discussion"><strong>Discussion</strong></a>&quot; later in this document.</li>
<li>The <em>exact rejection sampling</em> algorithm described by Oberhoff (2018)[^13] produces samples that act like PSRNs; however, the algorithm doesn&#39;t have the properties described in this section.  This is because the method requires calculating minimums of probabilities and, in practice, requires the use of floating-point arithmetic in most cases (see property 2 above).  Moreover, the algorithm&#39;s progression depends on the value of previously sampled bits, not just on the position of those bits as with the uniform and exponential distributions (see also (Thomas and Luk 2008)[^4]).  For completeness, Oberhoff&#39;s method appears in the appendix.</li>
</ol>
</blockquote>

<p><a id=Limitations></a></p>

<h3>Limitations</h3>

<p>Because a PSRN stores a random variate in a certain interval, PSRNs are not well suited for representing numbers in zero-volume sets.  Such sets include:</p>

<ul>
<li>Sets of integers or rational numbers.</li>
<li>Sets of individual points.</li>
<li>Curves on two- or higher-dimensional real number space.</li>
<li>Surfaces on three- or higher-dimensional real number space.</li>
</ul>

<p>In the case of curves and surfaces, a PSRN can&#39;t directly store the coordinates, in space, of a random point on that curve or surface (because the exact value of those coordinates may be an irrational number that no computer can store, and no interval can bound those exact coordinates &quot;tightly&quot; enough), but the PSRN <em>can</em> store upper and lower bounds that indirectly give that point&#39;s position on that curve or surface.</p>

<blockquote>
<p><strong>Examples:</strong></p>

<ol>
<li>To represent a point on the edge of a circle, a PSRN can store a random variate in the interval [0, 2*<em>&pi;</em>), via the <strong>RandUniformFromReal</strong> method, given later, for 2*<em>&pi;</em> (for example, it can store an integer part of 2 and a fractional part of [1, 3, 5] and thus represent a number in the interval [2.135, 2.136]), and the number stored this way indicates the distance on the circular arc relative to its starting position.  A program that cares about the point&#39;s X and Y coordinates can then generate enough digits of the PSRN to compute an approximation of cos(<em>P</em>) and sin(<em>P</em>), respectively, to the desired accuracy, where <em>P</em> is the number stored by the PSRN.  (However, the direct use of mathematical functions such as <code>cos</code> and <code>sin</code> is outside the scope of this document.)</li>
<li>Example 1 is trivial, because each point on the interval maps evenly to a point on the circle.  But this is not true in general: an interval&#39;s or box&#39;s points don&#39;t map evenly to points on a curve or surface in general.  For example, take two PSRNs describing the U and V coordinates of a 3 dimensional cone&#39;s surface: [1.135, 1.136] for U and [0.288, 0.289] for V, and the cone&#39;s coordinates are X = U*cos(V), Y = U*sin(V), Z = U. In this example, the PSRNs form a box that&#39;s mapped to a small part of the cone surface.  However, the points in the box don&#39;t map to the cone evenly this way, so generating enough digits to calculate X, Y, and Z to the desired accuracy will not sample uniformly from that part of the cone without more work (see Williamson (1987)[^15] for one solution).</li>
</ol>
</blockquote>

<p><a id=Relation_to_Constructive_Reals></a></p>

<h3>Relation to Constructive Reals</h3>

<p>Partially-sampled random numbers are related to a body of work dealing with so-called &quot;constructive reals&quot; or &quot;recursive reals&quot;, or operations on real numbers that compute an approximation of the exact result to a user-specified number of digit places.  For example, in Hans-J. Boehm&#39;s implementation (Boehm 2020)[^16], (Boehm 1987)[^17], each operation on &quot;constructive reals&quot; (such as addition, multiplication, <code>exp</code>, <code>ln</code>, and so on) is associated with a function <code>f(n)</code> (where <code>n</code> is usually 0 or greater) that returns an integer <code>m</code> such that <code>abs(m/pow(2, n) - x) &lt; 1/pow(2, n)</code>, where <code>x</code> is the exact result of the operation.  As suggested in Goubault-Larrecq et al. (2021)[^18], there can also be an operation that samples the digits of a uniform random variate in [0, 1] and gives access to approximations of that variate, sampling random digits as necessary.  Similarly, operations of this kind can be defined to access approximations of the value stored in a PSRN (including a uniform or exponential PSRN), sampling digits for the PSRN as necessary.</p>

<p><a id=Sampling_Uniform_and_Exponential_PSRNs></a></p>

<h2>Sampling Uniform and Exponential PSRNs</h2>

<p>&nbsp;</p>

<p><a id=Sampling_Uniform_PSRNs></a></p>

<h3>Sampling Uniform PSRNs</h3>

<p>There are several algorithms for sampling uniform partially-sampled random numbers given another number.</p>

<p>The <strong>RandUniform</strong> algorithm generates a uniformly distributed PSRN (<strong>a</strong>) that is greater than 0 and less than another PSRN (<strong>b</strong>) with probability 1.  This algorithm samples digits of <strong>b</strong>&#39;s fractional part as necessary.  This algorithm should not be used if <strong>b</strong> is known to be a real number rather than a partially-sampled random number, since this algorithm could overshoot the value <strong>b</strong> had (or appeared to have) at the beginning of the algorithm; instead, the <strong>RandUniformFromReal</strong> algorithm, given later, should be used.  (For example, if <strong>b</strong> is 3.425..., one possible result of this algorithm is <strong>a</strong> = 3.42574... and <strong>b</strong> = 3.42575... Note that in this example, 3.425... is not considered an exact number.)</p>

<ol>
<li>Create an empty uniform PSRN <strong>a</strong>.  Let <em>&beta;</em> be the base (or radix) of digits stored in <strong>b</strong>&#39;s fractional part (for example, 2 for binary or 10 for decimal).  If <strong>b</strong>&#39;s integer part or sign is unsampled, or if <strong>b</strong>&#39;s sign is negative, return an error.</li>
<li>(We now set <strong>a</strong>&#39;s integer part and sign.) Set <strong>a</strong>&#39;s sign to positive and <strong>a</strong>&#39;s integer part to an integer chosen uniformly at random in [0, <em>bi</em>], where <em>bi</em> is <strong>b</strong>&#39;s integer part (note that <em>bi</em> is included).  If <strong>a</strong>&#39;s integer part is less than <em>bi</em>, return <strong>a</strong>.</li>
<li>(We now sample <strong>a</strong>&#39;s fractional part.)  Set <em>i</em> to 0.</li>
<li>If <strong>b</strong>&#39;s integer part is 0 and <strong>b</strong>&#39;s fractional part begins with a sampled 0-digit, set <em>i</em> to the number of sampled zeros at the beginning of <strong>b</strong>&#39;s fractional part.  A nonzero digit or an unsampled digit ends this sequence.  Then append <em>i</em> zeros to <strong>a</strong>&#39;s fractional part.  (For example, if <strong>b</strong> is 5.000302 or 4.000 or 0.0008, there are three sampled zeros that begin <strong>b</strong>&#39;s fractional part, so <em>i</em> is set to 3 and three zeros are appended to <strong>a</strong>&#39;s fractional part.)</li>
<li>If the digit at position <em>i</em> of <strong>a</strong>&#39;s fractional part is unsampled, set the digit at that position to a base-<em>&beta;</em> digit chosen uniformly at random (such as an unbiased random bit if <em>&beta;</em> is 2). (Positions start at 0 where 0 is the most significant digit after the point, 1 is the next, etc.)</li>
<li>If the digit at position <em>i</em> of <strong>b</strong>&#39;s fractional part is unsampled, sample the digit at that position according to the kind of PSRN <strong>b</strong> is. (For example, if <strong>b</strong> is a uniform PSRN and <em>&beta;</em> is 2, this can be done by setting the digit at that position to an unbiased random bit.)</li>
<li>If the digit at position <em>i</em> of <strong>a</strong>&#39;s fractional part is less than the corresponding digit for <strong>b</strong>, return <strong>a</strong>.</li>
<li>If that digit is greater, then discard <strong>a</strong>, then create a new empty uniform PSRN <strong>a</strong>, then go to step 2.</li>
<li>Add 1 to <em>i</em> and go to step 5.</li>
</ol>

<blockquote>
<p><strong>Notes:</strong></p>

<ol>
<li>Karney (2014, end of sec. 4)[^1] discusses how even the integer part can be partially sampled rather than generating the whole integer as in step 2 of the algorithm.  However, incorporating this suggestion will add a non-trivial amount of complexity to the algorithm given above.</li>
<li>The <strong>RandUniform</strong> algorithm is equivalent to generating the product of a random variate (<strong>b</strong>) and a uniform random variate in the interval [0, 1].</li>
<li>If <strong>b</strong> is a uniform PSRN with a positive sign, an integer part of 0, and an empty fractional part, the <strong>RandUniform</strong> algorithm is equivalent to generating the product of two uniform random variate in the interval [0, 1].</li>
</ol>
</blockquote>

<p>The <strong>RandUniformInRangePositive</strong> algorithm generates a uniformly distributed PSRN (<strong>a</strong>) that is greater than one nonnegative real number <strong>bmin</strong> and less than another positive real number <strong>bmax</strong> with probability 1.  This algorithm works whether <strong>bmin</strong> or <strong>bmax</strong> is known to be a rational number or not (for example, either number can be the result of an expression such as <code>exp(-2)</code> or <code>ln(20)</code>), but the algorithm notes how it can be more efficiently implemented if <strong>bmin</strong> or <strong>bmax</strong> is known to be a rational number.</p>

<ol>
<li>If <strong>bmin</strong> is greater than or equal to <strong>bmax</strong>, if <strong>bmin</strong> is less than 0, or if <strong>bmax</strong> is 0 or less, return an error.</li>
<li>Create an empty uniform PSRN <strong>a</strong>.</li>
<li>Special case: If <strong>bmax</strong> is 1 and <strong>bmin</strong> is 0, set <strong>a</strong>&#39;s sign to positive, set <strong>a</strong>&#39;s integer part to 0, and return <strong>a</strong>.</li>
<li>Special case: If <strong>bmax</strong> and <strong>bmin</strong> are rational numbers and each of their denominators is a power of <em>&beta;</em>, including 1 (where <em>&beta;</em> is the desired digit base, or radix, of the uniform PSRN, such as 10 for decimal or 2 for binary), then do the following:

<ol>
<li>Let <em>denom</em> be <strong>bmax</strong>&#39;s or <strong>bmin</strong>&#39;s denominator, whichever is greater.</li>
<li>Set <em>c1</em> to floor(<strong>bmax</strong>*<em>denom</em>) and <em>c2</em> to floor((<strong>bmax</strong>&minus;<strong>bmin</strong>)*<em>denom</em>).</li>
<li>If <em>c2</em> is greater than 1, add to <em>c1</em> an integer chosen uniformly at random in [0, <em>c2</em>) (note that <em>c2</em> is excluded).</li>
<li>Let <em>d</em> be the base-<em>&beta;</em> logarithm of <em>denom</em> (this is equivalent to finding the minimum number of base-<em>&beta;</em> digits needed to store <em>denom</em> and subtracting 1). Transfer <em>c1</em>&#39;s least significant digits to <strong>a</strong>&#39;s fractional part; the variable <em>d</em> tells how many digits to transfer to each PSRN this way. Then set <strong>a</strong>&#39;s sign to positive and <strong>a</strong>&#39;s integer part to floor(<em>c1</em>/<em>&beta;</em><sup><em>d</em></sup>). (For example, if <em>&beta;</em> is 10, <em>d</em> is 3, and <em>c1</em> is 7342, set <strong>a</strong>&#39;s fractional part to [3, 4, 2] and <strong>a</strong>&#39;s integer part to 7.)  Finally, return <strong>a</strong>.</li>
</ol></li>
<li>Calculate floor(<strong>bmax</strong>), and set <em>bmaxi</em> to the result.  Likewise, calculate floor(<strong>bmin</strong>) and set <em>bmini</em> to the result.</li>
<li>If <em>bmini</em> is equal to <strong>bmin</strong> and <em>bmaxi</em> is equal to <strong>bmax</strong>, set <strong>a</strong>&#39;s sign to positive and <strong>a</strong>&#39;s integer part to an integer chosen uniformly at random in [<em>bmini</em>, <em>bmaxi</em>) (note that <em>bmaxi</em> is excluded), then return <strong>a</strong>.  (It should be noted that determining whether a real number is equal to another is undecidable in general.)</li>
<li>(We now set <strong>a</strong>&#39;s integer part and sign.) Set <strong>a</strong>&#39;s sign to positive and <strong>a</strong>&#39;s integer part to an integer chosen uniformly at random in the interval [<em>bmini</em>, <em>bmaxi</em>] (note that <em>bmaxi</em> is included).  If <em>bmaxi</em> is equal to <strong>bmax</strong>, the integer is chosen from the interval [<em>bmini</em>, <em>bmaxi</em>&minus;1] instead.  Return <strong>a</strong> if&mdash;

<ul>
<li><strong>a</strong>&#39;s integer part is greater than <em>bmini</em> and less than <em>bmaxi</em>, or</li>
<li><em>bmini</em> is equal to <strong>bmin</strong>, and <strong>a</strong>&#39;s integer part is equal to <em>bmini</em> and less than <em>bmaxi</em>.</li>
</ul></li>
<li>(We now sample <strong>a</strong>&#39;s fractional part.)  Set <em>i</em> to 0 and <em>istart</em> to 0. ( Then, <em>if <strong>bmax</strong> is known rational:</em> set <em>bmaxf</em> to <strong>bmax</strong> minus <em>bmaxi</em>, and <em>if <strong>bmin</strong> is known rational</em>, set <em>bminf</em> to <strong>bmin</strong> minus <em>bmini</em>.)</li>
<li>(This step is not crucial for correctness, but helps improve its efficiency.  It sets <strong>a</strong>&#39;s fractional part to the initial digits shared by <strong>bmin</strong> and <strong>bmax</strong>.) If <strong>a</strong>&#39;s integer part is equal to <em>bmini</em> and <em>bmaxi</em>, then do the following in a loop:
    1. Calculate the base-<em>&beta;</em> digit at position <em>i</em> of <strong>bmax</strong>&#39;s and <strong>bmin</strong>&#39;s fractional parts, and set <em>dmax</em> and <em>dmin</em> to those digits, respectively. (<em>If <strong>bmax</strong> is known rational:</em> Do this step by setting <em>dmax</em> to floor(<em>bmaxf</em>*<em>&beta;</em>) and <em>dmin</em> to floor(<em>bminf</em>*<em>&beta;</em>).)
    2. If <em>dmin</em> equals <em>dmax</em>, append <em>dmin</em> to <strong>a</strong>&#39;s fractional part, then add 1 to <em>i</em> (and, if <strong>bmax</strong> and/or <strong>bmin</strong> is known to be rational, set <em>bmaxf</em> to <em>bmaxf</em>*<em>&beta;</em>&minus;<em>d</em> and set <em>bminf</em> to <em>bminf</em>*<em>&beta;</em>&minus;<em>d</em>).  Otherwise, break from this loop and set <em>istart</em> to <em>i</em>.</li>
<li>(Ensure the fractional part is greater than <strong>bmin</strong>&#39;s.) Set <em>i</em> to <em>istart</em>, then if <strong>a</strong>&#39;s integer part is equal to <em>bmini</em>:

<ol>
<li>Calculate the base-<em>&beta;</em> digit at position <em>i</em> of <strong>bmin</strong>&#39;s fractional part, and set <em>dmin</em> to that digit.</li>
<li>If the digit at position <em>i</em> of <strong>a</strong>&#39;s fractional part is unsampled, set the digit at that position to a base-<em>&beta;</em> digit chosen uniformly at random (such as an unbiased random bit if <em>&beta;</em> is 2, or binary). (Positions start at 0 where 0 is the most significant digit after the point, 1 is the next, etc.)</li>
<li>Let <em>ad</em> be the digit at position <em>i</em> of <strong>a</strong>&#39;s fractional part.  If <em>ad</em> is greater than <em>dmin</em>, abort these substeps and go to step 11.</li>
<li>Discard <strong>a</strong>, create a new empty uniform PSRN <strong>a</strong>, and abort these substeps and go to step 7 if <em>ad</em> is less than <em>dmin</em>.</li>
<li>Add 1 to <em>i</em> and go to the first substep.</li>
</ol></li>
<li>(Ensure the fractional part is less than <strong>bmax</strong>&#39;s.) Set <em>i</em> to <em>istart</em>, then if <strong>a</strong>&#39;s integer part is equal to <em>bmaxi</em>:

<ol>
<li>If <em>bmaxi</em> is 0 and not equal to <strong>bmax</strong>, and if <strong>a</strong> has no digits in its fractional part, then do the following in a loop:

<ol>
<li>Calculate the base-<em>&beta;</em> digit at position <em>i</em> of <strong>bmax</strong>&#39;s fractional part, and set <em>d</em> to that digit. (<em>If <strong>bmax</strong> is known rational:</em> Do this step by setting <em>d</em> to floor(<em>bmaxf</em>*<em>&beta;</em>).)</li>
<li>If <em>d</em> is 0, append a 0-digit to <strong>a</strong>&#39;s fractional part, then add 1 to <em>i</em> (and, if <strong>bmax</strong> is known to be rational, set <em>bmaxf</em> to <em>bmaxf</em>*<em>&beta;</em>&minus;<em>d</em>).  Otherwise, break from this loop.</li>
</ol></li>
<li>Calculate the base-<em>&beta;</em> digit at position <em>i</em> of <strong>bmax</strong>&#39;s fractional part, and set <em>dmax</em> to that digit. (<em>If <strong>bmax</strong> is known rational:</em> Do this step by multiplying <em>bmaxf</em> by <em>&beta;</em>, then setting <em>dmax</em> to floor(<em>bmaxf</em>), then subtracting <em>dmax</em> from <em>bmaxf</em>.)</li>
<li>If the digit at position <em>i</em> of <strong>a</strong>&#39;s fractional part is unsampled, set the digit at that position to a base-<em>&beta;</em> digit chosen uniformly at random.</li>
<li>Let <em>ad</em> be the digit at position <em>i</em> of <strong>a</strong>&#39;s fractional part.  Return <strong>a</strong> if <em>ad</em> is less than <em>dmax</em>.</li>
<li>Discard <strong>a</strong>, create a new empty uniform PSRN <strong>a</strong>, and abort these substeps and go to step 7 if&mdash;

<ul>
<li><em><strong>bmax</strong> is not known to be rational</em>, and either <em>ad</em> is greater than <em>dmax</em> or all the digits after the digit at position <em>i</em> of <strong>bmax</strong>&#39;s fractional part are zeros, or</li>
<li><em><strong>bmax</strong> is known to be rational</em>, and either <em>ad</em> is greater than <em>dmax</em> or <em>bmaxf</em> is 0</li>
</ul></li>
<li>Add 1 to <em>i</em> and go to the second substep.</li>
</ol></li>
<li>Return <strong>a</strong>.</li>
</ol>

<p>The <strong>RandUniformInRange</strong> algorithm generates a uniformly distributed PSRN (<strong>a</strong>) that is greater than one real number <strong>bmin</strong> and less than another real number <strong>bmax</strong> with probability 1. It works for both positive and negative real numbers, but it&#39;s specified separately from <strong>RandUniformInRangePositive</strong> to reduce clutter.</p>

<ol>
<li>If <strong>bmin</strong> is greater than or equal to <strong>bmax</strong>, return an error.  If <strong>bmin</strong> and <strong>bmax</strong> are each 0 or greater, return the result of <strong>RandUniformInRangePositive</strong>.</li>
<li>If <strong>bmin</strong> and <strong>bmax</strong> are each 0 or less, call <strong>RandUniformInRangePositive</strong> with <strong>bmin</strong> = abs(<strong>bmax</strong>) and <strong>bmax</strong> = abs(<strong>bmin</strong>), set the result&#39;s fractional part to negative, and return the result.</li>
<li>(At this point, <strong>bmin</strong> is less than 0 and <strong>bmax</strong> is greater than 0.) Set <em>bmaxi</em> to either floor(<strong>bmax</strong>) if <strong>bmax</strong> is 0 or greater, or &minus;ceil(abs(<strong>bmax</strong>)) otherwise, and set <em>bmini</em> to either floor(<strong>bmin</strong>) if <strong>bmin</strong> is 0 or greater, or &minus;ceil(abs(<strong>bmin</strong>)) otherwise.  (Described this way to keep implementers from confusing floor with the integer part.)</li>
<li>Set <em>ipart</em> to an integer chosen uniformly at random in the interval [<em>bmini</em>, <em>bmaxi</em>] (note that <em>bmaxi</em> is included).  If <em>bmaxi</em> is equal to <strong>bmax</strong>, the integer is chosen from the interval [<em>bmini</em>, <em>bmaxi</em>&minus;1] instead.</li>
<li>If <em>ipart</em> is neither <em>bmini</em> nor <em>bmaxi</em>, create a uniform PSRN <strong>a</strong> with an empty fractional part; then set <strong>a</strong>&#39;s sign to either positive if <em>ipart</em> is 0 or greater, or negative otherwise; then set <strong>a</strong>&#39;s integer part to abs(<em>ipart</em>+1) if <em>ipart</em> is less than 0, or <em>ipart</em> otherwise; then return <strong>a</strong>.</li>
<li>If <em>ipart</em> is <em>bmini</em>, then create a uniform PSRN <strong>a</strong> with a positive sign, an integer part of abs(<em>ipart</em>+1), and an empty fractional part; then run <strong>URandLessThanReal</strong> with <strong>a</strong> = <strong>a</strong> and <strong>b</strong> = abs(<strong>bmin</strong>). If the result is 1, set <strong>a</strong>&#39;s sign to negative and return <strong>a</strong>.  Otherwise, go to step 3.</li>
<li>If <em>ipart</em> is <em>bmaxi</em>, then create a uniform PSRN <strong>a</strong> with a positive sign, an integer part of <em>ipart</em>, and an empty fractional part; then run <strong>URandLessThanReal</strong> with <strong>a</strong> = <strong>a</strong> and <strong>b</strong> = <strong>bmax</strong>. If the result is 1, return <strong>a</strong>.  Otherwise, go to step 3.</li>
</ol>

<p>The <strong>RandUniformFromReal</strong> algorithm generates a uniformly distributed PSRN (<strong>a</strong>) that is greater than 0 and less than a real number <strong>b</strong> with probability 1.  It is equivalent to the <strong>RandUniformInRangePositive</strong> algorithm with <strong>a</strong> = <strong>a</strong>, <strong>bmin</strong> = 0, and <strong>bmax</strong> = <strong>b</strong>.</p>

<p>The <strong>UniformComplement</strong> algorithm generates 1 minus the value of a uniform PSRN (<strong>a</strong>) as follows:</p>

<ol>
<li>If <strong>a</strong>&#39;s sign is negative or its integer part is other than 0, return an error.</li>
<li>For each sampled digit in <strong>a</strong>&#39;s fractional part, set it to <em>base</em>&minus;1&minus;<em>digit</em>, where <em>digit</em> is the digit and <em>base</em> is the base of digits stored by the PSRN, such as 2 for binary.</li>
<li>Return <strong>a</strong>.</li>
</ol>

<p><a id=Sampling_E_rands></a></p>

<h3>Sampling E-rands</h3>

<p><strong>Sampling an e-rand</strong> (a exponential PSRN) makes use of two observations (based on the parameter <em>&lambda;</em> of the exponential distribution):</p>

<ul>
<li>While a coin flip with probability of heads of exp(&minus;<em>&lambda;</em>) is heads, the exponential random variate is increased by 1.</li>
<li>If a coin flip with probability of heads of 1/(1+exp(<em>&lambda;</em>/2<sup><em>prec</em></sup>)) is heads, the exponential random variate is increased by 2<sup>&minus;<em>prec</em></sup>, where <em>prec</em> &gt; 0 is an integer.</li>
</ul>

<p>Devroye and Gravel (2020)[^3] already made these observations in section 3.8, but only for <em>&lambda;</em> = 1.</p>

<p>In this section, the parameter <em>&lambda;</em> can be written in one of the following ways:</p>

<ol>
<li>As a rational number, namely <em>x</em>/<em>y</em> where <em>x</em>&ge;0 and <em>y</em>&gt;0.</li>
<li>As an integer and fractional part, namely <em>m</em> + <em>&nu;</em> where <em>m</em> &ge; 0 is an integer and <em>&nu;</em> (0 &le; <em>&nu;</em> &le; 1) is the probability of heads of a coin.  (Specifically, the &quot;coin&quot; must implement a so-called <em>Bernoulli factory</em> algorithm that returns 1 [or outputs heads] with probability equal to the fractional part <em>&nu;</em>.[^19])</li>
<li>As a sum of <em>n</em> &gt; 0 positive numbers, each of which can be written in either of the preceding ways.  For example, <em>&lambda;</em> = &pi;, it can be decomposed into four components, each of which is (&pi; / 4), that is, <em>m</em> = 0 and <em>&nu;</em> = (&pi; / 4).</li>
</ol>

<p>To implement these probabilities using just random bits, the sampler uses algorithms from &quot;<a href="https://peteroupc.github.io/bernoulli.html"><strong>Bernoulli Factory Algorithms</strong></a>&quot;, described as follows.</p>

<ol>
<li><strong>ExpMinus</strong>: To flip a coin with probability of heads of exp(&minus;<em>&lambda;</em>):

<ul>
<li>In case 1, use the <strong>algorithm for exp(&minus;<em>x</em>/<em>y</em>)</strong>.</li>
<li>In case 2, use the <strong>algorithm for exp(&minus;(<em>m</em> + <em>&lambda;</em>)*<em>&mu;</em>)</strong> where <em>&lambda;</em> represents the coin for <em>&nu;</em>, and <em>&mu;</em> represents a coin that always returns 1.</li>
<li>In case 3, use the <strong>algorithm for exp(&minus;<em>z</em>)</strong> where <em>z</em> is the <em>&lambda;</em> parameter decomposed as a sum.</li>
</ul></li>
<li><strong>LogisticExp</strong>: To flip a coin with probability of heads of 1/(1+exp(<em>&lambda;</em>/2<sup><em>prec</em></sup>)) = 1 &minus; expit(<em>&lambda;</em>/2<sup><em>prec</em></sup>):

<ul>
<li>In case 1 the <strong>1 / (1 + exp(<em>x</em> / (<em>y</em> * 2<sup><em>prec</em></sup>))</strong>. Or...</li>
<li>In case 2 the <strong>algorithm for expit((<em>m</em> + <em>&lambda;</em>)*<em>&mu;</em>)</strong> where <em>&lambda;</em> represents the coin for <em>&nu;</em>, and <em>&mu;</em> represents a coin that returns either 1 with probability 1/(2<sup><em>prec</em></sup>) or 0 otherwise.  However the algorithm returns 1 minus the usual result instead (leading to <strong>1 &minus; expit((<em>m</em> + <em>&lambda;</em>)*<em>&mu;</em>)</strong>).</li>
<li>In case 3, use the <strong>algorithm for 1 / 1 + exp(<em>z</em> / 2<sup><em>index</em> + 1</sup>))</strong> where <em>z</em> is the <em>&lambda;</em> parameter decomposed as a sum.</li>
</ul></li>
</ol>

<blockquote>
<p><strong>Note:</strong> An exponential PSRN is an exponential random variate built up digit by digit, but an exponential random variate can also be stored in a <em>uniform PSRN</em> and generated by other algorithms.</p>
</blockquote>

<p><a id=Arithmetic_and_Comparisons_with_PSRNs></a></p>

<h2>Arithmetic and Comparisons with PSRNs</h2>

<p>This section describes addition, subtraction, multiplication, reciprocal, and division involving uniform PSRNs, and discusses other aspects of arithmetic involving PSRNs.</p>

<p><a id=Addition_and_Subtraction></a></p>

<h3>Addition and Subtraction</h3>

<p>The following algorithm (<strong>UniformAdd</strong>) shows how to add two uniform PSRNs (<strong>a</strong> and <strong>b</strong>) that store digits of the same base (radix) in their fractional parts, and get a uniform PSRN as a result.  The input PSRNs may have a positive or negative sign, and it is assumed that their integer parts and signs were sampled.  <em>Python code implementing this algorithm is given later in this document.</em></p>

<ol>
<li>If <strong>a</strong> has unsampled digits before the last sampled digit in its fractional part, set each of those unsampled digits to a digit chosen uniformly at random.  Do the same for <strong>b</strong>.</li>
<li>If <strong>a</strong> has fewer digits in its fractional part than <strong>b</strong> (or vice versa), sample enough digits (by setting them to uniform random digits, such as unbiased random bits if <strong>a</strong> and <strong>b</strong> store binary, or base-2, digits) so that both PSRNs&#39; fractional parts have the same number of digits.  Now, let <em>digitcount</em> be the number of digits in <strong>a</strong>&#39;s fractional part.</li>
<li>Let <em>asign</em> be &minus;1 if <strong>a</strong>&#39;s sign is negative, or 1 otherwise.  Let <em>bsign</em> be &minus;1 if <strong>b</strong>&#39;s sign is negative, or 1 otherwise.  Let <em>afp</em> be <strong>a</strong>&#39;s integer and fractional parts packed into an integer, as explained in the example, and let <em>bfp</em> be <strong>b</strong>&#39;s integer and fractional parts packed the same way.  (For example, if <strong>a</strong> represents the number 83.12344..., <em>afp</em> is 8312344.)  Let <em>base</em> be the base of digits stored by <strong>a</strong> and <strong>b</strong>, such as 2 for binary or 10 for decimal.</li>
<li>Calculate the following four numbers:

<ul>
<li><em>afp</em>*<em>asign</em> + <em>bfp</em>*<em>bsign</em>.</li>
<li><em>afp</em>*<em>asign</em> + (<em>bfp</em>+1)*<em>bsign</em>.</li>
<li>(<em>afp</em>+1)*<em>asign</em> + <em>bfp</em>*<em>bsign</em>.</li>
<li>(<em>afp</em>+1)*<em>asign</em> + (<em>bfp</em>+1)*<em>bsign</em>.</li>
</ul></li>
<li>Set <em>minv</em> to the minimum and <em>maxv</em> to the maximum of the four numbers just calculated.  These are lower and upper bounds to the result of applying interval addition to the PSRNs <strong>a</strong> and <strong>b</strong>. (For example, if <strong>a</strong> is 0.12344... and <strong>b</strong> is 0.38925..., their fractional parts are added to form <strong>c</strong> = 0.51269...., or the interval [0.51269, 0.51271].)  However, the resulting PSRN is not uniformly distributed in its interval, and this is what the rest of this algorithm will solve, since in fact, the distribution of numbers in the interval resembles the distribution of the sum of two uniform random variates.</li>
<li>Once the four numbers are sorted from lowest to highest, let <em>midmin</em> be the second number in the sorted order, and let <em>midmax</em> be the third number in that order.</li>
<li>Set <em>x</em> to a uniform random integer in the interval [0, <em>maxv</em>&minus;<em>minv</em>).  If <em>x</em> &lt; <em>midmin</em>&minus;<em>minv</em>, set <em>dir</em> to 0 (the left side of the sum density).  Otherwise, if <em>x</em> &gt; <em>midmax</em>&minus;<em>minv</em>, set <em>dir</em> to 1 (the right side of the sum density).  Otherwise, do the following:

<ol>
<li>Set <em>s</em> to <em>minv</em> + <em>x</em>.</li>
<li>Create a new uniform PSRN, <em>ret</em>.  If <em>s</em> is less than 0, set <em>s</em> to abs(1 + <em>s</em>) and set <em>ret</em>&#39;s sign to negative.  Otherwise, set <em>ret</em>&#39;s sign to positive.</li>
<li>Transfer the <em>digitcount</em> least significant digits of <em>s</em> to <em>ret</em>&#39;s fractional part.  (Note that <em>ret</em>&#39;s fractional part stores digits from most to least significant.)  Then set <em>ret</em>&#39;s integer part to floor(<em>s</em>/<em>base</em><sup><em>digitcount</em></sup>), then return <em>ret</em>.  (For example, if <em>base</em> is 10, <em>digitcount</em> is 3, and <em>s</em> is 34297, then <em>ret</em>&#39;s fractional part is set to [2, 9, 7], and <em>ret</em>&#39;s integer part is set to 34.)</li>
</ol></li>
<li>If <em>dir</em> is 0 (the left side), set <em>pw</em> to <em>x</em> and <em>b</em> to <em>midmin</em>&minus;<em>minv</em>.  Otherwise (the right side), set <em>pw</em> to <em>x</em>&minus;(<em>midmax</em>&minus;<em>minv</em>) and <em>b</em> to <em>maxv</em>&minus;<em>midmax</em>.</li>
<li>Set <em>newdigits</em> to 0, then set <em>y</em> to a uniform random integer in the interval [0, <em>b</em>).</li>
<li>If <em>dir</em> is 0, set <em>lower</em> to <em>pw</em>.  Otherwise, set <em>lower</em> to <em>b</em>&minus;1&minus;<em>pw</em>.</li>
<li>If <em>y</em> is less than <em>lower</em>, do the following:

<ol>
<li>Set <em>s</em> to <em>minv</em> if <em>dir</em> is 0, or <em>midmax</em> otherwise, then set <em>s</em> to <em>s</em>*(<em>base</em><sup><em>newdigits</em></sup>) + <em>pw</em>.</li>
<li>Create a new uniform PSRN, <em>ret</em>.  If <em>s</em> is less than 0, set <em>s</em> to abs(1 + <em>s</em>) and set <em>ret</em>&#39;s sign to negative.  Otherwise, set <em>ret</em>&#39;s sign to positive.</li>
<li>Transfer the <em>digitcount</em> + <em>newdigits</em> least significant digits of <em>s</em> to <em>ret</em>&#39;s fractional part, then set <em>ret</em>&#39;s integer part to floor(<em>s</em>/<em>base</em><sup><em>digitcount</em> + <em>newdigits</em></sup>), then return <em>ret</em>.</li>
</ol></li>
<li>If <em>y</em> is greater than <em>lower</em> + 1, go to step 7. (This is a rejection event.)</li>
<li>Multiply <em>pw</em>, <em>y</em>, and <em>b</em> each by <em>base</em>, then add a digit chosen uniformly at random to <em>pw</em>, then add a digit chosen uniformly at random to <em>y</em>, then add 1 to <em>newdigits</em>, then go to step 10.</li>
</ol>

<p>The following algorithm (<strong>UniformAddRational</strong>) shows how to add a uniform PSRN (<strong>a</strong>) and a rational number <strong>b</strong>.  The input PSRN may have a positive or negative sign, and it is assumed that its integer part and sign were sampled. Similarly, the rational number may be positive, negative, or zero.  <em>Python code implementing this algorithm is given later in this document.</em></p>

<ol>
<li>Let <em>ai</em> be <strong>a</strong>&#39;s integer part.  Special cases:

<ul>
<li>If <strong>a</strong>&#39;s sign is positive and has no sampled digits in its fractional part, and if <strong>b</strong> is an integer 0 or greater, return a uniform PSRN with a positive sign, an integer part equal to <em>ai</em> + <strong>b</strong>, and an empty fractional part.</li>
<li>If <strong>a</strong>&#39;s sign is negative and has no sampled digits in its fractional part, and if <strong>b</strong> is an integer less than 0, return a uniform PSRN with a negative sign, an integer part equal to <em>ai</em> + abs(<strong>b</strong>), and an empty fractional part.</li>
<li>If <strong>a</strong>&#39;s sign is positive, has an integer part of 0, and has no sampled digits in its fractional part, and if <strong>b</strong> is an integer, return a uniform PSRN with an empty fractional part.  If <strong>b</strong> is less than 0, the PSRN&#39;s sign is negative and its integer part is abs(<strong>b</strong>)&minus;1.  If <strong>b</strong> is 0 or greater, the PSRN&#39;s sign is positive and its integer part is abs(<strong>b</strong>).</li>
<li>If <strong>b</strong> is 0, return a copy of <strong>a</strong>.</li>
</ul></li>
<li>If <strong>a</strong> has unsampled digits before the last sampled digit in its fractional part, set each of those unsampled digits to a digit chosen uniformly at random.   Now, let <em>digitcount</em> be the number of digits in <strong>a</strong>&#39;s fractional part.</li>
<li>Let <em>asign</em> be &minus;1 if <strong>a</strong>&#39;s sign is negative or 1 otherwise.  Let <em>base</em> be the base of digits stored in <strong>a</strong>&#39;s fractional part (such as 2 for binary or 10 for decimal).  Set <em>absfrac</em> to abs(<strong>b</strong>), then set <em>fraction</em> to <em>absfrac</em> &minus; floor(<em>absfrac</em>).</li>
<li>Let <em>afp</em> be <strong>a</strong>&#39;s integer and fractional parts packed into an integer, as explained in the example.  (For example, if <strong>a</strong> represents the number 83.12344..., <em>afp</em> is 8312344.)  Let <em>asign</em> be &minus;1 if</li>
<li>Set <em>ddc</em> to <em>base</em><sup><em>dcount</em></sup>, then set <em>lower</em> to ((<em>afp</em>*<em>asign</em>)/<em>ddc</em>)+<strong>b</strong> (using rational arithmetic), then set <em>upper</em> to (((<em>afp</em>+1)*<em>asign</em>)/<em>ddc</em>)+<strong>b</strong> (again using rational arithmetic).  Set <em>minv</em> to min(<em>lower</em>, <em>upper</em>), and set <em>maxv</em> to min(<em>lower</em>, <em>upper</em>).</li>
<li>Set <em>newdigits</em> to 0, then set <em>b</em> to 1, then set <em>ddc</em> to <em>base</em><sup><em>dcount</em></sup>, then set <em>mind</em> to floor(abs(<em>minv</em>*<em>ddc</em>)), then set <em>maxd</em> to floor(abs(<em>maxv</em>*<em>ddc</em>)). (Outer bounds): Then set <em>rvstart</em> to <em>mind</em>&minus;1 if <em>minv</em> is less than 0, or <em>mind</em> otherwise, then set <em>rvend</em> to <em>maxd</em> if <em>maxv</em> is less than 0, or <em>maxd</em>+1 otherwise.</li>
<li>Set <em>rv</em> to a uniform random integer in the interval [0, <em>rvend</em>&minus;<em>rvstart</em>), then set <em>rvs</em> to <em>rv</em> + <em>rvstart</em>.</li>
<li>(Inner bounds.) Set <em>innerstart</em> to <em>mind</em> if <em>minv</em> is less than 0, or <em>mind</em>+1 otherwise, then set <em>innerend</em> to <em>maxd</em>&minus;1 if <em>maxv</em> is less than 0, or <em>maxd</em> otherwise.</li>
<li>If <em>rvs</em> is greater than <em>innerstart</em> and less than <em>innerend</em>, then the algorithm is almost done, so do the following:

<ol>
<li>Create an empty uniform PSRN, call it <em>ret</em>.  If <em>rvs</em> is less than 0, set <em>rvs</em> to abs(1 + <em>rvs</em>) and set <em>ret</em>&#39;s sign to negative.  Otherwise, set <em>ret</em>&#39;s sign to positive.</li>
<li>Transfer the <em>digitcount</em> + <em>newdigits</em> least significant digits of <em>rvs</em> to <em>ret</em>&#39;s fractional part, then set <em>ret</em>&#39;s integer part to floor(<em>rvs</em>/<em>base</em><sup><em>digitcount</em> + <em>newdigits</em></sup>), then return <em>ret</em>.</li>
</ol></li>
<li>If <em>rvs</em> is equal to or less than <em>innerstart</em> and (<em>rvs</em>+1)/<em>ddc</em> (calculated using rational arithmetic) is less than or equal to <em>minv</em>, go to step 6.  (This is a rejection event.)</li>
<li>If <em>rvs</em>/<em>ddc</em> (calculated using rational arithmetic) is greater than or equal to <em>maxv</em>, go to step 6.  (This is a rejection event.)</li>
<li>Add 1 to <em>newdigits</em>, then multiply <em>ddc</em>, <em>rvstart</em>, <em>rv</em>, and <em>rvend</em> each by <em>base</em>, then set <em>mind</em> to floor(abs(<em>minv</em>*<em>ddc</em>)), then set <em>maxd</em> to floor(abs(<em>maxv</em>*<em>ddc</em>)), then add a digit chosen uniformly at random to <em>rv</em>, then set <em>rvs</em> to <em>rv</em>+<em>rvstart</em>, then go to step 8.</li>
</ol>

<p><a id=Multiplication></a></p>

<h3>Multiplication</h3>

<p>The following algorithm (<strong>UniformMultiplyRational</strong>) shows how to multiply a uniform PSRN (<strong>a</strong>) by a nonzero rational number <strong>b</strong>.  The input PSRN may have a positive or negative sign, and it is assumed that its integer part and sign were sampled. <em>Python code implementing this algorithm is given later in this document.</em></p>

<ol>
<li>If <strong>a</strong> has unsampled digits before the last sampled digit in its fractional part, set each of those unsampled digits to a digit chosen uniformly at random.   Now, let <em>digitcount</em> be the number of digits in <strong>a</strong>&#39;s fractional part.</li>
<li>Create a uniform PSRN, call it <em>ret</em>.  Set <em>ret</em>&#39;s sign to be &minus;1 if <strong>a</strong>&#39;s sign is positive and <strong>b</strong> is less than 0 or if <strong>a</strong>&#39;s sign is negative and <strong>b</strong> is 0 or greater, or 1 otherwise, then set <em>ret</em>&#39;s integer part to 0.  Let <em>base</em> be the base of digits stored in <strong>a</strong>&#39;s fractional part (such as 2 for binary or 10 for decimal).  Set <em>absfrac</em> to abs(<strong>b</strong>), then set <em>fraction</em> to <em>absfrac</em> &minus; floor(<em>absfrac</em>).</li>
<li>Let <em>afp</em> be <strong>a</strong>&#39;s integer and fractional parts packed into an integer, as explained in the example.  (For example, if <strong>a</strong> represents the number 83.12344..., <em>afp</em> is 8312344.)</li>
<li>Set <em>dcount</em> to <em>digitcount</em>, then set <em>ddc</em> to <em>base</em><sup><em>dcount</em></sup>, then set <em>lower</em> to (<em>afp</em>/<em>ddc</em>)*<em>absfrac</em> (using rational arithmetic), then set <em>upper</em> to ((<em>afp</em>+1)/<em>ddc</em>)*<em>absfrac</em> (again using rational arithmetic).</li>
<li>Set <em>rv</em> to a uniform random integer in the interval [floor(<em>lower</em>*<em>ddc</em>), floor(<em>upper</em>*<em>ddc</em>)).</li>
<li>Set <em>rvlower</em> to <em>rv</em>/<em>ddc</em> (as a rational number), then set <em>rvupper</em> to (<em>rv</em>+1)/<em>ddc</em> (as a rational number).</li>
<li>If <em>rvlower</em> is greater than or equal to <em>lower</em> and <em>rvupper</em> is less than <em>upper</em>, then the algorithm is almost done, so do the following: Transfer the <em>dcount</em> least significant digits of <em>rv</em> to <em>ret</em>&#39;s fractional part (note that <em>ret</em>&#39;s fractional part stores digits from most to least significant),  then set <em>ret</em>&#39;s integer part to floor(<em>rv</em>/<em>base</em><sup><em>dcount</em></sup>), then return <em>ret</em>. (For example, if <em>base</em> is 10, <em>dcount</em> is 4, and <em>rv</em> is 342978, then <em>ret</em>&#39;s fractional part is set to [2, 9, 7, 8], and <em>ret</em>&#39;s integer part is set to 34.)</li>
<li>If <em>rvlower</em> is greater than <em>upper</em> or if <em>rvupper</em> is less than <em>lower</em>, go to step 4.</li>
<li>Multiply <em>rv</em> and <em>ddc</em> each by <em>base</em>, then add 1 to <em>dcount</em>, then add a digit chosen uniformly at random to <em>rv</em>, then go to step 6.</li>
</ol>

<p>Another algorithm (<strong>UniformMultiply</strong>) shows how to multiply two uniform PSRNs (<strong>a</strong> and <strong>b</strong>) is given in the appendix &mdash; the algorithm is complicated and it may be simpler to instead connect PSRNs with &quot;constructive reals&quot; (described earlier) that implement multiplication to arbitrary precision.</p>

<blockquote>
<p><strong>Note:</strong> Let <em>b</em>&gt;0, <em>c</em>&ge;0, and <em>d</em>&gt;0 be rational numbers where <em>d</em>&gt;<em>c</em>. To generate the product of two uniform variates, one in [0, <em>b</em>] and the other in [<em>c</em>, <em>d</em>], the following algorithm can be used.<br>(1) Generate a uniform PSRN using <strong>RandUniformFromReal</strong> with parameter <em>b</em>*(<em>d</em>&minus;<em>c</em>), call it <strong>K</strong>;<br>(2) Get the result of <strong>UniformAddRational</strong> with parameters <strong>K</strong> and <em>b</em>*<em>c</em>, call it <strong>M</strong>;<br>(3) Generate a uniform PSRN using <strong>RandUniform</strong> with parameter <strong>M</strong>; return the PSRN.<br>Broadly speaking: &quot;generate a uniform(0, <em>b</em>*(<em>d</em>&minus;<em>c</em>)) random variate <em>X</em>, then return a uniform(0, <em>X</em>+<em>b</em>*<em>c</em>) random variate&quot;.  See the <a href="#Uniform_of_Uniforms_Produces_a_Product_of_Uniforms"><strong>appendix</strong></a> for evidence that this algorithm works, at least when <em>c</em> = 0.</p>
</blockquote>

<p><a id=Reciprocal_and_Division></a></p>

<h3>Reciprocal and Division</h3>

<p>The following algorithm (<strong>UniformReciprocal</strong>) generates 1/<strong>a</strong>, where <strong>a</strong> is a uniform PSRN, and generates a new uniform PSRN with that reciprocal.  The input PSRN may have a positive or negative sign, and it is assumed that its integer part and sign were sampled.  All divisions mentioned here should be done using rational arithmetic. <em>Python code implementing this algorithm is given later in this document.</em></p>

<ol>
<li>If <strong>a</strong> has unsampled digits before the last sampled digit in its fractional part, set each of those unsampled digits to a digit chosen uniformly at random.   Now, let <em>digitcount</em> be the number of digits in <strong>a</strong>&#39;s fractional part.</li>
<li>Create a uniform PSRN, call it <em>ret</em>.  Set <em>ret</em>&#39;s sign to <strong>a</strong>&#39;s sign.  Let <em>base</em> be the base of digits stored in <strong>a</strong>&#39;s fractional part (such as 2 for binary or 10 for decimal).</li>
<li>If <strong>a</strong> has no non-zero digit in its fractional part, and has an integer part of 0, then append a digit chosen uniformly at random to <strong>a</strong>&#39;s fractional part. If that digit is 0, repeat this step. (This step is crucial for correctness when both PSRNs&#39; intervals cover the number 0, since the distribution of their product is different from the usual case.)</li>
<li>Let <em>afp</em> be <strong>a</strong>&#39;s integer and fractional parts packed into an integer, as explained in the example.  (For example, if <strong>a</strong> represents the number 83.12344..., <em>afp</em> is 8312344.)</li>
<li>(Calculate lower and upper bounds of 1/<strong>a</strong>, disregarding <strong>a</strong>&#39;s sign.)  Set <em>dcount</em> to <em>digitcount</em>, then set <em>ddc</em> to <em>base</em><sup><em>dcount</em></sup>, then set <em>lower</em> to (<em>ddc</em>/(<em>afp</em>+1)), then set <em>upper</em> to (<em>ddc</em>/<em>afp</em>).</li>
<li>Set <em>lowerdc</em> to floor(<em>lower</em>*<em>ddc</em>).  If <em>lowerdc</em> is 0, add 1 to <em>dcount</em>, multiply <em>ddc</em> by <em>base</em>, then repeat this step. (This step too is important for correctness.)</li>
<li>(<em>rv</em> represents a tight interval between the lower and upper bounds, and <em>rv2</em> represents a uniform(0, 1) random variate to compare with the density function for the reciprocal.) Set <em>rv</em> to a uniform random integer in the interval [<em>lowerdc</em>, floor(<em>upper</em>*<em>ddc</em>)).  Set <em>rv2</em> to a uniform random integer in the interval [0, <em>lowerdc</em>).</li>
<li>(Get the bounds of the tight interval <em>rv</em>.) Set <em>rvlower</em> to <em>rv</em>/<em>ddc</em>, then set <em>rvupper</em> to (<em>rv</em>+1)/<em>ddc</em>.</li>
<li>If <em>rvlower</em> is greater than or equal to <em>lower</em> and <em>rvupper</em> is less than <em>upper</em>:

<ol>
<li>Set <em>rvd</em> to <em>lowerdc</em>/<em>ddc</em>, then set <em>rvlower2</em> to <em>rv2</em>/<em>lowerdc</em>, then set <em>rvupper2</em> to (<em>rv2</em>+1)/<em>lowerdc</em>. (<em>rvlower2</em> and <em>rvupper2</em> are bounds of the uniform(0, 1) variate.)</li>
<li>(Compare with upper bounded density: <em>y</em><sup>2</sup>/<em>x</em><sup>2</sup>, where <em>y</em> is the lower bound of 1/<strong>a</strong> and <em>x</em> is between the lower and upper bounds.) If <em>rvupper2</em> is less than (<em>rvd</em>*<em>rvd</em>)/(<em>rvupper</em>*<em>rvupper</em>), then the algorithm is almost done, so do the following: Transfer the <em>dcount</em> least significant digits of <em>rv</em> to <em>ret</em>&#39;s fractional part (note that <em>ret</em>&#39;s fractional part stores digits from most to least significant), then set <em>ret</em>&#39;s integer part to floor(<em>rv</em>/<em>base</em><sup><em>dcount</em></sup>), then return <em>ret</em>. (For example, if <em>base</em> is 10, <em>dcount</em> is 4, and <em>rv</em> is 342978, then <em>ret</em>&#39;s fractional part is set to [2, 9, 7, 8], and <em>ret</em>&#39;s integer part is set to 34.)</li>
<li>(Compare with lower bounded density.) If <em>rvlower2</em> is greater than (<em>rvd</em>*<em>rvd</em>)/(<em>rvlower</em>*<em>rvlower</em>), then abort these substeps and go to step 5. (This is a rejection event.)</li>
</ol></li>
<li>If <em>rvlower</em> is greater than <em>upper</em> or if <em>rvupper</em> is less than <em>lower</em>, go to step 5. (This is a rejection event.)</li>
<li>Multiply <em>rv</em>, <em>rv2</em>, <em>lowerdc</em>, and <em>ddc</em> each by <em>base</em>, then add 1 to <em>dcount</em>, then add a digit chosen uniformly at random to <em>rv</em>, then add a digit chosen uniformly at random to <em>rv2</em>, then go to step 8.</li>
</ol>

<p>With this algorithm it&#39;s now trivial to describe an algorithm for dividing one uniform PSRN <strong>a</strong> by another uniform PSRN <strong>b</strong>, here called <strong>UniformDivide</strong>:</p>

<ol>
<li>Run the <strong>UniformReciprocal</strong> algorithm on <strong>b</strong> to create a new uniform PSRN <strong>c</strong>.</li>
<li>If <strong>c</strong>&#39;s fractional part has no digits or all of them are zeros, append uniform random digits to <strong>c</strong> until a nonzero digit is appended this way.</li>
<li>Run the <strong>UniformMultiply</strong> algorithm (given in the appendix) on <strong>a</strong> and <strong>b</strong>, in that order, and return the result of that algorithm.</li>
</ol>

<p>It&#39;s likewise trivial to describe an algorithm for multiplying a uniform PSRN <strong>a</strong> by a nonzero rational number <strong>b</strong>, here called <strong>UniformDivideRational</strong>:</p>

<ol>
<li>If <strong>b</strong> is 0, return an error.</li>
<li>Run the <strong>UniformMultiplyRational</strong> algorithm on <strong>a</strong> and 1/<strong>b</strong>, in that order, and return the result of that algorithm.</li>
</ol>

<p><a id=Using_the_Arithmetic_Algorithms></a></p>

<h3>Using the Arithmetic Algorithms</h3>

<p>The algorithms given above for addition and multiplication are useful for scaling and shifting PSRNs.  For example, they can transform a normally-distributed PSRN into one with an arbitrary mean and standard deviation (by first multiplying the PSRN by the standard deviation, then adding the mean).  Here is a sketch of a procedure that achieves this, given two parameters, <em>location</em> and <em>scale</em>, that are both rational numbers.</p>

<ol>
<li>Generate a uniform PSRN, then transform it into a variate of the desired distribution via an algorithm that employs rejection from the uniform distribution (such as Karney&#39;s algorithm for the standard normal distribution (Karney 2016)[^1])).  This procedure won&#39;t work for exponential PSRNs (e-rands).</li>
<li>Run the <strong>UniformMultiplyRational</strong> algorithm to multiply the uniform PSRN by the rational parameter <em>scale</em> to get a new uniform PSRN.</li>
<li>Run the <strong>UniformAddRational</strong> algorithm to add the new uniform PSRN and the rational parameter <em>location</em> to get a third uniform PSRN.  Return this third PSRN.</li>
</ol>

<p>See also the section &quot;Discussion&quot; later in this article.</p>

<p><a id=Comparisons></a></p>

<h3>Comparisons</h3>

<p>Two PSRNs, each of a different distribution but storing digits of the same base (radix), can be exactly compared to each other using algorithms similar to those in this section.</p>

<p>The <strong>RandLess</strong> algorithm compares two PSRNs, <strong>a</strong> and <strong>b</strong> (and samples additional bits from them as necessary) and returns 1 if <strong>a</strong> turns out to be less than <strong>b</strong> with probability 1, or 0 otherwise (see also (Karney 2016)[^1])).</p>

<ol>
<li>If <strong>a</strong>&#39;s integer part wasn&#39;t sampled yet, sample <strong>a</strong>&#39;s integer part according to the kind of PSRN <strong>a</strong> is.  Do the same for <strong>b</strong>.</li>
<li>If <strong>a</strong>&#39;s sign is different from <strong>b</strong>&#39;s sign, return 1 if <strong>a</strong>&#39;s sign is negative and 0 if it&#39;s positive.  If <strong>a</strong>&#39;s sign is positive, return 1 if <strong>a</strong>&#39;s integer part is less than <strong>b</strong>&#39;s, or 0 if greater.  If <strong>a</strong>&#39;s sign is negative, return 0 if <strong>a</strong>&#39;s integer part is less than <strong>b</strong>&#39;s, or 1 if greater.</li>
<li>Set <em>i</em> to 0.</li>
<li>If the digit at position <em>i</em> of <strong>a</strong>&#39;s fractional part is unsampled, set the digit at that position according to the kind of PSRN <strong>a</strong> is. (Positions start at 0 where 0 is the most significant digit after the point, 1 is the next, etc.)  Do the same for <strong>b</strong>.</li>
<li>Let <em>da</em> be the digit at position <em>i</em> of <strong>a</strong>&#39;s fractional part, and let <em>db</em> be <strong>b</strong>&#39;s corresponding digit.</li>
<li>If <strong>a</strong>&#39;s sign is positive, return 1 if <em>da</em> is less than <em>db</em>, or 0 if <em>da</em> is greater than <em>db</em>.</li>
<li>If <strong>a</strong>&#39;s sign is negative, return 0 if <em>da</em> is less than <em>db</em>, or 1 if <em>da</em> is greater than <em>db</em>.</li>
<li>Add 1 to <em>i</em> and go to step 4.</li>
</ol>

<p><strong>URandLess</strong> is a version of <strong>RandLess</strong> that involves two uniform PSRNs.  The algorithm for <strong>URandLess</strong> samples digit <em>i</em> in step 4 by setting the digit at position <em>i</em> to a digit chosen uniformly at random. (For example, if <strong>a</strong> is a uniform PSRN that stores base-2 or binary digits, this can be done by setting the digit at that position to an unbiased random bit.)</p>

<blockquote>
<p><strong>Note</strong>: To sample the <strong>maximum</strong> of two uniform random variate in the interval [0, 1], or the <strong>square root</strong> of a uniform random variate in the interval [0, 1]: (1) Generate two uniform PSRNs <strong>a</strong> and <strong>b</strong> each with a positive sign, an integer part of 0, and an empty fractional part. (2) Run <strong>RandLess</strong> on <strong>a</strong> and <strong>b</strong> in that order.  If the call returns 0, return <strong>a</strong>; otherwise, return <strong>b</strong>.</p>
</blockquote>

<p>The <strong>RandLessThanReal</strong> algorithm compares a PSRN <strong>a</strong> with a real number <strong>b</strong> and returns 1 if <strong>a</strong> turns out to be less than <strong>b</strong> with probability 1, or 0 otherwise.  This algorithm samples digits of <strong>a</strong>&#39;s fractional part as necessary.  This algorithm works whether <strong>b</strong> is known to be a rational number or not (for example, <strong>b</strong> can be the result of an expression such as <code>exp(-2)</code> or <code>ln(20)</code>), but the algorithm notes how it can be more efficiently implemented if <strong>b</strong> is known to be a rational number.</p>

<ol>
<li>If <strong>a</strong>&#39;s integer part or sign is unsampled, return an error.</li>
<li>Set <em>bs</em> to &minus;1 if <strong>b</strong> is less than 0, or 1 otherwise. Calculate floor(abs(<strong>b</strong>)), and set <em>bi</em> to the result. (<em>If <strong>b</strong> is known rational:</em> Then set <em>bf</em> to abs(<strong>b</strong>) minus <em>bi</em>.)</li>
<li>If <strong>a</strong>&#39;s sign is different from <em>bs</em>&#39;s sign, return 1 if <strong>a</strong>&#39;s sign is negative and 0 if it&#39;s positive.  If <strong>a</strong>&#39;s sign is positive, return 1 if <strong>a</strong>&#39;s integer part is less than <em>bi</em>, or 0 if greater. (Continue if both are equal.)  If <strong>a</strong>&#39;s sign is negative, return 0 if <strong>a</strong>&#39;s integer part is less than <em>bi</em>, or 1 if greater. (Continue if both are equal.)</li>
<li>Set <em>i</em> to 0.</li>
<li>If the digit at position <em>i</em> of <strong>a</strong>&#39;s fractional part is unsampled, set the digit at that position according to the kind of PSRN <strong>a</strong> is. (Positions start at 0 where 0 is the most significant digit after the point, 1 is the next, etc.)</li>
<li>Calculate the base-<em>&beta;</em> digit at position <em>i</em> of <strong>b</strong>&#39;s fractional part, and set <em>d</em> to that digit. (<em>If <strong>b</strong> is known rational:</em> Do this step by multiplying <em>bf</em> by <em>&beta;</em>, then setting <em>d</em> to floor(<em>bf</em>), then subtracting <em>d</em> from <em>bf</em>.)</li>
<li>Let <em>ad</em> be the digit at position <em>i</em> of <strong>a</strong>&#39;s fractional part.</li>
<li>Return 1 if&mdash;

<ul>
<li><em>ad</em> is less than <em>d</em> and <strong>a</strong>&#39;s sign is positive,</li>
<li><em>ad</em> is greater than <em>d</em> and <strong>a</strong>&#39;s sign is negative, or</li>
<li><em>ad</em> is equal to <em>d</em>, <strong>a</strong>&#39;s sign is negative, and&mdash;

<ul>
<li><em><strong>b</strong> is not known to be rational</em> and all the digits after the digit at position <em>i</em> of <strong>b</strong>&#39;s fractional part are zeros (indicating <strong>a</strong> is less than <strong>b</strong> with probability 1), or</li>
<li><em><strong>b</strong> is known to be rational</em> and <em>bf</em> is 0 (indicating <strong>a</strong> is less than <strong>b</strong> with probability 1).</li>
</ul></li>
</ul></li>
<li>Return 0 if&mdash;

<ul>
<li><em>ad</em> is less than <em>d</em> and <strong>a</strong>&#39;s sign is negative,</li>
<li><em>ad</em> is greater than <em>d</em> and <strong>a</strong>&#39;s sign is positive, or</li>
<li><em>ad</em> is equal to <em>d</em>, <strong>a</strong>&#39;s sign is positive, and&mdash;

<ul>
<li><em><strong>b</strong> is not known to be rational</em> and all the digits after the digit at position <em>i</em> of <strong>b</strong>&#39;s fractional part are zeros (indicating <strong>a</strong> is greater than <strong>b</strong> with probability 1), or</li>
<li><em><strong>b</strong> is known to be rational</em> and <em>bf</em> is 0 (indicating <strong>a</strong> is greater than <strong>b</strong> with probability 1).</li>
</ul></li>
</ul></li>
<li>Add 1 to <em>i</em> and go to step 5.</li>
</ol>

<p>An alternative version of steps 6 through 9 in the algorithm above are as follows (see also (Brassard et al. 2019)[^20]):</p>

<ul>
<li>(6.) Calculate <em>bp</em>, which is an approximation to <strong>b</strong> such that abs(<strong>b</strong> &minus; <em>bp</em>) &lt;= <em>&beta;</em><sup>&minus;<em>i</em> &minus; 1</sup>, and such that <em>bp</em> has the same sign as <strong>b</strong>.  Let <em>bk</em> be <em>bp</em>&#39;s digit expansion up to the <em>i</em> + 1 digits after the point (ignoring its sign).  For example, if <strong>b</strong> is &pi; or &minus;&pi;, <em>&beta;</em> is 10, and <em>i</em> is 4, one possibility is <em>bp</em> = 3.14159 and <em>bk</em> = 314159.</li>
<li>(7.) Let <em>ak</em> be <strong>a</strong>&#39;s digit expansion up to the <em>i</em> + 1 digits after the point (ignoring its sign).</li>
<li>(8.) If <em>ak</em> &lt;= <em>bk</em> &minus; 2, return either 1 if <strong>a</strong>&#39;s sign is positive or 0 otherwise.</li>
<li>(9.) If <em>ak</em> &gt;= <em>bk</em> + 1, return either 1 if <strong>a</strong>&#39;s sign is negative or 0 otherwise.[^21]</li>
</ul>

<p><strong>URandLessThanReal</strong> is a version of <strong>RandLessThanReal</strong> in which <strong>a</strong> is a uniform PSRN.  The algorithm for <strong>URandLessThanReal</strong> samples digit <em>i</em> in step 4 by setting the digit at position <em>i</em> to a digit chosen uniformly at random.</p>

<p>The following shows how to implement <strong>URandLessThanReal</strong> when <strong>b</strong> is a fraction known by its numerator and denominator, <em>num</em>/<em>den</em>.</p>

<ol>
<li>If <strong>a</strong>&#39;s integer part or sign is unsampled, or if <em>den</em> is 0, return an error.  Then, if <em>num</em> and <em>den</em> are both less than 0, set them to their absolute values.  Then if <strong>a</strong>&#39;s sign is positive, its integer part is 0, and <em>num</em> is 0, return 0.  Then if <strong>a</strong>&#39;s sign is positive, its integer part is 0, and <em>num</em>&#39;s sign is different from <em>den</em>&#39;s sign, return 0.</li>
<li>Set <em>bs</em> to &minus;1 if <em>num</em> or <em>den</em>, but not both, is less than 0, or 1 otherwise, then set <em>den</em> to abs(<em>den</em>), then set <em>bi</em> to floor(abs(<em>num</em>)/<em>den</em>), then set <em>num</em> to rem(abs(<em>num</em>), <em>den</em>).</li>
<li>If <strong>a</strong>&#39;s sign is different from <em>bs</em>&#39;s sign, return 1 if <strong>a</strong>&#39;s sign is negative and 0 if it&#39;s positive.  If <strong>a</strong>&#39;s sign is positive, return 1 if <strong>a</strong>&#39;s integer part is less than <em>bi</em>, or 0 if greater. (Continue if both are equal.)  If <strong>a</strong>&#39;s sign is negative, return 0 if <strong>a</strong>&#39;s integer part is less than <em>bi</em>, or 1 if greater. (Continue if both are equal.)  If <em>num</em> is 0 (indicating the fraction is an integer), return 0 if <strong>a</strong>&#39;s sign is positive and 1 otherwise.</li>
<li>Set <em>pt</em> to <em>base</em>, and set <em>i</em> to 0. (<em>base</em> is the base, or radix, of <strong>a</strong>&#39;s digits, such as 2 for binary or 10 for decimal.)</li>
<li>Set <em>d1</em> to the digit at the <em>i</em><sup>th</sup> position (starting from 0) of <strong>a</strong>&#39;s fractional part.  If the digit at that position is unsampled, put a digit chosen uniformly at random at that position and set <em>d1</em> to that digit.</li>
<li>Set <em>c</em> to 1 if <em>num</em> * <em>pt</em> &gt;= <em>den</em>, and 0 otherwise.</li>
<li>Set <em>d2</em> to floor(<em>num</em> * <em>pt</em> / <em>den</em>).  (In base 2, this is equivalent to setting <em>d2</em> to <em>c</em>.)</li>
<li>If <em>d1</em> is less than <em>d2</em>, return either 1 if <strong>a</strong>&#39;s sign is positive, or 0 otherwise.  If <em>d1</em> is greater than <em>d2</em>, return either 0 if <strong>a</strong>&#39;s sign is positive, or 1 otherwise.</li>
<li>If <em>c</em> is 1, set <em>num</em> to <em>num</em> * <em>pt</em> &minus; <em>den</em> * <em>d2</em>, then multiply <em>den</em> by <em>pt</em>.</li>
<li>If <em>num</em> is 0, return either 0 if <strong>a</strong>&#39;s sign is positive, or 1 otherwise.</li>
<li>Multiply <em>pt</em> by <em>base</em>, add 1 to <em>i</em>, and go to step 5.</li>
</ol>

<p><a id=Discussion></a></p>

<h3>Discussion</h3>

<p>This section discusses issues involving arithmetic with PSRNs.</p>

<p><strong>Uniform PSRN arithmetic produces non-uniform distributions in general.</strong> As can be seen in the arithmetic algorithms earlier in this section (such as <strong>UniformAdd</strong> and <strong>UniformMultiplyRational</strong>), addition, multiplication, and other arithmetic operations with PSRNs (see also (Brassard et al., 2019)[^20]) are not as trivial as adding, multiplying, etc. their integer and fractional parts.  A uniform PSRN is ultimately a uniform random variate inside an interval (this is its nature), yet arithmetic on random variates does not produce a uniform distribution in general.</p>

<p>An example illustrates this. Say we have two uniform PSRNs: <em>A</em> = 0.12345... and <em>B</em> = 0.38901....  They represent random variates in the intervals <em>AI</em> = [0.12345, 0.12346] and <em>BI</em> = [0.38901, 0.38902], respectively.  Adding two uniform PSRNs is akin to adding their intervals (using interval arithmetic), so that in this example, the result <em>C</em> lies in <em>CI</em> = [0.12345 + 0.38901, 0.12346 + 0.38902] = [0.51246, 0.51248].  However, the resulting random variate is <em>not</em> uniformly distributed in [0.51246, 0.51248], so that simply choosing a uniform random variate in the interval won&#39;t work.  (This is true in general for other arithmetic operations besides addition.)  This can be demonstrated by generating many pairs of uniform random variates in the intervals <em>AI</em> and <em>BI</em>, summing the numbers in each pair, and building a histogram using the sums (which will all lie in the interval <em>CI</em>).  In this case, the histogram will show a triangular distribution that peaks at 0.51247.</p>

<p>The example applies in general to most other math operations besides addition (including multiplication, division, <code>log</code>, <code>sin</code>, and so on): do the math operation on the intervals <em>AI</em> and <em>BI</em>, and build a histogram of random results (products, quotients, etc.) that lie in the resulting interval to find out what distribution forms this way.</p>

<p><strong>Implementing other operations.</strong> In contrast to addition, multiplication, and division, certain other math operations are trivial to carry out in PSRNs.  They include negation, as mentioned in (Karney 2016)[^1], and operations affecting the PSRN&#39;s integer part only.</p>

<p>A promising way to connect PSRNs with other math operations (such as multiplication, <code>ln</code>, and <code>exp</code>) is to use &quot;constructive reals&quot; or &quot;recursive reals&quot;.  See the section &quot;Relation to Constructive Reals&quot;, earlier.</p>

<p>A sampler can be created that uses the probabilities of getting each digit under the target distribution.  But if the distribution is non-discrete:</p>

<ul>
<li>These probabilities will depend on previous digits except for a very limited class of distributions (including uniform and exponential); see the <a href="#Setting_Digits_by_Digit_Probabilities"><strong>appendix</strong></a> for details.</li>
<li>For distributions outside that limited class, the sampler will be <em>limited-precision</em> (not <em>arbitrary-precision</em>) in practice, since it can hold only so many digit probabilities.  For example, the works (Habibizad Navin et al., 2007)[^22], (Nezhad et al., 2013)[^23] point to building a &quot;tree&quot; of such digit probabilities. [^24]</li>
</ul>

<p>Finally, arithmetic with PSRNs may be possible if the result of the arithmetic is distributed with a known probability density function (PDF), allowing for an algorithm that implements rejection from the uniform or exponential distribution.  An example of this is found in the <strong>UniformReciprocal</strong> algorithm above or in in my article on <a href="https://peteroupc.github.io/uniformsum.html"><strong>arbitrary-precision samplers for the sum of uniform random variates</strong></a>.  However, that PDF may have an unbounded peak, thus ruling out rejection sampling in practice.  For example, if <em>X</em> is a uniform PSRN in the interval [0, 1], then the distribution of <em>X</em><sup>3</sup> has the PDF <code>(1/3) / pow(X, 2/3)</code>, which has an unbounded peak at 0.  While this rules out plain rejection samplers for <em>X</em><sup>3</sup> in practice, it&#39;s still possible to sample powers of uniforms using PSRNs, which will be described later in this article.</p>

<p><strong>Reusing PSRNs.</strong> The arithmetic algorithms in this section may give incorrect results if the <em>same PSRN</em> is used more than once in different runs of these algorithms.</p>

<p>This issue happens in general when the original sampler uses the same random variate for different purposes in the algorithm (an example is &quot;<em>W</em>*<em>Y</em>, (1&minus;<em>W</em>)*<em>Y</em>&quot;, where <em>W</em> and <em>Y</em> are independent random variates (Devroye 1986, p. 394)[^25]).  In this case, if one PSRN spawns additional PSRNs (so that they become <em>dependent</em> on the first), those additional PSRNs may become inaccurate once additional digits of the first PSRN are sampled uniformly at random. (This is not always the case, but it&#39;s hard to characterize when the additional PSRNs become inaccurate this way and when not.)</p>

<p>This issue is easy to see for the <strong>UniformAddRational</strong> or <strong>UniformMultiplyRational</strong> algorithm when it&#39;s called more than once with the same PSRN and the same rational number:  although the same random variate ought to be returned each time, in reality different variates will be generated this way with probability 1, especially when additional digits are sampled from them afterwards.</p>

<p>It might be believed that the issue just described could be solved by the algorithm below:</p>

<p><em>Assume we want to multiply the same PSRN by different numbers.  Let vec be a vector of rational numbers to multiply the same PSRN by, and let vec[i] be the rational number at position i of the vector (positions start at 0).</em></p>

<ol>
<li><em>Set i to 0, set <strong>a</strong> to the input PSRN, set num to vec[i], and set &#39;output&#39; to an empty list.</em></li>
<li><em>Set ret to the result of <strong>UniformMultiplyRational</strong> with the PSRN <strong>a</strong> and the rational number num.</em></li>
<li><em>Add a pointer to ret to the list &#39;output&#39;.  If vec[i] was the last number in the vector, stop this algorithm.</em></li>
<li><em>Set <strong>a</strong> to point to ret, then add 1 to i, then set num to vec[i]/vec[i&minus;1], then go to step 2.</em></li>
</ol>

<p>However, even this algorithm doesn&#39;t ensure that the output PSRNs will be exactly proportional to the same random variate.  An example: Let <strong>a</strong> be the PSRN 0.... (or the interval [0.0, 1.0]), then let <strong>b</strong> be the result of <strong>UniformMultiplyRational</strong>(<strong>a</strong>, 1/2), then let <strong>c</strong> be the result of <strong>UniformMultiplyRational</strong>(<strong>b</strong>, 1/3).  One possible result for <strong>b</strong> is 0.41... and for <strong>c</strong> is 0.138.... Now we fill <strong>a</strong>, <strong>b</strong>, and <strong>c</strong> with uniform random bits.  Thus, as one possible result, <strong>a</strong> is now 0.13328133..., <strong>b</strong> is now 0.41792367..., and <strong>c</strong> is now 0.13860371....  Here, however, <strong>c</strong> divided by <strong>b</strong> is not exactly 1/3, although it&#39;s close, and <strong>b</strong> divided by <strong>a</strong> is far from 1/2 (especially since <strong>a</strong> was very coarse to begin with). Although this example shows PSRNs with decimal digits, the situation is worse with binary digits.</p>

<p><a id=Building_Blocks></a></p>

<h2>Building Blocks</h2>

<p>This document relies on several building blocks described in this section.</p>

<p>One of them is the &quot;geometric bag&quot; technique by Flajolet and others (2010)[^7], which generates heads or tails with a probability that is built up digit by digit.</p>

<p><a id=SampleGeometricBag></a></p>

<h3>SampleGeometricBag</h3>

<p>The algorithm <strong>SampleGeometricBag</strong> returns 1 with a probability built up by a uniform PSRN&#39;s fractional part.  (Flajolet et al., 2010)[^7] described an algorithm for the base-2 (binary) case, but that algorithm is difficult to apply to other digit bases.  Thus the following is a general version of the algorithm for any digit base.  For convenience, this algorithm ignores the PSRN&#39;s integer part and sign.</p>

<ol>
<li>Set <em>i</em> to 0, and set <strong>b</strong> to a uniform PSRN with a positive sign and an integer part of 0.</li>
<li>If the item at position <em>i</em> of the input PSRN&#39;s fractional part is unsampled (that is, not set to a digit), set the item at that position to a digit chosen uniformly at random, increasing the fractional part&#39;s capacity as necessary (positions start at 0 where 0 is the most significant digit after the point, 1 is the next, etc.), and append the result to that fractional part&#39;s digit expansion.  Do the same for <strong>b</strong>.</li>
<li>Let <em>da</em> be the digit at position <em>i</em> of the input PSRN&#39;s fractional part, and let <em>db</em> be the corresponding digit for <strong>b</strong>.  Return 0 if <em>da</em> is less than <em>db</em>, or 1 if <em>da</em> is greater than <em>db</em>.</li>
<li>Add 1 to <em>i</em> and go to step 2.</li>
</ol>

<p>For base 2, the following <strong>SampleGeometricBag</strong> algorithm can be used, which is closer to the one given in the Flajolet paper.  It likewise ignores the input PSRN&#39;s integer part and sign.</p>

<ol>
<li> Set <em>N</em> to 0.</li>
<li> With probability 1/2, go to the next step.  Otherwise, add 1 to <em>N</em> and repeat this step. (When the algorithm moves to the next step, <em>N</em> is what the Flajolet paper calls a <em>geometric</em> random variate (with parameter 1/2), hence the name &quot;geometric bag&quot;, but the terminology &quot;geometric random variate&quot; is avoided in this article since it has several conflicting meanings in academic works.)</li>
<li> If the item at position <em>N</em> in the uniform PSRN&#39;s fractional part (positions start at 0) is not set to a digit (for example, 0 or 1 for base 2), set the item at that position to a digit chosen uniformly at random (for example, either 0 or 1 for base 2), increasing the fractional part&#39;s capacity as necessary.  (As a result of this step, there may be &quot;gaps&quot; in the uniform PSRN where no digit was sampled yet.)</li>
<li> Return the item at position <em>N</em>.</li>
</ol>

<p>For more on why these two algorithms are equivalent, see the appendix.</p>

<p><strong>SampleGeometricBagComplement</strong> is the same as the <strong>SampleGeometricBag</strong> algorithm, except the return value is 1 minus the original return value.  The result is that if <strong>SampleGeometricBag</strong> outputs 1 with probability <em>U</em>, <strong>SampleGeometricBagComplement</strong> outputs 1 with probability 1 &minus; <em>U</em>.</p>

<p><a id=FillGeometricBag></a></p>

<h3>FillGeometricBag</h3>

<p><strong>FillGeometricBag</strong> takes a uniform PSRN and generates a number whose fractional part has <code>p</code> digits as follows:</p>

<ol>
<li>For each position in [0, <code>p</code>), if the item at that position in the uniform PSRN&#39;s fractional part is unsampled, set the item there to a digit chosen uniformly at random (for example, either 0 or 1 for binary), increasing the fractional part&#39;s capacity as necessary. (Positions start at 0 where 0 is the most significant digit after the point, 1 is the next, etc.  See also (Oberhoff 2018, sec. 8)[^13].)</li>
<li>Let <code>sign</code> be -1 if the PSRN&#39;s sign is negative, or 1 otherwise; let <code>ipart</code> be the PSRN&#39;s integer part; and let <code>bag</code> be the PSRN&#39;s fractional part.  Take the first <code>p</code> digits of <code>bag</code> and return <code>sign</code> * (<code>ipart</code> + bag[0] * <em>b</em><sup>&minus;0&minus;1</sup> + bag[1] * <em>b</em><sup>&minus;1&minus;1</sup> + ... + bag[<code>p</code>&minus;1] * <em>b</em><sup>&minus;(<code>p</code>&minus;1)&minus;1</sup>), where <em>b</em> is the base, or radix.</li>
</ol>

<p>After step 2, if it somehow happens that digits beyond <code>p</code> in the PSRN&#39;s fractional part were already sampled (that is, they were already set to a digit), then the implementation could choose instead to fill all unsampled digits between the first and the last set digit and return the full number, optionally rounding it to a number whose fractional part has <code>p</code> digits, with a rounding mode of choice. (For example, if <code>p</code> is 4, <em>b</em> is 10, and the PSRN is 0.3437500... or 0.3438500..., it could use a round-to-nearest mode to round the PSRN to the number 0.3438 or 0.3439, respectively; because this is a PSRN with an &quot;infinite&quot; but unsampled digit expansion, there is no tie-breaking such as &quot;ties to even&quot; applied here.)</p>

<p><a id=kthsmallest></a></p>

<h3>kthsmallest</h3>

<p>The <strong>kthsmallest</strong> method generates the &#39;k&#39;th smallest &#39;bitcount&#39;-digit uniform random variate in the interval [0, 1] out of &#39;n&#39; of them (also known as the &#39;n&#39;th <em>order statistic</em>), is also relied on by this beta sampler.  It is used when both <code>a</code> and <code>b</code> are integers, based on the known property that a beta random variate in this case is the <code>a</code>th smallest uniform random variate in the interval [0, 1] out of <code>a + b - 1</code> of them (Devroye 1986, p. 431)[^25].</p>

<p><strong>kthsmallest</strong>, however, doesn&#39;t simply generate &#39;n&#39; &#39;bitcount&#39;-digit numbers and then sort them.  Rather, it builds up their digit expansions digit by digit, via PSRNs.    It uses the observation that (in the binary case) each uniform random variate in the interval [0, 1] is either less than half or greater than half with equal probability; thus, the number of uniform numbers that are less than half vs. greater than half follows a binomial(n, 1/2) distribution (and of the numbers less than half, say, the less-than-one-quarter vs. greater-than-one-quarter numbers follows the same distribution, and so on).    Thanks to this observation, the algorithm can generate a sorted sample &quot;on the fly&quot;.  A similar observation applies to other bases than base 2 if we use the multinomial distribution instead of the binomial distribution.  I am not aware of any other article or paper (besides one by me) that describes the <strong>kthsmallest</strong> algorithm given here.</p>

<p>The algorithm is as follows:</p>

<ol>
<li>Create <code>n</code> uniform PSRNs with positive sign and an integer part of 0.</li>
<li>Set <code>index</code> to 1.</li>
<li>If <code>index &lt;= k</code> and <code>index + n &gt;= k</code>:

<ol>
<li>Generate <strong>v</strong>, a multinomial random vector with <em>b</em> probabilities equal to 1/<em>b</em>, where <em>b</em> is the base, or radix (for the binary case, <em>b</em> = 2, so this is equivalent to generating <code>LC</code>, a binomial random variate with parameters <code>n</code> and 0.5, and setting <strong>v</strong> to {<code>LC</code>, <code>n - LC</code>}).</li>
<li>Starting at <code>index</code>, append the digit 0 to the first <strong>v</strong>[0] PSRNs, a 1 digit to the next <strong>v</strong>[1] PSRNs, and so on to appending a <em>b</em> &minus; 1 digit to the last <strong>v</strong>[<em>b</em> &minus; 1] PSRNs (for the binary case, this means appending a 0 bit to the first <code>LC</code> PSRNs and a 1 bit to the next <code>n - LC</code> PSRNs).</li>
<li>For each integer <em>i</em> in [0, <em>b</em>): If <strong>v</strong>[<em>i</em>] &gt; 1, repeat step 3 and these substeps with <code>index</code> = <code>index</code> + <strong>v</strong>[0] + <strong>v</strong>[1] + ... + <strong>v</strong>[<em>i</em> &minus; 1] and <code>n</code> = <strong>v</strong>[<em>i</em>]. (For the binary case, this means: If <code>LC &gt; 1</code>, repeat step 3 and these substeps with the same <code>index</code> and <code>n = LC</code>; then, if <code>n - LC &gt; 1</code>, repeat step 3 and these substeps with <code>index = index + LC</code>, and <code>n = n - LC</code>).</li>
</ol></li>
<li>Take the <code>k</code>th PSRN (starting at 1), then optionally fill it with uniform random digits as necessary to give its fractional part <code>bitcount</code> many digits (similarly to <strong>FillGeometricBag</strong> above), then return that number.  (Note that the beta sampler  described later chooses to fill the PSRN this way via this algorithm.)</li>
</ol>

<p><a id=Power_of_Uniform_Sub_Algorithm></a></p>

<h3>Power-of-Uniform Sub-Algorithm</h3>

<p>The power-of-uniform sub-algorithm is used for certain cases of the beta sampler below.  It returns <em>U</em><sup><em>px</em>/<em>py</em></sup>, where <em>U</em> is a uniform random variate in the interval [0, 1] and <em>px</em>/<em>py</em> is greater than 1, but unlike the na√Øve algorithm it supports an arbitrary precision, uses only random bits, and avoids floating-point arithmetic.  It also uses a <em>complement</em> flag to determine whether to return 1 minus the result.</p>

<p>It makes use of a number of algorithms as follows:</p>

<ul>
<li>It uses an algorithm for <a href="https://peteroupc.github.io/randmisc.html"><strong>sampling unbounded monotone PDFs</strong></a>, which in turn is similar to the inversion-rejection algorithm in (Devroye 1986, ch. 7, sec. 4.4)[^25].  This is needed because when <em>px</em>/<em>py</em> is greater than 1, the distribution of <em>U</em><sup><em>px</em>/<em>py</em></sup> has the PDF <code>(py/px) / pow(U, 1-py/px)</code>, which has an unbounded peak at 0.</li>
<li>It uses a number of Bernoulli factory algorithms, including <strong>SampleGeometricBag</strong> and some algorithms described in &quot;<a href="https://peteroupc.github.io/bernoulli.html"><strong>Bernoulli Factory Algorithms</strong></a>&quot;.</li>
</ul>

<p>However, this algorithm currently only supports generating a PSRN with base-2 (binary) digits in its fractional part.</p>

<p>The power-of-uniform algorithm is as follows:</p>

<ol>
<li>Set <em>i</em> to 1.</li>
<li>Call the <strong>algorithm for (<em>a</em>/<em>b</em>)<sup><em>x</em>/<em>y</em></sup></strong> described in &quot;<a href="https://peteroupc.github.io/bernoulli.html"><strong>Bernoulli Factory Algorithms</strong></a>&quot;, with parameters <code>a = 1, b = 2, x = py, y = px</code>.  If the call returns 1 and <em>i</em> is less than <em>n</em>, add 1 to <em>i</em> and repeat this step.  If the call returns 1 and <em>i</em> is <em>n</em> or greater, return 1 if the <em>complement</em> flag is 1 or 0 otherwise (or return a uniform PSRN with a positive sign, an integer part of 0, and a fractional part filled with exactly <em>n</em> ones or zeros, respectively).</li>
<li>As a result, we will now sample a number in the interval [2<sup>&minus;<em>i</em></sup>, 2<sup>&minus;(<em>i</em> &minus; 1)</sup>).  We now have to generate a uniform random variate <em>X</em> in this interval, then accept it with probability (<em>py</em> / (<em>px</em> * 2<sup><em>i</em></sup>)) / <em>X</em><sup>1 &minus; <em>py</em> / <em>px</em></sup>; the 2<sup><em>i</em></sup> in this formula is to help avoid very low probabilities for sampling purposes.  The following steps will achieve this without having to use floating-point arithmetic.</li>
<li>Create a positive-sign zero-integer-part uniform PSRN, then create a <em>geobag</em> input coin that returns the result of <strong>SampleGeometricBag</strong> on that PSRN.</li>
<li>Create a <em>powerbag</em> input coin that does the following: &quot;Call the  <strong>algorithm for <em>&lambda;</em><sup><em>x</em>/<em>y</em></sup></strong>, described in &#39;<a href="https://peteroupc.github.io/bernoulli.html#lambda__x___y"><strong>Bernoulli Factory Algorithms</strong></a>&#39;, using the <em>geobag</em> input coin and with <em>x</em>/<em>y</em> = 1 &minus; <em>py</em> / <em>px</em>, and return the result.&quot;</li>
<li>Append <em>i</em> &minus; 1 zero-digits followed by a single one-digit to the PSRN&#39;s fractional part.  This will allow us to sample a uniform random variate limited to the interval mentioned earlier.</li>
<li>Call the <strong>algorithm for œµ / Œª</strong>, described in &quot;<a href="https://peteroupc.github.io/bernoulli.html#x03F5_lambda"><strong>Bernoulli Factory Algorithms</strong></a>&quot;, using the <em>powerbag</em> input coin (which represents <em>b</em>) and with œµ = <em>py</em>/(<em>px</em> * 2<sup><em>i</em></sup>) (which represents <em>a</em>), thus returning 1 with probability <em>a</em>/<em>b</em>.  If the call returns 1, the PSRN was accepted, so do the following:

<ol>
<li>If the <em>complement</em> flag is 1, make each zero-digit in the PSRN&#39;s fractional part a one-digit and vice versa.</li>
<li>Optionally, fill the PSRN with uniform random digits as necessary to give its fractional part <em>n</em> digits (similarly to <strong>FillGeometricBag</strong> above), where <em>n</em> is a precision parameter.  Then, return the PSRN.</li>
</ol></li>
<li>If the call to the algorithm for œµ / Œª returns 0, remove all but the first <em>i</em> digits from the PSRN&#39;s fractional part, then go to step 7.</li>
</ol>

<p><a id=Algorithms_for_the_Beta_and_Exponential_Distributions></a></p>

<h2>Algorithms for the Beta and Exponential Distributions</h2>

<p>&nbsp;</p>

<p><a id=Beta_Distribution></a></p>

<h3>Beta Distribution</h3>

<p>All the building blocks are now in place to describe a <em>new</em> algorithm to sample the beta distribution, described as follows.  It takes three parameters: <em>a</em> &gt;= 1 and <em>b</em> &gt;= 1 (or one parameter is 1 and the other is greater than 0 in the binary case) are the parameters to the beta distribution, and <em>p</em> &gt; 0 is a precision parameter.</p>

<ol>
<li>Special cases:

<ul>
<li>If <em>a</em> = 1 and <em>b</em> = 1, return a positive-sign zero-integer-part uniform PSRN.</li>
<li>If <em>a</em> and <em>b</em> are both integers, return the result of <strong>kthsmallest</strong> with <code>n = a - b + 1</code> and <code>k = a</code></li>
<li>In the binary case, if <em>a</em> is 1 and <em>b</em> is less than 1, call the <strong>power-of-uniform sub-algorithm</strong> described below, with <em>px</em>/<em>py</em> = 1/<em>b</em>, and the <em>complement</em> flag set to 1, and return the result of that algorithm as is (without filling it as described in substep 7.2 of that algorithm).</li>
<li>In the binary case, if <em>b</em> is 1 and <em>a</em> is less than 1, call the <strong>power-of-uniform sub-algorithm</strong> described below, with <em>px</em>/<em>py</em> = 1/<em>a</em>, and the <em>complement</em> flag set to 0, and return the result of that algorithm as is (without filling it as described in substep 7.2 of that algorithm).</li>
</ul></li>
<li>If <em>a</em> &gt; 2 and <em>b</em> &gt; 2, do the following steps, which split <em>a</em> and <em>b</em> into two parts that are faster to simulate (and implement the generalized rejection strategy in (Devroye 1986, top of page 47)[^25]):

<ol>
<li>Set <em>aintpart</em> to floor(<em>a</em>) &minus; 1, set <em>bintpart</em> to floor(<em>b</em>) &minus; 1, set <em>arest</em> to <em>a</em> &minus; <em>aintpart</em>, and set <em>brest</em> to <em>b</em> &minus; <em>bintpart</em>.</li>
<li>Do a separate (recursive) run of this algorithm, but with <em>a</em> = <em>aintpart</em> and <em>b</em> = <em>bintpart</em>. Set <em>bag</em> to the PSRN created by the run.</li>
<li>Create an input coin <em>geobag</em> that returns the result of <strong>SampleGeometricBag</strong> using the given PSRN.  Create another input coin <em>geobagcomp</em> that returns the result of <strong>SampleGeometricBagComplement</strong> using the given PSRN.</li>
<li>Call the <strong>algorithm for <em>&lambda;</em><sup><em>x</em>/<em>y</em></sup></strong>, described in &quot;<a href="https://peteroupc.github.io/bernoulli.html"><strong>Bernoulli Factory Algorithms</strong></a>&quot;, using the <em>geobag</em> input coin and <em>x</em>/<em>y</em> = <em>arest</em>/1, then call the same algorithm using the <em>geobagcomp</em> input coin and <em>x</em>/<em>y</em> = <em>brest</em>/1. If both calls return 1, return <em>bag</em>. Otherwise, go to substep 2.</li>
</ol></li>
<li>Create an positive-sign zero-integer-part uniform PSRN.  Create an input coin <em>geobag</em> that returns the result of <strong>SampleGeometricBag</strong> using the given PSRN.  Create another input coin <em>geobagcomp</em> that returns the result of <strong>SampleGeometricBagComplement</strong> using the given PSRN.</li>
<li>Remove all digits from the PSRN&#39;s fractional part.  This will result in an &quot;empty&quot; uniform random variate in the interval [0, 1], <em>U</em>, for the following steps, which will accept <em>U</em> with probability <em>U</em><sup>a&minus;1</sup>*(1&minus;<em>U</em>)<sup>b&minus;1</sup>) (the proportional probability for the beta distribution), as <em>U</em> is built up.</li>
<li>Call the <strong>algorithm for <em>&lambda;</em><sup><em>x</em>/<em>y</em></sup></strong>, described in &quot;<a href="https://peteroupc.github.io/bernoulli.html"><strong>Bernoulli Factory Algorithms</strong></a>&quot;, using the <em>geobag</em> input coin and <em>x</em>/<em>y</em> = <em>a</em> &minus; 1)/1 (thus returning with probability <em>U</em><sup>a&minus;1</sup>).  If the result is 0, go to step 4.</li>
<li>Call the same algorithm using the <em>geobagcomp</em> input coin and <em>x</em>/<em>y</em> = (<em>b</em> &minus; 1)/1 (thus returning 1 with probability (1&minus;<em>U</em>)<sup>b&minus;1</sup>).  If the result is 0, go to step 4. (Note that this step and the previous step don&#39;t depend on each other and can be done in either order without affecting correctness, and this is taken advantage of in the Python code below.)</li>
<li><em>U</em> was accepted, so return the result of <strong>FillGeometricBag</strong>.</li>
</ol>

<p>Once a PSRN is accepted by the steps above, optionally fill the unsampled digits of the PSRN&#39;s fractional part with uniform random digits as necessary to give the number a <em>p</em>-digit fractional part (similarly to <strong>FillGeometricBag</strong>), then return the resulting number.</p>

<blockquote>
<p><strong>Notes:</strong></p>

<ul>
<li>A beta random variate with parameters 1/<em>x</em> and 1 is the same as a uniform random variate in [0, 1] raised to the power of <em>x</em>.</li>
<li>For the beta distribution, the bigger <code>alpha</code> or <code>beta</code> is, the smaller the area of acceptance becomes (and the greater the probability that random variates get rejected by steps 5 and 6, raising its run-time).  This is because <code>max(u^(alpha-1)*(1-u)^(beta-1))</code>, the peak of the PDF, approaches 0 as the parameters get bigger.  To deal with this, step 2 was included, which under certain circumstances breaks the PDF into two parts that are relatively trivial to sample (in terms of bit complexity).</li>
</ul>
</blockquote>

<p><a id=Exponential_Distribution></a></p>

<h3>Exponential Distribution</h3>

<p>We also have the necessary building blocks to describe how to sample e-rands.  An e-rand consists of four numbers: the first is a multiple of 1/(2<sup><em>k</em></sup>), the second is <em>k</em>, the third is the integer part (initially &minus;1 to indicate the integer part wasn&#39;t sampled yet), and the fourth is the <em>&lambda;</em> parameter. (Because exponential random variates are always 0 or greater, the e-rand&#39;s sign is implicitly positive.)  In the Python code, e-rands are as described, except <em>&lambda;</em> must be a rational number and its numerator and denominator take up a parameter each.</p>

<p>In the rest of this section, though, an e-rand&#39;s <em>&lambda;</em> parameter can be written as a rational number, as an integer and fractional part, or as a sum of components, as described in the section &quot;Sampling E-rands&quot;.</p>

<p>To sample bit <em>k</em> after the binary point of an exponential random variate with rate <em>&lambda;</em> (where <em>k</em> = 1 means the first digit after the point, <em>k</em> = 2 means the second, etc.), call the <strong>LogisticExp</strong> algorithm (see &quot;Sampling E-rands&quot;) with <em>&lambda;</em>=<em>&lambda;</em> and <em>prec</em> = <em>k</em>.</p>

<p>The <strong>ExpRandLess</strong> algorithm is a special case of the general <strong>RandLess</strong> algorithm given earlier.  It compares two e-rands <strong>a</strong> and <strong>b</strong> (and samples additional bits from them as necessary) and returns 1 if <strong>a</strong> turns out to be less than <strong>b</strong>, or 0 otherwise. (Note that <strong>a</strong> and <strong>b</strong> are allowed to have different <em>&lambda;</em> parameters.)</p>

<ol>
<li>If <strong>a</strong>&#39;s integer part wasn&#39;t sampled yet, call the <strong>ExpMinus</strong> algorithm (see &quot;Sampling E-rands&quot;) with <em>&lambda;</em>=<em>&lambda;</em>, until the call returns 0, then set the integer part to the number of times 1 was returned this way.  Do the same for <strong>b</strong>.</li>
<li>Return 1 if <strong>a</strong>&#39;s integer part is less than <strong>b</strong>&#39;s, or 0 if <strong>a</strong>&#39;s integer part is greater than <strong>b</strong>&#39;s.</li>
<li>Set <em>i</em> to 0.</li>
<li>If <strong>a</strong>&#39;s fractional part has <em>i</em> or fewer bits, call the <strong>LogisticExp</strong> algorithm (see &quot;Sampling E-rands&quot;) with <em>&lambda;</em>=<em>&lambda;</em> and <em>prec</em> = <em>i</em> + 1, and append the result to that fractional part&#39;s binary expansion.  (For example, if the implementation stores the binary expansion as a packed integer and a size, the implementation can shift the packed integer by 1, add the result of the algorithm to that integer, then add 1 to the size.) Do the same for <strong>b</strong>.</li>
<li>Return 1 if <strong>a</strong>&#39;s fractional part is less than <strong>b</strong>&#39;s, or 0 if <strong>a</strong>&#39;s fractional part is greater than <strong>b</strong>&#39;s.</li>
<li>Add 1 to <em>i</em> and go to step 4.</li>
</ol>

<p>The <strong>ExpRandFill</strong> algorithm takes an e-rand and generates a number whose fractional part has <code>p</code> digits as follows:</p>

<ol>
<li>For each position <em>i</em> in [0, <code>p</code>), if the item at that position in the e-rand&#39;s fractional part is unsampled, call the <strong>LogisticExp</strong> algorithm (see &quot;Sampling E-rands&quot;) with <em>&lambda;</em>=<em>&lambda;</em> and <em>prec</em> = = <em>i</em> + 1, and set the item at position <em>i</em> to the result (which will be either 0 or 1), increasing the fractional part&#39;s capacity as necessary. (Bit positions start at 0 where 0 is the most significant bit after the point, 1 is the next, etc.  See also (Oberhoff 2018, sec. 8)[^13].)</li>
<li>Let <code>sign</code> be -1 if the e-rand&#39;s sign is negative, or 1 otherwise; let <code>ipart</code> be the e-rand&#39;s integer part; and let <code>bag</code> be the PSRN&#39;s fractional part.  Take the first <code>p</code> digits of <code>bag</code> and return <code>sign</code> * (<code>ipart</code> + bag[0] * 2<sup>&minus;0&minus;1</sup> + bag[1] * 2<sup>&minus;1&minus;1</sup> + ... + bag[<code>p</code>&minus;1] * 2<sup>&minus;(<code>p</code>&minus;1)&minus;1</sup>).</li>
</ol>

<p>See the discussion in <strong>FillGeometricBag</strong> for advice on how to handle the case when if it somehow happens that bits beyond <code>p</code> in the PSRN&#39;s fractional part were already sampled (that is, they were already set to a digit) after step 2 of this algorithm.</p>

<p>Here is a third algorithm (called <strong>ExpRand</strong>) that generates a <em>uniform PSRN</em>, rather than an e-rand, that follows the exponential distribution.   In the algorithm, the rate <em>&lambda;</em> is given as a rational number greater than 0.  The method is based on von Neumann&#39;s algorithm (von Neumann 1951)[^9].</p>

<ol>
<li>Set <em>recip</em> to 1/<em>&lambda;</em>, and set <em>highpart</em> to 0.</li>
<li>Set <em>u</em> to the result of <strong>RandUniformFromReal</strong> with the parameter <em>recip</em>.</li>
<li>Set <em>val</em> to point to the same value as <em>u</em>, and set <em>accept</em> to 1.</li>
<li>Set <em>v</em> to the result of <strong>RandUniformFromReal</strong> with the parameter <em>recip</em>.</li>
<li>Run the <strong>URandLess</strong> algorithm on <em>u</em> and <em>v</em>, in that order.  If the call returns 0, set <em>u</em> to <em>v</em>, then set <em>accept</em> to 1 minus <em>accept</em>, then go to step 4.</li>
<li>If <em>accept</em> is 1, add <em>highpart</em> to <em>val</em> via the <strong>UniformAddRational</strong> algorithm given earlier, then return <em>val</em>.</li>
<li>Add <em>recip</em> to <em>highpart</em> and go to step 2.</li>
</ol>

<p>The following alternative version of the previous algorithm (called <strong>ExpRand2</strong>) includes Karney&#39;s improvement to the von Neumann algorithm (Karney 2016)[^1], namely a so-called &quot;early rejection step&quot;. The algorithm here allows an arbitrary rate parameter (<em>&lambda;</em>), given as a rational number greater than 0, unlike with the von Neumann and Karney algorithms, where <em>&lambda;</em> is 1.</p>

<ol>
<li>Set <em>recip</em> to 1/<em>&lambda;</em>, and set <em>highpart</em> to 0.</li>
<li>Set <em>u</em> to the result of <strong>RandUniformFromReal</strong> with the parameter <em>recip</em>.</li>
<li>Run the <strong>URandLessThanReal</strong> algorithm on <em>u</em> with the parameter <em>recip</em>/2.  If the call returns 0, add <em>recip</em>/2 to <em>highpart</em> and go to step 2.  (This is Karney&#39;s &quot;early rejection step&quot;, where the parameter is 1/2 when <em>&lambda;</em> is 1.  However, Fan et al. (2019)[^26] point out that the parameter 1/2 in Karney&#39;s &quot;early rejection step&quot; is not optimal.)</li>
<li>Set <em>val</em> to point to the same value as <em>u</em>, and set <em>accept</em> to 1.</li>
<li>Set <em>v</em> to the result of <strong>RandUniformFromReal</strong> with the parameter <em>recip</em>.</li>
<li>Run the <strong>URandLess</strong> algorithm on <em>u</em> and <em>v</em>, in that order.  If the call returns 0, set <em>u</em> to <em>v</em>, then set <em>accept</em> to 1 minus <em>accept</em>, then go to step 5.</li>
<li>If <em>accept</em> is 1, add <em>highpart</em> to <em>val</em> via the <strong>UniformAddRational</strong> algorithm given earlier, then return <em>val</em>.</li>
<li>Add <strong><em>recip</em>/2</strong> to <em>highpart</em> and go to step 2.</li>
</ol>

<blockquote>
<p><strong>Note:</strong> A Laplace (double exponential) random variate is then implemented by giving the PSRN returned by <strong>ExpRand</strong> or <strong>ExpRand2</strong> a random sign (with equal probability, the PSRN&#39;s sign is either positive or negative).</p>
</blockquote>

<p><a id=Sampler_Code></a></p>

<h2>Sampler Code</h2>

<p>The following Python code implements the beta sampler just described.  It relies on two Python modules I wrote:</p>

<ul>
<li>&quot;<a href="https://github.com/peteroupc/peteroupc.github.io/blob/master/bernoulli.py"><strong>bernoulli.py</strong></a>&quot;, which collects a number of Bernoulli factories, some of which are relied on by the code below.</li>
<li>&quot;<a href="https://github.com/peteroupc/peteroupc.github.io/blob/master/randomgen.py"><strong>randomgen.py</strong></a>&quot;, which collects a number of random variate generation methods, including <code>kthsmallest</code>, as well as the <code>RandomGen</code> class.</li>
</ul>

<p>Note that the code uses floating-point arithmetic only to convert the result of the sampler to a convenient form, namely a floating-point number.</p>

<p>This code is far from fast, though, at least in Python.</p>

<p>The Python code below supports only rational-valued <em>&lambda;</em> parameters in the exponential sampler.</p>

<pre>import math
import random
import bernoulli
from randomgen import RandomGen
from fractions import Fraction

def _toreal(ret, precision):
        # NOTE: Although we convert to a floating-point
        # number here, this is not strictly necessary and
        # is merely for convenience.
        return ret*1.0/(1&lt;&lt;precision)

def _urand_to_geobag(bag):
  return [(bag[0]&gt;&gt;(bag[1]-1-i))&amp;1 for i in range(bag[1])]

def _power_of_uniform_greaterthan1(bern, power, complement=False, precision=53):
    return bern.fill_geometric_bag(
        _power_of_uniform_greaterthan1_geobag(bern, power, complement), precision
    )

def _power_of_uniform_greaterthan1_geobag(bern, power, complement=False, precision=53):
   if power&lt;1:
     raise ValueError(&quot;Not supported&quot;)
   if power==1:
        return []  # Empty uniform random variate
   i=1
   powerfrac=Fraction(power)
   powerrest=Fraction(1) - Fraction(1)/powerfrac
   # Choose an interval
   while bern.zero_or_one_power_ratio(1,2,
         powerfrac.denominator,powerfrac.numerator) == 1:
      i+=1
   epsdividend = Fraction(1)/(powerfrac * 2**i)
   # -- A choice for epsdividend which makes eps_div
   # -- much faster, but this will require floating-point arithmetic
   # -- to calculate &quot;**powerrest&quot;, which is not the focus
   # -- of this article.
   # probx=((2.0**(-i-1))**powerrest)
   # epsdividend=Fraction(probx)*255/256
   bag=[]
   gb=lambda: bern.geometric_bag(bag)
   bf =lambda: bern.power(gb, powerrest.numerator, powerrest.denominator)
   while True:
      # Limit sampling to the chosen interval
      bag.clear()
      for k in range(i-1):
         bag.append(0)
      bag.append(1)
      # Simulate epsdividend / x**(1-1/power)
      if bern.eps_div(bf, epsdividend) == 1:
          # Flip all bits if complement is true
          bag=[x if x==None else 1-x for x in bag] if complement else bag
          return bag

def powerOfUniform(b, px, py, precision=53):
        # Special case of beta, returning power of px/py
        # of a uniform random variate, provided px/py
        # is in (0, 1].
        return betadist(b, py, px, 1, 1, precision)

    return b.fill_geometric_bag(
        betadist_geobag(b, ax, ay, bx, by), precision
    )

def betadist_geobag(b, ax=1, ay=1, bx=1, by=1):
    &quot;&quot;&quot; Generates a beta-distributed random variate with arbitrary
          (user-defined) precision.  Currently, this sampler only works if (ax/ay) and
          (bx/by) are both 1 or greater, or if one of these parameters is
         1 and the other is less than 1.
         - b: Bernoulli object (from the &quot;bernoulli&quot; module).
         - ax, ay: Numerator and denominator of first shape parameter.
         - bx, by: Numerator and denominator of second shape parameter.
         - precision: Number of bits after the point that the result will contain.
        &quot;&quot;&quot;
    # Beta distribution for alpha&gt;=1 and beta&gt;=1
    bag = []
    afrac=(Fraction(ax) if ay==1 else Fraction(ax, ay))
    bfrac=(Fraction(bx) if by==1 else Fraction(bx, by))
    bpower = bfrac - 1
    apower = afrac - 1
    # Special case for a=b=1
    if bpower == 0 and apower == 0:
        return bag
    # Special case if a=1
    if apower == 0 and bpower &lt; 0:
        return _power_of_uniform_greaterthan1_geobag(b, Fraction(by, bx), True)
    # Special case if b=1
    if bpower == 0 and apower &lt; 0:
        return _power_of_uniform_greaterthan1_geobag(b, Fraction(ay, ax), False)
    if apower &lt;= -1 or bpower &lt;= -1:
        raise ValueError
    # Special case if a and b are integers
    if int(bpower) == bpower and int(apower) == apower:
        a = int(afrac)
        b = int(bfrac)
        return _urand_to_geobag(randomgen.RandomGen().kthsmallest_psrn(a + b - 1, a))
    # Split a and b into two parts which are relatively trivial to simulate
    if bfrac &gt; 2 and afrac &gt; 2:
        bintpart = int(bfrac) - 1
        aintpart = int(afrac) - 1
        brest = bfrac - bintpart
        arest = afrac - aintpart
        # Generalized rejection method, p. 47
        while True:
           bag = betadist_geobag(b, aintpart, 1, bintpart, 1)
           gb = lambda: b.geometric_bag(bag)
           gbcomp = lambda: b.geometric_bag(bag) ^ 1
           if (b.power(gbcomp, brest)==1 and \
              b.power(gb, arest)==1):
              return bag
    # Create a &quot;geometric bag&quot; to hold a uniform random
    # number (U), described by Flajolet et al. 2010
    gb = lambda: b.geometric_bag(bag)
    # Complement of &quot;geometric bag&quot;
    gbcomp = lambda: b.geometric_bag(bag) ^ 1
    bp1=lambda: (1 if b.power(gbcomp, bpower)==1 and \
            b.power(gb, apower)==1 else 0)
    while True:
        # Create a uniform random variate (U) bit-by-bit, and
        # accept it with probability U^(a-1)*(1-U)^(b-1), which
        # is the unnormalized PDF of the beta distribution
        bag.clear()
        if bp1() == 1:
            # Accepted
            return ret

def _fill_geometric_bag(b, bag, precision):
        ret = 0
        lb = min(len(bag), precision)
        for i in range(lb):
            if i &gt;= len(bag) or bag[i] == None:
                ret = (ret &lt;&lt; 1) | b.rndint(1)
            else:
                ret = (ret &lt;&lt; 1) | bag[i]
        if len(bag) &lt; precision:
            diff = precision - len(bag)
            ret = (ret &lt;&lt; diff) | b.rndint((1 &lt;&lt; diff) - 1)
        # Now we have a number that is a multiple of
        # 2^-precision.
        return ret / (1 &lt;&lt; precision)

def exprandless(a, b):
        &quot;&quot;&quot; Determines whether one partially-sampled exponential number
           is less than another; returns
           true if so and false otherwise.  During
           the comparison, additional bits will be sampled in both numbers
           if necessary for the comparison. &quot;&quot;&quot;
        # Check integer part of exponentials
        if a[2] == -1:
            a[2] = 0
            while zero_or_one_exp_minus(a[3], a[4]) == 1:
                a[2] += 1
        if b[2] == -1:
            b[2] = 0
            while zero_or_one_exp_minus(b[3], b[4]) == 1:
                b[2] += 1
        if a[2] &lt; b[2]:
            return True
        if a[2] &gt; b[2]:
            return False
        index = 0
        while True:
            # Fill with next bit in a&#39;s exponential number
            if a[1] &lt; index:
                raise ValueError
            if b[1] &lt; index:
                raise ValueError
            if a[1] &lt;= index:
                a[1] += 1
                a[0] = logisticexp(a[3], a[4], index + 1) | (a[0] &lt;&lt; 1)
            # Fill with next bit in b&#39;s exponential number
            if b[1] &lt;= index:
                b[1] += 1
                b[0] = logisticexp(b[3], b[4], index + 1) | (b[0] &lt;&lt; 1)
            aa = (a[0] &gt;&gt; (a[1] - 1 - index)) &amp; 1
            bb = (b[0] &gt;&gt; (b[1] - 1 - index)) &amp; 1
            if aa &lt; bb:
                return True
            if aa &gt; bb:
                return False
            index += 1

def zero_or_one(px, py):
        &quot;&quot;&quot; Returns 1 at probability px/py, 0 otherwise.
            Uses Bernoulli algorithm from Lumbroso appendix B,
            with one exception noted in this code. &quot;&quot;&quot;
        if py &lt;= 0:
            raise ValueError
        if px == py:
            return 1
        z = px
        while True:
            z = z * 2
            if z &gt;= py:
                if random.randint(0,1) == 0:
                    return 1
                z = z - py
            # Exception: Condition added to help save bits
            elif z == 0: return 0
            else:
                if random.randint(0,1) == 0:
                   return 0

def zero_or_one_exp_minus(x, y):
        &quot;&quot;&quot; Generates 1 with probability exp(-px/py); 0 otherwise.
               Reference: Canonne et al. 2020. &quot;&quot;&quot;
        if y &lt;= 0 or x &lt; 0:
            raise ValueError
        if x==0: return 1
        if x &gt; y:
            xf = int(x / y)  # Get integer part
            x = x % y  # Reduce to fraction
            if x &gt; 0 and zero_or_one_exp_minus(x, y) == 0:
                return 0
            for i in range(xf):
                if zero_or_one_exp_minus(1, 1) == 0:
                    return 0
            return 1
        r = 1
        ii = 1
        while True:
            if zero_or_one(x, y*ii) == 0:
                return r
            r=1-r
            ii += 1

# Example of use
def exprand(lam):
   return exprandfill(exprandnew(lam),53)*1.0/(1&lt;&lt;53)

</pre>

<p>In the following Python code, <code>add_psrns</code> is a method to generate the result of multiplying or adding two uniform PSRNs, respectively.</p>

<pre>def psrn_reciprocal(psrn1, digits=2):
    &quot;&quot;&quot; Generates the reciprocal of a partially-sampled random number.
        psrn1: List containing the sign, integer part, and fractional part
            of the first PSRN.  Fractional part is a list of digits
            after the point, starting with the first.
        digits: Digit base of PSRNs&#39; digits.  Default is 2, or binary. &quot;&quot;&quot;
    if psrn1[0] == None or psrn1[1] == None:
        raise ValueError
    for i in range(len(psrn1[2])):
        psrn1[2][i] = (
            random.randint(0, digits - 1) if psrn1[2][i] == None else psrn1[2][i]
        )
    digitcount = len(psrn1[2])
    # Perform multiplication
    frac1 = psrn1[1]
    for i in range(digitcount):
        frac1 = frac1 * digits + psrn1[2][i]
    while frac1 == 0:
        # Avoid degenerate cases
        d1 = random.randint(0, digits - 1)
        psrn1[2].append(d1)
        frac1 = frac1 * digits + d1
        digitcount += 1
    while True:
        dcount = digitcount
        ddc = digits ** dcount
        small = Fraction(ddc, frac1 + 1)
        large = Fraction(ddc, frac1)
        if small&gt;large: raise ValueError
        if small==0: raise ValueError
        while True:
           dc = int(small * ddc)
           if dc!=0: break
           dcount+=1
           ddc*=digits
        if dc == 0:
             print([&quot;dc&quot;,dc,&quot;dc/ddc&quot;,float(Fraction(dc,ddc)),&quot;small&quot;,float(small),&quot;dcount&quot;,dcount,&quot;psrn&quot;,psrn1])
        dc2 = int(large * ddc) + 1
        rv = random.randint(dc, dc2 - 1)
        rvx = random.randint(0, dc - 1)
        # print([count,float(small), float(large),dcount, dc/ddc, dc2/ddc])
        while True:
            rvsmall = Fraction(rv, ddc)
            rvlarge = Fraction(rv + 1, ddc)
            if rvsmall &gt;= small and rvlarge &lt; large:
                rvd = Fraction(dc, ddc)
                rvxf = Fraction(rvx, dc)
                rvxf2 = Fraction(rvx + 1, dc)
                # print([&quot;dcs&quot;,rvx,&quot;rvsmall&quot;,float(rvsmall),&quot;rvlarge&quot;,float(rvlarge),&quot;small&quot;,float(small),
                #   &quot;rvxf&quot;,float(rvxf),float(rvxf2),&quot;rvd&quot;,float(rvd),
                #   &quot;sl&quot;,float((rvd*rvd)/(rvlarge*rvlarge)),float((rvd*rvd)/(rvsmall*rvsmall))])
                if rvxf2 &lt; (rvd * rvd) / (rvlarge * rvlarge):
                    cpsrn = [1, 0, [0 for i in range(dcount)]]
                    cpsrn[0] = psrn1[0]
                    sret = rv
                    for i in range(dcount):
                        cpsrn[2][dcount - 1 - i] = sret % digits
                        sret //= digits
                    cpsrn[1] = sret
                    return cpsrn
                elif rvxf &gt; (rvd * rvd) / (rvsmall * rvsmall):
                    break
            elif rvsmall &gt; large or rvlarge &lt; small:
                break
            rv = rv * digits + random.randint(0, digits - 1)
            rvx = rvx * digits + random.randint(0, digits - 1)
            dcount += 1
            ddc *= digits
            dc *= digits

def multiply_psrn_by_fraction(psrn1, fraction, digits=2):
    &quot;&quot;&quot; Multiplies a partially-sampled random number by a fraction.
        psrn1: List containing the sign, integer part, and fractional part
            of the first PSRN.  Fractional part is a list of digits
            after the point, starting with the first.
        fraction: Fraction to multiply by.
        digits: Digit base of PSRNs&#39; digits.  Default is 2, or binary. &quot;&quot;&quot;
    if psrn1[0] == None or psrn1[1] == None:
        raise ValueError
    fraction = Fraction(fraction)
    for i in range(len(psrn1[2])):
        psrn1[2][i] = (
            random.randint(0, digits - 1) if psrn1[2][i] == None else psrn1[2][i]
        )
    digitcount = len(psrn1[2])
    # Perform multiplication
    frac1 = psrn1[1]
    fracsign = -1 if fraction &lt; 0 else 1
    absfrac = abs(fraction)
    for i in range(digitcount):
        frac1 = frac1 * digits + psrn1[2][i]
    while True:
        dcount = digitcount
        ddc = digits ** dcount
        small = Fraction(frac1, ddc) * absfrac
        large = Fraction(frac1 + 1, ddc) * absfrac
        dc = int(small * ddc)
        dc2 = int(large * ddc) + 1
        rv = random.randint(dc, dc2 - 1)
        while True:
            rvsmall = Fraction(rv, ddc)
            rvlarge = Fraction(rv + 1, ddc)
            if rvsmall &gt;= small and rvlarge &lt; large:
                cpsrn = [1, 0, [0 for i in range(dcount)]]
                cpsrn[0] = psrn1[0] * fracsign
                sret = rv
                for i in range(dcount):
                    cpsrn[2][dcount - 1 - i] = sret % digits
                    sret //= digits
                cpsrn[1] = sret
                return cpsrn
            elif rvsmall &gt; large or rvlarge &lt; small:
                break
            else:
                rv = rv * digits + random.randint(0, digits - 1)
                dcount += 1
                ddc *= digits

def add_psrns(psrn1, psrn2, digits=2):
    &quot;&quot;&quot; Adds two uniform partially-sampled random numbers.
        psrn1: List containing the sign, integer part, and fractional part
            of the first PSRN.  Fractional part is a list of digits
            after the point, starting with the first.
        psrn2: List containing the sign, integer part, and fractional part
            of the second PSRN.
        digits: Digit base of PSRNs&#39; digits.  Default is 2, or binary. &quot;&quot;&quot;
    if psrn1[0] == None or psrn1[1] == None or psrn2[0] == None or psrn2[1] == None:
        raise ValueError
    for i in range(len(psrn1[2])):
        psrn1[2][i] = (
            random.randint(0, digits - 1) if psrn1[2][i] == None else psrn1[2][i]
        )
    for i in range(len(psrn2[2])):
        psrn2[2][i] = (
            random.randint(0, digits - 1) if psrn2[2][i] == None else psrn2[2][i]
        )
    while len(psrn1[2]) &lt; len(psrn2[2]):
        psrn1[2].append(random.randint(0, digits - 1))
    while len(psrn1[2]) &gt; len(psrn2[2]):
        psrn2[2].append(random.randint(0, digits - 1))
    digitcount = len(psrn1[2])
    if len(psrn2[2]) != digitcount:
        raise ValueError
    # Perform addition
    frac1 = psrn1[1]
    frac2 = psrn2[1]
    for i in range(digitcount):
        frac1 = frac1 * digits + psrn1[2][i]
    for i in range(digitcount):
        frac2 = frac2 * digits + psrn2[2][i]
    small = frac1 * psrn1[0] + frac2 * psrn2[0]
    mid1 = frac1 * psrn1[0] + (frac2 + 1) * psrn2[0]
    mid2 = (frac1 + 1) * psrn1[0] + frac2 * psrn2[0]
    large = (frac1 + 1) * psrn1[0] + (frac2 + 1) * psrn2[0]
    minv = min(small, mid1, mid2, large)
    maxv = max(small, mid1, mid2, large)
    # Difference is expected to be a multiple of two
    if abs(maxv - minv) % 2 != 0:
        raise ValueError
    vs = [small, mid1, mid2, large]
    vs.sort()
    midmin = vs[1]
    midmax = vs[2]
    while True:
        rv = random.randint(0, maxv - minv - 1)
        if rv &lt; 0:
            raise ValueError
        side = 0
        start = minv
        if rv &lt; midmin - minv:
            # Left side of sum density; rising triangular
            side = 0
            start = minv
        elif rv &gt;= midmax - minv:
            # Right side of sum density; falling triangular
            side = 1
            start = midmax
        else:
            # Middle, or uniform, part of sum density
            sret = minv + rv
            cpsrn = [1, 0, [0 for i in range(digitcount)]]
            if sret &lt; 0:
                sret += 1
                cpsrn[0] = -1
            sret = abs(sret)
            for i in range(digitcount):
                cpsrn[2][digitcount - 1 - i] = sret % digits
                sret //= digits
            cpsrn[1] = sret
            return cpsrn
        if side == 0:  # Left side
            pw = rv
            b = midmin - minv
        else:
            pw = rv - (midmax - minv)
            b = maxv - midmax
        newdigits = 0
        y = random.randint(0, b - 1)
        while True:
            lowerbound = pw if side == 0 else b - 1 - pw
            if y &lt; lowerbound:
                # Success
                sret = start * (digits ** newdigits) + pw
                cpsrn = [1, 0, [0 for i in range(digitcount + newdigits)]]
                if sret &lt; 0:
                    sret += 1
                    cpsrn[0] = -1
                sret = abs(sret)
                for i in range(digitcount + newdigits):
                    idx = (digitcount + newdigits) - 1 - i
                    while idx &gt;= len(cpsrn[2]):
                        cpsrn[2].append(None)
                    cpsrn[2][idx] = sret % digits
                    sret //= digits
                cpsrn[1] = sret
                return cpsrn
            elif y &gt; lowerbound + 1:  # Greater than upper bound
                # Rejected
                break
            pw = pw * digits + random.randint(0, digits - 1)
            y = y * digits + random.randint(0, digits - 1)
            b *= digits
            newdigits += 1

def add_psrn_and_fraction(psrn, fraction, digits=2):
    if psrn[0] == None or psrn[1] == None:
        raise ValueError
    fraction = Fraction(fraction)
    fracsign = -1 if fraction &lt; 0 else 1
    absfrac = abs(fraction)
    origfrac = fraction
    isinteger = absfrac.denominator == 1
    # Special cases
    # positive+pos. integer or negative+neg. integer
    if ((fracsign &lt; 0) == (psrn[0] &lt; 0)) and isinteger and len(psrn[2]) == 0:
        return [fracsign, psrn[1] + int(absfrac), []]
    # PSRN has no fractional part, fraction is integer
    if (
        isinteger
        and psrn[0] == 1
        and psrn[1] == 0
        and len(psrn[2]) == 0
        and fracsign &lt; 0
    ):
        return [fracsign, int(absfrac) - 1, []]
    if (
        isinteger
        and psrn[0] == 1
        and psrn[1] == 0
        and len(psrn[2]) == 0
        and fracsign &gt; 0
    ):
        return [fracsign, int(absfrac), []]
    if fraction == 0:  # Special case of 0
        return [psrn[0], psrn[1], [x for x in psrn[2]]]
    # End special cases
    for i in range(len(psrn[2])):
        psrn[2][i] = random.randint(0, digits - 1) if psrn[2][i] == None else psrn[2][i]
    digitcount = len(psrn[2])
    # Perform addition
    frac1 = psrn[1]
    frac2 = int(absfrac)
    fraction = absfrac - frac2
    for i in range(digitcount):
        frac1 = frac1 * digits + psrn[2][i]
    for i in range(digitcount):
        digit = int(fraction * digits)
        fraction = (fraction * digits) - digit
        frac2 = frac2 * digits + digit
    ddc = digits ** digitcount
    small = Fraction(frac1 * psrn[0], ddc) + origfrac
    large = Fraction((frac1 + 1) * psrn[0], ddc) + origfrac
    minv = min(small, large)
    maxv = max(small, large)
    while True:
        newdigits = 0
        b = 1
        ddc = digits ** digitcount
        mind = int(minv * ddc)
        maxd = int(maxv * ddc)
        rvstart = mind - 1 if minv &lt; 0 else mind
        rvend = maxd if maxv &lt; 0 else maxd + 1
        rv = random.randint(0, rvend - rvstart - 1)
        rvs = rv + rvstart
        if rvs &gt;= rvend:
            raise ValueError
        while True:
            rvstartbound = mind if minv &lt; 0 else mind + 1
            rvendbound = maxd - 1 if maxv &lt; 0 else maxd
            if rvs &gt; rvstartbound and rvs &lt; rvendbound:
                sret = rvs
                cpsrn = [1, 0, [0 for i in range(digitcount + newdigits)]]
                if sret &lt; 0:
                    sret += 1
                    cpsrn[0] = -1
                sret = abs(sret)
                for i in range(digitcount + newdigits):
                    idx = (digitcount + newdigits) - 1 - i
                    cpsrn[2][idx] = sret % digits
                    sret //= digits
                cpsrn[1] = sret
                return cpsrn
            elif rvs &lt;= rvstartbound:
                rvd = Fraction(rvs + 1, ddc)
                if rvd &lt;= minv:
                    # Rejected
                    break
                else:
                    # print([&quot;rvd&quot;,rv+rvstart,float(rvd),float(minv)])
                    newdigits += 1
                    ddc *= digits
                    rvstart *= digits
                    rvend *= digits
                    mind = int(minv * ddc)
                    maxd = int(maxv * ddc)
                    rv = rv * digits + random.randint(0, digits - 1)
                    rvs = rv + rvstart
            else:
                rvd = Fraction(rvs, ddc)
                if rvd &gt;= maxv:
                    # Rejected
                    break
                else:
                    newdigits += 1
                    ddc *= digits
                    rvstart *= digits
                    rvend *= digits
                    mind = int(minv * ddc)
                    maxd = int(maxv * ddc)
                    rv = rv * digits + random.randint(0, digits - 1)
                    rvs = rv + rvstart
</pre>

<p><a id=Correctness_Testing></a></p>

<h2>Correctness Testing</h2>

<p>&nbsp;</p>

<p><a id=Beta_Sampler></a></p>

<h3>Beta Sampler</h3>

<p>To test the correctness of the beta sampler presented in this document, the Kolmogorov&ndash;Smirnov test was applied with various values of <code>alpha</code> and <code>beta</code> and the default precision of 53, using SciPy&#39;s <code>kstest</code> method.  The code for the test is very simple: <code>kst = scipy.stats.kstest(ksample, lambda x: scipy.stats.beta.cdf(x, alpha, beta))</code>, where <code>ksample</code> is a sample of random variates generated using the sampler above.  This test can be used because the beta distribution has a probability density function; independently sampled variates from the distribution are tested; and the distribution&#39;s parameters are known. Note that SciPy uses a two-sided Kolmogorov&ndash;Smirnov test by default.</p>

<p>See the results of the <a href="https://peteroupc.github.io/betadistresults.html"><strong>correctness testing</strong></a>.   For each pair of parameters, five samples with 50,000 numbers per sample were taken, and results show the lowest and highest Kolmogorov&ndash;Smirnov statistics and p-values achieved for the five samples.  If p-values tend to be close to 0 (or close to 1, since this test is two-sided), then this is evidence that the samples do not come from the corresponding beta distribution.</p>

<p><a id=ExpRandFill></a></p>

<h3>ExpRandFill</h3>

<p>To test the correctness of the <code>exprandfill</code> method (which implements the <strong>ExpRandFill</strong> algorithm), the Kolmogorov&ndash;Smirnov test was applied with various values of <em>&lambda;</em> and the default precision of 53, using SciPy&#39;s <code>kstest</code> method.  The code for the test is very simple: <code>kst = scipy.stats.kstest(ksample, lambda x: scipy.stats.expon.cdf(x, scale=1/lamda))</code>, where <code>ksample</code> is a sample of random variates generated using the <code>exprand</code> method above.  This test can be used because the exponential distribution has a probability density function; independently sampled variates from the distribution are tested; and the distribution&#39;s parameters are known.  Note that SciPy uses a two-sided Kolmogorov&ndash;Smirnov test by default.</p>

<p>The table below shows the results of the correctness testing. For each parameter, five samples with 50,000 numbers per sample were taken, and results show the lowest and highest Kolmogorov&ndash;Smirnov statistics and p-values achieved for the five samples.  If p-values tend to be close to 0 (or close to 1, since this test is two-sided), then this is evidence that the samples do not come from the corresponding beta distribution.</p>

<table><thead>
<tr>
<th><em>&lambda;</em></th>
<th>Statistic</th>
<th><em>p</em>-value</th>
</tr>
</thead><tbody>
<tr>
<td>1/10</td>
<td>0.00233-0.00435</td>
<td>0.29954-0.94867</td>
</tr>
<tr>
<td>1/4</td>
<td>0.00254-0.00738</td>
<td>0.00864-0.90282</td>
</tr>
<tr>
<td>1/2</td>
<td>0.00195-0.00521</td>
<td>0.13238-0.99139</td>
</tr>
<tr>
<td>2/3</td>
<td>0.00295-0.00457</td>
<td>0.24659-0.77715</td>
</tr>
<tr>
<td>3/4</td>
<td>0.00190-0.00636</td>
<td>0.03514-0.99381</td>
</tr>
<tr>
<td>9/10</td>
<td>0.00226-0.00474</td>
<td>0.21032-0.96029</td>
</tr>
<tr>
<td>1</td>
<td>0.00267-0.00601</td>
<td>0.05389-0.86676</td>
</tr>
<tr>
<td>2</td>
<td>0.00293-0.00684</td>
<td>0.01870-0.78310</td>
</tr>
<tr>
<td>3</td>
<td>0.00284-0.00675</td>
<td>0.02091-0.81589</td>
</tr>
<tr>
<td>5</td>
<td>0.00256-0.00546</td>
<td>0.10130-0.89935</td>
</tr>
<tr>
<td>10</td>
<td>0.00279-0.00528</td>
<td>0.12358-0.82974</td>
</tr>
</tbody></table>

<p><a id=ExpRandLess></a></p>

<h3>ExpRandLess</h3>

<p>To test the correctness of <code>exprandless</code>, a two-independent-sample T-test was applied to scores involving e-rands and scores involving the Python <code>random.expovariate</code> method.  Specifically, the score is calculated as the number of times one exponential variate compares as less than another; for the same <em>&lambda;</em> this event should have the same probability as the event that it compares as greater.  (In fact, this should be the case for <em>any</em> pair of independent random variates of the same non-degenerate distribution; see proposition 2 in my note on <a href="https://peteroupc.github.io/randextract.html"><strong>randomness extraction</strong></a>.)  The Python code that follows the table calculates this score for e-rands and <code>expovariate</code>.   Even here, the code for the test is very simple: <code>kst = scipy.stats.ttest_ind(exppyscores, exprandscores)</code>, where <code>exppyscores</code> and <code>exprandscores</code> are each lists of 20 results from <code>exppyscore</code> or <code>exprandscore</code>, respectively, and the results contained in <code>exppyscores</code> and <code>exprandscores</code> were generated independently of each other.</p>

<p>The table below shows the results of the correctness testing. For each pair of parameters, results show the lowest and highest T-test statistics and p-values achieved for the 20 results.  If p-values tend to be close to 0, then this is evidence that the exponential random variates are not compared as less or greater with the expected probability.</p>

<table><thead>
<tr>
<th>Left <em>&lambda;</em></th>
<th>Right <em>&lambda;</em></th>
<th>Statistic</th>
<th><em>p</em>-value</th>
</tr>
</thead><tbody>
<tr>
<td>1/10</td>
<td>1/10</td>
<td>-1.21015 &ndash; 0.93682</td>
<td>0.23369 &ndash; 0.75610</td>
</tr>
<tr>
<td>1/10</td>
<td>1/2</td>
<td>-1.25248 &ndash; 3.56291</td>
<td>0.00101 &ndash; 0.39963</td>
</tr>
<tr>
<td>1/10</td>
<td>1</td>
<td>-0.76586 &ndash; 1.07628</td>
<td>0.28859 &ndash; 0.94709</td>
</tr>
<tr>
<td>1/10</td>
<td>2</td>
<td>-1.80624 &ndash; 1.58347</td>
<td>0.07881 &ndash; 0.90802</td>
</tr>
<tr>
<td>1/10</td>
<td>5</td>
<td>-0.16197 &ndash; 1.78700</td>
<td>0.08192 &ndash; 0.87219</td>
</tr>
<tr>
<td>1/2</td>
<td>1/10</td>
<td>-1.46973 &ndash; 1.40308</td>
<td>0.14987 &ndash; 0.74549</td>
</tr>
<tr>
<td>1/2</td>
<td>1/2</td>
<td>-0.79555 &ndash; 1.21538</td>
<td>0.23172 &ndash; 0.93613</td>
</tr>
<tr>
<td>1/2</td>
<td>1</td>
<td>-0.90496 &ndash; 0.11113</td>
<td>0.37119 &ndash; 0.91210</td>
</tr>
<tr>
<td>1/2</td>
<td>2</td>
<td>-1.32157 &ndash; -0.07066</td>
<td>0.19421 &ndash; 0.94404</td>
</tr>
<tr>
<td>1/2</td>
<td>5</td>
<td>-0.55135 &ndash; 1.85604</td>
<td>0.07122 &ndash; 0.76994</td>
</tr>
<tr>
<td>1</td>
<td>1/10</td>
<td>-1.27023 &ndash; 0.73501</td>
<td>0.21173 &ndash; 0.87314</td>
</tr>
<tr>
<td>1</td>
<td>1/2</td>
<td>-2.33246 &ndash; 0.66827</td>
<td>0.02507 &ndash; 0.58741</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>-1.24446 &ndash; 0.84555</td>
<td>0.22095 &ndash; 0.90587</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
<td>-1.13643 &ndash; 0.84148</td>
<td>0.26289 &ndash; 0.95717</td>
</tr>
<tr>
<td>1</td>
<td>5</td>
<td>-0.70037 &ndash; 1.46778</td>
<td>0.15039 &ndash; 0.86996</td>
</tr>
<tr>
<td>2</td>
<td>1/10</td>
<td>-0.77675 &ndash; 1.15350</td>
<td>0.25591 &ndash; 0.97870</td>
</tr>
<tr>
<td>2</td>
<td>1/2</td>
<td>-0.23122 &ndash; 1.20764</td>
<td>0.23465 &ndash; 0.91855</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>-0.92273 &ndash; -0.05904</td>
<td>0.36197 &ndash; 0.95323</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>-1.88150 &ndash; 0.64096</td>
<td>0.06758 &ndash; 0.73056</td>
</tr>
<tr>
<td>2</td>
<td>5</td>
<td>-0.08315 &ndash; 1.01951</td>
<td>0.31441 &ndash; 0.93417</td>
</tr>
<tr>
<td>5</td>
<td>1/10</td>
<td>-0.60921 &ndash; 1.54606</td>
<td>0.13038 &ndash; 0.91563</td>
</tr>
<tr>
<td>5</td>
<td>1/2</td>
<td>-1.30038 &ndash; 1.43602</td>
<td>0.15918 &ndash; 0.86349</td>
</tr>
<tr>
<td>5</td>
<td>1</td>
<td>-1.22803 &ndash; 1.35380</td>
<td>0.18380 &ndash; 0.64158</td>
</tr>
<tr>
<td>5</td>
<td>2</td>
<td>-1.83124 &ndash; 1.40222</td>
<td>0.07491 &ndash; 0.66075</td>
</tr>
<tr>
<td>5</td>
<td>5</td>
<td>-0.97110 &ndash; 2.00904</td>
<td>0.05168 &ndash; 0.74398</td>
</tr>
</tbody></table>

<pre>def exppyscore(ln,ld,ln2,ld2):
        return sum(1 if random.expovariate(ln*1.0/ld)&lt;random.expovariate(ln2*1.0/ld2) \
              else 0 for i in range(1000))

def exprandscore(ln,ld,ln2,ld2):
        return sum(1 if exprandless(exprandnew(ln,ld), exprandnew(ln2,ld2)) \
              else 0 for i in range(1000))
</pre>

<p><a id=Accurate_Simulation_of_Continuous_Distributions_Supported_on_0_to_1></a></p>

<h2>Accurate Simulation of Continuous Distributions Supported on 0 to 1</h2>

<p>The beta sampler in this document shows one case of a general approach to simulating a wide class of continuous distributions with PDFs on the domain [0, 1], thanks to Bernoulli factories.  This general approach can sample a number that follows one of these distributions, using the algorithm below.  The algorithm allows any arbitrary base (or radix) <em>b</em> (such as 2 for binary).  (See also (Devroye 1986, ch. 2, sec. 3.8, exercise 14)[^25].)</p>

<ol>
<li>Create an uniform PSRN with a positive sign, an integer part of 0, and an empty fractional part.  Create a <strong>SampleGeometricBag</strong> Bernoulli factory that uses that PSRN.</li>
<li><p>As the PSRN builds up a uniform random variate, accept the PSRN with a probability that can be represented by a Bernoulli factory algorithm (that takes the <strong>SampleGeometricBag</strong> factory from step 1 as part of its input), or reject it otherwise. (A number of these algorithms can be found in &quot;<a href="https://peteroupc.github.io/bernoulli.html"><strong>Bernoulli Factory Algorithms</strong></a>&quot;.)  Let <em>f</em>(<em>U</em>) be the probability density function (PDF) modeled by this Bernoulli factory, where <em>U</em> is the uniform random variate built up by the PSRN. <em>f</em> has a domain equal to the open interval (0, 1) or a subset of that interval, and returns a value of [0, 1] everywhere in its domain. <em>f</em> is the PDF for the underlying continuous distribution, or the PDF times a (possibly unknown) constant factor.  As shown by Keane and O&#39;Brien [^6], however, this step works if and only if&mdash;</p>

<ul>
<li><em>f</em>(<em>&lambda;</em>) is constant on its domain, or</li>
<li><em>f</em>(<em>&lambda;</em>) is continuous and polynomially bounded on its domain (polynomially bounded means that both <em>f</em>(<em>&lambda;</em>) and 1&minus;<em>f</em>(<em>&lambda;</em>) are greater than or equal to min(<em>&lambda;</em><sup><em>n</em></sup>, (1&minus;<em>&lambda;</em>)<sup><em>n</em></sup>) for some integer <em>n</em>),</li>
</ul>

<p>and they show that 2 * <em>&lambda;</em> with domain [0, 1/2), is one function that does not admit a Bernoulli factory.  Notice that the probability can be a constant, including an irrational number; see &quot;<a href="https://peteroupc.github.io/bernoulli.html#Algorithms_for_Irrational_Constants"><strong>Algorithms for Irrational Constants</strong></a>&quot; for ways to simulate constant probabilities.</p></li>
<li>If the PSRN is accepted, optionally fill the PSRN with uniform random digits as necessary to give its fractional part <em>n</em> digits (similarly to <strong>FillGeometricBag</strong> above), where <em>n</em> is a precision parameter, then return the PSRN.</li>
</ol>

<p>However, the speed of this algorithm depends crucially on the mode (highest point) of <em>f</em> in [0, 1].[^27]  As the mode approaches 0, the average rejection rate increases.  Effectively, this step generates a point uniformly at random in a 1&times;1 area in space.  If the mode is close to 0, <em>f</em> will cover only a tiny portion of this area, so that the chance is high that the generated point will fall outside the area of <em>f</em> and have to be rejected.</p>

<p>The beta distribution&#39;s PDF at (1) fits the requirements of Keane and O&#39;Brien (for <code>alpha</code> and <code>beta</code> both greater than 1), thus it can be simulated by Bernoulli factories and is covered by this general algorithm.</p>

<p>This algorithm can be modified to produce random variates in the interval [<em>m</em>, <em>m</em> + <em>y</em>] (where <em>m</em> and <em>y</em> are rational numbers and <em>y</em> is greater than 0), rather than [0, 1], as follows:</p>

<ol>
<li>Apply the algorithm above, except that a modified function <em>f&prime;</em>(<em>x</em>) = <em>f</em>(<em>x</em> * <em>y</em> + <em>m</em>) is used rather than <em>f</em>, where <em>x</em> is the number in [0, 1] that is built up by the PSRN, and that the choice is not made to fill the PSRN as given in step 3 of that algorithm.</li>
<li>Multiply the resulting random PSRN by <em>y</em> via the second algorithm in &quot;<a href="#Multiplication"><strong>Multiplication</strong></a>&quot;.  (Note that if <em>y</em> has the form <em>b</em><sup><em>i</em></sup>, this step is relatively trivial.)</li>
<li>Add <em>m</em> to the resulting random PSRN via the second algorithm in &quot;<a href="#Addition_and_Subtraction"><strong>Addition and Subtraction</strong></a>&quot;.</li>
</ol>

<p>Note that here, the function <em>f&prime;</em> must meet the requirements of Keane and O&#39;Brien.  (For example, take the function <code>sqrt((x - 4) / 2)</code>, which isn&#39;t a Bernoulli factory function.  If we now seek to sample from the interval [4, 4+2<sup>1</sup>] = [4, 6], the <em>f</em> used in step 2 is now <code>sqrt(x)</code>, which <em>is</em> a Bernoulli factory function so that we can apply this algorithm.)</p>

<p><a id=An_Example_The_Continuous_Bernoulli_Distribution></a></p>

<h3>An Example: The Continuous Bernoulli Distribution</h3>

<p>The continuous Bernoulli distribution (Loaiza-Ganem and Cunningham 2019)[^28] was designed to considerably improve performance of variational autoencoders (a machine learning model) in modeling continuous data that takes values in the interval [0, 1], including &quot;almost-binary&quot; image data.</p>

<p>The continous Bernoulli distribution takes one parameter <code>lamda</code> (a number in [0, 1]), and takes on values in the interval [0, 1] with a probability proportional to&mdash;</p>

<pre>pow(lamda, x) * pow(1 - lamda, 1 - x).
</pre>

<p>Again, this function meets the requirements stated by Keane and O&#39;Brien, so it can be simulated via Bernoulli factories.  Thus, this distribution can be simulated in Python as described below.</p>

<p>The algorithm for sampling the continuous Bernoulli distribution follows.  It uses an input coin that returns 1 with probability <code>lamda</code>.</p>

<ol>
<li>Create a positive-sign zero-integer-part uniform PSRN.</li>
<li>Create a <strong>complementary lambda Bernoulli factory</strong> that returns 1 minus the result of the input coin.</li>
<li>Remove all digits from the uniform PSRN&#39;s fractional part.  This will result in an &quot;empty&quot; uniform random variate, <em>U</em>, in the interval [0, 1] for the following steps, which will accept <em>U</em> with probability <code>lamda</code><sup><em>U</em></sup>*(1&minus;<code>lamda</code>)<sup>1&minus;<em>U</em></sup>) (the proportional probability for the beta distribution), as <em>U</em> is built up.</li>
<li>Call the <strong>algorithm for <em>&lambda;</em><sup>&mu;</sup></strong> described in &quot;<a href="https://peteroupc.github.io/bernoulli.html"><strong>Bernoulli Factory Algorithms</strong></a>&quot;, using the input coin as the <em>&lambda;</em>-coin, and <strong>SampleGeometricBag</strong> as the &mu;-coin (which will return 1 with probability <code>lamda</code><sup><em>U</em></sup>).  If the result is 0, go to step 3.</li>
<li>Call the <strong>algorithm for <em>&lambda;</em><sup>&mu;</sup></strong> using the <strong>complementary lambda Bernoulli factory</strong> as the <em>&lambda;</em>-coin and <strong>SampleGeometricBagComplement</strong> algorithm as the &mu;-coin (which will return 1 with probability (1-<code>lamda</code>)<sup>1&minus;<em>U</em></sup>).  If the result is 0, go to step 3. (Note that steps 4 and 5 don&#39;t depend on each other and can be done in either order without affecting correctness.)</li>
<li><em>U</em> was accepted, so return the result of <strong>FillGeometricBag</strong>.</li>
</ol>

<p>The Python code that samples the continuous Bernoulli distribution follows.</p>

<pre>def _twofacpower(b, fbase, fexponent):
    &quot;&quot;&quot; Bernoulli factory B(p, q) =&gt; B(p^q).
           - fbase, fexponent: Functions that return 1 if heads and 0 if tails.
             The first is the base, the second is the exponent.
             &quot;&quot;&quot;
    i = 1
    while True:
        if fbase() == 1:
            return 1
        if fexponent() == 1 and \
            b.zero_or_one(1, i) == 1:
            return 0
        i = i + 1

def contbernoullidist(b, lamda, precision=53):
    # Continuous Bernoulli distribution
    bag=[]
    lamda=Fraction(lamda)
    gb=lambda: b.geometric_bag(bag)
    # Complement of &quot;geometric bag&quot;
    gbcomp=lambda: b.geometric_bag(bag)^1
    fcoin=b.coin(lamda)
    lamdab=lambda: fcoin()
    # Complement of &quot;lambda coin&quot;
    lamdabcomp=lambda: fcoin()^1
    acc=0
    while True:
       # Create a uniform random variate (U) bit-by-bit, and
       # accept it with probability lamda^U*(1-lamda)^(1-U), which
       # is the unnormalized PDF of the beta distribution
       bag.clear()
       # Produce 1 with probability lamda^U
       r=_twofacpower(b, lamdab, gb)
       # Produce 1 with probability (1-lamda)^(1-U)
       if r==1: r=_twofacpower(b, lamdabcomp, gbcomp)
       if r == 1:
             # Accepted, so fill up the &quot;bag&quot; and return the
             # uniform number
             ret=_fill_geometric_bag(b, bag, precision)
             return ret
       acc+=1
</pre>

<p><a id=Complexity></a></p>

<h2>Complexity</h2>

<p>The <em>bit complexity</em> of an algorithm that generates random variates is measured as the number of unbiased random bits that algorithm uses on average.</p>

<p><a id=General_Principles></a></p>

<h3>General Principles</h3>

<p>Existing work shows how to calculate the bit complexity for any probability distribution:</p>

<ul>
<li>For a 1-dimensional distribution with a probability density function (PDF), the bit complexity is greater than or equal to <code>DE + prec - 1</code> random bits, where <code>DE</code> is the differential entropy for the distribution and <em>prec</em> is the number of bits in the random variate&#39;s fractional part (Devroye and Gravel 2020)[^3].</li>
<li>For a discrete distribution (a distribution of random integers with separate probabilities of occurring), the bit complexity is greater than or equal to the binary entropies of all the probabilities involved, summed together (Knuth and Yao 1976)[^29].  (For a given probability <em>p</em>, the binary entropy is <code>0 - p*log2(p)</code> where <code>log2(x) = ln(x)/ln(2)</code>.)  An optimal algorithm will come within 2 bits of this lower bound on average.</li>
</ul>

<p>For example, in the case of the exponential distribution, <code>DE</code> is log2(exp(1)/<em>&lambda;</em>), so the minimum bit complexity for this distribution is log2(exp(1)/<em>&lambda;</em>) + <em>prec</em> &minus; 1, so that if <em>prec</em> = 20, this minimum is about 20.443 bits when <em>&lambda;</em> = 1, decreases when <em>&lambda;</em> goes up, and increases when <em>&lambda;</em> goes down.  In the case of any other distribution with a PDF, <code>DE</code> is the integral of <code>f(x) * log2(1/f(x))</code> over all valid values <code>x</code>, where <code>f</code> is the distribution&#39;s PDF.</p>

<p>Although existing work shows lower bounds on the number of random bits an algorithm will need on average, most algorithms will generally not achieve these lower bounds in practice.</p>

<p>In general, if an algorithm calls other algorithms that generate random variates, the total expected bit complexity is&mdash;</p>

<ul>
<li>the expected number of calls to each of those other algorithms, times</li>
<li>the bit complexity for each such call.</li>
</ul>

<p><a id=Complexity_of_Specific_Algorithms></a></p>

<h3>Complexity of Specific Algorithms</h3>

<p>The beta and exponential samplers given here will generally use many more bits on average than the lower bounds on bit complexity, especially since they generate a PSRN one digit at a time.</p>

<p>The <code>zero_or_one</code> method generally uses 2 random bits on average, due to its nature as a Bernoulli trial involving random bits, see also (Lumbroso 2013, Appendix B)[^30].  However, it uses no random bits if both its parameters are the same.</p>

<p>For <strong>SampleGeometricBag</strong> with base 2, the bit complexity has two components.</p>

<ul>
<li>One component comes from sampling the number of heads from a fair coin until the first tails, as follows:

<ul>
<li>Optimal lower bound: Since the binary entropy of the random variate is 2, the optimal lower bound is 2 bits.</li>
<li>Optimal upper bound: 4 bits.</li>
</ul></li>
<li>The other component comes from filling the partially-sampled random number&#39;s fractional part with random bits.  The complexity here depends on the number of times <strong>SampleGeometricBag</strong> is called for the same PSRN, call it <code>n</code>.  Then the expected number of bits is the expected number of bit positions filled this way after <code>n</code> calls.</li>
</ul>

<p><strong>SampleGeometricBagComplement</strong> has the same bit complexity as <strong>SampleGeometricBag</strong>.</p>

<p><strong>FillGeometricBag</strong>&#39;s bit complexity is rather easy to find.  For base 2, it uses only one bit to sample each unfilled digit at positions less than <code>p</code>. (For bases other than 2, sampling <em>each</em> digit this way might not be optimal, since the digits are generated one at a time and random bits are not recycled over several digits.)  As a result, for an algorithm that uses both <strong>SampleGeometricBag</strong> and <strong>FillGeometricBag</strong> with <code>p</code> bits, these two contribute, on average, anywhere from <code>p + g * 2</code> to <code>p + g * 4</code> bits to the complexity, where <code>g</code> is the number of calls to <strong>SampleGeometricBag</strong>. (This complexity could be increased by 1 bit if <strong>FillGeometricBag</strong> is implemented with a rounding mechanism other than simple truncation.)</p>

<p><a id=Application_to_Weighted_Reservoir_Sampling></a></p>

<h2>Application to Weighted Reservoir Sampling</h2>

<p><a href="https://peteroupc.github.io/randomfunc.html#Weighted_Choice_Without_Replacement_List_of_Unknown_Size"><strong>Weighted reservoir sampling</strong></a> (choosing an item at random from a list of unknown size) is often implemented by&mdash;</p>

<ul>
<li>assigning each item a <em>weight</em> (an integer 0 or greater) as it&#39;s encountered, call it <em>w</em>,</li>
<li>giving each item an exponential random variate with <em>&lambda;</em> = <em>w</em>, call it a key, and</li>
<li>choosing the item with the smallest key</li>
</ul>

<p>(see also (Efraimidis 2015)[^31]). However, using fully-sampled exponential random variates as keys (such as the na√Øve idiom <code>-ln(1-X)/w</code>, where <code>X</code> is a uniform random variate in the interval [0, 1], in common floating-point arithmetic) can lead to inexact sampling, since the keys have a limited precision, it&#39;s possible for multiple items to have the same random key (which can make sampling those items depend on their order rather than on randomness), and the maximum weight is unknown.  Partially-sampled e-rands, as given in this document, eliminate the problem of inexact sampling.  This is notably because the <code>exprandless</code> method returns one of only two answers&mdash;either &quot;less&quot; or &quot;greater&quot;&mdash;and samples from both e-rands as necessary so that they will differ from each other by the end of the operation.  (This is not a problem because randomly generated real numbers are expected to differ from each other with probability 1.) Another reason is that partially-sampled e-rands have potentially arbitrary precision.</p>

<p><a id=Acknowledgments></a></p>

<h2>Acknowledgments</h2>

<p>I acknowledge Claude Gravel who reviewed a previous version of this article.</p>

<p><a id=Other_Documents></a></p>

<h2>Other Documents</h2>

<p>The following are some additional articles I have written on the topic of random and pseudorandom number generation.  All of them are open-source.</p>

<ul>
<li><a href="https://peteroupc.github.io/random.html"><strong>Random Number Generator Recommendations for Applications</strong></a></li>
<li><a href="https://peteroupc.github.io/randomfunc.html"><strong>Randomization and Sampling Methods</strong></a></li>
<li><a href="https://peteroupc.github.io/randomnotes.html"><strong>More Random Sampling Methods</strong></a></li>
<li><a href="https://peteroupc.github.io/autodist.html"><strong>Code Generator for Discrete Distributions</strong></a></li>
<li><a href="https://peteroupc.github.io/randomcommon.html"><strong>The Most Common Topics Involving Randomization</strong></a></li>
<li><a href="https://peteroupc.github.io/bernoulli.html"><strong>Bernoulli Factory Algorithms</strong></a></li>
<li><a href="https://peteroupc.github.io/morealg.html"><strong>More Algorithms for Arbitrary-Precision Sampling</strong></a></li>
<li><a href="https://peteroupc.github.io/randomtest.html"><strong>Testing PRNGs for High-Quality Randomness</strong></a></li>
<li><a href="https://peteroupc.github.io/hqprng.html"><strong>Examples of High-Quality PRNGs</strong></a></li>
</ul>

<p><a id=Notes></a></p>

<h2>Notes</h2>

<p>[^1]: Karney, C.F.F., 2016. Sampling exactly from the normal distribution. ACM Transactions on Mathematical Software (TOMS), 42(1), pp.1-14. Also: &quot;<a href="https://arxiv.org/abs/1303.6257v2"><strong>Sampling exactly from the normal distribution</strong></a>&quot;, arXiv:1303.6257v2  [physics.comp-ph], 2014.</p>

<p>[^2]: Philippe Flajolet, Nasser Saheb. The complexity of generating an exponentially distributed variate. [Research Report] RR-0159, INRIA. 1982. inria-00076400.</p>

<p>[^3]: Devroye, L., Gravel, C., &quot;<a href="https://arxiv.org/abs/1502.02539v6"><strong>Random variate generation using only finitely many unbiased, independently and identically distributed random bits</strong></a>&quot;, arXiv:1502.02539v6  [cs.IT], 2020.</p>

<p>[^4]: Thomas, D.B. and Luk, W., 2008, September. Sampling from the exponential distribution using independent bernoulli variates. In 2008 International Conference on Field Programmable Logic and Applications (pp. 239-244). IEEE.</p>

<p>[^5]: A. Habibizad Navin, R. Olfatkhah and M. K. Mirnia, &quot;A data-oriented model of exponential random variable,&quot; 2010 2nd International Conference on Advanced Computer Control, Shenyang, 2010, pp. 603-607, doi: 10.1109/ICACC.2010.5487128.</p>

<p>[^6]: Keane,  M.  S.,  and  O&#39;Brien,  G.  L., &quot;A Bernoulli factory&quot;, <em>ACM Transactions on Modeling and Computer Simulation</em> 4(2), 1994.</p>

<p>[^7]: Flajolet, P., Pelletier, M., Soria, M., &quot;<a href="https://arxiv.org/abs/0906.5560v2"><strong>On Buffon machines and numbers</strong></a>&quot;, arXiv:0906.5560v2  [math.PR], 2010.</p>

<p>[^8]: Pedersen, K., &quot;<a href="https://arxiv.org/abs/1704.07949"><strong>Reconditioning your quantile function</strong></a>&quot;, arXiv:1704.07949 [stat.CO], 2018.</p>

<p>[^9]: von Neumann, J., &quot;Various techniques used in connection with random digits&quot;, 1951.</p>

<p>[^10]: As noted by von Neumann (1951), a uniform random variate bounded by 0 and 1 can be produced by &quot;juxtapos[ing] enough random binary digits&quot;.  In this sense, the variate is <em>X1</em>/<code>B</code><sup>1</sup> + <em>X2</em>/<code>B</code><sup>2</sup> + ..., (where <code>B</code> is the digit base 2, and <em>X1</em>, <em>X2</em>, etc. are independent uniform random integers in the interval [0, <code>B</code>)), perhaps &quot;forc[ing] the last [random bit] to be 1&quot; &quot;[t]o avoid any bias&quot;.  It is not hard to see that this approach can be applied to generate any digit expansion of any base, not just 2.</p>

<p>[^11]: Yusong Du, Baoying Fan, and Baodian Wei, &quot;<a href="https://arxiv.org/abs/2008.03855"><strong>An Improved Exact Sampling Algorithm for the Standard Normal Distribution</strong></a>&quot;, arXiv:2008.03855 [cs.DS], 2020.</p>

<p>[^12]: This means that every zero-volume (Lebesgue measure zero) subset of the distribution&#39;s domain (such as a finite set of points) has zero probability.  Equivalently, it means the distribution has a probability density function.</p>

<p>[^13]: Oberhoff, Sebastian, &quot;<a href="https://dc.uwm.edu/etd/1888"><strong>Exact Sampling and Prefix Distributions</strong></a>&quot;, <em>Theses and Dissertations</em>, University of Wisconsin Milwaukee, 2018.</p>

<p>[^14]: Hill, T.P. and Sch√ºrger, K., 2005. Regularity of digits and significant digits of random variables. <em>Stochastic processes and their applications</em>, 115(10), pp.1723-1743.</p>

<p>[^15]: J.F. Williamson, &quot;Random selection of points distributed on curved surfaces&quot;, <em>Physics in Medicine &amp; Biology</em> 32(10), 1987.</p>

<p>[^16]: Boehm, Hans-J. &quot;Towards an API for the real numbers.&quot; In Proceedings of the 41st ACM SIGPLAN Conference on Programming Language Design and Implementation, pp. 562-576. 2020.</p>

<p>[^17]: Hans-J. Boehm. 1987. Constructive Real Interpretation of Numerical Programs. In Proceedings of the SIGPLAN ‚Äô87 Symposium on Interpreters and Interpretive Techniques. 214-221</p>

<p>[^18]: Goubault-Larrecq, Jean, Xiaodong Jia, and Cl√©ment Th√©ron. &quot;A Domain-Theoretic Approach to Statistical Programming Languages.&quot; arXiv preprint arXiv:2106.16190 (2021) (especially sec. 12.3).</p>

<p>[^19]: In fact, thanks to the &quot;geometric bag&quot; technique of Flajolet et al. (2010), the fractional part <em>&nu;</em> can even come from a uniform PSRN.</p>

<p>[^20]: Brassard, G., Devroye, L., Gravel, C., &quot;Remote Sampling with Applications to General Entanglement Simulation&quot;, <em>Entropy</em> 2019(21)(92), doi:10.3390/e21010092.</p>

<p>[^21]: Note that <em>ak</em> * <em>&beta;</em><sup>&minus;(<em>i</em> + 1)</sup> is not just within <em>&beta;</em><sup>&minus;(<em>i</em> + 1)</sup> of its &quot;true&quot; result&#39;s absolute value, but also not more than that value.  Hence <em>ak</em> &gt;= <em>bk</em> + 1 rather than <em>ak</em> &gt;= <em>bk</em> + 2.</p>

<p>[^22]: A. Habibizad Navin, Fesharaki, M.N., Teshnelab, M. and Mirnia, M., 2007. &quot;Data oriented modeling of uniform random variable: Applied approach&quot;. <em>World Academy Science Engineering Technology</em>, 21, pp.382-385.</p>

<p>[^23]: Nezhad, R.F., Effatparvar, M., Rahimzadeh, M., 2013. &quot;Designing a Universal Data-Oriented Random Number Generator&quot;, <em>International Journal of Modern Education and Computer Science</em> 2013(2), pp. 19-24.</p>

<p>[^24]: In effect, for each supported integer <em>n</em>, the tree gives the probabilities of getting a value in [<em>n</em>*<em>p</em>, (<em>n</em>+1)*<em>p</em>], where <em>p</em> is the resolution of the tree such as 1/100000.</p>

<p>[^25]: Devroye, L., <a href="http://luc.devroye.org/rnbookindex.html"><strong><em>Non-Uniform Random Variate Generation</em></strong></a>, 1986.</p>

<p>[^26]: Fan, Baoying et al. ‚ÄúOn Generating Exponentially Distributed Variates by Using Early Rejection.‚Äù <em>2019 IEEE 5th International Conference on Computer and Communications (ICCC)</em> (2019): 1307-1311.</p>

<p>[^27]: More specifically, the <em>essential supremum</em>, that is, the function&#39;s highest point in [0, 1] ignoring zero-volume, or measure-zero, sets.  However, the mode is also correct here, since discontinuous PDFs don&#39;t admit Bernoulli factories, as required by step 2.</p>

<p>[^28]: Loaiza-Ganem, Gabriel, and John P. Cunningham. &quot;The continuous Bernoulli: fixing a pervasive error in variational autoencoders.&quot; <em>Advances in Neural Information Processing Systems</em> 32 (2019).</p>

<p>[^29]: Knuth, Donald E. and Andrew Chi-Chih Yao. &quot;The complexity of nonuniform random number generation&quot;, in <em>Algorithms and Complexity: New Directions and Recent Results</em>, 1976.</p>

<p>[^30]: Lumbroso, J., &quot;<a href="https://arxiv.org/abs/1304.1916"><strong>Optimal Discrete Uniform Generation from Coin Flips, and Applications</strong></a>&quot;, arXiv:1304.1916 [cs.DS].</p>

<p>[^31]: Efraimidis, P. &quot;<a href="https://arxiv.org/abs/1012.0256v2"><strong>Weighted Random Sampling over Data Streams</strong></a>&quot;, arXiv:1012.0256v2 [cs.DS], 2015.</p>

<p>[^32]: Glen, A.G., Leemis, L.M. and Drew, J.H., 2004. Computing the distribution of the product of two continuous random variables. Computational statistics &amp; data analysis, 44(3), pp.451-464.</p>

<p>[^33]: S. Kakutani, &quot;On equivalence of infinite product measures&quot;, <em>Annals of Mathematics</em> 1948.</p>

<p>[^34]: George Marsaglia. &quot;Random Variables with Independent Binary Digits.&quot; Ann. Math. Statist. 42 (6) 1922 - 1929, December, 1971. <a href="https://doi.org/10.1214/aoms/1177693058"><strong>https://doi.org/10.1214/aoms/1177693058</strong></a> .</p>

<p>[^35]: Chatterji, S. D.. ‚ÄúCertain induced measures and the fractional dimensions of their ‚Äúsupports‚Äù.‚Äù Zeitschrift f√ºr Wahrscheinlichkeitstheorie und Verwandte Gebiete 3 (1964): 184-192.</p>

<p><a id=Appendix></a></p>

<h2>Appendix</h2>

<p><a id=Equivalence_of_SampleGeometricBag_Algorithms></a></p>

<h3>Equivalence of SampleGeometricBag Algorithms</h3>

<p>For the <strong>SampleGeometricBag</strong>, there are two versions: one for binary (base 2) and one for other bases.  Here is why these two versions are equivalent in the binary case.  Step 2 of the first algorithm samples a temporary random variate <em>N</em>.  This can be implemented by generating unbiased random bits (that is, each bit is either 0 or 1, chosen with equal probability) until a zero is generated this way.  There are three cases relevant here.</p>

<ul>
<li>The generated bit is one, which will occur at a 50% chance. This means the bit position is skipped and the algorithm moves on to the next position.  In algorithm 3, this corresponds to moving to step 3 because <strong>a</strong>&#39;s fractional part is equal to <strong>b</strong>&#39;s, which likewise occurs at a 50% chance compared to the fractional parts being unequal (since <strong>a</strong> is fully built up in the course of the algorithm).</li>
<li>The generated bit is zero, and the algorithm samples (or retrieves) a zero bit at position <em>N</em>, which will occur at a 25% chance. In algorithm 3, this corresponds to returning 0 because <strong>a</strong>&#39;s fractional part is less than <strong>b</strong>&#39;s, which will occur with the same probability.</li>
<li>The generated bit is zero, and the algorithm samples (or retrieves) a one bit at position <em>N</em>, which will occur at a 25% chance. In algorithm 3, this corresponds to returning 1 because <strong>a</strong>&#39;s fractional part is greater than <strong>b</strong>&#39;s, which will occur with the same probability.</li>
</ul>

<p><a id=UniformMultiply_Algorithm></a></p>

<h3>UniformMultiply Algorithm</h3>

<p>The following algorithm (<strong>UniformMultiply</strong>) shows how to multiply two uniform PSRNs (<strong>a</strong> and <strong>b</strong>) that store digits of the same base (radix) in their fractional parts, and get a uniform PSRN as a result.  The input PSRNs may have a positive or negative sign, and it is assumed that their integer parts and signs were sampled.</p>

<p>The algorithm currently works only if each PSRN&#39;s fractional part has at least one nonzero digit; otherwise, it can produce results that follow an incorrect distribution.  This case might be handled by applying the note in the section &quot;Multiplication&quot;, but this will further complicate the algorithm below.</p>

<ol>
<li>If <strong>a</strong> has unsampled digits before the last sampled digit in its fractional part, set each of those unsampled digits to a digit chosen uniformly at random.  Do the same for <strong>b</strong>.</li>
<li>If <strong>a</strong> has fewer digits in its fractional part than <strong>b</strong> (or vice versa), sample enough digits (by setting them to uniform random digits, such as unbiased random bits if <strong>a</strong> and <strong>b</strong> store binary, or base-2, digits) so that both PSRNs&#39; fractional parts have the same number of digits.</li>
<li>If either <strong>a</strong> or <strong>b</strong> has an integer part of 0 and a fractional part with no non-zero digits, then do the following.

<ol>
<li>Append a digit chosen uniformly at random to <strong>a</strong>&#39;s fractional part.  Do the same for <strong>b</strong>.</li>
<li>If either <strong>a</strong> or <strong>b</strong> has an integer part of 0 and a fractional part with no non-zero digits, go to the previous substep.</li>
</ol></li>
<li>Let <em>afp</em> be <strong>a</strong>&#39;s integer and fractional parts packed into an integer, as explained in the example, and let <em>bfp</em> be <strong>b</strong>&#39;s integer and fractional parts packed the same way.  (For example, if <strong>a</strong> represents the number 83.12344..., <em>afp</em> is 8312344.)  Let <em>digitcount</em> be the number of digits in <strong>a</strong>&#39;s fractional part.</li>
<li>Calculate <em>n1</em> = <em>afp</em>*<em>bfp</em>, <em>n2</em> = <em>afp</em>*(<em>bfp</em>+1), <em>n3</em> = (<em>afp</em>+1)*<em>bfp</em>, and <em>n4</em> = (<em>afp</em>+1)*(<em>bfp</em>+1).</li>
<li>Set <em>minv</em> to <em>n1</em> and <em>maxv</em> to <em>n2</em>.  Set <em>midmin</em> to min(<em>n2</em>, <em>n3</em>) and <em>midmax</em> to max(<em>n2</em>, <em>n3</em>).

<ul>
<li><small>The numbers <em>minv</em> and <em>maxv</em> are lower and upper bounds to the result of applying interval multiplication to the PSRNs <strong>a</strong> and <strong>b</strong>. For example, if <strong>a</strong> is 0.12344... and <strong>b</strong> is 0.38925..., their fractional parts are added to form <strong>c</strong> = 0.51269...., or the interval [0.51269, 0.51271].  However, the resulting PSRN is not uniformly distributed in its interval.  In the case of multiplication the distribution is almost a trapezoid whose domain is the interval [<em>minv</em>, <em>maxv</em>] and whose top is delimited by <em>midmin</em> and <em>midmax</em>. (See note 1 at the end of this section.)</small></li>
</ul></li>
<li>Create a new uniform PSRN, <em>ret</em>.  If <strong>a</strong>&#39;s sign is negative and <strong>b</strong>&#39;s sign is negative, or vice versa, set <em>ret</em>&#39;s sign to negative.  Otherwise, set <em>ret</em>&#39;s sign to positive.</li>
<li>Set <em>z</em> to a uniform random integer in the interval [0, <em>maxv</em>&minus;<em>minv</em>).</li>
<li>If <em>z</em> &lt; <em>midmin</em>&minus;<em>minv</em> or if <em>z</em> &ge; <em>midmax</em> &minus; <em>minv</em>, we will sample from the left side or right side of the &quot;trapezoid&quot;, respectively.  In this case, do the following:

<ol>
<li>Set <em>x</em> to <em>minv</em> + <em>z</em>.  Create <em>psrn</em>, a PSRN with positive sign and empty fractional part.</li>
<li>If <em>z</em> &lt; <em>midmin</em> &minus; <em>minv</em> (left side), set <em>psrn</em>&#39;s integer part to <em>x</em> &minus; <em>minv</em>, then run <strong>sub-algorithm 1</strong> given later, with the parameters <em>minv</em> and <em>psrn</em>. (The sub-algorithm returns 1 with probability ln((<em>minv</em>+<em>psrn</em>)/<em>minv</em>).)</li>
<li>If <em>z</em> &ge; <em>midmin</em> &minus; <em>minv</em> (right side), set <em>psrn</em>&#39;s integer part to <em>x</em> &minus; <em>midmax</em>, then run <strong>sub-algorithm 2</strong> given later, with the parameters <em>maxv</em>, <em>midmax</em> and <em>psrn</em>. (The sub-algorithm returns 1 with probability ln(<em>maxv</em>/(<em>midmax</em>+<em>psrn</em>)).)</li>
<li>If sub-algorithm 1 or 2 returns 1, the algorithm succeeds, so do the following:

<ol>
<li>Set <em>s</em> to <em>ru</em>.</li>
<li>Transfer the <em>n</em>*2 least significant digits of <em>s</em> to <em>ret</em>&#39;s fractional part, where <em>n</em> is the number of digits in <strong>a</strong>&#39;s fractional part.  (Note that <em>ret</em>&#39;s fractional part stores digits from most to least significant.)</li>
<li>Append the digits in <em>psrn</em>&#39;s fractional part to the end of <em>ret</em>&#39;s fractional part.</li>
<li>Set <em>ret</em>&#39;s integer part to floor(<em>s</em>/<em>base</em><sup><em>n</em>*2</sup>).  (For example, if <em>base</em> is 10, <em>n</em>*2 is 4, and <em>s</em> is 342978, then <em>ret</em>&#39;s fractional part is set to [2, 9, 7, 8], and <em>ret</em>&#39;s integer part is set to 34.)  Finally, return <em>ret</em>.</li>
</ol></li>
<li>If sub-algorithm 1 or 2 returns 0, abort these substeps and go to step 8.</li>
</ol></li>
<li>(If we reach here, we have reached the middle part of the trapezoid, which is flat and uniform.) If <em>n2</em> &gt; <em>n3</em>, run <strong>sub-algorithm 3</strong> given later, with the parameter <em>afp</em> (returns 1 with probability ln(1+1/<em>afp</em>)).  Otherwise, run <strong>sub-algorithm 3</strong> with the parameter <em>bfp</em> (returns 1 with probability ln(1+1/<em>bfp</em>)).  In either case, if the sub-algorithm returns 0, go to step 8.</li>
<li>(The algorithm succeeds.) Set <em>s</em> to <em>minv</em> + <em>z</em>, then transfer the (<em>n</em>*2) least significant digits of <em>s</em> to <em>ret</em>&#39;s fractional part, then set <em>ret</em>&#39;s integer part to floor(<em>s</em>/<em>base</em><sup><em>n</em>*2</sup>), then return <em>ret</em>.</li>
</ol>

<p>The following sub-algorithms are used by <strong>UniformMultiply</strong>.  They all involve the same underlying function, ln(1+<em>x</em>), with an <a href="https://peteroupc.github.io/bernoulli.html#ln_1___lambda"><strong>algorithm</strong></a> mentioned in the page &quot;Bernoulli Factory Algorithms&quot;.</p>

<ul>
<li>The sub-algorithm <strong>ln(1+<em>x</em>)</strong> takes an <strong>input algorithm</strong> and returns 1 with probability ln(1+<em>x</em>), where <em>x</em> is the probability that the input algorithm returns 1.

<ul>
<li>Do the following process repeatedly, until this sub-algorithm returns a value:

<ol>
<li>Generate an unbiased random bit.  If that bit is 1 (which happens with probability 1/2), run the <strong>input algorithm</strong> and return the result.</li>
<li>If <em>u</em> wasn&#39;t created yet, create <em>u</em>, a uniform PSRN with positive sign, an integer part of 0, and an empty fractional part.</li>
<li>Run the <strong>SampleGeometricBag</strong> algorithm on <em>u</em>&#39;s fractional part, then run the <strong>input algorithm</strong>.  If the call and the run both return 1, return 0.</li>
</ol></li>
</ul></li>
<li><strong>Sub-algorithm 1</strong> takes two parameters (<em>minv</em> and <em>psrn</em>) and returns 1 with probability ln((<em>minv</em>+<em>psrn</em>)/<em>minv</em>).  Run the <strong>ln(1+<em>x</em>)</strong> sub-algorithm with an <strong>input algorithm</strong> as follows:

<ol>
<li>Let <em>p</em> be <em>psrn</em>&#39;s integer part.  Generate an integer in [0, <em>minv</em>) uniformly at random, call it <em>i</em>.</li>
<li>If <em>i</em> &lt; <em>p</em>, return 1.  If <em>i</em> = <em>p</em>, flip the input coin and return the result.  If neither is the case, return 0.</li>
</ol></li>
<li><strong>Sub-algorithm 2</strong> takes three parameters (<em>maxv</em>, <em>midmax</em> and <em>psrn</em>) and returns 1 with probability ln(<em>maxv</em>/(<em>midmax</em>+<em>psrn</em>)).  Run the <strong>ln(1+<em>x</em>)</strong> sub-algorithm with an <strong>input algorithm</strong> as follows:

<ol>
<li>Let <em>p</em> be <em>psrn</em>&#39;s integer part.  Set <em>d</em> to <em>maxv</em> &minus; <em>p</em> &minus; <em>midmax</em> &minus; 1, and set <em>c</em> to <em>p</em> + <em>midmax</em>.</li>
<li>With probability <em>c</em> / (1 + <em>c</em>), do the following:

<ul>
<li>Generate an integer in [0, <em>c</em>) uniformly at random, call it <em>i</em>.   If <em>i</em> &lt; <em>d</em>, return 1.  If <em>i</em> = <em>d</em>, run <strong>SampleGeometricBag</strong> on <em>psrn</em>&#39;s fractional part and return 1 minus the result.  If <em>i</em> &gt; <em>d</em>, return 0.</li>
</ul></li>
<li>Run <strong>SampleGeometricBag</strong> on <em>psrn</em>&#39;s fractional part.  If the result is 1, return 0.  Otherwise, go to step 2.</li>
</ol></li>
<li><strong>Sub-algorithm 3</strong> takes one parameter (called <em>n</em> here) and returns 1 with probability ln(1+1/<em>n</em>).  Run the <strong>ln(1+<em>x</em>)</strong> sub-algorithm with an <strong>input algorithm</strong> as follows: &quot;Return a number that is 1 with probability 1/<em>n</em> and 0 otherwise.&quot;</li>
</ul>

<blockquote>
<p><strong>Note:</strong> The product distribution of two uniform PSRNs is not exactly a trapezoid, but follows a not-so-trivial distribution; when each PSRN is bounded away from 0, the distribution&#39;s left and right sides are not exactly &quot;triangular&quot;, but are based on logarithmic functions.  However, these logarithmic functions approach a triangular shape as the distribution&#39;s &quot;width&quot; gets smaller.  See Glen et al. (2004)[^32] and a <a href="https://math.stackexchange.com/questions/375967/probability-density-function-of-a-product-of-uniform-random-variables"><strong>Stack Exchange question</strong></a>.</p>
</blockquote>

<p><a id=Uniform_of_Uniforms_Produces_a_Product_of_Uniforms></a></p>

<h3>Uniform of Uniforms Produces a Product of Uniforms</h3>

<p>This section contains evidence that the algorithm given in the note in the section &quot;Multiplication&quot; correctly produces the product of two uniform random variates, one in [0, <em>b</em>] and the other in [<em>c</em>, <em>d</em>], at least when <em>c</em> = 0.</p>

<p>The probability density function (PDF) for a uniform(<em>&alpha;</em>, <em>&beta;</em>) random variate is 1/(<em>&beta;</em>&minus;<em>&alpha;</em>) if <em>x</em> is in [<em>&alpha;</em>, <em>&beta;</em>], and 0 elsewhere.  It will be called UPDF(<em>x</em>, <em>&alpha;</em>, <em>&beta;</em>) here.</p>

<p>Let <em>K</em> = <em>b</em>*(<em>d</em>&minus;<em>c</em>).  To show the result, we find two PDFs as described below.</p>

<ul>
<li>To find the PDF for the algorithm, find the expected value of UPDF(<em>x</em>, 0, <em>Z</em>+<em>b</em>*<em>c</em>), where <em>Z</em> is distributed as uniform(0, <em>K</em>).  This is done by finding the integral (area under the graph) with respect to <em>z</em> of UPDF(<em>x</em>, 0, <em>z</em>+<em>b</em>*<em>c</em>)*UPDF(<em>z</em>, 0, <em>K</em>) in the interval [0, <em>K</em>] (the set of values <em>Z</em> can take on).  The result is <code>PDF1(x) = ln(b**2*c**2 - b**2*c*d + (b*c - b*d)*min(b*(-c + d), max(0, -b*c + x)))/(b*c - b*d) - ln(b**2*c**2 - b**2*c*d + b*(-c + d)*(b*c - b*d))/(b*c - b*d)</code>.</li>
<li>The second PDF is the PDF for the product of two uniform random variates, one in [0, <em>b</em>] and the other in [<em>c</em>, <em>d</em>].  By Rohatgi&#39;s formula (see also (Glen et al. 2004)[^32]), it can be found by finding the integral with respect to <em>z</em> of UPDF(<em>z</em>, 0, <em>b</em>)*UPDF(<em>x</em>/<em>z</em>, <em>c</em>, <em>d</em>)/<em>z</em>, in the interval [0, &infin;) (noting that <em>z</em> is never negative here).  The result is <code>PDF2(x) = (ln(max(c,x/b)) - ln(max(c,d,x/b)))/(b*c-b*d)</code>.</li>
</ul>

<p>Now it must be shown that <code>PDF1</code> and <code>PDF2</code> are equal whenever <em>x</em> is in the interval (0, <em>b</em>*<em>d</em>).  Subtracting one PDF from the other and simplifying, it is seen that:</p>

<ul>
<li>Both PDFs are equal at least when <em>c</em> = 0 (and when <em>b</em>, <em>d</em>, and <em>x</em> are all greater than 0), and they are equal in all calculations so far when <em>b</em>, <em>c</em>, and <em>d</em> are replaced with specific values.</li>
<li>The simplified difference between the PDFs has an integral equal to 0, which strongly suggests the PDFs are equal (this is not conclusive because the simplified difference can be negative).</li>
</ul>

<p><a id=Oberhoff_s_Exact_Rejection_Sampling_Method></a></p>

<h3>Oberhoff&#39;s &quot;Exact Rejection Sampling&quot; Method</h3>

<p>The following describes an algorithm described by Oberhoff for sampling a continuous distribution taking on values in [0, 1], as long as the distribution has a probability density function (PDF) and the PDF is continuous &quot;almost everywhere&quot; and less than or equal to a finite number (Oberhoff 2018, section 3)[^13], see also (Devroye and Gravel 2020)[^3]. (Note that if the PDF&#39;s domain is wider than [0, 1], then the function needs to be divided into one-unit-long pieces, one piece chosen at random with probability proportional to its area, and that piece shifted so that it lies in [0, 1] rather than its usual place; see Oberhoff pp. 11-12.)</p>

<ol>
<li>Set <em>pdfmax</em> to an upper bound of the PDF (or the PDF times a possibly unknown constant factor) on the domain at [0, 1].  Let <em>base</em> be the base, or radix, of the digits in the return value (such as 2 for binary or 10 for decimal).</li>
<li>Set <em>prefix</em> to 0 and <em>prefixLength</em> to 0.</li>
<li>Set <em>y</em> to a uniform random variate in the interval [0, <em>pdfmax</em>].</li>
<li>Let <em>pw</em> be <em>base</em><sup>&minus;<em>prefixLength</em></sup>.  Set <em>lower</em> and <em>upper</em> to a lower or upper bound, respectively, of the value of the PDF (or the PDF times a possibly unknown constant factor) on the domain at [<em>prefix</em> * <em>pw</em>, <em>prefix</em> * <em>pw</em> + <em>pw</em>].</li>
<li>If <em>y</em> turns out to be greater than <em>upper</em>, the prefix was rejected, so go to step 2.</li>
<li>If <em>y</em> turns out to be less than <em>lower</em>, the prefix was accepted.  Now do the following:

<ol>
<li>While <em>prefixLength</em> is less than the desired precision, set <em>prefix</em> to <em>prefix</em> * <em>base</em> + <em>r</em>, where <em>r</em> is a uniform random digit, then add 1 to <em>prefixLength</em>.</li>
<li>Return <em>prefix</em> * <em>base</em><sup>&minus;<em>prefixLength</em></sup>.  (If <em>prefixLength</em> is somehow greater than the desired precision, then the algorithm could choose to round the return value to a number whose fractional part has the desired number of digits, with a rounding mode of choice.)</li>
</ol></li>
<li>Set <em>prefix</em> to <em>prefix</em> * <em>base</em> + <em>r</em>, where <em>r</em> is a uniform random digit, then add 1 to <em>prefixLength</em>, then go to step 4.</li>
</ol>

<p>Because this algorithm requires evaluating the PDF (or a constant times the PDF) and finding its maximum and minimum values at an interval (which often requires floating-point arithmetic and is often not trivial), this algorithm appears here in the appendix rather than in the main text.  Moreover, there is additional approximation error from generating <em>y</em> with a fixed number of digits, unless <em>y</em> is a uniform PSRN (see also &quot;<a href="#Application_to_Weighted_Reservoir_Sampling"><strong>Application to Weighted Reservoir Sampling</strong></a>&quot;).  For practical purposes, the lower and upper bounds calculated in step 4 should depend on <em>prefixLength</em> (the higher <em>prefixLength</em> is, the more accurate).</p>

<p>Oberhoff also describes <em>prefix distributions</em> that sample a box that covers the PDF, with probability proportional to the box&#39;s area, but these distributions will have to support a fixed maximum prefix length and so will only approximate the underlying distribution.</p>

<p><a id=Setting_Digits_by_Digit_Probabilities></a></p>

<h3>Setting Digits by Digit Probabilities</h3>

<p>In principle, a partially-sampled random number is possible by finding a sequence of digit probabilities and setting that number&#39;s digits according to those probabilities.  However, the uniform and exponential distributions are the only practical distributions of this kind.  Details follow.</p>

<p>Let <em>X</em> be a random variate of the form <code>0.bbbbbbb...</code>, where each <code>b</code> is an independent random binary digit (0 or 1).</p>

<p>Let <em>a</em><sub><em>j</em></sub> be the probability that the digit at position <em>j</em> equals 1 (starting with <em>j</em> = 1 for the first digit after the point).</p>

<p>Then Kakutani&#39;s theorem (Kakutani 1948)[^33] says that <em>X</em> has an <em>absolutely continuous</em>[^12] distribution if and only if the sum of squares of (<em>a</em><sub><em>j</em></sub> &minus; 1/2) converges.  In other words, the binary digits become less and less biased as they move farther and farther from the binary point.  See also (Marsaglia 1971)[^34], (Chatterji 1964)[^35].</p>

<p>This kind of absolutely continuous distribution can thus be built if we can find an infinite sequence <em>a</em><sub><em>j</em></sub> that converges to 1/2, and set <em>X</em>&#39;s binary digits using those probabilities.  However, as Marsaglia (1971)[^34] showed, the absolutely continuous distribution can only be one of the following:</p>

<ol>
<li>The distribution&#39;s probability density function (PDF) is zero somewhere in every open interval in (0, 1), without being 0 on all of [0, 1].  Thus, the PDF is not continuous.</li>
<li><p>The PDF is positive at 1/2, 1/4, 1/8, and so on, so the PDF is continuous and positive on all of (0, 1), and the sequence has the form&mdash;</p>

<p><em>a</em><sub><em>j</em></sub> = exp(<em>w</em>/2<sup><em>j</em></sup>)/(1 + exp(<em>w</em>/2<sup><em>j</em></sup>)),</p>

<p>where <em>w</em> is a constant.</p></li>
<li>The PDF is not described in Case 2 above, but is positive on some open interval in (0, 1), so the PDF will be piecewise continuous, and <em>X</em> can be multiplied by an integer power of 2 so that the new variate&#39;s distribution has a PDF described in Case 2.</li>
</ol>

<p>As Marsaglia also showed, similar results apply when the base of the random digits is other than 2 (binary).  See also my <a href="https://math.stackexchange.com/questions/4052024/on-random-variables-made-up-of-independent-random-digits"><strong>Stack Exchange question</strong></a>.</p>

<p>Case 2 has several special cases, including:</p>

<ul>
<li>The uniform distribution (<em>w</em> = 0).</li>
<li>The fractional part of an exponential random variate with rate 1 (<em>w</em> = &minus;1; (Devroye and Gravel 2020)[^3]).</li>
<li>More general, the fractional part of an exponential variate with rate <em>&lambda;</em> (<em>w</em> = &minus;<em>&lambda;</em>).</li>
<li>1 minus the fractional part of an exponential variate with rate <em>w</em> when <em>w</em> &gt; 0.</li>
<li><em>a</em><sub><em>j</em></sub> = <em>y</em><sup><em>v</em>/2<sup><em>j</em></sup></sup>/(1 + <em>y</em><sup><em>v</em>/2<sup><em>j</em></sup></sup>), with <em>w</em> = ln(<em>y</em>)*<em>v</em> where <em>y</em> &gt; 0 and <em>v</em> are constants.</li>
</ul>

<p><a id=License></a></p>

<h2>License</h2>

<p>Any copyright to this page is released to the Public Domain.  In case this is not possible, this page is also licensed under <a href="https://creativecommons.org/publicdomain/zero/1.0/"><strong>Creative Commons Zero</strong></a>.</p>
</div><nav id="navigation"><ul>
<li><a href="/">Back to start site.</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io">This site's repository (source code)</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io/issues">Post an issue or comment</a></ul>

<div class="noprint">
<p>
<a href="//twitter.com/intent/tweet">Share via Twitter</a>, <a href="//www.facebook.com/sharer/sharer.php" id="sharer">Share via Facebook</a>
</p>
</div>
</nav><script>
 document.getElementById("sharer").href="//www.facebook.com/sharer/sharer.php?u="+
    encodeURIComponent(document.location.href)
</script>
</body></html>
