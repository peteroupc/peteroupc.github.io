<!DOCTYPE html><html><head><meta http-equiv=Content-Type content="text/html; charset=utf-8"><title>com.upokecenter.numbers.EInteger</title><meta name="viewport" content="width=device-width"><link rel=stylesheet type="text/css" href="/style.css"></head><body>  <div class="header">
<p><a href="#navigation">Menu</a> - <a href="#top">Top</a> - <a href="/">Home</a> -
<a href="http://peteroupc.github.io/">Donate to Me</a></p></div>
<div class="mainarea" id="top">
<h1>com.upokecenter.numbers.EInteger</h1>

<h1>com.upokecenter.numbers.EInteger</h1>

<pre>public final class EInteger extends java.lang.Object implements java.lang.Comparable&lt;EInteger&gt;
</pre>

<p>Represents an arbitrary-precision integer. (The &quot;E&quot; stands for &quot;extended&quot;,
 and has this prefix to group it with the other classes common to this
 library, particularly EDecimal, EFloat, and ERational.) <p>Instances
 of this class are immutable, so they are inherently safe for use by
 multiple threads. Multiple instances of this object with the same
 value are interchangeable, but they should be compared using the
  &quot;Equals&quot; method rather than the &quot;==&quot; operator.</p> <p><b>Security
 note</b></p> <p>It is not recommended to implement security-sensitive
 algorithms using the methods in this class, for several reasons:</p>
 <ul> <li><code>EInteger</code> objects are immutable, so they can&#39;t be
 modified, and the memory they occupy is not guaranteed to be cleared
 in a timely fashion due to garbage collection. This is relevant for
 applications that use many-bit-long numbers as secret parameters.</li>
 <li>The methods in this class (especially those that involve
  arithmetic) are not guaranteed to be &quot;constant-time&quot;
 (non-data-dependent) for all relevant inputs. Certain attacks that
 involve encrypted communications have exploited the timing and other
 aspects of such communications to derive keying material or cleartext
 indirectly.</li></ul> <p>Applications should instead use dedicated
 security libraries to handle big numbers in security-sensitive
 algorithms.</p></p>

<h2>Methods</h2>

<ul>
<li><code>EInteger Abs()</code><br>
Returns the absolute value of this object&#39;s value.</li>
<li><code>EInteger Add​(int intValue)</code><br>
Adds this arbitrary-precision integer and a 32-bit signed integer and
returns the result.</li>
<li><code>EInteger Add​(long longValue)</code><br>
Adds this arbitrary-precision integer and a 64-bit signed integer and
returns the result.</li>
<li><code>EInteger Add​(EInteger bigintAugend)</code><br>
Adds this arbitrary-precision integer and another arbitrary-precision
integer and returns the result.</li>
<li><code>EInteger And​(EInteger other)</code><br>
Does an AND operation between this arbitrary-precision integer and another
one.</li>
<li><code>EInteger AndNot​(EInteger second)</code><br>
Does an AND NOT operation between this arbitrary-precision integer and
another one.</li>
<li><code>int AsInt32Checked()</code><br>
Deprecated.
Renamed to ToInt32Checked.
Renamed to ToInt32Checked.</li>
<li><code>int AsInt32Unchecked()</code><br>
Deprecated.
Renamed to ToInt32Unchecked.
Renamed to ToInt32Unchecked.</li>
<li><code>long AsInt64Checked()</code><br>
Deprecated.
Renamed to ToInt64Checked.
Renamed to ToInt64Checked.</li>
<li><code>long AsInt64Unchecked()</code><br>
Deprecated.
Renamed to ToInt64Unchecked.
Renamed to ToInt64Unchecked.</li>
<li><code>boolean CanFitInInt32()</code><br>
Returns whether this object&#39;s value can fit in a 32-bit signed integer.</li>
<li><code>boolean CanFitInInt64()</code><br>
Returns whether this object&#39;s value can fit in a 64-bit signed integer.</li>
<li><code>int compareTo​(int intValue)</code><br>
Compares an arbitrary-precision integer with this instance.</li>
<li><code>int compareTo​(long longValue)</code><br>
Compares an arbitrary-precision integer with this instance.</li>
<li><code>int compareTo​(EInteger other)</code><br>
Compares an arbitrary-precision integer with this instance.</li>
<li><code>EInteger Decrement()</code><br>
Returns one subtracted from this arbitrary-precision integer.</li>
<li><code>EInteger Divide​(int intValue)</code><br>
Divides this arbitrary-precision integer by a 32-bit signed integer and
returns the result.</li>
<li><code>EInteger Divide​(long longValue)</code><br>
Divides this arbitrary-precision integer by a 64-bit signed integer and
returns the result.</li>
<li><code>EInteger Divide​(EInteger bigintDivisor)</code><br>
Divides this arbitrary-precision integer by another arbitrary-precision
integer and returns the result.</li>
<li><code>EInteger[] DivRem​(int intDivisor)</code><br>
Divides this arbitrary-precision integer by a 32-bit signed integer and
returns a two-item array containing the result of the division and
the remainder, in that order.</li>
<li><code>EInteger[] DivRem​(long intDivisor)</code><br>
Divides this arbitrary-precision integer by a 64-bit signed integer and
returns a two-item array containing the result of the division and
the remainder, in that order.</li>
<li><code>EInteger[] DivRem​(EInteger divisor)</code><br>
Divides this arbitrary-precision integer by another arbitrary-precision
integer and returns a two-item array containing the result of the
division and the remainder, in that order.</li>
<li><code>boolean equals​(java.lang.Object obj)</code><br>
Determines whether this object and another object are equal and have the
same type.</li>
<li><code>EInteger Eqv​(EInteger second)</code><br>
Does an XOR NOT operation (or equivalence operation, EQV operation, or
exclusive-OR NOT operation) between this arbitrary-precision integer
and another one.</li>
<li><code>static EInteger FromBoolean​(boolean boolValue)</code><br>
Converts a boolean value (true or false) to an arbitrary-precision integer.</li>
<li><code>static EInteger FromByte​(byte inputByte)</code><br>
Converts a byte (from 0 to 255) to an arbitrary-precision integer.</li>
<li><code>static EInteger FromBytes​(byte[] bytes,
     boolean littleEndian)</code><br>
Initializes an arbitrary-precision integer from an array of bytes.</li>
<li><code>static EInteger FromBytes​(byte[] bytes,
     int offset,
     int length,
     boolean littleEndian)</code><br>
Initializes an arbitrary-precision integer from a portion of an array of
bytes.</li>
<li><code>static EInteger FromInt16​(short inputInt16)</code><br>
Converts a 16-bit signed integer to an arbitrary-precision integer.</li>
<li><code>static EInteger FromInt32​(int intValue)</code><br>
Converts a 32-bit signed integer to an arbitrary-precision integer.</li>
<li><code>static EInteger FromInt64​(long longerValue)</code><br>
Converts a 64-bit signed integer to an arbitrary-precision integer.</li>
<li><code>static EInteger FromRadixString​(byte[] bytes,
           int radix)</code><br>
Converts a sequence of bytes (interpreted as text) to an arbitrary-precision
integer in a given radix.</li>
<li><code>static EInteger FromRadixString​(char[] cs,
           int radix) char</code><br>
Converts a sequence of char s to an arbitrary-precision integer in a
given radix.</li>
<li><code>static EInteger FromRadixString​(java.lang.String str,
           int radix)</code><br>
Converts a string to an arbitrary-precision integer in a given radix.</li>
<li><code>static EInteger FromRadixSubstring​(byte[] bytes,
              int radix,
              int index,
              int endIndex)</code><br>
Converts a portion of a sequence of bytes (interpreted as text) to an
arbitrary-precision integer in a given radix.</li>
<li><code>static EInteger FromRadixSubstring​(char[] cs,
              int radix,
              int index,
              int endIndex) char</code><br>
Converts a portion of a sequence of char s to an arbitrary-precision
integer in a given radix.</li>
<li><code>static EInteger FromRadixSubstring​(java.lang.String str,
              int radix,
              int index,
              int endIndex)</code><br>
Converts a portion of a string to an arbitrary-precision integer in a given
radix.</li>
<li><code>static EInteger FromString​(byte[] bytes)</code><br>
Converts a sequence of bytes (interpreted as text) to an arbitrary-precision
integer.</li>
<li><code>static EInteger FromString​(char[] cs) char</code><br>
Converts a sequence of char s to an arbitrary-precision integer.</li>
<li><code>static EInteger FromString​(java.lang.String str)</code><br>
Converts a string to an arbitrary-precision integer.</li>
<li><code>static EInteger FromSubstring​(byte[] bytes,
         int index,
         int endIndex)</code><br>
Converts a portion of a sequence of bytes (interpreted as text) to an
arbitrary-precision integer.</li>
<li><code>static EInteger FromSubstring​(char[] cs,
         int index,
         int endIndex) char</code><br>
Converts a portion of a sequence of char s to an arbitrary-precision
integer.</li>
<li><code>static EInteger FromSubstring​(java.lang.String str,
         int index,
         int endIndex)</code><br>
Converts a portion of a string to an arbitrary-precision integer.</li>
<li><code>EInteger Gcd​(EInteger bigintSecond)</code><br>
Returns the greatest common divisor of this integer and the given integer.</li>
<li><code>int GetDigitCount()</code><br>
Deprecated.
This method may overflow.
This method may overflow.</li>
<li><code>EInteger GetDigitCountAsEInteger()</code><br>
Returns the number of decimal digits used by this integer, in the form of an
arbitrary-precision integer.</li>
<li><code>long GetDigitCountAsInt64()</code><br>
Returns the number of decimal digits used by this integer, in the form of a
64-bit signed integer.</li>
<li><code>int GetLowBit()</code><br>
Deprecated.
This method may overflow.
This method may overflow.</li>
<li><code>EInteger GetLowBitAsEInteger()</code><br>
Gets the bit position of the lowest set bit in this number&#39;s absolute value,
in the form of an arbitrary-precision integer.</li>
<li><code>long GetLowBitAsInt64()</code><br>
Gets the bit position of the lowest set bit in this number&#39;s absolute value,
in the form of a 64-bit signed integer.</li>
<li><code>static EInteger getOne()</code><br>
Gets the number 1 as an arbitrary-precision integer.</li>
<li><code>boolean GetSignedBit​(int index) &quot;Forms of numbers&quot;</code><br>
Returns whether a bit is set in the two&#39;s-complement form (see &quot;Forms of numbers&quot;) of this
object&#39;s value.</li>
<li><code>boolean GetSignedBit​(EInteger bigIndex) &quot;Forms of numbers&quot;</code><br>
Returns whether a bit is set in the two&#39;s-complement form (see &quot;Forms of numbers&quot;) of this
object&#39;s value.</li>
<li><code>int GetSignedBitLength()</code><br>
Deprecated.
This method may overflow.
This method may overflow.</li>
<li><code>EInteger GetSignedBitLengthAsEInteger()</code><br>
Finds the minimum number of bits needed to represent this object&#39;s value,
except for its sign, in the form of an arbitrary-precision integer.</li>
<li><code>long GetSignedBitLengthAsInt64()</code><br>
Finds the minimum number of bits needed to represent this object&#39;s value,
except for its sign, in the form of a 64-bit signed integer.</li>
<li><code>static EInteger getTen()</code><br>
Gets the number 10 as an arbitrary-precision integer.</li>
<li><code>boolean GetUnsignedBit​(int index)</code><br>
Returns whether a bit is set in this number&#39;s absolute value.</li>
<li><code>boolean GetUnsignedBit​(EInteger bigIndex)</code><br>
Returns whether a bit is set in this number&#39;s absolute value.</li>
<li><code>int GetUnsignedBitLength()</code><br>
Deprecated.
This method may overflow.
This method may overflow.</li>
<li><code>EInteger GetUnsignedBitLengthAsEInteger()</code><br>
Finds the minimum number of bits needed to represent this number&#39;s absolute
value, in the form of an arbitrary-precision integer.</li>
<li><code>long GetUnsignedBitLengthAsInt64()</code><br>
Finds the minimum number of bits needed to represent this number&#39;s absolute
value, in the form of a 64-bit signed integer.</li>
<li><code>static EInteger getZero()</code><br>
Gets the number zero as an arbitrary-precision integer.</li>
<li><code>int hashCode()</code><br>
Returns the hash code for this instance.</li>
<li><code>EInteger Imp​(EInteger second)</code><br>
Does an OR NOT operation (or implication or IMP operation) between this
arbitrary-precision integer and another one.</li>
<li><code>EInteger Increment()</code><br>
Returns one added to this arbitrary-precision integer.</li>
<li><code>boolean isEven()</code><br>
Gets a value indicating whether this value is even.</li>
<li><code>boolean isPowerOfTwo()</code><br>
Gets a value indicating whether this object&#39;s value is a power of two, and
greater than 0.</li>
<li><code>boolean isZero()</code><br>
Gets a value indicating whether this value is 0.</li>
<li><code>static EInteger Max​(EInteger first,
EInteger second)</code><br>
Returns the greater of two arbitrary-precision integers.</li>
<li><code>static EInteger MaxMagnitude​(EInteger first,
        EInteger second)</code><br>
Of two arbitrary-precision integers, returns the one with the greater
absolute value.</li>
<li><code>static EInteger Min​(EInteger first,
EInteger second)</code><br>
Returns the smaller of two arbitrary-precision integers.</li>
<li><code>static EInteger MinMagnitude​(EInteger first,
        EInteger second)</code><br>
Of two arbitrary-precision integers, returns the one with the smaller
absolute value.</li>
<li><code>EInteger Mod​(int smallDivisor)</code><br>
Finds the modulus remainder that results when this instance is divided by
the value of another integer.</li>
<li><code>EInteger Mod​(EInteger divisor)</code><br>
Finds the modulus remainder that results when this instance is divided by
the value of an arbitrary-precision integer.</li>
<li><code>EInteger ModPow​(EInteger pow,
  EInteger mod)</code><br>
Calculates the remainder when this arbitrary-precision integer raised to a
certain power is divided by another arbitrary-precision integer.</li>
<li><code>EInteger Multiply​(int intValue)</code><br>
Multiplies this arbitrary-precision integer by a 32-bit signed integer and
returns the result.</li>
<li><code>EInteger Multiply​(long longValue)</code><br>
Multiplies this arbitrary-precision integer by a 64-bit signed integer and
returns the result.</li>
<li><code>EInteger Multiply​(EInteger bigintMult)</code><br>
Multiplies this arbitrary-precision integer by another arbitrary-precision
integer and returns the result.</li>
<li><code>EInteger Negate()</code><br>
Gets the value of this object with the sign reversed.</li>
<li><code>EInteger Not()</code><br>
Returns an arbitrary-precision integer with every bit flipped from this one
(also called an inversion or NOT operation).</li>
<li><code>EInteger Or​(EInteger second)</code><br>
Does an OR operation between this arbitrary-precision integer and another
one.</li>
<li><code>EInteger OrNot​(EInteger second)</code><br>
Does an OR NOT operation (or implication or IMP operation) between this
arbitrary-precision integer and another one.</li>
<li><code>EInteger Pow​(int powerSmall)</code><br>
Raises an arbitrary-precision integer to a power.</li>
<li><code>EInteger Pow​(EInteger bigPower)</code><br>
Raises an arbitrary-precision integer to a power.</li>
<li><code>EInteger PowBigIntVar​(EInteger power)</code><br>
Raises an arbitrary-precision integer to a power, which is given as another
arbitrary-precision integer.</li>
<li><code>EInteger Remainder​(int intValue)</code><br>
Returns the remainder that would result when this arbitrary-precision
integer is divided by a 32-bit signed integer.</li>
<li><code>EInteger Remainder​(long longValue)</code><br>
Returns the remainder that would result when this arbitrary-precision
integer is divided by a 64-bit signed integer.</li>
<li><code>EInteger Remainder​(EInteger divisor)</code><br>
Returns the remainder that would result when this arbitrary-precision
integer is divided by another arbitrary-precision integer.</li>
<li><code>EInteger Root​(int root)</code><br>
Finds the nth root of this instance&#39;s value, rounded down.</li>
<li><code>EInteger Root​(EInteger root)</code><br>
Finds the nth root of this instance&#39;s value, rounded down.</li>
<li><code>EInteger[] RootRem​(int root)</code><br>
Calculates the nth root and the remainder.</li>
<li><code>EInteger[] RootRem​(EInteger root)</code><br>
Calculates the nth root and the remainder.</li>
<li><code>EInteger ShiftLeft​(int numberBits)</code><br>
Returns an arbitrary-precision integer with the bits shifted to the left by
a number of bits.</li>
<li><code>EInteger ShiftLeft​(EInteger eshift)</code><br>
Returns an arbitrary-precision integer with the bits shifted to the left by
a number of bits given as an arbitrary-precision integer.</li>
<li><code>EInteger ShiftRight​(int numberBits)</code><br>
Returns an arbitrary-precision integer with the bits shifted to the right.</li>
<li><code>EInteger ShiftRight​(EInteger eshift)</code><br>
Returns an arbitrary-precision integer with the bits shifted to the right.</li>
<li><code>int signum()</code><br>
Gets the sign of this object&#39;s value.</li>
<li><code>EInteger Sqrt()</code><br>
Finds the square root of this instance&#39;s value, rounded down.</li>
<li><code>EInteger[] SqrtRem()</code><br>
Calculates the square root and the remainder.</li>
<li><code>EInteger Subtract​(int intValue)</code><br>
Subtracts a 32-bit signed integer from this arbitrary-precision integer and
returns the result.</li>
<li><code>EInteger Subtract​(long longValue)</code><br>
Subtracts a 64-bit signed integer from this arbitrary-precision integer and
returns the result.</li>
<li><code>EInteger Subtract​(EInteger subtrahend)</code><br>
Subtracts an arbitrary-precision integer from this arbitrary-precision
integer and returns the result.</li>
<li><code>byte ToByteChecked()</code><br>
Converts this number&#39;s value to a byte (from 0 to 255) if it can fit in a
byte (from 0 to 255).</li>
<li><code>byte[] ToBytes​(boolean littleEndian)</code><br>
Returns a byte array of this integer&#39;s value.</li>
<li><code>byte ToByteUnchecked()</code><br>
Converts this number to a byte (from 0 to 255), returning the
least-significant bits of this number&#39;s two&#39;s-complement form.</li>
<li><code>short ToInt16Checked()</code><br>
Converts this number&#39;s value to a 16-bit signed integer if it can fit in a
16-bit signed integer.</li>
<li><code>short ToInt16Unchecked()</code><br>
Converts this number to a 16-bit signed integer, returning the
least-significant bits of this number&#39;s two&#39;s-complement form.</li>
<li><code>int ToInt32Checked()</code><br>
Converts this object&#39;s value to a 32-bit signed integer, throwing an
exception if it can&#39;t fit.</li>
<li><code>int ToInt32Unchecked()</code><br>
Converts this object&#39;s value to a 32-bit signed integer.</li>
<li><code>long ToInt64Checked()</code><br>
Converts this object&#39;s value to a 64-bit signed integer, throwing an
exception if it can&#39;t fit.</li>
<li><code>long ToInt64Unchecked()</code><br>
Converts this object&#39;s value to a 64-bit signed integer.</li>
<li><code>java.lang.String ToRadixString​(int radix)</code><br>
Generates a string representing the value of this object, in the given
radix.</li>
<li><code>java.lang.String toString()</code><br>
Converts this object to a text string in base 10.</li>
<li><code>EInteger Xor​(EInteger other)</code><br>
Does an exclusive OR (XOR) operation between this arbitrary-precision
integer and another one.</li>
<li><code>EInteger XorNot​(EInteger second)</code><br>
Does an XOR NOT operation (or equivalence operation, EQV operation, or
exclusive-OR NOT operation) between this arbitrary-precision integer
and another one.</li>
</ul>

<h2>Method Details</h2>

<h3>getOne</h3>

<pre>public static EInteger getOne()
</pre>

<p>Gets the number 1 as an arbitrary-precision integer.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>The number 1 as an arbitrary-precision integer.</li>
</ul>

<h3>getTen</h3>

<pre>public static EInteger getTen()
</pre>

<p>Gets the number 10 as an arbitrary-precision integer.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>The number 10 as an arbitrary-precision integer.</li>
</ul>

<h3>getZero</h3>

<pre>public static EInteger getZero()
</pre>

<p>Gets the number zero as an arbitrary-precision integer.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>The number zero as an arbitrary-precision integer.</li>
</ul>

<h3>isEven</h3>

<pre>public final boolean isEven()
</pre>

<p>Gets a value indicating whether this value is even.</p>

<p><strong>Returns:</strong></p>

<ul>
<li><code>true</code> if this value is even; otherwise, <code>false</code>.</li>
</ul>

<h3>isPowerOfTwo</h3>

<pre>public final boolean isPowerOfTwo()
</pre>

<p>Gets a value indicating whether this object&#39;s value is a power of two, and
 greater than 0.</p>

<p><strong>Returns:</strong></p>

<ul>
<li><code>true</code> if this object&#39;s value is a power of two, and greater
than 0; otherwise, <code>false</code>.</li>
</ul>

<h3>isZero</h3>

<pre>public final boolean isZero()
</pre>

<p>Gets a value indicating whether this value is 0.</p>

<p><strong>Returns:</strong></p>

<ul>
<li><code>true</code> if this value is 0; otherwise, <code>false</code>.</li>
</ul>

<h3>signum</h3>

<pre>public final int signum()
</pre>

<p>Gets the sign of this object&#39;s value.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>The sign of this object&#39;s value.</li>
</ul>

<h3>FromBytes</h3>

<pre>public static EInteger FromBytes​(byte[] bytes, boolean littleEndian)
</pre>

<p>Initializes an arbitrary-precision integer from an array of bytes.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>bytes</code> - A byte array consisting of the two&#39;s-complement form (see
<code>&quot;Forms of numbers&quot;</code>) of the
arbitrary-precision integer to create. The byte array is encoded
using the rules given in the FromBytes(bytes, offset, length,
littleEndian) overload.</p></li>
<li><p><code>littleEndian</code> - If true, the byte order is little-endian, or
least-significant-byte first. If false, the byte order is
big-endian, or most-significant-byte first.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision integer. Returns 0 if the byte array&#39;s length
is 0.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.NullPointerException</code> - The parameter <code>bytes</code> is null.</li>
</ul>

<h3>FromBytes</h3>

<pre>public static EInteger FromBytes​(byte[] bytes, int offset, int length, boolean littleEndian)
</pre>

<p>Initializes an arbitrary-precision integer from a portion of an array of
 bytes. The portion of the byte array is encoded using the following
 rules: <ul> <li>Positive numbers have the first byte&#39;s highest bit
 cleared, and negative numbers have the bit set.</li> <li>The last
 byte contains the lowest 8-bits, the next-to-last contains the next
 lowest 8 bits, and so on. For example, the number 300 can be encoded
 as <code>0x01, 0x2C</code> and 200 as <code>0x00, 0xC8</code>. (Note that the
 second example contains a set high bit in <code>0xC8</code>, so an
 additional 0 is added at the start to ensure it&#39;s interpreted as
 positive.)</li> <li>To encode negative numbers, take the absolute
 value of the number, subtract by 1, encode the number into bytes,
 and toggle each bit of each byte. Any further bits that appear
 beyond the most significant bit of the number will be all ones. For
 example, the number -450 can be encoded as <code>0xfe, 0x70</code> and
 -52869 as <code>0xff, 0x31, 0x7B</code>. (Note that the second example
 contains a cleared high bit in <code>0x31, 0x7B</code>, so an additional
 0xff is added at the start to ensure it&#39;s interpreted as
 negative.)</li></ul> <p>For little-endian, the byte order is
 reversed from the byte order just discussed.</p></p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>bytes</code> - A byte array consisting of the two&#39;s-complement form (see
<code>&quot;Forms of numbers&quot;</code>) of the
arbitrary-precision integer to create. The byte array is encoded
using the rules given in the FromBytes(bytes, offset, length,
littleEndian) overload.</p></li>
<li><p><code>offset</code> - An index starting at 0 showing where the desired portion of
<code>bytes</code> begins.</p></li>
<li><p><code>length</code> - The length, in bytes, of the desired portion of <code>bytes</code>
(but not more than <code>bytes</code> &#39;s length).</p></li>
<li><p><code>littleEndian</code> - If true, the byte order is little-endian, or
least-significant-byte first. If false, the byte order is
big-endian, or most-significant-byte first.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision integer. Returns 0 if the byte array&#39;s length
is 0.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>bytes</code> is null.</p></li>
<li><p><code>java.lang.IllegalArgumentException</code> - Either <code>offset</code> or <code>length</code> is less
than 0 or greater than <code>bytes</code> &#39;s length, or <code>bytes</code> &#39;s
length minus <code>offset</code> is less than <code>length</code>.</p></li>
</ul>

<h3>FromBoolean</h3>

<pre>public static EInteger FromBoolean​(boolean boolValue)
</pre>

<p>Converts a boolean value (true or false) to an arbitrary-precision integer.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>boolValue</code> - Either true or false.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The number 1 if <code>boolValue</code> is true; otherwise, 0.</li>
</ul>

<h3>FromInt32</h3>

<pre>public static EInteger FromInt32​(int intValue)
</pre>

<p>Converts a 32-bit signed integer to an arbitrary-precision integer.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>intValue</code> - The parameter <code>intValue</code> is a 32-bit signed integer.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision integer with the same value as the 64-bit
number.</li>
</ul>

<h3>FromInt64</h3>

<pre>public static EInteger FromInt64​(long longerValue)
</pre>

<p>Converts a 64-bit signed integer to an arbitrary-precision integer.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>longerValue</code> - The parameter <code>longerValue</code> is a 64-bit signed
integer.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision integer with the same value as the 64-bit
number.</li>
</ul>

<h3>FromRadixString</h3>

<pre>public static EInteger FromRadixString​(java.lang.String str, int radix)
</pre>

<p>Converts a string to an arbitrary-precision integer in a given radix.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>str</code> - A string described by the FromRadixSubstring method.</p></li>
<li><p><code>radix</code> - A base from 2 to 36. Depending on the radix, the string can use
the basic digits 0 to 9 (U+0030 to U+0039) and then the basic
upper-case letters A to Z (U+0041 to U+005A). For example, 0-9 in
radix 10, and 0-9, then A-F in radix 16. Where a basic upper-case
letter A to Z is allowed in the string, the corresponding basic
lower-case letter (U+0061 to U+007a) is allowed instead.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision integer with the same value as the given
string.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>str</code> is null.</p></li>
<li><p><code>java.lang.NumberFormatException</code> - The string is empty or in an invalid format.</p></li>
</ul>

<h3>FromRadixSubstring</h3>

<pre>public static EInteger FromRadixSubstring​(java.lang.String str, int radix, int index, int endIndex)
</pre>

<p>Converts a portion of a string to an arbitrary-precision integer in a given
 radix.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>str</code> - A text string. The desired portion of the string must contain
only characters allowed by the given radix, except that it may start
with a minus sign (&quot;-&quot;, U+002D) to indicate a negative number. The
desired portion is not allowed to contain white space characters,
including spaces. The desired portion may start with any number of
zeros.</p></li>
<li><p><code>radix</code> - A base from 2 to 36. Depending on the radix, the string can use
the basic digits 0 to 9 (U+0030 to U+0039) and then the basic
upper-case letters A to Z (U+0041 to U+005A). For example, 0-9 in
radix 10, and 0-9, then A-F in radix 16. Where a basic upper-case
letter A to Z is allowed in the string, the corresponding basic
lower-case letter (U+0061 to U+007a) is allowed instead.</p></li>
<li><p><code>index</code> - The index of the string that starts the string portion.</p></li>
<li><p><code>endIndex</code> - The index of the string that ends the string portion. The
length will be index + endIndex - 1.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision integer with the same value as given in the
string portion.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>str</code> is null.</p></li>
<li><p><code>java.lang.NumberFormatException</code> - The string portion is empty or in an invalid format.</p></li>
</ul>

<h3>FromSubstring</h3>

<pre>public static EInteger FromSubstring​(char[] cs, int index, int endIndex)
</pre>

<p>Converts a portion of a sequence of <code>char</code> s to an arbitrary-precision
 integer.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>cs</code> - A sequence of <code>char</code> s, the desired portion of which
describes an integer in base-10 (decimal) form. The desired portion
of the sequence of <code>char</code> s must contain only basic digits 0
to 9 (U+0030 to U+0039), except that it may start with a minus sign
(&quot;-&quot;, U+002D) to indicate a negative number. The desired portion is
not allowed to contain white space characters, including spaces. The
desired portion may start with any number of zeros.</p></li>
<li><p><code>index</code> - The index of the sequence of <code>char</code> s that starts the
desired portion.</p></li>
<li><p><code>endIndex</code> - The index of the sequence of <code>char</code> s that ends the
desired portion. The length will be index + endIndex - 1.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision integer with the same value as given in the
sequence of <code>char</code> s portion.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.IllegalArgumentException</code> - The parameter <code>index</code> is less than 0, <code>
endIndex</code> is less than 0, or either is greater than the sequence&#39;s
length, or <code>endIndex</code> is less than <code>index</code>.</p></li>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>cs</code> is null.</p></li>
</ul>

<h3>FromString</h3>

<pre>public static EInteger FromString​(char[] cs)
</pre>

<p>Converts a sequence of <code>char</code> s to an arbitrary-precision integer.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>cs</code> - A sequence of <code>char</code> s describing an integer in base-10
(decimal) form. The sequence must contain only basic digits 0 to 9
(U+0030 to U+0039), except that it may start with a minus sign (&quot;-&quot;,
U+002D) to indicate a negative number. The sequence is not allowed
to contain white space characters, including spaces. The sequence
may start with any number of zeros.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision integer with the same value as given in the
sequence of <code>char</code> s.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.NumberFormatException</code> - The parameter <code>cs</code> is in an invalid format.</p></li>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>cs</code> is null.</p></li>
</ul>

<h3>FromRadixString</h3>

<pre>public static EInteger FromRadixString​(char[] cs, int radix)
</pre>

<p>Converts a sequence of <code>char</code> s to an arbitrary-precision integer in a
 given radix.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>cs</code> - A sequence of <code>char</code> s described by the FromRadixSubstring
method.</p></li>
<li><p><code>radix</code> - A base from 2 to 36. Depending on the radix, the sequence of
<code>char</code> s can use the basic digits 0 to 9 (U+0030 to U+0039)
and then the basic upper-case letters A to Z (U+0041 to U+005A). For
example, 0-9 in radix 10, and 0-9, then A-F in radix 16. Where a
basic upper-case letter A to Z is allowed in the sequence of <code>
char</code> s, the corresponding basic lower-case letter (U+0061 to
U+007a) is allowed instead.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision integer with the same value as the given
sequence of <code>char</code> s.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>cs</code> is null.</p></li>
<li><p><code>java.lang.NumberFormatException</code> - The sequence of <code>char</code> s is empty or in an
invalid format.</p></li>
</ul>

<h3>FromRadixSubstring</h3>

<pre>public static EInteger FromRadixSubstring​(char[] cs, int radix, int index, int endIndex)
</pre>

<p>Converts a portion of a sequence of <code>char</code> s to an arbitrary-precision
 integer in a given radix.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>cs</code> - A text sequence of <code>char</code> s. The desired portion of the
sequence of <code>char</code> s must contain only characters allowed by
the given radix, except that it may start with a minus sign (&quot;-&quot;,
U+002D) to indicate a negative number. The desired portion is not
allowed to contain white space characters, including spaces. The
desired portion may start with any number of zeros.</p></li>
<li><p><code>radix</code> - A base from 2 to 36. Depending on the radix, the sequence of
<code>char</code> s can use the basic digits 0 to 9 (U+0030 to U+0039)
and then the basic upper-case letters A to Z (U+0041 to U+005A). For
example, 0-9 in radix 10, and 0-9, then A-F in radix 16. Where a
basic upper-case letter A to Z is allowed in the sequence of <code>
char</code> s, the corresponding basic lower-case letter (U+0061 to
U+007a) is allowed instead.</p></li>
<li><p><code>index</code> - The index of the sequence of <code>char</code> s that starts the
desired portion.</p></li>
<li><p><code>endIndex</code> - The index of the sequence of <code>char</code> s that ends the
desired portion. The length will be index + endIndex - 1.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision integer with the same value as given in the
sequence&#39;s portion.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>cs</code> is null.</p></li>
<li><p><code>java.lang.NumberFormatException</code> - The portion is empty or in an invalid format.</p></li>
</ul>

<h3>FromSubstring</h3>

<pre>public static EInteger FromSubstring​(byte[] bytes, int index, int endIndex)
</pre>

<p>Converts a portion of a sequence of bytes (interpreted as text) to an
 arbitrary-precision integer. Each byte in the sequence has to be a
 character in the Basic Latin range (0x00 to 0x7f or U+0000 to
 U+007F) of the Unicode Standard.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>bytes</code> - A sequence of bytes (interpreted as text), the desired portion
of which describes an integer in base-10 (decimal) form. The desired
portion of the sequence of bytes (interpreted as text) must contain
only basic digits 0 to 9 (U+0030 to U+0039), except that it may
start with a minus sign (&quot;-&quot;, U+002D) to indicate a negative number.
The desired portion is not allowed to contain white space
characters, including spaces. The desired portion may start with any
number of zeros.</p></li>
<li><p><code>index</code> - The index of the sequence of bytes (interpreted as text) that
starts the desired portion.</p></li>
<li><p><code>endIndex</code> - The index of the sequence of bytes (interpreted as text)
that ends the desired portion. The length will be index + endIndex -
1.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision integer with the same value as given in the
sequence of bytes (interpreted as text) portion.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.IllegalArgumentException</code> - The parameter <code>index</code> is less than 0, <code>
endIndex</code> is less than 0, or either is greater than the sequence&#39;s
length, or <code>endIndex</code> is less than <code>index</code>.</p></li>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>bytes</code> is null.</p></li>
</ul>

<h3>FromString</h3>

<pre>public static EInteger FromString​(byte[] bytes)
</pre>

<p>Converts a sequence of bytes (interpreted as text) to an arbitrary-precision
 integer. Each byte in the sequence has to be a code point in the
 Basic Latin range (0x00 to 0x7f or U+0000 to U+007F) of the Unicode
 Standard.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>bytes</code> - A sequence of bytes describing an integer in base-10 (decimal)
form. The sequence must contain only basic digits 0 to 9 (U+0030 to
U+0039), except that it may start with a minus sign (&quot;-&quot;, U+002D) to
indicate a negative number. The sequence is not allowed to contain
white space characters, including spaces. The sequence may start
with any number of zeros.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision integer with the same value as given in the
sequence of bytes.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.NumberFormatException</code> - The parameter <code>bytes</code> is in an invalid format.</p></li>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>bytes</code> is null.</p></li>
</ul>

<h3>FromRadixString</h3>

<pre>public static EInteger FromRadixString​(byte[] bytes, int radix)
</pre>

<p>Converts a sequence of bytes (interpreted as text) to an arbitrary-precision
 integer in a given radix. Each byte in the sequence has to be a
 character in the Basic Latin range (0x00 to 0x7f or U+0000 to
 U+007F) of the Unicode Standard.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>bytes</code> - A sequence of bytes (interpreted as text) described by the
FromRadixSubstring method.</p></li>
<li><p><code>radix</code> - A base from 2 to 36. Depending on the radix, the sequence of
bytes can use the basic digits 0 to 9 (U+0030 to U+0039) and then
the basic upper-case letters A to Z (U+0041 to U+005A). For example,
0-9 in radix 10, and 0-9, then A-F in radix 16. Where a basic
upper-case letter A to Z is allowed in the sequence of bytes, the
corresponding basic lower-case letter (U+0061 to U+007a) is allowed
instead.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision integer with the same value as the given
sequence of bytes.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>bytes</code> is null.</p></li>
<li><p><code>java.lang.NumberFormatException</code> - The sequence of bytes (interpreted as text) is empty
or in an invalid format.</p></li>
</ul>

<h3>FromRadixSubstring</h3>

<pre>public static EInteger FromRadixSubstring​(byte[] bytes, int radix, int index, int endIndex)
</pre>

<p>Converts a portion of a sequence of bytes (interpreted as text) to an
 arbitrary-precision integer in a given radix. Each byte in the
 sequence has to be a character in the Basic Latin range (0x00 to
 0x7f or U+0000 to U+007F) of the Unicode Standard.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>bytes</code> - A sequence of bytes (interpreted as text). The desired portion
of the sequence of bytes (interpreted as text) must contain only
characters allowed by the given radix, except that it may start with
a minus sign (&quot;-&quot;, U+002D) to indicate a negative number. The
desired portion is not allowed to contain white space characters,
including spaces. The desired portion may start with any number of
zeros.</p></li>
<li><p><code>radix</code> - A base from 2 to 36. Depending on the radix, the sequence of
bytes (interpreted as text) can use the basic digits 0 to 9 (U+0030
to U+0039) and then the basic upper-case letters A to Z (U+0041 to
U+005A). For example, 0-9 in radix 10, and 0-9, then A-F in radix</p>

<ol>
<li>Where a basic upper-case letter A to Z is allowed in the
sequence of bytes (interpreted as text), the corresponding basic
lower-case letter (U+0061 to U+007a) is allowed instead.</li>
</ol></li>
<li><p><code>index</code> - The index of the sequence of bytes (interpreted as text) that
starts the desired portion.</p></li>
<li><p><code>endIndex</code> - The index of the sequence of bytes (interpreted as text)
that ends the desired portion. The length will be index + endIndex -
1.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision integer with the same value as given in the
sequence&#39;s portion.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>bytes</code> is null.</p></li>
<li><p><code>java.lang.NumberFormatException</code> - The portion is empty or in an invalid format.</p></li>
</ul>

<h3>FromString</h3>

<pre>public static EInteger FromString​(java.lang.String str)
</pre>

<p>Converts a string to an arbitrary-precision integer.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>str</code> - A text string describing an integer in base-10 (decimal) form.
The string must contain only basic digits 0 to 9 (U+0030 to U+0039),
except that it may start with a minus sign (&quot;-&quot;, U+002D) to indicate
a negative number. The string is not allowed to contain white space
characters, including spaces. The string may start with any number
of zeros.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision integer with the same value as given in the
string.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.NumberFormatException</code> - The parameter <code>str</code> is in an invalid format.</p></li>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>str</code> is null.</p></li>
</ul>

<h3>FromSubstring</h3>

<pre>public static EInteger FromSubstring​(java.lang.String str, int index, int endIndex)
</pre>

<p>Converts a portion of a string to an arbitrary-precision integer.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>str</code> - A text string, the desired portion of which describes an integer
in base-10 (decimal) form. The desired portion of the string must
contain only basic digits 0 to 9 (U+0030 to U+0039), except that it
may start with a minus sign (&quot;-&quot;, U+002D) to indicate a negative
number. The desired portion is not allowed to contain white space
characters, including spaces. The desired portion may start with any
number of zeros.</p></li>
<li><p><code>index</code> - The index of the string that starts the string portion.</p></li>
<li><p><code>endIndex</code> - The index of the string that ends the string portion. The
length will be index + endIndex - 1.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision integer with the same value as given in the
string portion.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.IllegalArgumentException</code> - The parameter <code>index</code> is less than 0, <code>
endIndex</code> is less than 0, or either is greater than the string&#39;s
length, or <code>endIndex</code> is less than <code>index</code>.</p></li>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>str</code> is null.</p></li>
</ul>

<h3>Abs</h3>

<pre>public EInteger Abs()
</pre>

<p>Returns the absolute value of this object&#39;s value.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>This object&#39;s value with the sign removed.</li>
</ul>

<h3>Add</h3>

<pre>public EInteger Add​(EInteger bigintAugend)
</pre>

<p>Adds this arbitrary-precision integer and another arbitrary-precision
 integer and returns the result.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>bigintAugend</code> - Another arbitrary-precision integer.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The sum of the two numbers, that is, this arbitrary-precision
integer plus another arbitrary-precision integer.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.NullPointerException</code> - The parameter <code>bigintAugend</code> is null.</li>
</ul>

<h3>AsInt32Checked</h3>

<pre>@Deprecated public int AsInt32Checked()
</pre>

<p>Deprecated.
Renamed to ToInt32Checked.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>A 32-bit signed integer.</li>
</ul>

<h3>AsInt32Unchecked</h3>

<pre>@Deprecated public int AsInt32Unchecked()
</pre>

<p>Deprecated.
Renamed to ToInt32Unchecked.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>A 32-bit signed integer.</li>
</ul>

<h3>AsInt64Checked</h3>

<pre>@Deprecated public long AsInt64Checked()
</pre>

<p>Deprecated.
Renamed to ToInt64Checked.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>A 64-bit signed integer.</li>
</ul>

<h3>AsInt64Unchecked</h3>

<pre>@Deprecated public long AsInt64Unchecked()
</pre>

<p>Deprecated.
Renamed to ToInt64Unchecked.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>A 64-bit signed integer.</li>
</ul>

<h3>CanFitInInt32</h3>

<pre>public boolean CanFitInInt32()
</pre>

<p>Returns whether this object&#39;s value can fit in a 32-bit signed integer.</p>

<p><strong>Returns:</strong></p>

<ul>
<li><code>true</code> if this object&#39;s value is from -2147483648 through
2147483647; otherwise, <code>false</code>.</li>
</ul>

<h3>CanFitInInt64</h3>

<pre>public boolean CanFitInInt64()
</pre>

<p>Returns whether this object&#39;s value can fit in a 64-bit signed integer.</p>

<p><strong>Returns:</strong></p>

<ul>
<li><code>true</code> if this object&#39;s value is from -9223372036854775808
through 9223372036854775807; otherwise, <code>false</code>.</li>
</ul>

<h3>compareTo</h3>

<pre>public int compareTo​(EInteger other)
</pre>

<p>Compares an arbitrary-precision integer with this instance.</p>

<p><strong>Specified by:</strong></p>

<ul>
<li><code>compareTo</code> in interface <code>java.lang.Comparable&lt;EInteger&gt;</code></li>
</ul>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>other</code> - The integer to compare to this value.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>Zero if the values are equal; a negative number if this instance is
less, or a positive number if this instance is greater. This
implementation returns a positive number if.</li>
</ul>

<h3>Max</h3>

<pre>public static EInteger Max​(EInteger first, EInteger second)
</pre>

<p>Returns the greater of two arbitrary-precision integers.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>first</code> - The first integer to compare.</p></li>
<li><p><code>second</code> - The second integer to compare.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The greater of the two integers.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.NullPointerException</code> - The parameter <code>first</code> or <code>second</code>
is null.</li>
</ul>

<h3>Min</h3>

<pre>public static EInteger Min​(EInteger first, EInteger second)
</pre>

<p>Returns the smaller of two arbitrary-precision integers.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>first</code> - The first integer to compare.</p></li>
<li><p><code>second</code> - The second integer to compare.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The smaller of the two integers.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.NullPointerException</code> - The parameter <code>first</code> or <code>second</code>
is null.</li>
</ul>

<h3>MaxMagnitude</h3>

<pre>public static EInteger MaxMagnitude​(EInteger first, EInteger second)
</pre>

<p>Of two arbitrary-precision integers, returns the one with the greater
 absolute value. If both integers have the same absolute value, this
 method has the same effect as Max.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>first</code> - The first integer to compare.</p></li>
<li><p><code>second</code> - The second integer to compare.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The integer with the greater absolute value.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.NullPointerException</code> - The parameter <code>first</code> or <code>second</code>
is null.</li>
</ul>

<h3>MinMagnitude</h3>

<pre>public static EInteger MinMagnitude​(EInteger first, EInteger second)
</pre>

<p>Of two arbitrary-precision integers, returns the one with the smaller
 absolute value. If both integers have the same absolute value, this
 method has the same effect as Min.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>first</code> - The first integer to compare.</p></li>
<li><p><code>second</code> - The second integer to compare.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The integer with the smaller absolute value.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.NullPointerException</code> - The parameter <code>first</code> or <code>second</code>
is null.</li>
</ul>

<h3>Add</h3>

<pre>public EInteger Add​(int intValue)
</pre>

<p>Adds this arbitrary-precision integer and a 32-bit signed integer and
 returns the result.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>intValue</code> - The parameter <code>intValue</code> is a 32-bit signed integer.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The sum of the two numbers, that is, this arbitrary-precision
integer plus a 32-bit signed integer.</li>
</ul>

<h3>Subtract</h3>

<pre>public EInteger Subtract​(int intValue)
</pre>

<p>Subtracts a 32-bit signed integer from this arbitrary-precision integer and
 returns the result.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>intValue</code> - The parameter <code>intValue</code> is a 32-bit signed integer.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The difference between the two numbers, that is, this
arbitrary-precision integer minus a 32-bit signed integer.</li>
</ul>

<h3>Multiply</h3>

<pre>public EInteger Multiply​(int intValue)
</pre>

<p>Multiplies this arbitrary-precision integer by a 32-bit signed integer and
  returns the result.<p> </p><pre>EInteger result = EInteger.FromString(&quot;5&quot;).Multiply(200);</pre> .</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>intValue</code> - The parameter <code>intValue</code> is a 32-bit signed integer.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The product of the two numbers, that is, this arbitrary-precision
integer times a 32-bit signed integer.</li>
</ul>

<h3>Divide</h3>

<pre>public EInteger Divide​(int intValue)
</pre>

<p>Divides this arbitrary-precision integer by a 32-bit signed integer and
 returns the result. The result of the division is rounded down (the
 fractional part is discarded). Except if the result of the division
 is 0, it will be negative if this arbitrary-precision integer is
 positive and the other 32-bit signed integer is negative, or vice
 versa, and will be positive if both are positive or both are
 negative.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>intValue</code> - The divisor.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The result of dividing this arbitrary-precision integer by a 32-bit
signed integer. The result of the division is rounded down (the
fractional part is discarded). Except if the result of the division
is 0, it will be negative if this arbitrary-precision integer is
positive and the other 32-bit signed integer is negative, or vice
versa, and will be positive if both are positive or both are
negative.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.ArithmeticException</code> - Attempted to divide by zero.</li>
</ul>

<h3>Remainder</h3>

<pre>public EInteger Remainder​(int intValue)
</pre>

<p>Returns the remainder that would result when this arbitrary-precision
 integer is divided by a 32-bit signed integer. The remainder is the
 number that remains when the absolute value of this
 arbitrary-precision integer is divided by the absolute value of the
 other 32-bit signed integer; the remainder has the same sign
 (positive or negative) as this arbitrary-precision integer.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>intValue</code> - The parameter <code>intValue</code> is a 32-bit signed integer.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The remainder that would result when this arbitrary-precision
integer is divided by a 32-bit signed integer.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.ArithmeticException</code> - Attempted to divide by zero.</p></li>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>intValue</code> is null.</p></li>
</ul>

<h3>compareTo</h3>

<pre>public int compareTo​(int intValue)
</pre>

<p>Compares an arbitrary-precision integer with this instance.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>intValue</code> - The parameter <code>intValue</code> is a 32-bit signed integer.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>Zero if the values are equal; a negative number if this instance is
less, or a positive number if this instance is greater.</li>
</ul>

<h3>Divide</h3>

<pre>public EInteger Divide​(EInteger bigintDivisor)
</pre>

<p>Divides this arbitrary-precision integer by another arbitrary-precision
 integer and returns the result. The result of the division is
 rounded down (the fractional part is discarded). Except if the
 result of the division is 0, it will be negative if this
 arbitrary-precision integer is positive and the other
 arbitrary-precision integer is negative, or vice versa, and will be
 positive if both are positive or both are negative.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>bigintDivisor</code> - The divisor.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The result of dividing this arbitrary-precision integer by another
arbitrary-precision integer. The result of the division is rounded
down (the fractional part is discarded). Except if the result of the
division is 0, it will be negative if this arbitrary-precision
integer is positive and the other arbitrary-precision integer is
negative, or vice versa, and will be positive if both are positive
or both are negative.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>bigintDivisor</code> is null.</p></li>
<li><p><code>java.lang.ArithmeticException</code> - Attempted to divide by zero.</p></li>
</ul>

<h3>DivRem</h3>

<pre>public EInteger[] DivRem​(int intDivisor)
</pre>

<p>Divides this arbitrary-precision integer by a 32-bit signed integer and
 returns a two-item array containing the result of the division and
 the remainder, in that order. The result of the division is rounded
 down (the fractional part is discarded). Except if the result of the
 division is 0, it will be negative if this arbitrary-precision
 integer is positive and the other 32-bit signed integer is negative,
 or vice versa, and will be positive if both are positive or both are
 negative. The remainder is the number that remains when the absolute
 value of this arbitrary-precision integer is divided by the absolute
 value of the other 32-bit signed integer; the remainder has the same
 sign (positive or negative) as this arbitrary-precision integer.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>intDivisor</code> - The number to divide by.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An array of two items: the first is the result of the division as an
arbitrary-precision integer, and the second is the remainder as an
arbitrary-precision integer. The result of division is the result of
the Divide method on the two operands, and the remainder is the
result of the Remainder method on the two operands.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.ArithmeticException</code> - The parameter <code>intDivisor</code> is 0.</li>
</ul>

<h3>Add</h3>

<pre>public EInteger Add​(long longValue)
</pre>

<p>Adds this arbitrary-precision integer and a 64-bit signed integer and
 returns the result.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>longValue</code> - The parameter <code>longValue</code> is a 64-bit signed integer.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The sum of the two numbers, that is, this arbitrary-precision
integer plus a 64-bit signed integer.</li>
</ul>

<h3>Subtract</h3>

<pre>public EInteger Subtract​(long longValue)
</pre>

<p>Subtracts a 64-bit signed integer from this arbitrary-precision integer and
 returns the result.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>longValue</code> - The parameter <code>longValue</code> is a 64-bit signed integer.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The difference between the two numbers, that is, this
arbitrary-precision integer minus a 64-bit signed integer.</li>
</ul>

<h3>Multiply</h3>

<pre>public EInteger Multiply​(long longValue)
</pre>

<p>Multiplies this arbitrary-precision integer by a 64-bit signed integer and
 returns the result.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>longValue</code> - The parameter <code>longValue</code> is a 64-bit signed integer.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The product of the two numbers, that is, this arbitrary-precision
integer times a 64-bit signed integer.</li>
</ul>

<h3>Divide</h3>

<pre>public EInteger Divide​(long longValue)
</pre>

<p>Divides this arbitrary-precision integer by a 64-bit signed integer and
 returns the result. The result of the division is rounded down (the
 fractional part is discarded). Except if the result of the division
 is 0, it will be negative if this arbitrary-precision integer is
 positive and the other 64-bit signed integer is negative, or vice
 versa, and will be positive if both are positive or both are
 negative.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>longValue</code> - The parameter <code>longValue</code> is a 64-bit signed integer.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The result of dividing this arbitrary-precision integer by a 64-bit
signed integer. The result of the division is rounded down (the
fractional part is discarded). Except if the result of the division
is 0, it will be negative if this arbitrary-precision integer is
positive and the other 64-bit signed integer is negative, or vice
versa, and will be positive if both are positive or both are
negative.</li>
</ul>

<h3>Remainder</h3>

<pre>public EInteger Remainder​(long longValue)
</pre>

<p>Returns the remainder that would result when this arbitrary-precision
 integer is divided by a 64-bit signed integer. The remainder is the
 number that remains when the absolute value of this
 arbitrary-precision integer is divided by the absolute value of the
 other 64-bit signed integer; the remainder has the same sign
 (positive or negative) as this arbitrary-precision integer.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>longValue</code> - The parameter <code>longValue</code> is a 64-bit signed integer.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The remainder that would result when this arbitrary-precision
integer is divided by a 64-bit signed integer.</li>
</ul>

<h3>compareTo</h3>

<pre>public int compareTo​(long longValue)
</pre>

<p>Compares an arbitrary-precision integer with this instance.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>longValue</code> - The parameter <code>longValue</code> is a 64-bit signed integer.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>Zero if the values are equal; a negative number if this instance is
less, or a positive number if this instance is greater.</li>
</ul>

<h3>DivRem</h3>

<pre>public EInteger[] DivRem​(long intDivisor)
</pre>

<p>Divides this arbitrary-precision integer by a 64-bit signed integer and
 returns a two-item array containing the result of the division and
 the remainder, in that order. The result of the division is rounded
 down (the fractional part is discarded). Except if the result of the
 division is 0, it will be negative if this arbitrary-precision
 integer is positive and the other 64-bit signed integer is negative,
 or vice versa, and will be positive if both are positive or both are
 negative. The remainder is the number that remains when the absolute
 value of this arbitrary-precision integer is divided by the absolute
 value of the other 64-bit signed integer; the remainder has the same
 sign (positive or negative) as this arbitrary-precision integer.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>intDivisor</code> - The parameter <code>intDivisor</code> is a 64-bit signed
integer.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An array of two items: the first is the result of the division as an
arbitrary-precision integer, and the second is the remainder as an
arbitrary-precision integer. The result of division is the result of
the Divide method on the two operands, and the remainder is the
result of the Remainder method on the two operands.</li>
</ul>

<h3>DivRem</h3>

<pre>public EInteger[] DivRem​(EInteger divisor)
</pre>

<p>Divides this arbitrary-precision integer by another arbitrary-precision
 integer and returns a two-item array containing the result of the
 division and the remainder, in that order. The result of the
 division is rounded down (the fractional part is discarded). Except
 if the result of the division is 0, it will be negative if this
 arbitrary-precision integer is positive and the other
 arbitrary-precision integer is negative, or vice versa, and will be
 positive if both are positive or both are negative. The remainder is
 the number that remains when the absolute value of this
 arbitrary-precision integer is divided by the absolute value of the
 other arbitrary-precision integer; the remainder has the same sign
 (positive or negative) as this arbitrary-precision integer.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>divisor</code> - The number to divide by.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An array of two items: the first is the result of the division as an
arbitrary-precision integer, and the second is the remainder as an
arbitrary-precision integer. The result of division is the result of
the Divide method on the two operands, and the remainder is the
result of the Remainder method on the two operands.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.ArithmeticException</code> - The parameter <code>divisor</code> is 0.</p></li>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>divisor</code> is null.</p></li>
</ul>

<h3>equals</h3>

<pre>public boolean equals​(java.lang.Object obj)
</pre>

<p>Determines whether this object and another object are equal and have the
 same type.</p>

<p><strong>Overrides:</strong></p>

<ul>
<li><code>equals</code> in class <code>java.lang.Object</code></li>
</ul>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>obj</code> - The parameter <code>obj</code> is an arbitrary object.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li><code>true</code> if this object and another object are equal; otherwise,
<code>false</code>.</li>
</ul>

<h3>Gcd</h3>

<pre>public EInteger Gcd​(EInteger bigintSecond)
</pre>

<p>Returns the greatest common divisor of this integer and the given integer.
 The greatest common divisor (GCD) is also known as the greatest
 common factor (GCF). This method works even if either or both
 integers are negative.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>bigintSecond</code> - Another arbitrary-precision integer. Can be negative.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The greatest common divisor of this integer and the given integer.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>bigintSecond</code> is null.</p></li>
<li><p><code>java.lang.ArithmeticException</code> - Attempted to divide by zero.</p></li>
<li><p><code>java.lang.IllegalArgumentException</code> - bigPower is negative; doesn&#39;t satisfy
shiftBits&lt;16; doesn&#39;t satisfy sqroot.signum()&gt;= 0</p></li>
</ul>

<h3>GetDigitCountAsEInteger</h3>

<pre>public EInteger GetDigitCountAsEInteger()
</pre>

<p>Returns the number of decimal digits used by this integer, in the form of an
 arbitrary-precision integer.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>The number of digits in the decimal form of this integer. Returns 1
if this number is 0.</li>
</ul>

<h3>GetDigitCount</h3>

<pre>@Deprecated public int GetDigitCount()
</pre>

<p>Deprecated.
This method may overflow. Use GetDigitCountAsEInteger instead.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>The number of digits in the decimal form of this integer. Returns 1
if this number is 0.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.ArithmeticException</code> - The return value would exceed the range of a
32-bit signed integer.</li>
</ul>

<h3>GetDigitCountAsInt64</h3>

<pre>public long GetDigitCountAsInt64()
</pre>

<p>Returns the number of decimal digits used by this integer, in the form of a
 64-bit signed integer.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>The number of digits in the decimal form of this integer. Returns 1
if this number is 0. Returns 2^63 - 1(<code>Long.MAX_VALUE</code> in.NET
or <code>Long.MAX_VALUE</code> in Java) if the number of decimal digits
is 2^63 - 1 or greater. (Use <code>GetDigitCountAsEInteger</code> instead
if the application relies on the exact number of decimal digits.).</li>
</ul>

<h3>hashCode</h3>

<pre>public int hashCode()
</pre>

<p>Returns the hash code for this instance. No application or process IDs are
 used in the hash code calculation.</p>

<p><strong>Overrides:</strong></p>

<ul>
<li><code>hashCode</code> in class <code>java.lang.Object</code></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A 32-bit signed integer.</li>
</ul>

<h3>GetLowBit</h3>

<pre>@Deprecated public int GetLowBit()
</pre>

<p>Deprecated.
This method may overflow. Use GetLowBitAsEInteger instead.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>The bit position of the lowest bit set in the number&#39;s absolute
value, starting at 0. Returns -1 if this value is 0.</li>
</ul>

<h3>GetLowBitAsInt64</h3>

<pre>public long GetLowBitAsInt64()
</pre>

<p>Gets the bit position of the lowest set bit in this number&#39;s absolute value,
 in the form of a 64-bit signed integer. (This will also be the
 position of the lowest set bit in the number&#39;s two&#39;s-complement form
  (see <code>&quot;Forms of numbers&quot;</code>
).).</p>

<p><strong>Returns:</strong></p>

<ul>
<li>The bit position of the lowest bit set in the number&#39;s absolute
value, starting at 0. Returns -1 if this value is 0 or odd. Returns
2^63 - 1 (<code>Long.MAX_VALUE</code> in.NET or <code>Long.MAX_VALUE</code>
in Java) if this number is other than zero but the lowest set bit is
at 2^63 - 1 or greater. (Use <code>GetLowBitAsEInteger</code> instead if
the application relies on the exact value of the lowest set bit
position.).</li>
</ul>

<h3>GetLowBitAsEInteger</h3>

<pre>public EInteger GetLowBitAsEInteger()
</pre>

<p>Gets the bit position of the lowest set bit in this number&#39;s absolute value,
 in the form of an arbitrary-precision integer. (This will also be
 the position of the lowest set bit in the number&#39;s two&#39;s-complement
  form (see <code>&quot;Forms of
  numbers&quot;</code>).).</p>

<p><strong>Returns:</strong></p>

<ul>
<li>The bit position of the lowest bit set in the number&#39;s absolute
value, starting at 0. Returns -1 if this value is 0 or odd.</li>
</ul>

<h3>GetSignedBit</h3>

<pre>public boolean GetSignedBit​(EInteger bigIndex)
</pre>

<p>Returns whether a bit is set in the two&#39;s-complement form (see <code>&quot;Forms of numbers&quot;</code>) of this
 object&#39;s value.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>bigIndex</code> - The index, starting at zero, of the bit to test, where 0 is
the least significant bit, 1 is the next least significant bit, and
so on.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li><code>true</code> if the given bit is set in the two&#39; s-complement form
(see <code>EDecimal</code>) of this object&#39;s
value; otherwise, <code>false</code>.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.NullPointerException</code> - The parameter <code>bigIndex</code> is null.</li>
</ul>

<h3>GetSignedBit</h3>

<pre>public boolean GetSignedBit​(int index)
</pre>

<p>Returns whether a bit is set in the two&#39;s-complement form (see <code>&quot;Forms of numbers&quot;</code>) of this
 object&#39;s value.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>index</code> - The index, starting at 0, of the bit to test, where 0 is the
least significant bit, 1 is the next least significant bit, and so
on.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li><code>true</code> if the given bit is set in the two&#39; s-complement form
(see <code>EDecimal</code>) of this object&#39;s
value; otherwise, <code>false</code>.</li>
</ul>

<h3>GetSignedBitLengthAsEInteger</h3>

<pre>public EInteger GetSignedBitLengthAsEInteger()
</pre>

<p>Finds the minimum number of bits needed to represent this object&#39;s value,
 except for its sign, in the form of an arbitrary-precision integer.
 If the value is negative, finds the number of bits in the value
 equal to this object&#39;s absolute value minus 1. For example, all
 integers in the interval [-(2^63), (2^63) - 1], which is the same as
 the range of integers in Java&#39;s and.NET&#39;s <code>long</code> type, have a
 signed bit length of 63 or less, and all other integers have a
 signed bit length of greater than 63.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>The number of bits in this object&#39;s value, except for its sign.
Returns 0 if this object&#39;s value is 0 or negative 1.</li>
</ul>

<h3>GetSignedBitLengthAsInt64</h3>

<pre>public long GetSignedBitLengthAsInt64()
</pre>

<p>Finds the minimum number of bits needed to represent this object&#39;s value,
 except for its sign, in the form of a 64-bit signed integer. If the
 value is negative, finds the number of bits in the value equal to
 this object&#39;s absolute value minus 1. For example, all integers in
 the interval [-(2^63), (2^63) - 1], which is the same as the range
 of integers in Java&#39;s and.NET&#39;s <code>long</code> type, have a signed bit
 length of 63 or less, and all other integers have a signed bit
 length of greater than 63.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>The number of bits in this object&#39;s value, except for its sign.
Returns 0 if this object&#39;s value is 0 or negative 1. Returns 2^63 -
1 (<code>Long.MAX_VALUE</code> in.NET or <code>Long.MAX_VALUE</code> in Java)
if the number of bits is 2^63 - 1 or greater. (Use <code>
GetUnsignedBitLengthAsEInteger</code> instead if the application relies on
the exact number of bits.).</li>
</ul>

<h3>GetSignedBitLength</h3>

<pre>@Deprecated public int GetSignedBitLength()
</pre>

<p>Deprecated.
This method may overflow. Use GetSignedBitLengthAsEInteger instead.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>The number of bits in this object&#39;s value, except for its sign.
Returns 0 if this object&#39;s value is 0 or negative 1.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.ArithmeticException</code> - The return value would exceed the range of a
32-bit signed integer.</li>
</ul>

<h3>GetUnsignedBit</h3>

<pre>public boolean GetUnsignedBit​(EInteger bigIndex)
</pre>

<p>Returns whether a bit is set in this number&#39;s absolute value.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>bigIndex</code> - The index, starting at zero, of the bit to test, where 0 is
the least significant bit, 1 is the next least significant bit, and
so on.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li><code>true</code> if the given bit is set in this number&#39;s absolute
value.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.NullPointerException</code> - The parameter <code>bigIndex</code> is null.</li>
</ul>

<h3>GetUnsignedBit</h3>

<pre>public boolean GetUnsignedBit​(int index)
</pre>

<p>Returns whether a bit is set in this number&#39;s absolute value.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>index</code> - The index, starting at 0, of the bit to test, where 0 is the
least significant bit, 1 is the next least significant bit, and so
on.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li><code>true</code> if the given bit is set in this number&#39;s absolute
value.</li>
</ul>

<h3>GetUnsignedBitLengthAsEInteger</h3>

<pre>public EInteger GetUnsignedBitLengthAsEInteger()
</pre>

<p>Finds the minimum number of bits needed to represent this number&#39;s absolute
 value, in the form of an arbitrary-precision integer. For example,
 all integers in the interval [-((2^63) - 1), (2^63) - 1] have an
 unsigned bit length of 63 or less, and all other integers have an
 unsigned bit length of greater than 63. This interval is not the
 same as the range of integers in Java&#39;s and.NET&#39;s <code>long</code> type.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>The number of bits in this object&#39;s absolute value. Returns 0 if
this object&#39;s value is 0, and returns 1 if the value is negative 1.</li>
</ul>

<h3>GetUnsignedBitLengthAsInt64</h3>

<pre>public long GetUnsignedBitLengthAsInt64()
</pre>

<p>Finds the minimum number of bits needed to represent this number&#39;s absolute
 value, in the form of a 64-bit signed integer. For example, all
 integers in the interval [-((2^63) - 1), (2^63) - 1] have an
 unsigned bit length of 63 or less, and all other integers have an
 unsigned bit length of greater than 63. This interval is not the
 same as the range of integers in Java&#39;s and.NET&#39;s <code>long</code> type.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>The number of bits in this object&#39;s absolute value. Returns 0 if
this object&#39;s value is 0, and returns 1 if the value is negative 1.
Returns 2^63 - 1 (<code>Long.MAX_VALUE</code> in.NET or <code>
Long.MAX_VALUE</code> in Java) if the number of bits is 2^63 - 1 or
greater. (Use <code>GetUnsignedBitLengthAsEInteger</code> instead if the
application relies on the exact number of bits.).</li>
</ul>

<h3>GetUnsignedBitLength</h3>

<pre>@Deprecated public int GetUnsignedBitLength()
</pre>

<p>Deprecated.
This method may overflow. Use GetUnsignedBitLengthAsEInteger instead.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>The number of bits in this object&#39;s absolute value. Returns 0 if
this object&#39;s value is 0, and returns 1 if the value is negative 1.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.ArithmeticException</code> - The return value would exceed the range of a
32-bit signed integer.</li>
</ul>

<h3>Mod</h3>

<pre>public EInteger Mod​(EInteger divisor)
</pre>

<p>Finds the modulus remainder that results when this instance is divided by
 the value of an arbitrary-precision integer. The modulus remainder
 is the same as the normal remainder if the normal remainder is
 positive, and equals divisor plus normal remainder if the normal
 remainder is negative.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>divisor</code> - The number to divide by.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision integer.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.IllegalArgumentException</code> - The parameter <code>divisor</code> is less than 0.</p></li>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>divisor</code> is null.</p></li>
</ul>

<h3>Mod</h3>

<pre>public EInteger Mod​(int smallDivisor)
</pre>

<p>Finds the modulus remainder that results when this instance is divided by
 the value of another integer. The modulus remainder is the same as
 the normal remainder if the normal remainder is positive, and equals
 divisor plus normal remainder if the normal remainder is negative.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>smallDivisor</code> - The divisor of the modulus.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The modulus remainder.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.IllegalArgumentException</code> - The parameter <code>smallDivisor</code> is less than 0.</li>
</ul>

<h3>ModPow</h3>

<pre>public EInteger ModPow​(EInteger pow, EInteger mod)
</pre>

<p>Calculates the remainder when this arbitrary-precision integer raised to a
 certain power is divided by another arbitrary-precision integer.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>pow</code> - The power to raise this integer by.</p></li>
<li><p><code>mod</code> - The integer to divide the raised number by.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision integer.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.NullPointerException</code> - The parameter <code>pow</code> or <code>mod</code> is
null.</li>
</ul>

<h3>Multiply</h3>

<pre>public EInteger Multiply​(EInteger bigintMult)
</pre>

<p>Multiplies this arbitrary-precision integer by another arbitrary-precision
 integer and returns the result.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>bigintMult</code> - Another arbitrary-precision integer.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The product of the two numbers, that is, this arbitrary-precision
integer times another arbitrary-precision integer.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.NullPointerException</code> - The parameter <code>bigintMult</code> is null.</li>
</ul>

<h3>Negate</h3>

<pre>public EInteger Negate()
</pre>

<p>Gets the value of this object with the sign reversed.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>This object&#39;s value with the sign reversed.</li>
</ul>

<h3>Pow</h3>

<pre>public EInteger Pow​(EInteger bigPower)
</pre>

<p>Raises an arbitrary-precision integer to a power.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>bigPower</code> - The exponent to raise this integer to.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The result. Returns 1 if <code>bigPower</code> is 0.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>bigPower</code> is null.</p></li>
<li><p><code>java.lang.IllegalArgumentException</code> - BigPower is negative.</p></li>
</ul>

<h3>Pow</h3>

<pre>public EInteger Pow​(int powerSmall)
</pre>

<p>Raises an arbitrary-precision integer to a power.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>powerSmall</code> - The exponent to raise this integer to.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The result. Returns 1 if <code>powerSmall</code> is 0.</li>
</ul>

<h3>PowBigIntVar</h3>

<pre>public EInteger PowBigIntVar​(EInteger power)
</pre>

<p>Raises an arbitrary-precision integer to a power, which is given as another
 arbitrary-precision integer.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>power</code> - The exponent to raise to.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The result. Returns 1 if <code>power</code> is 0.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.IllegalArgumentException</code> - The parameter <code>power</code> is less than 0.</p></li>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>power</code> is null.</p></li>
</ul>

<h3>Remainder</h3>

<pre>public EInteger Remainder​(EInteger divisor)
</pre>

<p>Returns the remainder that would result when this arbitrary-precision
 integer is divided by another arbitrary-precision integer. The
 remainder is the number that remains when the absolute value of this
 arbitrary-precision integer is divided by the absolute value of the
 other arbitrary-precision integer; the remainder has the same sign
 (positive or negative) as this arbitrary-precision integer.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>divisor</code> - The number to divide by.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The remainder that would result when this arbitrary-precision
integer is divided by another arbitrary-precision integer.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.ArithmeticException</code> - Attempted to divide by zero.</p></li>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>divisor</code> is null.</p></li>
</ul>

<h3>ShiftRight</h3>

<pre>public EInteger ShiftRight​(EInteger eshift)
</pre>

<p>Returns an arbitrary-precision integer with the bits shifted to the right.
 For this operation, the arbitrary-precision integer is treated as a
 two&#39;s-complement form (see <code>&quot;Forms of numbers&quot;</code>). Thus, for negative values, the
 arbitrary-precision integer is sign-extended.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>eshift</code> - The number of bits to shift. Can be negative, in which case
this is the same as ShiftLeft with the absolute value of this
parameter.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision integer.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.NullPointerException</code> - The parameter <code>eshift</code> is null.</li>
</ul>

<h3>ShiftLeft</h3>

<pre>public EInteger ShiftLeft​(EInteger eshift)
</pre>

<p>Returns an arbitrary-precision integer with the bits shifted to the left by
 a number of bits given as an arbitrary-precision integer. A value of
 1 doubles this value, a value of 2 multiplies it by 4, a value of 3
 by 8, a value of 4 by 16, and so on.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>eshift</code> - The number of bits to shift. Can be negative, in which case
this is the same as ShiftRight with the absolute value of this
parameter.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision integer.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.NullPointerException</code> - The parameter <code>eshift</code> is null.</li>
</ul>

<h3>ShiftLeft</h3>

<pre>public EInteger ShiftLeft​(int numberBits)
</pre>

<p>Returns an arbitrary-precision integer with the bits shifted to the left by
 a number of bits. A value of 1 doubles this value, a value of 2
 multiplies it by 4, a value of 3 by 8, a value of 4 by 16, and so
 on.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>numberBits</code> - The number of bits to shift. Can be negative, in which
case this is the same as shiftRight with the absolute value of this
parameter.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision integer.</li>
</ul>

<h3>Not</h3>

<pre>public EInteger Not()
</pre>

<p>Returns an arbitrary-precision integer with every bit flipped from this one
 (also called an inversion or NOT operation).</p>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision integer in which each bit in its two&#39;s
complement representation is set if the corresponding bit of this
integer is clear, and vice versa. Returns -1 if this integer is 0.
If this integer is positive, the return value is negative, and vice
versa. This method uses the two&#39;s complement form of negative
integers (see <code>EDecimal</code>). For
example, in binary, NOT 10100 =...11101011 (or in decimal, NOT 20 =
-21). In binary, NOT...11100110 = 11001 (or in decimal, NOT -26 =
25).</li>
</ul>

<h3>And</h3>

<pre>public EInteger And​(EInteger other)
</pre>

<p>Does an AND operation between this arbitrary-precision integer and another
 one.<p>Each arbitrary-precision integer is treated as a
 two&#39;s-complement form (see <code>&quot;Forms of numbers&quot;</code>) for the purposes of this operator.</p></p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>other</code> - Another arbitrary-precision integer that participates in the
operation.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision integer in which each bit is set if the
corresponding bits of this integer and the other integer (in their
two&#39;s-complement representation) are both set. For example, in
binary, 10110 AND 01100 = 00100 (or in decimal, 22 AND 12 = 4). This
method uses the two&#39;s complement form of negative integers (see
<code>EDecimal</code>). For example, in binary,
...11100111 AND 01100 = 00100 (or in decimal, -25 AND 12 = 4).</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.NullPointerException</code> - The parameter <code>other</code> is null.</li>
</ul>

<h3>Or</h3>

<pre>public EInteger Or​(EInteger second)
</pre>

<p>Does an OR operation between this arbitrary-precision integer and another
 one.<p>Each arbitrary-precision integer is treated as a
 two&#39;s-complement form (see <code>&quot;Forms of numbers&quot;</code>) for the purposes of this operator.</p></p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>second</code> - Another arbitrary-precision integer that participates in the
operation.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision integer in which each bit is set if the
corresponding bit of this integer is set, the other integer&#39;s
corresponding bit is set, or both. For example, in binary, 10110 OR
11010 = 11110 (or in decimal, 22 OR 26 = 30). This method uses the
two&#39;s complement form of negative integers (see <code>EDecimal</code>). For example, in binary,
...11101110 OR 01011 =...11101111 (or in decimal, -18 OR 11 = -17).</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.NullPointerException</code> - The parameter <code>second</code> is null.</li>
</ul>

<h3>AndNot</h3>

<pre>public EInteger AndNot​(EInteger second)
</pre>

<p>Does an AND NOT operation between this arbitrary-precision integer and
 another one.<p>Each arbitrary-precision integer is treated as a
 two&#39;s-complement form (see <code>&quot;Forms of numbers&quot;</code>) for the purposes of this operator.</p></p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>second</code> - Another arbitrary-precision integer that participates in the
operation.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision integer in which each bit is set if the
corresponding bit of this integer is set, and the other integer&#39;s
corresponding bit is not set. For example, in binary, 10110 AND NOT
11010 = 00100 (or in decimal, 22 AND NOT 26 = 4). This method uses
the two&#39;s complement form of negative integers (see <code>EDecimal</code>). For example, in binary,
...11101110 AND NOT 01011 = 00100 (or in decimal, -18 OR 11 = 4).</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.NullPointerException</code> - The parameter <code>second</code> is null.</li>
</ul>

<h3>OrNot</h3>

<pre>public EInteger OrNot​(EInteger second)
</pre>

<p>Does an OR NOT operation (or implication or IMP operation) between this
 arbitrary-precision integer and another one.<p>Each
 arbitrary-precision integer is treated as a two&#39;s-complement form
  (see <code>&quot;Forms of numbers&quot;</code>)
 for the purposes of this operator.</p></p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>second</code> - Another arbitrary-precision integer that participates in the
operation.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision integer in which each bit is set if the
corresponding bit of this integer is set, the other integer&#39;s
corresponding bit is not set, or both. For example, in binary, 10110
OR NOT 11010 = 00100 (or in decimal, 22 OR NOT 26 = 23). This method
uses the two&#39;s complement form of negative integers (see <code>EDecimal</code>). For example, in binary,
...11101110 OR NOT 01011 =...11111110 (or in decimal, -18 OR 11 =
-2).</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.NullPointerException</code> - The parameter <code>second</code> is null.</li>
</ul>

<h3>Imp</h3>

<pre>public EInteger Imp​(EInteger second)
</pre>

<p>Does an OR NOT operation (or implication or IMP operation) between this
 arbitrary-precision integer and another one.<p>Each
 arbitrary-precision integer is treated as a two&#39;s-complement form
  (see <code>&quot;Forms of numbers&quot;</code>)
 for the purposes of this operator.</p></p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>second</code> - Another arbitrary-precision integer that participates in the
operation.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision integer in which each bit is set if the
corresponding bit of this integer is set, the other integer&#39;s
corresponding bit is not set, or both. For example, in binary, 10110
OR NOT 11010 = 00100 (or in decimal, 22 OR NOT 26 = 23). This method
uses the two&#39;s complement form of negative integers (see <code>EDecimal</code>). For example, in binary,
...11101110 OR NOT 01011 =...11111110 (or in decimal, -18 OR 11 =
-2).</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.NullPointerException</code> - The parameter <code>second</code> is null.</li>
</ul>

<h3>XorNot</h3>

<pre>public EInteger XorNot​(EInteger second)
</pre>

<p>Does an XOR NOT operation (or equivalence operation, EQV operation, or
 exclusive-OR NOT operation) between this arbitrary-precision integer
 and another one.<p>Each arbitrary-precision integer is treated as a
 two&#39;s-complement form (see <code>&quot;Forms of numbers&quot;</code>) for the purposes of this operator.</p></p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>second</code> - Another arbitrary-precision integer that participates in the
operation.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision integer in which each bit is set if the
corresponding bit of this integer is set or the other integer&#39;s
corresponding bit is not set, but not both. For example, in binary,
10110 XOR NOT 11010 = 10011 (or in decimal, 22 XOR NOT 26 = 19).
This method uses the two&#39;s complement form of negative integers (see
<code>EDecimal</code>). For example, in binary,
...11101110 XOR NOT 01011 =...11111010 (or in decimal, -18 OR 11 =
-6).</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.NullPointerException</code> - The parameter <code>second</code> is null.</li>
</ul>

<h3>Eqv</h3>

<pre>public EInteger Eqv​(EInteger second)
</pre>

<p>Does an XOR NOT operation (or equivalence operation, EQV operation, or
 exclusive-OR NOT operation) between this arbitrary-precision integer
 and another one.<p>Each arbitrary-precision integer is treated as a
 two&#39;s-complement form (see <code>&quot;Forms of numbers&quot;</code>) for the purposes of this operator.</p></p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>second</code> - Another arbitrary-precision integer that participates in the
operation.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision integer in which each bit is set if the
corresponding bit of this integer is set or the other integer&#39;s
corresponding bit is not set, but not both. For example, in binary,
10110 XOR NOT 11010 = 10011 (or in decimal, 22 XOR NOT 26 = 19).
This method uses the two&#39;s complement form of negative integers (see
<code>EDecimal</code>). For example, in binary,
...11101110 XOR NOT 01011 =...11111010 (or in decimal, -18 OR 11 =
-6).</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.NullPointerException</code> - The parameter <code>second</code> is null.</li>
</ul>

<h3>Xor</h3>

<pre>public EInteger Xor​(EInteger other)
</pre>

<p>Does an exclusive OR (XOR) operation between this arbitrary-precision
 integer and another one.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>other</code> - Another arbitrary-precision integer that participates in the
operation.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision integer in which each bit is set if the
corresponding bit is set in one input integer but not in the other.
For example, in binary, 11010 XOR 01001 = 10011 (or in decimal, 26
XOR 9 = 19). This method uses the two&#39;s complement form of negative
integers (see <code>EDecimal</code>). For
example, in binary, ...11101101 XOR 00011 =...11101110 (or in
decimal, -19 XOR 3 = -18).</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.NullPointerException</code> - The parameter <code>other</code> is null.</li>
</ul>

<h3>ShiftRight</h3>

<pre>public EInteger ShiftRight​(int numberBits)
</pre>

<p>Returns an arbitrary-precision integer with the bits shifted to the right.
 For this operation, the arbitrary-precision integer is treated as a
 two&#39;s-complement form (see <code>&quot;Forms of numbers&quot;</code>). Thus, for negative values, the
 arbitrary-precision integer is sign-extended.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>numberBits</code> - The number of bits to shift. Can be negative, in which
case this is the same as shiftLeft with the absolute value of this
parameter.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An arbitrary-precision integer.</li>
</ul>

<h3>Sqrt</h3>

<pre>public EInteger Sqrt()
</pre>

<p>Finds the square root of this instance&#39;s value, rounded down.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>The square root of this object&#39;s value. Returns 0 if this value is 0
or less.</li>
</ul>

<h3>SqrtRem</h3>

<pre>public EInteger[] SqrtRem()
</pre>

<p>Calculates the square root and the remainder.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>An array of two arbitrary-precision integers: the first integer is
the square root, and the second is the difference between this value
and the square of the first integer. Returns two zeros if this value
is 0 or less, or one and zero if this value equals 1.</li>
</ul>

<h3>Root</h3>

<pre>public EInteger Root​(EInteger root)
</pre>

<p>Finds the nth root of this instance&#39;s value, rounded down.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>root</code> - The root to find; must be 1 or greater. If this value is 2, this
method finds the square root; if 3, the cube root, and so on.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The square root of this object&#39;s value. Returns 0 if this value is 0
or less.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.NullPointerException</code> - The parameter <code>root</code> is null.</li>
</ul>

<h3>RootRem</h3>

<pre>public EInteger[] RootRem​(EInteger root)
</pre>

<p>Calculates the nth root and the remainder.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>root</code> - The root to find; must be 1 or greater. If this value is 2, this
method finds the square root; if 3, the cube root, and so on.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An array of two arbitrary-precision integers: the first integer is
the nth root, and the second is the difference between this value
and the nth power of the first integer. Returns two zeros if this
value is 0 or less, or one and zero if this value equals 1.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.NullPointerException</code> - The parameter <code>root</code> is null.</li>
</ul>

<h3>Root</h3>

<pre>public EInteger Root​(int root)
</pre>

<p>Finds the nth root of this instance&#39;s value, rounded down.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>root</code> - The root to find; must be 1 or greater. If this value is 2, this
method finds the square root; if 3, the cube root, and so on.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The square root of this object&#39;s value. Returns 0 if this value is 0
or less.</li>
</ul>

<h3>RootRem</h3>

<pre>public EInteger[] RootRem​(int root)
</pre>

<p>Calculates the nth root and the remainder.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>root</code> - The root to find; must be 1 or greater. If this value is 2, this
method finds the square root; if 3, the cube root, and so on.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An array of two arbitrary-precision integers: the first integer is
the nth root, and the second is the difference between this value
and the nth power of the first integer. Returns two zeros if this
value is 0 or less, or one and zero if this value equals 1.</li>
</ul>

<h3>Subtract</h3>

<pre>public EInteger Subtract​(EInteger subtrahend)
</pre>

<p>Subtracts an arbitrary-precision integer from this arbitrary-precision
 integer and returns the result.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>subtrahend</code> - Another arbitrary-precision integer.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The difference between the two numbers, that is, this
arbitrary-precision integer minus another arbitrary-precision
integer.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.NullPointerException</code> - The parameter <code>subtrahend</code> is null.</li>
</ul>

<h3>ToBytes</h3>

<pre>public byte[] ToBytes​(boolean littleEndian)
</pre>

<p>Returns a byte array of this integer&#39;s value. The byte array will take the
 number&#39;s two&#39;s-complement form (see <code>&quot;Forms of numbers&quot;</code>), using the
 fewest bytes necessary to store its value unambiguously. If this
 value is negative, the bits that appear beyond the most significant
 bit of the number will be all ones. The resulting byte array can be
 passed to the <code>FromBytes()</code> method (with the same byte order)
 to reconstruct this integer&#39;s value.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>littleEndian</code> - See the &#39;littleEndian&#39; parameter of the <code>
FromBytes()</code> method.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A byte array. If this value is 0, returns a byte array with the
single element 0.</li>
</ul>

<h3>ToInt32Checked</h3>

<pre>public int ToInt32Checked()
</pre>

<p>Converts this object&#39;s value to a 32-bit signed integer, throwing an
 exception if it can&#39;t fit.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>A 32-bit signed integer.</li>
</ul>

<h3>ToInt32Unchecked</h3>

<pre>public int ToInt32Unchecked()
</pre>

<p>Converts this object&#39;s value to a 32-bit signed integer. If the value can&#39;t
 fit in a 32-bit integer, returns the lower 32 bits of this object&#39;s
 two&#39;s-complement form (see <code>&quot;Forms of numbers&quot;</code>) (in which case the return value might have a
 different sign than this object&#39;s value).</p>

<p><strong>Returns:</strong></p>

<ul>
<li>A 32-bit signed integer.</li>
</ul>

<h3>ToInt64Checked</h3>

<pre>public long ToInt64Checked()
</pre>

<p>Converts this object&#39;s value to a 64-bit signed integer, throwing an
 exception if it can&#39;t fit.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>A 64-bit signed integer.</li>
</ul>

<h3>ToInt64Unchecked</h3>

<pre>public long ToInt64Unchecked()
</pre>

<p>Converts this object&#39;s value to a 64-bit signed integer. If the value can&#39;t
 fit in a 64-bit integer, returns the lower 64 bits of this object&#39;s
 two&#39;s-complement form (see <code>&quot;Forms of numbers&quot;</code>) (in which case the return value might have a
 different sign than this object&#39;s value).</p>

<p><strong>Returns:</strong></p>

<ul>
<li>A 64-bit signed integer.</li>
</ul>

<h3>ToRadixString</h3>

<pre>public java.lang.String ToRadixString​(int radix)
</pre>

<p>Generates a string representing the value of this object, in the given
 radix.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>radix</code> - A radix from 2 through 36. For example, to generate a
hexadecimal (base-16) string, specify 16. To generate a decimal
(base-10) string, specify 10.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A string representing the value of this object. If this value is 0,
returns &quot;0&quot;. If negative, the string will begin with a minus sign
(&quot;-&quot;, U+002D). Depending on the radix, the string will use the basic
digits 0 to 9 (U+0030 to U+0039) and then the basic upper-case
letters A to Z (U+0041 to U+005A). For example, 0-9 in radix 10, and
0-9, then A-F in radix 16.</li>
</ul>

<h3>toString</h3>

<pre>public java.lang.String toString()
</pre>

<p>Converts this object to a text string in base 10.</p>

<p><strong>Overrides:</strong></p>

<ul>
<li><code>toString</code> in class <code>java.lang.Object</code></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A string representation of this object. If this value is 0, returns
&quot;0&quot;. If negative, the string will begin with a minus sign (&quot;-&quot;,
U+002D). The string will use the basic digits 0 to 9 (U+0030 to
U+0039).</li>
</ul>

<h3>Increment</h3>

<pre>public EInteger Increment()
</pre>

<p>Returns one added to this arbitrary-precision integer.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>The given arbitrary-precision integer plus one.</li>
</ul>

<h3>Decrement</h3>

<pre>public EInteger Decrement()
</pre>

<p>Returns one subtracted from this arbitrary-precision integer.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>The given arbitrary-precision integer minus one.</li>
</ul>

<h3>ToByteChecked</h3>

<pre>public byte ToByteChecked()
</pre>

<p>Converts this number&#39;s value to a byte (from 0 to 255) if it can fit in a
 byte (from 0 to 255).</p>

<p><strong>Returns:</strong></p>

<ul>
<li>This number&#39;s value as a byte (from 0 to 255).</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.ArithmeticException</code> - This value is less than 0 or greater than 255.</li>
</ul>

<h3>ToByteUnchecked</h3>

<pre>public byte ToByteUnchecked()
</pre>

<p>Converts this number to a byte (from 0 to 255), returning the
 least-significant bits of this number&#39;s two&#39;s-complement form.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>This number, converted to a byte (from 0 to 255).</li>
</ul>

<h3>FromByte</h3>

<pre>public static EInteger FromByte​(byte inputByte)
</pre>

<p>Converts a byte (from 0 to 255) to an arbitrary-precision integer.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>inputByte</code> - The number to convert as a byte (from 0 to 255).</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>This number&#39;s value as an arbitrary-precision integer.</li>
</ul>

<h3>ToInt16Checked</h3>

<pre>public short ToInt16Checked()
</pre>

<p>Converts this number&#39;s value to a 16-bit signed integer if it can fit in a
 16-bit signed integer.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>This number&#39;s value as a 16-bit signed integer.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.ArithmeticException</code> - This value is less than -32768 or greater than
32767.</li>
</ul>

<h3>ToInt16Unchecked</h3>

<pre>public short ToInt16Unchecked()
</pre>

<p>Converts this number to a 16-bit signed integer, returning the
 least-significant bits of this number&#39;s two&#39;s-complement form.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>This number, converted to a 16-bit signed integer.</li>
</ul>

<h3>FromInt16</h3>

<pre>public static EInteger FromInt16​(short inputInt16)
</pre>

<p>Converts a 16-bit signed integer to an arbitrary-precision integer.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>inputInt16</code> - The number to convert as a 16-bit signed integer.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>This number&#39;s value as an arbitrary-precision integer.</li>
</ul>

<p><a href="/Numbers/">Back to Numbers start page.</a></p>
</div><nav id="navigation"><ul>
<li><a href="/">Back to start site.</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io">This site's repository (source code)</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io/issues">Post an issue or comment</a></ul>
<p>
If you like this software, you should consider donating to me, Peter O., at the link below:</p>
<p class="printonly"><b>peteroupc.github.io</b></p>
<div class="noprint">
<a href="https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=56E5T4FH7KD2S">
<img src="https://www.paypalobjects.com/en_US/i/btn/btn_donateCC_LG.gif"
name="submit" border="2" alt="PayPal - The safer, easier way to pay online!"></a>
<p>
<a href="//twitter.com/share">Share via Twitter</a>, <a href="//www.facebook.com/sharer/sharer.php" id="sharer">Share via Facebook</a>
</p>
</div>
</nav><script>
if("share" in navigator){
 document.getElementById("sharer").href="javascript:void(null)";
 document.getElementById("sharer").innerHTML="Share This Page";
 navigator.share({title:document.title,url:document.location.href}).then(
   function(){});
} else {
 document.getElementById("sharer").href="//www.facebook.com/sharer/sharer.php?u="+
    encodeURIComponent(document.location.href)
}
</script>
</body></html>
