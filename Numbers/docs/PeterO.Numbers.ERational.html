<!DOCTYPE html><html xmlns:dc="http://purl.org/dc/terms/"><head><meta http-equiv=Content-Type content="text/html; charset=utf-8"><title>PeterO.Numbers.ERational</title><meta name="viewport" content="width=device-width"><link rel=stylesheet type="text/css" href="/style.css">
            <script type="text/x-mathjax-config"> MathJax.Hub.Config({"HTML-CSS": { availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, preferredFont: "TeX" },
                    tex2jax: { displayMath: [ ["$$","$$"], ["\\[", "\\]"] ], inlineMath: [ ["$", "$"], ["\\\\(","\\\\)"] ], processEscapes: true } });
            </script><script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"></script></head><body>  <div class="header">
<nav><p><a href="#navigation">Menu</a> - <a href="#top">Top</a> - <a href="/">Home</a></nav></div>
<div class="mainarea" id="top">
<h1>PeterO.Numbers.ERational</h1>

<h2>PeterO.Numbers.ERational</h2>

<pre>public sealed class ERational :
    System.IComparable,
    System.IEquatable
</pre>

<p>Represents an arbitrary-precision rational number. This class can&#39;t be inherited. (The &quot;E&quot; stands for &quot;extended&quot;, meaning that instances of this class can be values other than numbers proper, such as infinity and not-a-number.) In this class, a rational number consists of a numerator and denominator, each an arbitrary-precision integer (EInteger), and this class does not automatically convert rational numbers to lowest terms. <b>Thread safety:</b> Instances of this class are immutable, so they are inherently safe for use by multiple threads. Multiple instances of this object with the same properties are interchangeable, so they should not be compared using the &quot;==&quot; operator (which might only check if each side of the operator is the same instance).</p>

<h3>Member Summary</h3>

<ul>
<li><code><a href="#Abs">Abs()</a></code> - Returns the absolute value of this rational number, that is, a number with the same value as this one but as a nonnegative number.</li>
<li><code><a href="#Add_int">Add(int)</a></code> - Adds this arbitrary-precision rational number and a 32-bit signed integer and returns the result.</li>
<li><code><a href="#Add_long">Add(long)</a></code> - Adds this arbitrary-precision rational number and a 64-bit signed integer and returns the result.</li>
<li><code><a href="#Add_PeterO_Numbers_ERational">Add(PeterO.Numbers.ERational)</a></code> - Adds this arbitrary-precision rational number and another arbitrary-precision rational number and returns the result.</li>
<li><code><a href="#CompareTo_int">CompareTo(int)</a></code> - Compares the mathematical value of an arbitrary-precision rational number with that of this instance.</li>
<li><code><a href="#CompareTo_long">CompareTo(long)</a></code> - Compares the mathematical values of this object and another object, accepting NaN values.</li>
<li><code><a href="#CompareTo_PeterO_Numbers_ERational">CompareTo(PeterO.Numbers.ERational)</a></code> - Compares the mathematical value of an arbitrary-precision rational number with that of this instance.</li>
<li><code><a href="#CompareToBinary_PeterO_Numbers_EFloat">CompareToBinary(PeterO.Numbers.EFloat)</a></code> - Compares an arbitrary-precision binary floating-point number with this instance.</li>
<li><code><a href="#CompareToDecimal_PeterO_Numbers_EDecimal">CompareToDecimal(PeterO.Numbers.EDecimal)</a></code> - Compares an arbitrary-precision decimal number with this instance.</li>
<li><code><a href="#CompareToTotal_PeterO_Numbers_ERational">CompareToTotal(PeterO.Numbers.ERational)</a></code> - Compares the values of this object and another object, imposing a total ordering on all possible values.</li>
<li><code><a href="#CompareToTotalMagnitude_PeterO_Numbers_ERational">CompareToTotalMagnitude(PeterO.Numbers.ERational)</a></code> - Compares the absolute values of this object and another object, imposing a total ordering on all possible values (ignoring their signs).</li>
<li><code><a href="#CompareToValue_int">CompareToValue(int)</a></code> - Compares the mathematical value of an arbitrary-precision rational number with that of this instance.</li>
<li><code><a href="#CompareToValue_long">CompareToValue(long)</a></code> - Compares the mathematical values of this object and another object, accepting NaN values.</li>
<li><code><a href="#CompareToValue_PeterO_Numbers_ERational">CompareToValue(PeterO.Numbers.ERational)</a></code> - Compares the mathematical value of an arbitrary-precision rational number with that of this instance.</li>
<li><code><a href="#Copy">Copy()</a></code> - Creates a copy of this arbitrary-precision rational number.</li>
<li><code><a href="#CopySign_PeterO_Numbers_ERational">CopySign(PeterO.Numbers.ERational)</a></code> - Returns a number with the same value as this one, but copying the sign (positive or negative) of another number.</li>
<li><code><a href="#Create_int_int">Create(int, int)</a></code> - Creates a rational number with the given numerator and denominator.</li>
<li><code><a href="#Create_long_long">Create(long, long)</a></code> - Creates a rational number with the given numerator and denominator.</li>
<li><code><a href="#Create_PeterO_Numbers_EInteger_PeterO_Numbers_EInteger">Create(PeterO.Numbers.EInteger, PeterO.Numbers.EInteger)</a></code> - Creates a rational number with the given numerator and denominator.</li>
<li><code><a href="#CreateNaN_PeterO_Numbers_EInteger">CreateNaN(PeterO.Numbers.EInteger)</a></code> - Creates a not-a-number arbitrary-precision rational number.</li>
<li><code><a href="#CreateNaN_PeterO_Numbers_EInteger_bool_bool">CreateNaN(PeterO.Numbers.EInteger, bool, bool)</a></code> - Creates a not-a-number arbitrary-precision rational number.</li>
<li><code><a href="#Decrement">Decrement()</a></code> - Subtracts one from an arbitrary-precision rational number.</li>
<li><code><a href="#Denominator">Denominator</a></code> - Gets this object&#39;s denominator.</li>
<li><code><a href="#Divide_int">Divide(int)</a></code> - Divides this arbitrary-precision rational number by a 32-bit signed integer and returns the result.</li>
<li><code><a href="#Divide_long">Divide(long)</a></code> - Divides this arbitrary-precision rational number by a 64-bit signed integer and returns the result.</li>
<li><code><a href="#Divide_PeterO_Numbers_ERational">Divide(PeterO.Numbers.ERational)</a></code> - Divides this arbitrary-precision rational number by another arbitrary-precision rational number and returns the result.</li>
<li><code><a href="#Equals_object">Equals(object)</a></code> - Determines whether this object&#39;s numerator, denominator, and properties are equal to those of another object and that other object is an arbitrary-precision rational number.</li>
<li><code><a href="#Equals_PeterO_Numbers_ERational">Equals(PeterO.Numbers.ERational)</a></code> - Determines whether this object&#39;s numerator, denominator, and properties are equal to those of another object.</li>
<li><code><a href="#explicit_operator_byte_PeterO_Numbers_ERational">explicit operator byte(PeterO.Numbers.ERational)</a></code> - Converts an arbitrary-precision rational number to a byte (from 0 to 255) if it can fit in a byte (from 0 to 255) after converting it to an integer by discarding its fractional part.</li>
<li><code><a href="#explicit_operator_decimal_PeterO_Numbers_ERational">explicit operator decimal(PeterO.Numbers.ERational)</a></code> - Converts an arbitrary-precision rational number to a decimal under the Common Language Infrastructure (see T:PeterO.</li>
<li><code><a href="#explicit_operator_double_PeterO_Numbers_ERational">explicit operator double(PeterO.Numbers.ERational)</a></code> - Converts an arbitrary-precision rational number to a 64-bit floating-point number.</li>
<li><code><a href="#explicit_operator_float_PeterO_Numbers_ERational">explicit operator float(PeterO.Numbers.ERational)</a></code> - Converts an arbitrary-precision rational number to a 32-bit binary floating-point number.</li>
<li><code><a href="#explicit_operator_int_PeterO_Numbers_ERational">explicit operator int(PeterO.Numbers.ERational)</a></code> - Converts an arbitrary-precision rational number to a 32-bit signed integer if it can fit in a 32-bit signed integer after converting it to an integer by discarding its fractional part.</li>
<li><code><a href="#explicit_operator_long_PeterO_Numbers_ERational">explicit operator long(PeterO.Numbers.ERational)</a></code> - Converts an arbitrary-precision rational number to a 64-bit signed integer if it can fit in a 64-bit signed integer after converting it to an integer by discarding its fractional part.</li>
<li><code><a href="#explicit_operator_PeterO_Numbers_EInteger_PeterO_Numbers_ERational">explicit operator PeterO.Numbers.EInteger(PeterO.Numbers.ERational)</a></code> - Converts an arbitrary-precision rational number to an arbitrary-precision integer.</li>
<li><code><a href="#explicit_operator_PeterO_Numbers_ERational_bool">explicit operator PeterO.Numbers.ERational(bool)</a></code> - Converts a boolean value (true or false) to an arbitrary-precision rational number.</li>
<li><code><a href="#explicit_operator_sbyte_PeterO_Numbers_ERational">explicit operator sbyte(PeterO.Numbers.ERational)</a></code> - Converts an arbitrary-precision rational number to an 8-bit signed integer if it can fit in an 8-bit signed integer after converting it to an integer by discarding its fractional part.</li>
<li><code><a href="#explicit_operator_short_PeterO_Numbers_ERational">explicit operator short(PeterO.Numbers.ERational)</a></code> - Converts an arbitrary-precision rational number to a 16-bit signed integer if it can fit in a 16-bit signed integer after converting it to an integer by discarding its fractional part.</li>
<li><code><a href="#explicit_operator_uint_PeterO_Numbers_ERational">explicit operator uint(PeterO.Numbers.ERational)</a></code> - Converts an arbitrary-precision rational number to a 32-bit signed integer if it can fit in a 32-bit signed integer after converting it to an integer by discarding its fractional part.</li>
<li><code><a href="#explicit_operator_ulong_PeterO_Numbers_ERational">explicit operator ulong(PeterO.Numbers.ERational)</a></code> - Converts an arbitrary-precision rational number to a 64-bit unsigned integer if it can fit in a 64-bit unsigned integer after converting it to an integer by discarding its fractional part.</li>
<li><code><a href="#explicit_operator_ushort_PeterO_Numbers_ERational">explicit operator ushort(PeterO.Numbers.ERational)</a></code> - Converts an arbitrary-precision rational number to a 16-bit unsigned integer if it can fit in a 16-bit unsigned integer after converting it to an integer by discarding its fractional part.</li>
<li><code><a href="#FromBoolean_bool">FromBoolean(bool)</a></code> - Converts a boolean value (true or false) to an arbitrary-precision rational number.</li>
<li><code><a href="#FromByte_byte">FromByte(byte)</a></code> - Converts a byte (from 0 to 255) to an arbitrary-precision rational number.</li>
<li><code><a href="#FromDecimal_decimal">FromDecimal(decimal)</a></code> - Converts a decimal under the Common Language Infrastructure (usually a.</li>
<li><code><a href="#FromDouble_double">FromDouble(double)</a></code> - Converts a 64-bit floating-point number to a rational number.</li>
<li><code><a href="#FromDoubleBits_long">FromDoubleBits(long)</a></code> - Creates a binary rational number from a 64-bit floating-point number encoded in the IEEE 754 binary64 format.</li>
<li><code><a href="#FromEDecimal_PeterO_Numbers_EDecimal">FromEDecimal(PeterO.Numbers.EDecimal)</a></code> - Converts an arbitrary-precision decimal number to a rational number.</li>
<li><code><a href="#FromEFloat_PeterO_Numbers_EFloat">FromEFloat(PeterO.Numbers.EFloat)</a></code> - Converts an arbitrary-precision binary floating-point number to a rational number.</li>
<li><code><a href="#FromEInteger_PeterO_Numbers_EInteger">FromEInteger(PeterO.Numbers.EInteger)</a></code> - Converts an arbitrary-precision integer to a rational number.</li>
<li><code><a href="#FromExtendedDecimal_PeterO_Numbers_EDecimal">FromExtendedDecimal(PeterO.Numbers.EDecimal)</a></code> - <b>Deprecated:</b> Renamed to FromEDecimal.</li>
<li><code><a href="#FromExtendedFloat_PeterO_Numbers_EFloat">FromExtendedFloat(PeterO.Numbers.EFloat)</a></code> - <b>Deprecated:</b> Renamed to FromEFloat.</li>
<li><code><a href="#FromHalfBits_short">FromHalfBits(short)</a></code> - Creates a binary rational number from a binary floating-point number encoded in the IEEE 754 binary16 format (also known as a &quot;half-precision&quot; floating-point number).</li>
<li><code><a href="#FromInt16_short">FromInt16(short)</a></code> - Converts a 16-bit signed integer to an arbitrary-precision rational number.</li>
<li><code><a href="#FromInt32_int">FromInt32(int)</a></code> - Converts a 32-bit signed integer to an arbitrary-precision rational number.</li>
<li><code><a href="#FromInt64_long">FromInt64(long)</a></code> - Converts a 64-bit signed integer to an arbitrary-precision rational number.</li>
<li><code><a href="#FromInt64AsUnsigned_long">FromInt64AsUnsigned(long)</a></code> - Converts an unsigned integer expressed as a 64-bit signed integer to an arbitrary-precision rational number.</li>
<li><code><a href="#FromSByte_sbyte">FromSByte(sbyte)</a></code> - Converts an 8-bit signed integer to an arbitrary-precision rational number.</li>
<li><code><a href="#FromSingle_float">FromSingle(float)</a></code> - Converts a 32-bit binary floating-point number to a rational number.</li>
<li><code><a href="#FromSingleBits_int">FromSingleBits(int)</a></code> - Creates a binary rational number from a 32-bit floating-point number encoded in the IEEE 754 binary32 format.</li>
<li><code><a href="#FromString_byte">FromString(byte[])</a></code> - Creates a rational number from a sequence of bytes that represents a number.</li>
<li><code><a href="#FromString_byte_int_int">FromString(byte[], int, int)</a></code> - Creates a rational number from a sequence of bytes that represents a number.</li>
<li><code><a href="#FromString_char">FromString(char[])</a></code> - Creates a rational number from a sequence of char s that represents a number.</li>
<li><code><a href="#FromString_char_int_int">FromString(char[], int, int)</a></code> - Creates a rational number from a sequence of char s that represents a number.</li>
<li><code><a href="#FromString_string">FromString(string)</a></code> - Creates a rational number from a text string that represents a number.</li>
<li><code><a href="#FromString_string_int_int">FromString(string, int, int)</a></code> - Creates a rational number from a text string that represents a number.</li>
<li><code><a href="#FromUInt16_ushort">FromUInt16(ushort)</a></code> - Converts a 16-bit unsigned integer to an arbitrary-precision rational number.</li>
<li><code><a href="#FromUInt32_uint">FromUInt32(uint)</a></code> - Converts a 32-bit signed integer to an arbitrary-precision rational number.</li>
<li><code><a href="#FromUInt64_ulong">FromUInt64(ulong)</a></code> - Converts a 64-bit unsigned integer to an arbitrary-precision rational number.</li>
<li><code><a href="#GetHashCode">GetHashCode()</a></code> - Returns the hash code for this instance.</li>
<li><code><a href="#implicit_operator_PeterO_Numbers_ERational_byte">implicit operator PeterO.Numbers.ERational(byte)</a></code> - Converts a byte (from 0 to 255) to an arbitrary-precision rational number.</li>
<li><code><a href="#implicit_operator_PeterO_Numbers_ERational_decimal">implicit operator PeterO.Numbers.ERational(decimal)</a></code> - Converts a decimal under the Common Language Infrastructure (usually a.</li>
<li><code><a href="#implicit_operator_PeterO_Numbers_ERational_double">implicit operator PeterO.Numbers.ERational(double)</a></code> - Converts a 64-bit floating-point number to an arbitrary-precision rational number.</li>
<li><code><a href="#implicit_operator_PeterO_Numbers_ERational_float">implicit operator PeterO.Numbers.ERational(float)</a></code> - Converts a 32-bit binary floating-point number to a rational number.</li>
<li><code><a href="#implicit_operator_PeterO_Numbers_ERational_int">implicit operator PeterO.Numbers.ERational(int)</a></code> - Converts a 32-bit signed integer to an arbitrary-precision rational number.</li>
<li><code><a href="#implicit_operator_PeterO_Numbers_ERational_long">implicit operator PeterO.Numbers.ERational(long)</a></code> - Converts a 64-bit signed integer to an arbitrary-precision rational number.</li>
<li><code><a href="#implicit_operator_PeterO_Numbers_ERational_PeterO_Numbers_EDecimal">implicit operator PeterO.Numbers.ERational(PeterO.Numbers.EDecimal)</a></code> - Converts an arbitrary-precision decimal floating-point number to an arbitrary-precision rational number.</li>
<li><code><a href="#implicit_operator_PeterO_Numbers_ERational_PeterO_Numbers_EFloat">implicit operator PeterO.Numbers.ERational(PeterO.Numbers.EFloat)</a></code> - Converts an arbitrary-precision binary floating-point number to an arbitrary-precision rational number.</li>
<li><code><a href="#implicit_operator_PeterO_Numbers_ERational_PeterO_Numbers_EInteger">implicit operator PeterO.Numbers.ERational(PeterO.Numbers.EInteger)</a></code> - Converts an arbitrary-precision integer to an arbitrary-precision rational number.</li>
<li><code><a href="#implicit_operator_PeterO_Numbers_ERational_sbyte">implicit operator PeterO.Numbers.ERational(sbyte)</a></code> - Converts an 8-bit signed integer to an arbitrary-precision rational number.</li>
<li><code><a href="#implicit_operator_PeterO_Numbers_ERational_short">implicit operator PeterO.Numbers.ERational(short)</a></code> - Converts a 16-bit signed integer to an arbitrary-precision rational number.</li>
<li><code><a href="#implicit_operator_PeterO_Numbers_ERational_uint">implicit operator PeterO.Numbers.ERational(uint)</a></code> - Converts a 32-bit signed integer to an arbitrary-precision rational number.</li>
<li><code><a href="#implicit_operator_PeterO_Numbers_ERational_ulong">implicit operator PeterO.Numbers.ERational(ulong)</a></code> - Converts a 64-bit unsigned integer to an arbitrary-precision rational number.</li>
<li><code><a href="#implicit_operator_PeterO_Numbers_ERational_ushort">implicit operator PeterO.Numbers.ERational(ushort)</a></code> - Converts a 16-bit unsigned integer to an arbitrary-precision rational number.</li>
<li><code><a href="#Increment">Increment()</a></code> - Adds one to an arbitrary-precision rational number.</li>
<li><code><a href="#IsFinite">IsFinite</a></code> - Gets a value indicating whether this object is finite (not infinity or NaN).</li>
<li><code><a href="#IsInfinity">IsInfinity()</a></code> - Gets a value indicating whether this object&#39;s value is infinity.</li>
<li><code><a href="#IsInteger">IsInteger()</a></code> - Returns whether this object&#39;s value is an integer.</li>
<li><code><a href="#IsNaN">IsNaN()</a></code> - Returns whether this object is a not-a-number value.</li>
<li><code><a href="#IsNegative">IsNegative</a></code> - Gets a value indicating whether this object&#39;s value is negative (including negative zero).</li>
<li><code><a href="#IsNegativeInfinity">IsNegativeInfinity()</a></code> - Returns whether this object is negative infinity.</li>
<li><code><a href="#IsPositiveInfinity">IsPositiveInfinity()</a></code> - Returns whether this object is positive infinity.</li>
<li><code><a href="#IsQuietNaN">IsQuietNaN()</a></code> - Returns whether this object is a quiet not-a-number value.</li>
<li><code><a href="#IsSignalingNaN">IsSignalingNaN()</a></code> - Returns whether this object is a signaling not-a-number value (which causes an error if the value is passed to any arithmetic operation in this class).</li>
<li><code><a href="#IsZero">IsZero</a></code> - Gets a value indicating whether this object&#39;s value equals 0.</li>
<li><code><a href="#Max_PeterO_Numbers_ERational_PeterO_Numbers_ERational">Max(PeterO.Numbers.ERational, PeterO.Numbers.ERational)</a></code> - Gets the greater value between two rational numbers.</li>
<li><code><a href="#MaxMagnitude_PeterO_Numbers_ERational_PeterO_Numbers_ERational">MaxMagnitude(PeterO.Numbers.ERational, PeterO.Numbers.ERational)</a></code> - Gets the greater value between two values, ignoring their signs.</li>
<li><code><a href="#Min_PeterO_Numbers_ERational_PeterO_Numbers_ERational">Min(PeterO.Numbers.ERational, PeterO.Numbers.ERational)</a></code> - Gets the lesser value between two rational numbers.</li>
<li><code><a href="#MinMagnitude_PeterO_Numbers_ERational_PeterO_Numbers_ERational">MinMagnitude(PeterO.Numbers.ERational, PeterO.Numbers.ERational)</a></code> - Gets the lesser value between two values, ignoring their signs.</li>
<li><code><a href="#Multiply_int">Multiply(int)</a></code> - Multiplies this arbitrary-precision rational number by a 32-bit signed integer and returns the result.</li>
<li><code><a href="#Multiply_long">Multiply(long)</a></code> - Multiplies this arbitrary-precision rational number by a 64-bit signed integer and returns the result.</li>
<li><code><a href="#Multiply_PeterO_Numbers_ERational">Multiply(PeterO.Numbers.ERational)</a></code> - Multiplies this arbitrary-precision rational number by another arbitrary-precision rational number and returns the result.</li>
<li><code><a href="#NaN">public static readonly PeterO.Numbers.ERational NaN;</a></code> - A not-a-number value.</li>
<li><code><a href="#Negate">Negate()</a></code> - Returns a rational number with the same value as this one but with the sign reversed.</li>
<li><code><a href="#NegativeInfinity">public static readonly PeterO.Numbers.ERational NegativeInfinity;</a></code> - Negative infinity, less than any other number.</li>
<li><code><a href="#NegativeZero">public static readonly PeterO.Numbers.ERational NegativeZero;</a></code> - A rational number for negative zero.</li>
<li><code><a href="#Numerator">Numerator</a></code> - Gets this object&#39;s numerator.</li>
<li><code><a href="#One">public static readonly PeterO.Numbers.ERational One;</a></code> - The rational number one.</li>
<li><code><a href="#op_Addition">PeterO.Numbers.ERational operator +(PeterO.Numbers.ERational, PeterO.Numbers.ERational)</a></code> - Adds an arbitrary-precision rational number and another arbitrary-precision rational number and returns the result.</li>
<li><code><a href="#op_Decrement">PeterO.Numbers.ERational operator --(PeterO.Numbers.ERational)</a></code> - Subtracts one from an arbitrary-precision rational number.</li>
<li><code><a href="#op_Division">PeterO.Numbers.ERational operator /(PeterO.Numbers.ERational, PeterO.Numbers.ERational)</a></code> - Divides an arbitrary-precision rational number by the value of another arbitrary-precision rational number object.</li>
<li><code><a href="#op_Increment">PeterO.Numbers.ERational operator ++(PeterO.Numbers.ERational)</a></code> - Adds one to an arbitrary-precision rational number.</li>
<li><code><a href="#op_Modulus">PeterO.Numbers.ERational operator %(PeterO.Numbers.ERational, PeterO.Numbers.ERational)</a></code> - Returns the remainder that would result when an arbitrary-precision rational number is divided by another arbitrary-precision rational number.</li>
<li><code><a href="#op_Multiply">PeterO.Numbers.ERational operator &#x2a;(PeterO.Numbers.ERational, PeterO.Numbers.ERational)</a></code> - Multiplies an arbitrary-precision rational number by another arbitrary-precision rational number and returns the result.</li>
<li><code><a href="#op_Subtraction">PeterO.Numbers.ERational operator -(PeterO.Numbers.ERational, PeterO.Numbers.ERational)</a></code> - Subtracts an arbitrary-precision rational number from this instance.</li>
<li><code><a href="#op_UnaryNegation">PeterO.Numbers.ERational operator -(PeterO.Numbers.ERational)</a></code> - Returns an arbitrary-precision rational number with the same value as the given one but with its sign reversed.</li>
<li><code><a href="#PositiveInfinity">public static readonly PeterO.Numbers.ERational PositiveInfinity;</a></code> - Positive infinity, greater than any other number.</li>
<li><code><a href="#Remainder_int">Remainder(int)</a></code> - Returns the remainder that would result when this arbitrary-precision rational number is divided by a 32-bit signed integer.</li>
<li><code><a href="#Remainder_long">Remainder(long)</a></code> - Returns the remainder that would result when this arbitrary-precision rational number is divided by a 64-bit signed integer.</li>
<li><code><a href="#Remainder_PeterO_Numbers_ERational">Remainder(PeterO.Numbers.ERational)</a></code> - Returns the remainder that would result when this arbitrary-precision rational number is divided by another arbitrary-precision rational number.</li>
<li><code><a href="#Sign">Sign</a></code> - Gets the sign of this rational number.</li>
<li><code><a href="#SignalingNaN">public static readonly PeterO.Numbers.ERational SignalingNaN;</a></code> - A signaling not-a-number value.</li>
<li><code><a href="#Subtract_int">Subtract(int)</a></code> - Subtracts a 32-bit signed integer from this arbitrary-precision rational number and returns the result.</li>
<li><code><a href="#Subtract_long">Subtract(long)</a></code> - Subtracts a 64-bit signed integer from this arbitrary-precision rational number and returns the result.</li>
<li><code><a href="#Subtract_PeterO_Numbers_ERational">Subtract(PeterO.Numbers.ERational)</a></code> - Subtracts an arbitrary-precision rational number from this arbitrary-precision rational number and returns the result.</li>
<li><code><a href="#Ten">public static readonly PeterO.Numbers.ERational Ten;</a></code> - The rational number ten.</li>
<li><code><a href="#ToByteChecked">ToByteChecked()</a></code> - Converts this number&#39;s value to a byte (from 0 to 255) if it can fit in a byte (from 0 to 255) after converting it to an integer by discarding its fractional part.</li>
<li><code><a href="#ToByteIfExact">ToByteIfExact()</a></code> - Converts this number&#39;s value to a byte (from 0 to 255) if it can fit in a byte (from 0 to 255) without rounding to a different numerical value.</li>
<li><code><a href="#ToByteUnchecked">ToByteUnchecked()</a></code> - Converts this number&#39;s value to an integer (using ToEInteger), and returns the least-significant bits of that integer&#39;s two&#39;s-complement form as a byte (from 0 to 255).</li>
<li><code><a href="#ToDecimal">ToDecimal()</a></code> - Converts this value to a decimal under the Common Language Infrastructure (usually a.</li>
<li><code><a href="#ToDouble">ToDouble()</a></code> - Converts this value to a 64-bit floating-point number.</li>
<li><code><a href="#ToDoubleBits">ToDoubleBits()</a></code> - Converts this value to its closest equivalent as a 64-bit floating-point number, expressed as an integer in the IEEE 754 binary64 format.</li>
<li><code><a href="#ToEDecimal">ToEDecimal()</a></code> - Converts this rational number to an arbitrary-precision decimal number.</li>
<li><code><a href="#ToEDecimal_PeterO_Numbers_EContext">ToEDecimal(PeterO.Numbers.EContext)</a></code> - Converts this rational number to an arbitrary-precision decimal number and rounds the result to the given precision.</li>
<li><code><a href="#ToEDecimalExactIfPossible_PeterO_Numbers_EContext">ToEDecimalExactIfPossible(PeterO.Numbers.EContext)</a></code> - Converts this rational number to an arbitrary-precision decimal number, but if the result would have a nonterminating decimal expansion, rounds that result to the given precision.</li>
<li><code><a href="#ToEFloat">ToEFloat()</a></code> - Converts this rational number to a binary floating-point number.</li>
<li><code><a href="#ToEFloat_PeterO_Numbers_EContext">ToEFloat(PeterO.Numbers.EContext)</a></code> - Converts this rational number to a binary floating-point number and rounds that result to the given precision.</li>
<li><code><a href="#ToEFloatExactIfPossible_PeterO_Numbers_EContext">ToEFloatExactIfPossible(PeterO.Numbers.EContext)</a></code> - Converts this rational number to a binary floating-point number, but if the result would have a nonterminating binary expansion, rounds that result to the given precision.</li>
<li><code><a href="#ToEInteger">ToEInteger()</a></code> - Converts this value to an arbitrary-precision integer by dividing the numerator by the denominator and discarding the fractional part of the result.</li>
<li><code><a href="#ToEIntegerExact">ToEIntegerExact()</a></code> - <b>Deprecated:</b> Renamed to ToEIntegerIfExact.</li>
<li><code><a href="#ToEIntegerIfExact">ToEIntegerIfExact()</a></code> - Converts this value to an arbitrary-precision integer, checking whether the value is an exact integer.</li>
<li><code><a href="#ToExtendedDecimal">ToExtendedDecimal()</a></code> - <b>Deprecated:</b> Renamed to ToEDecimal.</li>
<li><code><a href="#ToExtendedDecimal_PeterO_Numbers_EContext">ToExtendedDecimal(PeterO.Numbers.EContext)</a></code> - <b>Deprecated:</b> Renamed to ToEDecimal.</li>
<li><code><a href="#ToExtendedDecimalExactIfPossible_PeterO_Numbers_EContext">ToExtendedDecimalExactIfPossible(PeterO.Numbers.EContext)</a></code> - <b>Deprecated:</b> Renamed to ToEDecimalExactIfPossible.</li>
<li><code><a href="#ToExtendedFloat">ToExtendedFloat()</a></code> - <b>Deprecated:</b> Renamed to ToEFloat.</li>
<li><code><a href="#ToExtendedFloat_PeterO_Numbers_EContext">ToExtendedFloat(PeterO.Numbers.EContext)</a></code> - <b>Deprecated:</b> Renamed to ToEFloat.</li>
<li><code><a href="#ToExtendedFloatExactIfPossible_PeterO_Numbers_EContext">ToExtendedFloatExactIfPossible(PeterO.Numbers.EContext)</a></code> - <b>Deprecated:</b> Renamed to ToEFloatExactIfPossible.</li>
<li><code><a href="#ToHalfBits">ToHalfBits()</a></code> - Converts this value to its closest equivalent as a binary floating-point number, expressed as an integer in the IEEE 754 binary16 format (also known as a &quot;half-precision&quot; floating-point number).</li>
<li><code><a href="#ToInt16Checked">ToInt16Checked()</a></code> - Converts this number&#39;s value to a 16-bit signed integer if it can fit in a 16-bit signed integer after converting it to an integer by discarding its fractional part.</li>
<li><code><a href="#ToInt16IfExact">ToInt16IfExact()</a></code> - Converts this number&#39;s value to a 16-bit signed integer if it can fit in a 16-bit signed integer without rounding to a different numerical value.</li>
<li><code><a href="#ToInt16Unchecked">ToInt16Unchecked()</a></code> - Converts this number&#39;s value to an integer by discarding its fractional part, and returns the least-significant bits of its two&#39;s-complement form as a 16-bit signed integer.</li>
<li><code><a href="#ToInt32Checked">ToInt32Checked()</a></code> - Converts this number&#39;s value to a 32-bit signed integer if it can fit in a 32-bit signed integer after converting it to an integer by discarding its fractional part.</li>
<li><code><a href="#ToInt32IfExact">ToInt32IfExact()</a></code> - Converts this number&#39;s value to a 32-bit signed integer if it can fit in a 32-bit signed integer without rounding to a different numerical value.</li>
<li><code><a href="#ToInt32Unchecked">ToInt32Unchecked()</a></code> - Converts this number&#39;s value to an integer by discarding its fractional part, and returns the least-significant bits of its two&#39;s-complement form as a 32-bit signed integer.</li>
<li><code><a href="#ToInt64Checked">ToInt64Checked()</a></code> - Converts this number&#39;s value to a 64-bit signed integer if it can fit in a 64-bit signed integer after converting it to an integer by discarding its fractional part.</li>
<li><code><a href="#ToInt64IfExact">ToInt64IfExact()</a></code> - Converts this number&#39;s value to a 64-bit signed integer if it can fit in a 64-bit signed integer without rounding to a different numerical value.</li>
<li><code><a href="#ToInt64Unchecked">ToInt64Unchecked()</a></code> - Converts this number&#39;s value to an integer by discarding its fractional part, and returns the least-significant bits of its two&#39;s-complement form as a 64-bit signed integer.</li>
<li><code><a href="#ToLowestTerms">ToLowestTerms()</a></code> - Converts this value to its form in lowest terms.</li>
<li><code><a href="#ToSByteChecked">ToSByteChecked()</a></code> - Converts this number&#39;s value to an 8-bit signed integer if it can fit in an 8-bit signed integer after converting it to an integer by discarding its fractional part.</li>
<li><code><a href="#ToSByteIfExact">ToSByteIfExact()</a></code> - Converts this number&#39;s value to an 8-bit signed integer if it can fit in an 8-bit signed integer without rounding to a different numerical value.</li>
<li><code><a href="#ToSByteUnchecked">ToSByteUnchecked()</a></code> - Converts this number&#39;s value to an integer by discarding its fractional part, and returns the least-significant bits of its two&#39;s-complement form as an 8-bit signed integer.</li>
<li><code><a href="#ToSingle">ToSingle()</a></code> - Converts this value to a 32-bit binary floating-point number.</li>
<li><code><a href="#ToSingleBits">ToSingleBits()</a></code> - Converts this value to its closest equivalent as 32-bit floating-point number, expressed as an integer in the IEEE 754 binary32 format.</li>
<li><code><a href="#ToSizedEInteger_int">ToSizedEInteger(int)</a></code> - Converts this value to an arbitrary-precision integer by dividing the numerator by the denominator, discarding its fractional part, and checking whether the resulting integer overflows the given signed bit count.</li>
<li><code><a href="#ToSizedEIntegerIfExact_int">ToSizedEIntegerIfExact(int)</a></code> - Converts this value to an arbitrary-precision integer, only if this number&#39;s value is an exact integer and that integer does not overflow the given signed bit count.</li>
<li><code><a href="#ToString">ToString()</a></code> - Converts this object to a text string.</li>
<li><code><a href="#ToUInt16Checked">ToUInt16Checked()</a></code> - Converts this number&#39;s value to a 16-bit unsigned integer if it can fit in a 16-bit unsigned integer after converting it to an integer by discarding its fractional part.</li>
<li><code><a href="#ToUInt16IfExact">ToUInt16IfExact()</a></code> - Converts this number&#39;s value to a 16-bit unsigned integer if it can fit in a 16-bit unsigned integer without rounding to a different numerical value.</li>
<li><code><a href="#ToUInt16Unchecked">ToUInt16Unchecked()</a></code> - Converts this number&#39;s value to an integer by discarding its fractional part, and returns the least-significant bits of its two&#39;s-complement form as a 16-bit unsigned integer.</li>
<li><code><a href="#ToUInt32Checked">ToUInt32Checked()</a></code> - Converts this number&#39;s value to a 32-bit signed integer if it can fit in a 32-bit signed integer after converting it to an integer by discarding its fractional part.</li>
<li><code><a href="#ToUInt32IfExact">ToUInt32IfExact()</a></code> - Converts this number&#39;s value to a 32-bit signed integer if it can fit in a 32-bit signed integer without rounding to a different numerical value.</li>
<li><code><a href="#ToUInt32Unchecked">ToUInt32Unchecked()</a></code> - Converts this number&#39;s value to an integer by discarding its fractional part, and returns the least-significant bits of its two&#39;s-complement form as a 32-bit signed integer.</li>
<li><code><a href="#ToUInt64Checked">ToUInt64Checked()</a></code> - Converts this number&#39;s value to a 64-bit unsigned integer if it can fit in a 64-bit unsigned integer after converting it to an integer by discarding its fractional part.</li>
<li><code><a href="#ToUInt64IfExact">ToUInt64IfExact()</a></code> - Converts this number&#39;s value to a 64-bit unsigned integer if it can fit in a 64-bit unsigned integer without rounding to a different numerical value.</li>
<li><code><a href="#ToUInt64Unchecked">ToUInt64Unchecked()</a></code> - Converts this number&#39;s value to an integer by discarding its fractional part, and returns the least-significant bits of its two&#39;s-complement form as a 64-bit unsigned integer.</li>
<li><code><a href="#UnsignedNumerator">UnsignedNumerator</a></code> - Gets this object&#39;s numerator with the sign removed.</li>
<li><code><a href="#Zero">public static readonly PeterO.Numbers.ERational Zero;</a></code> - A rational number for zero.</li>
</ul>

<p><a id="Void_ctor_PeterO_Numbers_EInteger_PeterO_Numbers_EInteger"></a></p>

<h3>ERational Constructor</h3>

<pre>public ERational(
    PeterO.Numbers.EInteger numerator,
    PeterO.Numbers.EInteger denominator);
</pre>

<p><b>Deprecated.</b> Use the Create method instead.</p>

<p>Initializes a new instance of the <a href="PeterO.Numbers.ERational.html">PeterO.Numbers.ERational</a> class.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>numerator</i>: An arbitrary-precision integer serving as the numerator.</p></li>
<li><p><i>denominator</i>: An arbitrary-precision integer serving as the denominator.</p></li>
</ul>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.ArgumentNullException:
The parameter  <i>numerator</i>
or  <i>denominator</i>
is null.</p></li>
<li><p>System.ArgumentException:
Denominator is zero.</p></li>
</ul>

<p><a id="NaN"></a></p>

<h3>NaN</h3>

<pre>public static readonly PeterO.Numbers.ERational NaN;
</pre>

<p>A not-a-number value.</p>

<p><a id="NegativeInfinity"></a></p>

<h3>NegativeInfinity</h3>

<pre>public static readonly PeterO.Numbers.ERational NegativeInfinity;
</pre>

<p>Negative infinity, less than any other number.</p>

<p><a id="NegativeZero"></a></p>

<h3>NegativeZero</h3>

<pre>public static readonly PeterO.Numbers.ERational NegativeZero;
</pre>

<p>A rational number for negative zero.</p>

<p><a id="One"></a></p>

<h3>One</h3>

<pre>public static readonly PeterO.Numbers.ERational One;
</pre>

<p>The rational number one.</p>

<p><a id="PositiveInfinity"></a></p>

<h3>PositiveInfinity</h3>

<pre>public static readonly PeterO.Numbers.ERational PositiveInfinity;
</pre>

<p>Positive infinity, greater than any other number.</p>

<p><a id="SignalingNaN"></a></p>

<h3>SignalingNaN</h3>

<pre>public static readonly PeterO.Numbers.ERational SignalingNaN;
</pre>

<p>A signaling not-a-number value.</p>

<p><a id="Ten"></a></p>

<h3>Ten</h3>

<pre>public static readonly PeterO.Numbers.ERational Ten;
</pre>

<p>The rational number ten.</p>

<p><a id="Zero"></a></p>

<h3>Zero</h3>

<pre>public static readonly PeterO.Numbers.ERational Zero;
</pre>

<p>A rational number for zero.</p>

<p><a id="Denominator"></a></p>

<h3>Denominator</h3>

<pre>public PeterO.Numbers.EInteger Denominator { get; }
</pre>

<p>Gets this object&#39;s denominator.</p>

<p><b>Returns:</b></p>

<p>This object&#39;s denominator.</p>

<p><a id="IsFinite"></a></p>

<h3>IsFinite</h3>

<pre>public bool IsFinite { get; }
</pre>

<p>Gets a value indicating whether this object is finite (not infinity or NaN).</p>

<p><b>Returns:</b></p>

<p><code>true</code>  if this object is finite (not infinity or NaN); otherwise,  <code>false</code> .</p>

<p><a id="IsNegative"></a></p>

<h3>IsNegative</h3>

<pre>public bool IsNegative { get; }
</pre>

<p>Gets a value indicating whether this object&#39;s value is negative (including negative zero).</p>

<p><b>Returns:</b></p>

<p><code>true</code>  if this object&#39;s value is negative (including negative zero); otherwise,  <code>false</code> .  <code>true</code>  if this object&#39;s value is negative; otherwise,  <code>false</code> .</p>

<p><a id="IsZero"></a></p>

<h3>IsZero</h3>

<pre>public bool IsZero { get; }
</pre>

<p>Gets a value indicating whether this object&#39;s value equals 0.</p>

<p><b>Returns:</b></p>

<p><code>true</code>  if this object&#39;s value equals 0; otherwise,  <code>false</code> .  <code>true</code>  if this object&#39;s value equals 0; otherwise,  <code>false</code> .</p>

<p><a id="Numerator"></a></p>

<h3>Numerator</h3>

<pre>public PeterO.Numbers.EInteger Numerator { get; }
</pre>

<p>Gets this object&#39;s numerator.</p>

<p><b>Returns:</b></p>

<p>This object&#39;s numerator. If this object is a not-a-number value, returns the diagnostic information (which will be negative if this object is negative).</p>

<p><a id="Sign"></a></p>

<h3>Sign</h3>

<pre>public int Sign { get; }
</pre>

<p>Gets the sign of this rational number.</p>

<p><b>Returns:</b></p>

<p>The sign of this rational number.</p>

<p><a id="UnsignedNumerator"></a></p>

<h3>UnsignedNumerator</h3>

<pre>public PeterO.Numbers.EInteger UnsignedNumerator { get; }
</pre>

<p>Gets this object&#39;s numerator with the sign removed.</p>

<p><b>Returns:</b></p>

<p>This object&#39;s numerator. If this object is a not-a-number value, returns the diagnostic information.</p>

<p><a id="Abs"></a></p>

<h3>Abs</h3>

<pre>public PeterO.Numbers.ERational Abs();
</pre>

<p>Returns the absolute value of this rational number, that is, a number with the same value as this one but as a nonnegative number.</p>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision rational number.</p>

<p><a id="Add_int"></a></p>

<h3>Add</h3>

<pre>public PeterO.Numbers.ERational Add(
    int v);
</pre>

<p>Adds this arbitrary-precision rational number and a 32-bit signed integer and returns the result.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>v</i>: A 32-bit signed integer.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The sum of the two numbers, that is, this arbitrary-precision rational number plus a 32-bit signed integer.</p>

<p><a id="Add_long"></a></p>

<h3>Add</h3>

<pre>public PeterO.Numbers.ERational Add(
    long v);
</pre>

<p>Adds this arbitrary-precision rational number and a 64-bit signed integer and returns the result.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>v</i>: A 64-bit signed integer.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The sum of the two numbers, that is, this arbitrary-precision rational number plus a 64-bit signed integer.</p>

<p><a id="Add_PeterO_Numbers_ERational"></a></p>

<h3>Add</h3>

<pre>public PeterO.Numbers.ERational Add(
    PeterO.Numbers.ERational otherValue);
</pre>

<p>Adds this arbitrary-precision rational number and another arbitrary-precision rational number and returns the result.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>otherValue</i>: Another arbitrary-precision rational number.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The sum of the two numbers, that is, this arbitrary-precision rational number plus another arbitrary-precision rational number.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter  <i>otherValue</i>
is null.</li>
</ul>

<p><a id="CompareTo_int"></a></p>

<h3>CompareTo</h3>

<pre>public int CompareTo(
    int intOther);
</pre>

<p>Compares the mathematical value of an arbitrary-precision rational number with that of this instance. This method currently uses the rules given in the CompareToValue method, so that it it is not consistent with the Equals method, but it may change in a future version to use the rules for the CompareToTotal method instead.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>intOther</i>: The parameter  <i>intOther</i>
is a 32-bit signed integer.</li>
</ul>

<p><b>Return Value:</b></p>

<p>Zero if the values are equal; a negative number if this instance is less, or a positive number if this instance is greater.</p>

<p><a id="CompareTo_long"></a></p>

<h3>CompareTo</h3>

<pre>public int CompareTo(
    long intOther);
</pre>

<p>Compares the mathematical values of this object and another object, accepting NaN values. This method currently uses the rules given in the CompareToValue method, so that it it is not consistent with the Equals method, but it may change in a future version to use the rules for the CompareToTotal method instead.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>intOther</i>: The parameter  <i>intOther</i>
is a 64-bit signed integer.</li>
</ul>

<p><b>Return Value:</b></p>

<p>Less than 0 if this object&#39;s value is less than the other value, or greater than 0 if this object&#39;s value is greater than the other value, or 0 if both values are equal.</p>

<p><a id="CompareTo_PeterO_Numbers_ERational"></a></p>

<h3>CompareTo</h3>

<pre>public sealed int CompareTo(
    PeterO.Numbers.ERational other);
</pre>

<p>Compares the mathematical value of an arbitrary-precision rational number with that of this instance. This method currently uses the rules given in the CompareToValue method, so that it it is not consistent with the Equals method, but it may change in a future version to use the rules for the CompareToTotal method instead.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>other</i>: An arbitrary-precision rational number.</li>
</ul>

<p><b>Return Value:</b></p>

<p>Zero if the values are equal; a negative number if this instance is less, or a positive number if this instance is greater. This implementation returns a positive number if  <i>other</i>
 is null, to conform to the.NET definition of CompareTo. This is the case even in the Java version of this library, for consistency&#39;s sake, even though implementations of  <code>Comparable.compareTo()</code>  in Java ought to throw an exception if they receive a null argument rather than treating null as less or greater than any object.</p>

<p>.</p>

<p><a id="CompareToBinary_PeterO_Numbers_EFloat"></a></p>

<h3>CompareToBinary</h3>

<pre>public int CompareToBinary(
    PeterO.Numbers.EFloat other);
</pre>

<p>Compares an arbitrary-precision binary floating-point number with this instance. In this method, NaN values are greater than any other ERational or EFloat value, and two NaN values (even if their payloads differ) are treated as equal by this method.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>other</i>: An arbitrary-precision binary floating-point number.</li>
</ul>

<p><b>Return Value:</b></p>

<p>Zero if the values are equal; a negative number if this instance is less, or a positive number if this instance is greater. This implementation returns a positive number if  <i>other</i>
 is null, to conform to the.NET definition of CompareTo. This is the case even in the Java version of this library, for consistency&#39;s sake, even though implementations of  <code>Comparable.compareTo()</code>  in Java ought to throw an exception if they receive a null argument rather than treating null as less or greater than any object.</p>

<p>.</p>

<p><a id="CompareToDecimal_PeterO_Numbers_EDecimal"></a></p>

<h3>CompareToDecimal</h3>

<pre>public int CompareToDecimal(
    PeterO.Numbers.EDecimal other);
</pre>

<p>Compares an arbitrary-precision decimal number with this instance.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>other</i>: An arbitrary-precision decimal number.</li>
</ul>

<p><b>Return Value:</b></p>

<p>Zero if the values are equal; a negative number if this instance is less, or a positive number if this instance is greater. This implementation returns a positive number if  <i>other</i>
 is null, to conform to the.NET definition of CompareTo. This is the case even in the Java version of this library, for consistency&#39;s sake, even though implementations of  <code>Comparable.compareTo()</code>  in Java ought to throw an exception if they receive a null argument rather than treating null as less or greater than any object.</p>

<p>.</p>

<p><a id="CompareToTotal_PeterO_Numbers_ERational"></a></p>

<h3>CompareToTotal</h3>

<pre>public int CompareToTotal(
    PeterO.Numbers.ERational other);
</pre>

<p>Compares the values of this object and another object, imposing a total ordering on all possible values. In this method:</p>

<ul>
<li><p>For objects with the same value, the one with the higher denominator has a greater &quot;absolute value&quot;.</p></li>
<li><p>Negative zero is less than positive zero.</p></li>
<li><p>Quiet NaN has a higher &quot;absolute value&quot; than signaling NaN. If both objects are quiet NaN or both are signaling NaN, the one with the higher diagnostic information has a greater &quot;absolute value&quot;.</p></li>
<li><p>NaN has a higher &quot;absolute value&quot; than infinity.</p></li>
<li><p>Infinity has a higher &quot;absolute value&quot; than any finite number.</p></li>
<li><p>Negative numbers are less than positive numbers.</p></li>
</ul>

<p><b>Parameters:</b></p>

<ul>
<li><i>other</i>: An arbitrary-precision rational number to compare with this one.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The number 0 if both objects have the same value, or -1 if this object is less than the other value, or 1 if this object is greater. This implementation returns a positive number if  <i>other</i>
 is null, to conform to the.NET definition of CompareTo. This is the case even in the Java version of this library, for consistency&#39;s sake, even though implementations of  <code>Comparable.compareTo()</code>  in Java ought to throw an exception if they receive a null argument rather than treating null as less or greater than any object.</p>

<p>.</p>

<p><a id="CompareToTotalMagnitude_PeterO_Numbers_ERational"></a></p>

<h3>CompareToTotalMagnitude</h3>

<pre>public int CompareToTotalMagnitude(
    PeterO.Numbers.ERational other);
</pre>

<p>Compares the absolute values of this object and another object, imposing a total ordering on all possible values (ignoring their signs). In this method:</p>

<ul>
<li><p>For objects with the same value, the one with the higher denominator has a greater &quot;absolute value&quot;.</p></li>
<li><p>Negative zero and positive zero are considered equal.</p></li>
<li><p>Quiet NaN has a higher &quot;absolute value&quot; than signaling NaN. If both objects are quiet NaN or both are signaling NaN, the one with the higher diagnostic information has a greater &quot;absolute value&quot;.</p></li>
<li><p>NaN has a higher &quot;absolute value&quot; than infinity.</p></li>
<li><p>Infinity has a higher &quot;absolute value&quot; than any finite number.</p></li>
</ul>

<p><b>Parameters:</b></p>

<ul>
<li><i>other</i>: An arbitrary-precision rational number to compare with this one.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The number 0 if both objects have the same value, or -1 if this object is less than the other value, or 1 if this object is greater. This implementation returns a positive number if  <i>other</i>
 is null, to conform to the.NET definition of CompareTo. This is the case even in the Java version of this library, for consistency&#39;s sake, even though implementations of  <code>Comparable.compareTo()</code>  in Java ought to throw an exception if they receive a null argument rather than treating null as less or greater than any object.</p>

<p>.</p>

<p><a id="CompareToValue_int"></a></p>

<h3>CompareToValue</h3>

<pre>public int CompareToValue(
    int intOther);
</pre>

<p>Compares the mathematical value of an arbitrary-precision rational number with that of this instance. In this method, NaN values are greater than any other ERational value, and two NaN values (even if their payloads differ) are treated as equal by this method. This method is not consistent with the Equals method.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>intOther</i>: The parameter  <i>intOther</i>
is a 32-bit signed integer.</li>
</ul>

<p><b>Return Value:</b></p>

<p>Zero if the values are equal; a negative number if this instance is less, or a positive number if this instance is greater.</p>

<p><a id="CompareToValue_long"></a></p>

<h3>CompareToValue</h3>

<pre>public int CompareToValue(
    long intOther);
</pre>

<p>Compares the mathematical values of this object and another object, accepting NaN values. This method is not consistent with the Equals method because two different numbers with the same mathematical value, but different exponents, will compare as equal.</p>

<p>In this method, negative zero and positive zero are considered equal.</p>

<p>If this object is a quiet NaN or signaling NaN, this method will not trigger an error. Instead, NaN will compare greater than any other number, including infinity.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>intOther</i>: The parameter  <i>intOther</i>
is a 64-bit signed integer.</li>
</ul>

<p><b>Return Value:</b></p>

<p>Less than 0 if this object&#39;s value is less than the other value, or greater than 0 if this object&#39;s value is greater than the other value, or 0 if both values are equal.</p>

<p><a id="CompareToValue_PeterO_Numbers_ERational"></a></p>

<h3>CompareToValue</h3>

<pre>public int CompareToValue(
    PeterO.Numbers.ERational other);
</pre>

<p>Compares the mathematical value of an arbitrary-precision rational number with that of this instance. In this method, NaN values are greater than any other ERational value, and two NaN values (even if their payloads differ) are treated as equal by this method. This method is not consistent with the Equals method.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>other</i>: An arbitrary-precision rational number.</li>
</ul>

<p><b>Return Value:</b></p>

<p>Zero if the values are equal; a negative number if this instance is less, or a positive number if this instance is greater. This implementation returns a positive number if  <i>other</i>
 is null, to conform to the.NET definition of CompareTo. This is the case even in the Java version of this library, for consistency&#39;s sake, even though implementations of  <code>Comparable.compareTo()</code>  in Java ought to throw an exception if they receive a null argument rather than treating null as less or greater than any object.</p>

<p>.</p>

<p><a id="Copy"></a></p>

<h3>Copy</h3>

<pre>public PeterO.Numbers.ERational Copy();
</pre>

<p>Creates a copy of this arbitrary-precision rational number.</p>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision rational number.</p>

<p><a id="CopySign_PeterO_Numbers_ERational"></a></p>

<h3>CopySign</h3>

<pre>public PeterO.Numbers.ERational CopySign(
    PeterO.Numbers.ERational other);
</pre>

<p>Returns a number with the same value as this one, but copying the sign (positive or negative) of another number.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>other</i>: A number whose sign will be copied.</li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision rational number.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter  <i>other</i>
is null.</li>
</ul>

<p><a id="Create_int_int"></a></p>

<h3>Create</h3>

<pre>public static PeterO.Numbers.ERational Create(
    int numeratorSmall,
    int denominatorSmall);
</pre>

<p>Creates a rational number with the given numerator and denominator.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>numeratorSmall</i>: The numerator.</p></li>
<li><p><i>denominatorSmall</i>: The denominator.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision rational number.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentException:
The denominator is zero.</li>
</ul>

<p><a id="Create_long_long"></a></p>

<h3>Create</h3>

<pre>public static PeterO.Numbers.ERational Create(
    long numeratorLong,
    long denominatorLong);
</pre>

<p>Creates a rational number with the given numerator and denominator.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>numeratorLong</i>: The numerator.</p></li>
<li><p><i>denominatorLong</i>: The denominator.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision rational number.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentException:
The denominator is zero.</li>
</ul>

<p><a id="Create_PeterO_Numbers_EInteger_PeterO_Numbers_EInteger"></a></p>

<h3>Create</h3>

<pre>public static PeterO.Numbers.ERational Create(
    PeterO.Numbers.EInteger numerator,
    PeterO.Numbers.EInteger denominator);
</pre>

<p>Creates a rational number with the given numerator and denominator.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>numerator</i>: The numerator.</p></li>
<li><p><i>denominator</i>: The denominator.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision rational number.</p>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.ArgumentException:
The denominator is zero.</p></li>
<li><p>System.ArgumentNullException:
The parameter  <i>numerator</i>
or  <i>denominator</i>
is null.</p></li>
</ul>

<p><a id="CreateNaN_PeterO_Numbers_EInteger"></a></p>

<h3>CreateNaN</h3>

<pre>public static PeterO.Numbers.ERational CreateNaN(
    PeterO.Numbers.EInteger diag);
</pre>

<p>Creates a not-a-number arbitrary-precision rational number.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>diag</i>: An integer, 0 or greater, to use as diagnostic information associated with this object. If none is needed, should be zero. To get the diagnostic information from another arbitrary-precision rational number, use that object&#39;s  <code>UnsignedNumerator</code>  property.</li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision rational number.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentException:
The parameter  <i>diag</i>
is less than 0.</li>
</ul>

<p><a id="CreateNaN_PeterO_Numbers_EInteger_bool_bool"></a></p>

<h3>CreateNaN</h3>

<pre>public static PeterO.Numbers.ERational CreateNaN(
    PeterO.Numbers.EInteger diag,
    bool signaling,
    bool negative);
</pre>

<p>Creates a not-a-number arbitrary-precision rational number.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>diag</i>: An integer, 0 or greater, to use as diagnostic information associated with this object. If none is needed, should be zero. To get the diagnostic information from another arbitrary-precision rational number, use that object&#39;s  <code>UnsignedNumerator</code>  property.</p></li>
<li><p><i>signaling</i>: Whether the return value will be signaling (true) or quiet (false).</p></li>
<li><p><i>negative</i>: Whether the return value is negative.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision rational number.</p>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.ArgumentException:
The parameter  <i>diag</i>
is less than 0.</p></li>
<li><p>System.ArgumentNullException:
The parameter  <i>diag</i>
is null.</p></li>
</ul>

<p><a id="Decrement"></a></p>

<h3>Decrement</h3>

<pre>public PeterO.Numbers.ERational Decrement();
</pre>

<p>Subtracts one from an arbitrary-precision rational number.</p>

<p><b>Return Value:</b></p>

<p>The given arbitrary-precision rational number minus one.</p>

<p><a id="Divide_int"></a></p>

<h3>Divide</h3>

<pre>public PeterO.Numbers.ERational Divide(
    int v);
</pre>

<p>Divides this arbitrary-precision rational number by a 32-bit signed integer and returns the result.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>v</i>: The parameter  <i>v</i>
is a 32-bit signed integer.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The result of dividing this arbitrary-precision rational number by a 32-bit signed integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArithmeticException:
The parameter  <i>v</i>
is zero.</li>
</ul>

<p><a id="Divide_long"></a></p>

<h3>Divide</h3>

<pre>public PeterO.Numbers.ERational Divide(
    long v);
</pre>

<p>Divides this arbitrary-precision rational number by a 64-bit signed integer and returns the result.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>v</i>: The parameter  <i>v</i>
is a 64-bit signed integer.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The result of dividing this arbitrary-precision rational number by a 64-bit signed integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArithmeticException:
The parameter  <i>v</i>
is zero.</li>
</ul>

<p><a id="Divide_PeterO_Numbers_ERational"></a></p>

<h3>Divide</h3>

<pre>public PeterO.Numbers.ERational Divide(
    PeterO.Numbers.ERational otherValue);
</pre>

<p>Divides this arbitrary-precision rational number by another arbitrary-precision rational number and returns the result.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>otherValue</i>: An arbitrary-precision rational number.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The result of dividing this arbitrary-precision rational number by another arbitrary-precision rational number.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter  <i>otherValue</i>
is null.</li>
</ul>

<p><a id="Equals_object"></a></p>

<h3>Equals</h3>

<pre>public override bool Equals(
    object obj);
</pre>

<p>Determines whether this object&#39;s numerator, denominator, and properties are equal to those of another object and that other object is an arbitrary-precision rational number. Not-a-number values are considered equal if the rest of their properties are equal. This is not the same as value equality. Notably, two ERationals with the same value, but of which one is in lowest terms and the other is not, are compared as unequal by this method (example: 1/2 vs. 5/10).</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>obj</i>: The parameter  <i>obj</i>
is an arbitrary object.</li>
</ul>

<p><b>Return Value:</b></p>

<p><code>true</code>  if the objects are equal; otherwise,  <code>false</code> . In this method, two objects are not equal if they don&#39;t have the same type or if one is null and the other isn&#39;t.</p>

<p><a id="Equals_PeterO_Numbers_ERational"></a></p>

<h3>Equals</h3>

<pre>public sealed bool Equals(
    PeterO.Numbers.ERational other);
</pre>

<p>Determines whether this object&#39;s numerator, denominator, and properties are equal to those of another object. Not-a-number values are considered equal if the rest of their properties are equal.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>other</i>: An arbitrary-precision rational number to compare to.</li>
</ul>

<p><b>Return Value:</b></p>

<p>Either  <code>true</code>  or  <code>false</code> .</p>

<p><a id="FromBoolean_bool"></a></p>

<h3>FromBoolean</h3>

<pre>public static PeterO.Numbers.ERational FromBoolean(
    bool boolValue);
</pre>

<p>Converts a boolean value (true or false) to an arbitrary-precision rational number.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>boolValue</i>: Either true or false.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The number 1 if  <i>boolValue</i>
 is true; otherwise, 0.</p>

<p><a id="FromByte_byte"></a></p>

<h3>FromByte</h3>

<pre>public static PeterO.Numbers.ERational FromByte(
    byte inputByte);
</pre>

<p>Converts a byte (from 0 to 255) to an arbitrary-precision rational number.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>inputByte</i>: The number to convert as a byte (from 0 to 255).</li>
</ul>

<p><b>Return Value:</b></p>

<p>This number&#39;s value as an arbitrary-precision rational number.</p>

<p><a id="FromDecimal_decimal"></a></p>

<h3>FromDecimal</h3>

<pre>public static PeterO.Numbers.ERational FromDecimal(
    decimal eint);
</pre>

<p>Converts a  <code>decimal</code>  under the Common Language Infrastructure (usually a.NET Framework decimal) to a rational number.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>eint</i>: The number to convert as a  <code>decimal</code>  under the Common Language Infrastructure (usually a.NET Framework decimal).</li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision rational number.</p>

<p><a id="FromDouble_double"></a></p>

<h3>FromDouble</h3>

<pre>public static PeterO.Numbers.ERational FromDouble(
    double flt);
</pre>

<p>Converts a 64-bit floating-point number to a rational number. This method computes the exact value of the floating point number, not an approximation, as is often the case by converting the number to a string. The input value can be a not-a-number (NaN) value (such as  <code>Double.NaN</code>  ); however, NaN values have multiple forms that are equivalent for many applications&#39; purposes, and  <code>Double.NaN</code>  is only one of these equivalent forms. In fact,  <code>ERational.FromDouble(Double.NaN)</code>  could produce an object that is represented differently between DotNet and Java, because  <code>Double.NaN</code>  may have a different form in DotNet and Java (for example, the NaN value&#39;s sign may be negative in DotNet, but positive in Java). Use <code>IsNaN()</code> to determine whether an object from this class stores a NaN value of any form.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>flt</i>: The parameter  <i>flt</i>
is a 64-bit floating-point number.</li>
</ul>

<p><b>Return Value:</b></p>

<p>A rational number with the same value as  <i>flt</i>
.</p>

<p><a id="FromDoubleBits_long"></a></p>

<h3>FromDoubleBits</h3>

<pre>public static PeterO.Numbers.ERational FromDoubleBits(
    long value);
</pre>

<p>Creates a binary rational number from a 64-bit floating-point number encoded in the IEEE 754 binary64 format. This method computes the exact value of the floating point number, not an approximation, as is often the case by converting the number to a string.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>value</i>: A 64-bit integer encoded in the IEEE 754 binary64 format.</li>
</ul>

<p><b>Return Value:</b></p>

<p>A rational number with the same floating-point value as  <i>value</i>
.</p>

<p><a id="FromEDecimal_PeterO_Numbers_EDecimal"></a></p>

<h3>FromEDecimal</h3>

<pre>public static PeterO.Numbers.ERational FromEDecimal(
    PeterO.Numbers.EDecimal ef);
</pre>

<p>Converts an arbitrary-precision decimal number to a rational number.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>ef</i>: The number to convert as an arbitrary-precision decimal number.</li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision rational number.</p>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.ArgumentNullException:
The parameter  <i>ef</i>
is null.</p></li>
<li><p>System.ArgumentException:
doesn&#39;t satisfy den.Sign &gt;= 0.</p></li>
</ul>

<p><a id="FromEFloat_PeterO_Numbers_EFloat"></a></p>

<h3>FromEFloat</h3>

<pre>public static PeterO.Numbers.ERational FromEFloat(
    PeterO.Numbers.EFloat ef);
</pre>

<p>Converts an arbitrary-precision binary floating-point number to a rational number.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>ef</i>: The number to convert as an arbitrary-precision binary floating-point number.</li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision rational number.</p>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.ArgumentNullException:
The parameter  <i>ef</i>
is null.</p></li>
<li><p>System.ArgumentException:
doesn&#39;t satisfy den.Sign &gt;= 0.</p></li>
</ul>

<p><a id="FromEInteger_PeterO_Numbers_EInteger"></a></p>

<h3>FromEInteger</h3>

<pre>public static PeterO.Numbers.ERational FromEInteger(
    PeterO.Numbers.EInteger bigint);
</pre>

<p>Converts an arbitrary-precision integer to a rational number.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>bigint</i>: The number to convert as an arbitrary-precision integer.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The exact value of the integer as a rational number.</p>

<p><a id="FromExtendedDecimal_PeterO_Numbers_EDecimal"></a></p>

<h3>FromExtendedDecimal</h3>

<pre>public static PeterO.Numbers.ERational FromExtendedDecimal(
    PeterO.Numbers.EDecimal ef);
</pre>

<p><b>Deprecated.</b> Renamed to FromEDecimal.</p>

<p>Converts an arbitrary-precision decimal number to a rational number.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>ef</i>: The number to convert as an arbitrary-precision decimal number.</li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision rational number.</p>

<p><a id="FromExtendedFloat_PeterO_Numbers_EFloat"></a></p>

<h3>FromExtendedFloat</h3>

<pre>public static PeterO.Numbers.ERational FromExtendedFloat(
    PeterO.Numbers.EFloat ef);
</pre>

<p><b>Deprecated.</b> Renamed to FromEFloat.</p>

<p>Converts an arbitrary-precision binary floating-point number to a rational number.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>ef</i>: The number to convert as an arbitrary-precision binary floating-point number.</li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision rational number.</p>

<p><a id="FromHalfBits_short"></a></p>

<h3>FromHalfBits</h3>

<pre>public static PeterO.Numbers.ERational FromHalfBits(
    short value);
</pre>

<p>Creates a binary rational number from a binary floating-point number encoded in the IEEE 754 binary16 format (also known as a &quot;half-precision&quot; floating-point number). This method computes the exact value of the floating point number, not an approximation, as is often the case by converting the number to a string.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>value</i>: A 16-bit integer encoded in the IEEE 754 binary16 format.</li>
</ul>

<p><b>Return Value:</b></p>

<p>A rational number with the same floating-point value as  <i>value</i>
.</p>

<p><a id="FromInt16_short"></a></p>

<h3>FromInt16</h3>

<pre>public static PeterO.Numbers.ERational FromInt16(
    short inputInt16);
</pre>

<p>Converts a 16-bit signed integer to an arbitrary-precision rational number.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>inputInt16</i>: The number to convert as a 16-bit signed integer.</li>
</ul>

<p><b>Return Value:</b></p>

<p>This number&#39;s value as an arbitrary-precision rational number.</p>

<p><a id="FromInt32_int"></a></p>

<h3>FromInt32</h3>

<pre>public static PeterO.Numbers.ERational FromInt32(
    int inputInt32);
</pre>

<p>Converts a 32-bit signed integer to an arbitrary-precision rational number.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>inputInt32</i>: The number to convert as a 32-bit signed integer.</li>
</ul>

<p><b>Return Value:</b></p>

<p>This number&#39;s value as an arbitrary-precision rational number.</p>

<p><a id="FromInt64_long"></a></p>

<h3>FromInt64</h3>

<pre>public static PeterO.Numbers.ERational FromInt64(
    long inputInt64);
</pre>

<p>Converts a 64-bit signed integer to an arbitrary-precision rational number.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>inputInt64</i>: The number to convert as a 64-bit signed integer.</li>
</ul>

<p><b>Return Value:</b></p>

<p>This number&#39;s value as an arbitrary-precision rational number.</p>

<p><a id="FromInt64AsUnsigned_long"></a></p>

<h3>FromInt64AsUnsigned</h3>

<pre>public static PeterO.Numbers.ERational FromInt64AsUnsigned(
    long longerValue);
</pre>

<p>Converts an unsigned integer expressed as a 64-bit signed integer to an arbitrary-precision rational number.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>longerValue</i>: A 64-bit signed integer. If this value is 0 or greater, the return value will represent it. If this value is less than 0, the return value will store 2^64 plus this value instead.</li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision rational number. If  <i>longerValue</i>
 is 0 or greater, the return value will represent it. If  <i>longerValue</i>
 is less than 0, the return value will store 2^64 plus this value instead.</p>

<p><a id="FromSByte_sbyte"></a></p>

<h3>FromSByte</h3>

<pre>public static PeterO.Numbers.ERational FromSByte(
    sbyte inputSByte);
</pre>

<p><b>This API is not CLS-compliant.</b></p>

<p>Converts an 8-bit signed integer to an arbitrary-precision rational number.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>inputSByte</i>: The number to convert as an 8-bit signed integer.</li>
</ul>

<p><b>Return Value:</b></p>

<p>This number&#39;s value as an arbitrary-precision rational number.</p>

<p><a id="FromSingle_float"></a></p>

<h3>FromSingle</h3>

<pre>public static PeterO.Numbers.ERational FromSingle(
    float flt);
</pre>

<p>Converts a 32-bit binary floating-point number to a rational number. This method computes the exact value of the floating point number, not an approximation, as is often the case by converting the number to a string. The input value can be a not-a-number (NaN) value (such as  <code>Single.NaN</code>  in DotNet or Float.NaN in Java); however, NaN values have multiple forms that are equivalent for many applications&#39; purposes, and  <code>Single.NaN</code>  /  <code>Float.NaN</code>  is only one of these equivalent forms. In fact,  <code>ERational.FromSingle(Single.NaN)</code>  or  <code>ERational.FromSingle(Float.NaN)</code>  could produce an object that is represented differently between DotNet and Java, because  <code>Single.NaN</code>  /  <code>Float.NaN</code>  may have a different form in DotNet and Java (for example, the NaN value&#39;s sign may be negative in DotNet, but positive in Java). Use <code>IsNaN()</code> to determine whether an object from this class stores a NaN value of any form.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>flt</i>: The parameter  <i>flt</i>
is a 32-bit binary floating-point number.</li>
</ul>

<p><b>Return Value:</b></p>

<p>A rational number with the same value as  <i>flt</i>
.</p>

<p><a id="FromSingleBits_int"></a></p>

<h3>FromSingleBits</h3>

<pre>public static PeterO.Numbers.ERational FromSingleBits(
    int value);
</pre>

<p>Creates a binary rational number from a 32-bit floating-point number encoded in the IEEE 754 binary32 format. This method computes the exact value of the floating point number, not an approximation, as is often the case by converting the number to a string.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>value</i>: A 32-bit integer encoded in the IEEE 754 binary32 format.</li>
</ul>

<p><b>Return Value:</b></p>

<p>A rational number with the same floating-point value as  <i>value</i>
.</p>

<p><a id="FromString_byte"></a></p>

<h3>FromString</h3>

<pre>public static PeterO.Numbers.ERational FromString(
    byte[] bytes);
</pre>

<p>Creates a rational number from a sequence of bytes that represents a number. See  <code>FromString(String, int, int)</code>  for more information.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>bytes</i>: A sequence of bytes that represents a number.</li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision rational number with the same value as the given sequence of bytes.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.FormatException:
The parameter  <i>bytes</i>
is not a correctly formatted sequence of bytes.</li>
</ul>

<p><a id="FromString_byte_int_int"></a></p>

<h3>FromString</h3>

<pre>public static PeterO.Numbers.ERational FromString(
    byte[] bytes,
    int offset,
    int length);
</pre>

<p>Creates a rational number from a sequence of bytes that represents a number.</p>

<p>The format of the sequence of bytes generally consists of:</p>

<ul>
<li><p>An optional plus sign (&quot;+&quot; , U+002B) or minus sign (&quot;-&quot;, U+002D) (if &#39;-&#39; , the value is negative.)</p></li>
<li><p>The numerator in the form of one or more digits (these digits may begin with any number of zeros).</p></li>
<li><p>Optionally, &quot;/&quot; followed by the denominator in the form of one or more digits (these digits may begin with any number of zeros). If a denominator is not given, it&#39;s equal to 1.</p></li>
</ul>

<p>The sequence of bytes can also be &quot;-INF&quot;, &quot;-Infinity&quot;, &quot;Infinity&quot;, &quot;INF&quot;, quiet NaN (&quot;NaN&quot; /&quot;-NaN&quot;) followed by any number of digits, or signaling NaN (&quot;sNaN&quot; /&quot;-sNaN&quot;) followed by any number of digits, all in any combination of upper and lower case.</p>

<p>All characters mentioned above are the corresponding characters in the Basic Latin range. In particular, the digits must be the basic digits 0 to 9 (U+0030 to U+0039). The sequence of bytes is not allowed to contain white space characters, including spaces.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>bytes</i>: A sequence of bytes, a portion of which represents a number.</p></li>
<li><p><i>offset</i>: An index starting at 0 showing where the desired portion of  <i>bytes</i>
begins.</p></li>
<li><p><i>length</i>: The length, in code units, of the desired portion of  <i>bytes</i>
(but not more than  <i>bytes</i>
&#39;s length).</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision rational number.</p>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.FormatException:
The parameter  <i>bytes</i>
is not a correctly formatted sequence of bytes.</p></li>
<li><p>System.ArgumentNullException:
The parameter  <i>bytes</i>
is null.</p></li>
<li><p>System.ArgumentException:
Either  <i>offset</i>
or  <i>length</i>
is less than 0 or greater than  <i>bytes</i>
&#39;s length, or  <i>bytes</i>
&#39;s length minus  <i>offset</i>
is less than  <i>length</i>
.</p></li>
</ul>

<p><a id="FromString_char"></a></p>

<h3>FromString</h3>

<pre>public static PeterO.Numbers.ERational FromString(
    char[] chars);
</pre>

<p>Creates a rational number from a sequence of  <code>char</code>  s that represents a number. See  <code>FromString(String, int, int)</code>  for more information.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>chars</i>: A sequence of  <code>char</code>  s that represents a number.</li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision rational number with the same value as the given sequence of  <code>char</code>  s.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.FormatException:
The parameter  <i>chars</i>
is not a correctly formatted sequence of  <code>char</code>  s.</li>
</ul>

<p><a id="FromString_char_int_int"></a></p>

<h3>FromString</h3>

<pre>public static PeterO.Numbers.ERational FromString(
    char[] chars,
    int offset,
    int length);
</pre>

<p>Creates a rational number from a sequence of  <code>char</code>  s that represents a number.</p>

<p>The format of the sequence of  <code>char</code>  s generally consists of:</p>

<ul>
<li><p>An optional plus sign (&quot;+&quot; , U+002B) or minus sign (&quot;-&quot;, U+002D) (if &#39;-&#39; , the value is negative.)</p></li>
<li><p>The numerator in the form of one or more digits (these digits may begin with any number of zeros).</p></li>
<li><p>Optionally, &quot;/&quot; followed by the denominator in the form of one or more digits (these digits may begin with any number of zeros). If a denominator is not given, it&#39;s equal to 1.</p></li>
</ul>

<p>The sequence of  <code>char</code>  s can also be &quot;-INF&quot;, &quot;-Infinity&quot;, &quot;Infinity&quot;, &quot;INF&quot;, quiet NaN (&quot;NaN&quot; /&quot;-NaN&quot;) followed by any number of digits, or signaling NaN (&quot;sNaN&quot; /&quot;-sNaN&quot;) followed by any number of digits, all in any combination of upper and lower case.</p>

<p>All characters mentioned above are the corresponding characters in the Basic Latin range. In particular, the digits must be the basic digits 0 to 9 (U+0030 to U+0039). The sequence of  <code>char</code>  s is not allowed to contain white space characters, including spaces.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>chars</i>: A sequence of  <code>char</code>  s, a portion of which represents a number.</p></li>
<li><p><i>offset</i>: An index starting at 0 showing where the desired portion of  <i>chars</i>
begins.</p></li>
<li><p><i>length</i>: The length, in code units, of the desired portion of  <i>chars</i>
(but not more than  <i>chars</i>
&#39;s length).</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision rational number.</p>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.FormatException:
The parameter  <i>chars</i>
is not a correctly formatted sequence of  <code>char</code>  s.</p></li>
<li><p>System.ArgumentNullException:
The parameter  <i>chars</i>
is null.</p></li>
<li><p>System.ArgumentException:
Either  <i>offset</i>
or  <i>length</i>
is less than 0 or greater than  <i>chars</i>
&#39;s length, or  <i>chars</i>
&#39;s length minus  <i>offset</i>
is less than  <i>length</i>
.</p></li>
</ul>

<p><a id="FromString_string"></a></p>

<h3>FromString</h3>

<pre>public static PeterO.Numbers.ERational FromString(
    string str);
</pre>

<p>Creates a rational number from a text string that represents a number. See  <code>FromString(String, int, int)</code>  for more information.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>str</i>: A string that represents a number.</li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision rational number with the same value as the given string.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.FormatException:
The parameter  <i>str</i>
is not a correctly formatted number string.</li>
</ul>

<p><a id="FromString_string_int_int"></a></p>

<h3>FromString</h3>

<pre>public static PeterO.Numbers.ERational FromString(
    string str,
    int offset,
    int length);
</pre>

<p>Creates a rational number from a text string that represents a number.</p>

<p>The format of the string generally consists of:</p>

<ul>
<li><p>An optional plus sign (&quot;+&quot; , U+002B) or minus sign (&quot;-&quot;, U+002D) (if &#39;-&#39; , the value is negative.)</p></li>
<li><p>The numerator in the form of one or more digits (these digits may begin with any number of zeros).</p></li>
<li><p>Optionally, &quot;/&quot; followed by the denominator in the form of one or more digits (these digits may begin with any number of zeros). If a denominator is not given, it&#39;s equal to 1.</p></li>
</ul>

<p>The string can also be &quot;-INF&quot;, &quot;-Infinity&quot;, &quot;Infinity&quot;, &quot;INF&quot;, quiet NaN (&quot;NaN&quot; /&quot;-NaN&quot;) followed by any number of digits, or signaling NaN (&quot;sNaN&quot; /&quot;-sNaN&quot;) followed by any number of digits, all in any combination of upper and lower case.</p>

<p>All characters mentioned above are the corresponding characters in the Basic Latin range. In particular, the digits must be the basic digits 0 to 9 (U+0030 to U+0039). The string is not allowed to contain white space characters, including spaces.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>str</i>: A text string, a portion of which represents a number.</p></li>
<li><p><i>offset</i>: An index starting at 0 showing where the desired portion of  <i>str</i>
begins.</p></li>
<li><p><i>length</i>: The length, in code units, of the desired portion of  <i>str</i>
(but not more than  <i>str</i>
&#39;s length).</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision rational number.</p>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.FormatException:
The parameter  <i>str</i>
is not a correctly formatted number string.</p></li>
<li><p>System.ArgumentNullException:
The parameter  <i>str</i>
is null.</p></li>
<li><p>System.ArgumentException:
Either  <i>offset</i>
or  <i>length</i>
is less than 0 or greater than  <i>str</i>
&#39;s length, or  <i>str</i>
&#39;s length minus  <i>offset</i>
is less than  <i>length</i>
.</p></li>
</ul>

<p><a id="FromUInt16_ushort"></a></p>

<h3>FromUInt16</h3>

<pre>public static PeterO.Numbers.ERational FromUInt16(
    ushort inputUInt16);
</pre>

<p><b>This API is not CLS-compliant.</b></p>

<p>Converts a 16-bit unsigned integer to an arbitrary-precision rational number.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>inputUInt16</i>: The number to convert as a 16-bit unsigned integer.</li>
</ul>

<p><b>Return Value:</b></p>

<p>This number&#39;s value as an arbitrary-precision rational number.</p>

<p><a id="FromUInt32_uint"></a></p>

<h3>FromUInt32</h3>

<pre>public static PeterO.Numbers.ERational FromUInt32(
    uint inputUInt32);
</pre>

<p><b>This API is not CLS-compliant.</b></p>

<p>Converts a 32-bit signed integer to an arbitrary-precision rational number.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>inputUInt32</i>: The number to convert as a 32-bit signed integer.</li>
</ul>

<p><b>Return Value:</b></p>

<p>This number&#39;s value as an arbitrary-precision rational number.</p>

<p><a id="FromUInt64_ulong"></a></p>

<h3>FromUInt64</h3>

<pre>public static PeterO.Numbers.ERational FromUInt64(
    ulong inputUInt64);
</pre>

<p><b>This API is not CLS-compliant.</b></p>

<p>Converts a 64-bit unsigned integer to an arbitrary-precision rational number.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>inputUInt64</i>: The number to convert as a 64-bit unsigned integer.</li>
</ul>

<p><b>Return Value:</b></p>

<p>This number&#39;s value as an arbitrary-precision rational number.</p>

<p><a id="GetHashCode"></a></p>

<h3>GetHashCode</h3>

<pre>public override int GetHashCode();
</pre>

<p>Returns the hash code for this instance. No application or process IDs are used in the hash code calculation.</p>

<p><b>Return Value:</b></p>

<p>A 32-bit signed integer.</p>

<p><a id="Increment"></a></p>

<h3>Increment</h3>

<pre>public PeterO.Numbers.ERational Increment();
</pre>

<p>Adds one to an arbitrary-precision rational number.</p>

<p><b>Return Value:</b></p>

<p>The given arbitrary-precision rational number plus one.</p>

<p><a id="IsInfinity"></a></p>

<h3>IsInfinity</h3>

<pre>public bool IsInfinity();
</pre>

<p>Gets a value indicating whether this object&#39;s value is infinity.</p>

<p><b>Return Value:</b></p>

<p><code>true</code>  if this object&#39;s value is infinity; otherwise,  <code>false</code> .</p>

<p><a id="IsInteger"></a></p>

<h3>IsInteger</h3>

<pre>public bool IsInteger();
</pre>

<p>Returns whether this object&#39;s value is an integer.</p>

<p><b>Return Value:</b></p>

<p><code>true</code>  if this object&#39;s value is an integer; otherwise,  <code>false</code> .</p>

<p><a id="IsNaN"></a></p>

<h3>IsNaN</h3>

<pre>public bool IsNaN();
</pre>

<p>Returns whether this object is a not-a-number value.</p>

<p><b>Return Value:</b></p>

<p><code>true</code>  if this object is a not-a-number value; otherwise,  <code>false</code> .</p>

<p><a id="IsNegativeInfinity"></a></p>

<h3>IsNegativeInfinity</h3>

<pre>public bool IsNegativeInfinity();
</pre>

<p>Returns whether this object is negative infinity.</p>

<p><b>Return Value:</b></p>

<p><code>true</code>  if this object is negative infinity; otherwise,  <code>false</code> .</p>

<p><a id="IsPositiveInfinity"></a></p>

<h3>IsPositiveInfinity</h3>

<pre>public bool IsPositiveInfinity();
</pre>

<p>Returns whether this object is positive infinity.</p>

<p><b>Return Value:</b></p>

<p><code>true</code>  if this object is positive infinity; otherwise,  <code>false</code> .</p>

<p><a id="IsQuietNaN"></a></p>

<h3>IsQuietNaN</h3>

<pre>public bool IsQuietNaN();
</pre>

<p>Returns whether this object is a quiet not-a-number value.</p>

<p><b>Return Value:</b></p>

<p><code>true</code>  if this object is a quiet not-a-number value; otherwise,  <code>false</code> .</p>

<p><a id="IsSignalingNaN"></a></p>

<h3>IsSignalingNaN</h3>

<pre>public bool IsSignalingNaN();
</pre>

<p>Returns whether this object is a signaling not-a-number value (which causes an error if the value is passed to any arithmetic operation in this class).</p>

<p><b>Return Value:</b></p>

<p><code>true</code>  if this object is a signaling not-a-number value (which causes an error if the value is passed to any arithmetic operation in this class); otherwise,  <code>false</code> .</p>

<p><a id="Max_PeterO_Numbers_ERational_PeterO_Numbers_ERational"></a></p>

<h3>Max</h3>

<pre>public static PeterO.Numbers.ERational Max(
    PeterO.Numbers.ERational first,
    PeterO.Numbers.ERational second);
</pre>

<p>Gets the greater value between two rational numbers.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>first</i>: An arbitrary-precision rational number.</p></li>
<li><p><i>second</i>: Another arbitrary-precision rational number.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>The larger value of the two numbers. If one is positive zero and the other is negative zero, returns the positive zero. If the two numbers are positive and have the same value, returns the one with the larger denominator. If the two numbers are negative and have the same value, returns the one with the smaller denominator.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter  <i>first</i>
or  <i>second</i>
is null.</li>
</ul>

<p><a id="MaxMagnitude_PeterO_Numbers_ERational_PeterO_Numbers_ERational"></a></p>

<h3>MaxMagnitude</h3>

<pre>public static PeterO.Numbers.ERational MaxMagnitude(
    PeterO.Numbers.ERational first,
    PeterO.Numbers.ERational second);
</pre>

<p>Gets the greater value between two values, ignoring their signs. If the absolute values are equal, has the same effect as Max.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>first</i>: The first value to compare.</p></li>
<li><p><i>second</i>: The second value to compare.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>The larger value of the two numbers, ignoring their signs.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter  <i>first</i>
or  <i>second</i>
is null.</li>
</ul>

<p><a id="Min_PeterO_Numbers_ERational_PeterO_Numbers_ERational"></a></p>

<h3>Min</h3>

<pre>public static PeterO.Numbers.ERational Min(
    PeterO.Numbers.ERational first,
    PeterO.Numbers.ERational second);
</pre>

<p>Gets the lesser value between two rational numbers.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>first</i>: The first value to compare.</p></li>
<li><p><i>second</i>: The second value to compare.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>The smaller value of the two numbers. If one is positive zero and the other is negative zero, returns the negative zero. If the two numbers are positive and have the same value, returns the one with the smaller denominator. If the two numbers are negative and have the same value, returns the one with the larger denominator.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter  <i>first</i>
or  <i>second</i>
is null.</li>
</ul>

<p><a id="MinMagnitude_PeterO_Numbers_ERational_PeterO_Numbers_ERational"></a></p>

<h3>MinMagnitude</h3>

<pre>public static PeterO.Numbers.ERational MinMagnitude(
    PeterO.Numbers.ERational first,
    PeterO.Numbers.ERational second);
</pre>

<p>Gets the lesser value between two values, ignoring their signs. If the absolute values are equal, has the same effect as Min.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>first</i>: The first value to compare.</p></li>
<li><p><i>second</i>: The second value to compare.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>The smaller value of the two numbers, ignoring their signs.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter  <i>first</i>
or  <i>second</i>
is null.</li>
</ul>

<p><a id="Multiply_int"></a></p>

<h3>Multiply</h3>

<pre>public PeterO.Numbers.ERational Multiply(
    int v);
</pre>

<p>Multiplies this arbitrary-precision rational number by a 32-bit signed integer and returns the result.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>v</i>: The parameter  <i>v</i>
is a 32-bit signed integer.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The product of the two numbers, that is, this arbitrary-precision rational number times a 32-bit signed integer.</p>

<p><a id="Multiply_long"></a></p>

<h3>Multiply</h3>

<pre>public PeterO.Numbers.ERational Multiply(
    long v);
</pre>

<p>Multiplies this arbitrary-precision rational number by a 64-bit signed integer and returns the result.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>v</i>: The parameter  <i>v</i>
is a 64-bit signed integer.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The product of the two numbers, that is, this arbitrary-precision rational number times a 64-bit signed integer.</p>

<p><a id="Multiply_PeterO_Numbers_ERational"></a></p>

<h3>Multiply</h3>

<pre>public PeterO.Numbers.ERational Multiply(
    PeterO.Numbers.ERational otherValue);
</pre>

<p>Multiplies this arbitrary-precision rational number by another arbitrary-precision rational number and returns the result.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>otherValue</i>: An arbitrary-precision rational number.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The product of the two numbers, that is, this arbitrary-precision rational number times another arbitrary-precision rational number.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter  <i>otherValue</i>
is null.</li>
</ul>

<p><a id="Negate"></a></p>

<h3>Negate</h3>

<pre>public PeterO.Numbers.ERational Negate();
</pre>

<p>Returns a rational number with the same value as this one but with the sign reversed.</p>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision rational number.</p>

<p><a id="op_Addition"></a></p>

<h3>Operator <code>+</code></h3>

<pre>public static PeterO.Numbers.ERational operator +(
    PeterO.Numbers.ERational bthis,
    PeterO.Numbers.ERational augend);
</pre>

<p>Adds an arbitrary-precision rational number and another arbitrary-precision rational number and returns the result.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>bthis</i>: The first operand.</p></li>
<li><p><i>augend</i>: The second operand.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>The sum of the two numbers, that is, an arbitrary-precision rational number plus another arbitrary-precision rational number.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter &quot;otherValue&quot; is null.</li>
</ul>

<p><a id="op_Decrement"></a></p>

<h3>Operator <code>--</code></h3>

<pre>public static PeterO.Numbers.ERational operator --(
    PeterO.Numbers.ERational bthis);
</pre>

<p>Subtracts one from an arbitrary-precision rational number.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>bthis</i>: An arbitrary-precision rational number.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The number given in  <i>bthis</i>
 minus one.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter  <i>bthis</i>
is null.</li>
</ul>

<p><a id="op_Division"></a></p>

<h3>Operator <code>/</code></h3>

<pre>public static PeterO.Numbers.ERational operator /(
    PeterO.Numbers.ERational dividend,
    PeterO.Numbers.ERational divisor);
</pre>

<p>Divides an arbitrary-precision rational number by the value of another arbitrary-precision rational number object.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>dividend</i>: An arbitrary-precision rational number serving as the dividend.</p></li>
<li><p><i>divisor</i>: An arbitrary-precision rational number serving as the divisor.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>The quotient of the two objects.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter &quot;otherValue&quot; is null.</li>
</ul>

<p><a id="explicit_operator_byte_PeterO_Numbers_ERational"></a></p>

<h3>Explicit Operator</h3>

<pre>public static explicit operator byte(
    PeterO.Numbers.ERational input);
</pre>

<p>Converts an arbitrary-precision rational number to a byte (from 0 to 255) if it can fit in a byte (from 0 to 255) after converting it to an integer by discarding its fractional part.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>input</i>: The number to convert as an arbitrary-precision rational number.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The value of  <i>input</i>
, truncated to a byte (from 0 to 255).</p>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.OverflowException:
The parameter  <i>input</i>
is infinity or not-a-number, or the number, once converted to an integer by discarding its fractional part, is less than 0 or greater than 255.</p></li>
<li><p>System.ArgumentNullException:
The parameter  <i>input</i>
is null.</p></li>
</ul>

<p><a id="explicit_operator_decimal_PeterO_Numbers_ERational"></a></p>

<h3>Explicit Operator</h3>

<pre>public static explicit operator decimal(
    PeterO.Numbers.ERational extendedNumber);
</pre>

<p>Converts an arbitrary-precision rational number to a  <code>decimal</code>  under the Common Language Infrastructure (see <a href="PeterO.Numbers.EDecimal.html">&#x22;Forms of numbers&#x22;</a>&quot;Forms of numbers&quot; ).</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>extendedNumber</i>: The number to convert as an arbitrary-precision rational number.</li>
</ul>

<p><b>Return Value:</b></p>

<p>A  <code>decimal</code>  under the Common Language Infrastructure (usually a.NET Framework decimal).</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter  <i>extendedNumber</i>
is null.</li>
</ul>

<p><a id="explicit_operator_double_PeterO_Numbers_ERational"></a></p>

<h3>Explicit Operator</h3>

<pre>public static explicit operator double(
    PeterO.Numbers.ERational bigValue);
</pre>

<p>Converts an arbitrary-precision rational number to a 64-bit floating-point number. The half-even rounding mode is used.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>bigValue</i>: The number to convert as an arbitrary-precision rational number.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The closest 64-bit floating-point number to this value. The return value can be positive infinity or negative infinity if this value exceeds the range of a 64-bit floating point number.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter  <i>bigValue</i>
is null.</li>
</ul>

<p><a id="explicit_operator_float_PeterO_Numbers_ERational"></a></p>

<h3>Explicit Operator</h3>

<pre>public static explicit operator float(
    PeterO.Numbers.ERational bigValue);
</pre>

<p>Converts an arbitrary-precision rational number to a 32-bit binary floating-point number. The half-even rounding mode is used.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>bigValue</i>: The number to convert as an arbitrary-precision rational number.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The closest 32-bit binary floating-point number to this value. The return value can be positive infinity or negative infinity if this value exceeds the range of a 32-bit floating point number.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter  <i>bigValue</i>
is null.</li>
</ul>

<p><a id="explicit_operator_int_PeterO_Numbers_ERational"></a></p>

<h3>Explicit Operator</h3>

<pre>public static explicit operator int(
    PeterO.Numbers.ERational input);
</pre>

<p>Converts an arbitrary-precision rational number to a 32-bit signed integer if it can fit in a 32-bit signed integer after converting it to an integer by discarding its fractional part.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>input</i>: The number to convert as an arbitrary-precision rational number.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The value of  <i>input</i>
, truncated to a 32-bit signed integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.OverflowException:
The parameter  <i>input</i>
is infinity or not-a-number, or the number, once converted to an integer by discarding its fractional part, is less than -2147483648 or greater than 2147483647.</p></li>
<li><p>System.ArgumentNullException:
The parameter  <i>input</i>
is null.</p></li>
</ul>

<p><a id="explicit_operator_long_PeterO_Numbers_ERational"></a></p>

<h3>Explicit Operator</h3>

<pre>public static explicit operator long(
    PeterO.Numbers.ERational input);
</pre>

<p>Converts an arbitrary-precision rational number to a 64-bit signed integer if it can fit in a 64-bit signed integer after converting it to an integer by discarding its fractional part.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>input</i>: The number to convert as an arbitrary-precision rational number.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The value of  <i>input</i>
, truncated to a 64-bit signed integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.OverflowException:
The parameter  <i>input</i>
is infinity or not-a-number, or the number, once converted to an integer by discarding its fractional part, is less than -9223372036854775808 or greater than 9223372036854775807.</p></li>
<li><p>System.ArgumentNullException:
The parameter  <i>input</i>
is null.</p></li>
</ul>

<p><a id="explicit_operator_PeterO_Numbers_EInteger_PeterO_Numbers_ERational"></a></p>

<h3>Explicit Operator</h3>

<pre>public static explicit operator PeterO.Numbers.EInteger(
    PeterO.Numbers.ERational bigValue);
</pre>

<p>Converts an arbitrary-precision rational number to an arbitrary-precision integer. Any fractional part in the value will be discarded when converting to an arbitrary-precision integer.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>bigValue</i>: An arbitrary-precision rational number.</li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.OverflowException:
This object&#39;s value is infinity or not-a-number (NaN).</p></li>
<li><p>System.ArgumentNullException:
The parameter  <i>bigValue</i>
is null.</p></li>
</ul>

<p><a id="explicit_operator_PeterO_Numbers_ERational_bool"></a></p>

<h3>Explicit Operator</h3>

<pre>public static explicit operator PeterO.Numbers.ERational(
    bool boolValue);
</pre>

<p>Converts a boolean value (true or false) to an arbitrary-precision rational number.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>boolValue</i>: Either true or false.</li>
</ul>

<p><b>Return Value:</b></p>

<p>1 if  <i>boolValue</i>
 is true; otherwise, 0.</p>

<p><a id="explicit_operator_sbyte_PeterO_Numbers_ERational"></a></p>

<h3>Explicit Operator</h3>

<pre>public static explicit operator sbyte(
    PeterO.Numbers.ERational input);
</pre>

<p><b>This API is not CLS-compliant.</b></p>

<p>Converts an arbitrary-precision rational number to an 8-bit signed integer if it can fit in an 8-bit signed integer after converting it to an integer by discarding its fractional part.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>input</i>: The number to convert as an arbitrary-precision rational number.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The value of  <i>input</i>
, truncated to an 8-bit signed integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.OverflowException:
The parameter  <i>input</i>
is infinity or not-a-number, or the number, once converted to an integer by discarding its fractional part, is less than -128 or greater than 127.</p></li>
<li><p>System.ArgumentNullException:
The parameter  <i>input</i>
is null.</p></li>
</ul>

<p><a id="explicit_operator_short_PeterO_Numbers_ERational"></a></p>

<h3>Explicit Operator</h3>

<pre>public static explicit operator short(
    PeterO.Numbers.ERational input);
</pre>

<p>Converts an arbitrary-precision rational number to a 16-bit signed integer if it can fit in a 16-bit signed integer after converting it to an integer by discarding its fractional part.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>input</i>: The number to convert as an arbitrary-precision rational number.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The value of  <i>input</i>
, truncated to a 16-bit signed integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.OverflowException:
The parameter  <i>input</i>
is infinity or not-a-number, or the number, once converted to an integer by discarding its fractional part, is less than -32768 or greater than 32767.</p></li>
<li><p>System.ArgumentNullException:
The parameter  <i>input</i>
is null.</p></li>
</ul>

<p><a id="explicit_operator_uint_PeterO_Numbers_ERational"></a></p>

<h3>Explicit Operator</h3>

<pre>public static explicit operator uint(
    PeterO.Numbers.ERational input);
</pre>

<p><b>This API is not CLS-compliant.</b></p>

<p>Converts an arbitrary-precision rational number to a 32-bit signed integer if it can fit in a 32-bit signed integer after converting it to an integer by discarding its fractional part.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>input</i>: The number to convert as an arbitrary-precision rational number.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The value of  <i>input</i>
, truncated to a 32-bit signed integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.OverflowException:
The parameter  <i>input</i>
is infinity or not-a-number, or the number, once converted to an integer by discarding its fractional part, is less than 0 or greater than 4294967295.</p></li>
<li><p>System.ArgumentNullException:
The parameter  <i>input</i>
is null.</p></li>
</ul>

<p><a id="explicit_operator_ulong_PeterO_Numbers_ERational"></a></p>

<h3>Explicit Operator</h3>

<pre>public static explicit operator ulong(
    PeterO.Numbers.ERational input);
</pre>

<p><b>This API is not CLS-compliant.</b></p>

<p>Converts an arbitrary-precision rational number to a 64-bit unsigned integer if it can fit in a 64-bit unsigned integer after converting it to an integer by discarding its fractional part.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>input</i>: The number to convert as an arbitrary-precision rational number.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The value of  <i>input</i>
, truncated to a 64-bit unsigned integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.OverflowException:
The parameter  <i>input</i>
is infinity or not-a-number, or the number, once converted to an integer by discarding its fractional part, is less than 0 or greater than 18446744073709551615.</p></li>
<li><p>System.ArgumentNullException:
The parameter  <i>input</i>
is null.</p></li>
</ul>

<p><a id="explicit_operator_ushort_PeterO_Numbers_ERational"></a></p>

<h3>Explicit Operator</h3>

<pre>public static explicit operator ushort(
    PeterO.Numbers.ERational input);
</pre>

<p><b>This API is not CLS-compliant.</b></p>

<p>Converts an arbitrary-precision rational number to a 16-bit unsigned integer if it can fit in a 16-bit unsigned integer after converting it to an integer by discarding its fractional part.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>input</i>: The number to convert as an arbitrary-precision rational number.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The value of  <i>input</i>
, truncated to a 16-bit unsigned integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.OverflowException:
The parameter  <i>input</i>
is infinity or not-a-number, or the number, once converted to an integer by discarding its fractional part, is less than 0 or greater than 65535.</p></li>
<li><p>System.ArgumentNullException:
The parameter  <i>input</i>
is null.</p></li>
</ul>

<p><a id="implicit_operator_PeterO_Numbers_ERational_byte"></a></p>

<h3>Implicit Operator</h3>

<pre>public static implicit operator PeterO.Numbers.ERational(
    byte inputByte);
</pre>

<p>Converts a byte (from 0 to 255) to an arbitrary-precision rational number.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>inputByte</i>: The number to convert as a byte (from 0 to 255).</li>
</ul>

<p><b>Return Value:</b></p>

<p>The value of  <i>inputByte</i>
 as an arbitrary-precision rational number.</p>

<p><a id="implicit_operator_PeterO_Numbers_ERational_decimal"></a></p>

<h3>Implicit Operator</h3>

<pre>public static implicit operator PeterO.Numbers.ERational(
    decimal eint);
</pre>

<p>Converts a  <code>decimal</code>  under the Common Language Infrastructure (usually a.NET Framework decimal). to an arbitrary-precision rational number.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>eint</i>: A  <code>decimal</code>  under the Common Language Infrastructure (usually a.NET Framework decimal).</li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision rational number.</p>

<p><a id="implicit_operator_PeterO_Numbers_ERational_double"></a></p>

<h3>Implicit Operator</h3>

<pre>public static implicit operator PeterO.Numbers.ERational(
    double eint);
</pre>

<p>Converts a 64-bit floating-point number to an arbitrary-precision rational number.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>eint</i>: The parameter  <i>eint</i>
is a 64-bit floating-point number.</li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision rational number.</p>

<p><a id="implicit_operator_PeterO_Numbers_ERational_float"></a></p>

<h3>Implicit Operator</h3>

<pre>public static implicit operator PeterO.Numbers.ERational(
    float eint);
</pre>

<p>Converts a 32-bit binary floating-point number to a rational number.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>eint</i>: The parameter  <i>eint</i>
is a 32-bit binary floating-point number.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The value of  <i>eint</i>
 as an arbitrary-precision rational number.</p>

<p><a id="implicit_operator_PeterO_Numbers_ERational_int"></a></p>

<h3>Implicit Operator</h3>

<pre>public static implicit operator PeterO.Numbers.ERational(
    int inputInt32);
</pre>

<p>Converts a 32-bit signed integer to an arbitrary-precision rational number.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>inputInt32</i>: The number to convert as a 32-bit signed integer.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The value of  <i>inputInt32</i>
 as an arbitrary-precision rational number.</p>

<p><a id="implicit_operator_PeterO_Numbers_ERational_long"></a></p>

<h3>Implicit Operator</h3>

<pre>public static implicit operator PeterO.Numbers.ERational(
    long inputInt64);
</pre>

<p>Converts a 64-bit signed integer to an arbitrary-precision rational number.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>inputInt64</i>: The number to convert as a 64-bit signed integer.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The value of  <i>inputInt64</i>
 as an arbitrary-precision rational number.</p>

<p><a id="implicit_operator_PeterO_Numbers_ERational_PeterO_Numbers_EDecimal"></a></p>

<h3>Implicit Operator</h3>

<pre>public static implicit operator PeterO.Numbers.ERational(
    PeterO.Numbers.EDecimal eint);
</pre>

<p>Converts an arbitrary-precision decimal floating-point number to an arbitrary-precision rational number.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>eint</i>: The parameter  <i>eint</i>
is an arbitrary-precision decimal floating-point number.</li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision rational number.</p>

<p><a id="implicit_operator_PeterO_Numbers_ERational_PeterO_Numbers_EFloat"></a></p>

<h3>Implicit Operator</h3>

<pre>public static implicit operator PeterO.Numbers.ERational(
    PeterO.Numbers.EFloat eint);
</pre>

<p>Converts an arbitrary-precision binary floating-point number to an arbitrary-precision rational number.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>eint</i>: An arbitrary-precision binary floating-point number.</li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision rational number.</p>

<p><a id="implicit_operator_PeterO_Numbers_ERational_PeterO_Numbers_EInteger"></a></p>

<h3>Implicit Operator</h3>

<pre>public static implicit operator PeterO.Numbers.ERational(
    PeterO.Numbers.EInteger eint);
</pre>

<p>Converts an arbitrary-precision integer to an arbitrary-precision rational number.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>eint</i>: An arbitrary-precision integer.</li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision rational number.</p>

<p><a id="implicit_operator_PeterO_Numbers_ERational_sbyte"></a></p>

<h3>Implicit Operator</h3>

<pre>public static implicit operator PeterO.Numbers.ERational(
    sbyte inputSByte);
</pre>

<p><b>This API is not CLS-compliant.</b></p>

<p>Converts an 8-bit signed integer to an arbitrary-precision rational number.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>inputSByte</i>: The number to convert as an 8-bit signed integer.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The value of  <i>inputSByte</i>
 as an arbitrary-precision rational number.</p>

<p><a id="implicit_operator_PeterO_Numbers_ERational_short"></a></p>

<h3>Implicit Operator</h3>

<pre>public static implicit operator PeterO.Numbers.ERational(
    short inputInt16);
</pre>

<p>Converts a 16-bit signed integer to an arbitrary-precision rational number.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>inputInt16</i>: The number to convert as a 16-bit signed integer.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The value of  <i>inputInt16</i>
 as an arbitrary-precision rational number.</p>

<p><a id="implicit_operator_PeterO_Numbers_ERational_uint"></a></p>

<h3>Implicit Operator</h3>

<pre>public static implicit operator PeterO.Numbers.ERational(
    uint inputUInt32);
</pre>

<p><b>This API is not CLS-compliant.</b></p>

<p>Converts a 32-bit signed integer to an arbitrary-precision rational number.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>inputUInt32</i>: The number to convert as a 32-bit signed integer.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The value of  <i>inputUInt32</i>
 as an arbitrary-precision rational number.</p>

<p><a id="implicit_operator_PeterO_Numbers_ERational_ulong"></a></p>

<h3>Implicit Operator</h3>

<pre>public static implicit operator PeterO.Numbers.ERational(
    ulong inputUInt64);
</pre>

<p><b>This API is not CLS-compliant.</b></p>

<p>Converts a 64-bit unsigned integer to an arbitrary-precision rational number.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>inputUInt64</i>: The number to convert as a 64-bit unsigned integer.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The value of  <i>inputUInt64</i>
 as an arbitrary-precision rational number.</p>

<p><a id="implicit_operator_PeterO_Numbers_ERational_ushort"></a></p>

<h3>Implicit Operator</h3>

<pre>public static implicit operator PeterO.Numbers.ERational(
    ushort inputUInt16);
</pre>

<p><b>This API is not CLS-compliant.</b></p>

<p>Converts a 16-bit unsigned integer to an arbitrary-precision rational number.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>inputUInt16</i>: The number to convert as a 16-bit unsigned integer.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The value of  <i>inputUInt16</i>
 as an arbitrary-precision rational number.</p>

<p><a id="op_Increment"></a></p>

<h3>Operator <code>++</code></h3>

<pre>public static PeterO.Numbers.ERational operator ++(
    PeterO.Numbers.ERational bthis);
</pre>

<p>Adds one to an arbitrary-precision rational number.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>bthis</i>: An arbitrary-precision rational number.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The number given in  <i>bthis</i>
 plus one.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter  <i>bthis</i>
is null.</li>
</ul>

<p><a id="op_Modulus"></a></p>

<h3>Operator <code>%</code></h3>

<pre>public static PeterO.Numbers.ERational operator %(
    PeterO.Numbers.ERational dividend,
    PeterO.Numbers.ERational divisor);
</pre>

<p>Returns the remainder that would result when an arbitrary-precision rational number is divided by another arbitrary-precision rational number.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>dividend</i>: The dividend.</p></li>
<li><p><i>divisor</i>: The divisor.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>The remainder that would result when an arbitrary-precision rational number is divided by another arbitrary-precision rational number.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter &quot;otherValue&quot; is null.</li>
</ul>

<p><a id="op_Multiply"></a></p>

<h3>Operator <code>*</code></h3>

<pre>public static PeterO.Numbers.ERational operator *(
    PeterO.Numbers.ERational operand1,
    PeterO.Numbers.ERational operand2);
</pre>

<p>Multiplies an arbitrary-precision rational number by another arbitrary-precision rational number and returns the result.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>operand1</i>: The first operand.</p></li>
<li><p><i>operand2</i>: The second operand.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>The product of the two numbers, that is, an arbitrary-precision rational number times another arbitrary-precision rational number.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter &quot;otherValue&quot; is null.</li>
</ul>

<p><a id="op_Subtraction"></a></p>

<h3>Operator <code>-</code></h3>

<pre>public static PeterO.Numbers.ERational operator -(
    PeterO.Numbers.ERational bthis,
    PeterO.Numbers.ERational subtrahend);
</pre>

<p>Subtracts an arbitrary-precision rational number from this instance.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>bthis</i>: The first operand.</p></li>
<li><p><i>subtrahend</i>: The second operand.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>The difference of the two objects.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter &quot;otherValue&quot; is null.</li>
</ul>

<p><a id="op_UnaryNegation"></a></p>

<h3>Operator <code>-</code></h3>

<pre>public static PeterO.Numbers.ERational operator -(
    PeterO.Numbers.ERational bigValue);
</pre>

<p>Returns an arbitrary-precision rational number with the same value as the given one but with its sign reversed.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>bigValue</i>: An arbitrary-precision rational number to negate.</li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision rational number.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter  <i>bigValue</i>
is null.</li>
</ul>

<p><a id="Remainder_int"></a></p>

<h3>Remainder</h3>

<pre>public PeterO.Numbers.ERational Remainder(
    int v);
</pre>

<p>Returns the remainder that would result when this arbitrary-precision rational number is divided by a 32-bit signed integer.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>v</i>: The divisor.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The remainder that would result when this arbitrary-precision rational number is divided by a 32-bit signed integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentException:
The parameter  <i>v</i>
is zero.</li>
</ul>

<p><a id="Remainder_long"></a></p>

<h3>Remainder</h3>

<pre>public PeterO.Numbers.ERational Remainder(
    long v);
</pre>

<p>Returns the remainder that would result when this arbitrary-precision rational number is divided by a 64-bit signed integer.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>v</i>: The divisor.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The remainder that would result when this arbitrary-precision rational number is divided by a 64-bit signed integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentException:
The parameter  <i>v</i>
is zero.</li>
</ul>

<p><a id="Remainder_PeterO_Numbers_ERational"></a></p>

<h3>Remainder</h3>

<pre>public PeterO.Numbers.ERational Remainder(
    PeterO.Numbers.ERational otherValue);
</pre>

<p>Returns the remainder that would result when this arbitrary-precision rational number is divided by another arbitrary-precision rational number.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>otherValue</i>: An arbitrary-precision rational number.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The remainder that would result when this arbitrary-precision rational number is divided by another arbitrary-precision rational number.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter  <i>otherValue</i>
is null.</li>
</ul>

<p><a id="Subtract_int"></a></p>

<h3>Subtract</h3>

<pre>public PeterO.Numbers.ERational Subtract(
    int v);
</pre>

<p>Subtracts a 32-bit signed integer from this arbitrary-precision rational number and returns the result.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>v</i>: The parameter  <i>v</i>
is a 32-bit signed integer.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The difference between the two numbers, that is, this arbitrary-precision rational number minus a 32-bit signed integer.</p>

<p><a id="Subtract_long"></a></p>

<h3>Subtract</h3>

<pre>public PeterO.Numbers.ERational Subtract(
    long v);
</pre>

<p>Subtracts a 64-bit signed integer from this arbitrary-precision rational number and returns the result.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>v</i>: The parameter  <i>v</i>
is a 64-bit signed integer.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The difference between the two numbers, that is, this arbitrary-precision rational number minus a 64-bit signed integer.</p>

<p><a id="Subtract_PeterO_Numbers_ERational"></a></p>

<h3>Subtract</h3>

<pre>public PeterO.Numbers.ERational Subtract(
    PeterO.Numbers.ERational otherValue);
</pre>

<p>Subtracts an arbitrary-precision rational number from this arbitrary-precision rational number and returns the result.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>otherValue</i>: An arbitrary-precision rational number.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The difference between the two numbers, that is, this arbitrary-precision rational number minus another arbitrary-precision rational number.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter  <i>otherValue</i>
is null.</li>
</ul>

<p><a id="ToByteChecked"></a></p>

<h3>ToByteChecked</h3>

<pre>public byte ToByteChecked();
</pre>

<p>Converts this number&#39;s value to a byte (from 0 to 255) if it can fit in a byte (from 0 to 255) after converting it to an integer by discarding its fractional part.</p>

<p><b>Return Value:</b></p>

<p>This number&#39;s value, truncated to a byte (from 0 to 255).</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.OverflowException:
This value is infinity or not-a-number, or the number, once converted to an integer by discarding its fractional part, is less than 0 or greater than 255.</li>
</ul>

<p><a id="ToByteIfExact"></a></p>

<h3>ToByteIfExact</h3>

<pre>public byte ToByteIfExact();
</pre>

<p>Converts this number&#39;s value to a byte (from 0 to 255) if it can fit in a byte (from 0 to 255) without rounding to a different numerical value.</p>

<p><b>Return Value:</b></p>

<p>This number&#39;s value as a byte (from 0 to 255).</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArithmeticException:
This value is infinity or not-a-number, is not an exact integer, or is less than 0 or greater than 255.</li>
</ul>

<p><a id="ToByteUnchecked"></a></p>

<h3>ToByteUnchecked</h3>

<pre>public byte ToByteUnchecked();
</pre>

<p>Converts this number&#39;s value to an integer (using ToEInteger), and returns the least-significant bits of that integer&#39;s two&#39;s-complement form as a byte (from 0 to 255).</p>

<p><b>Return Value:</b></p>

<p>This number, converted to a byte (from 0 to 255). Returns 0 if this value is infinity or not-a-number.</p>

<p><a id="ToDecimal"></a></p>

<h3>ToDecimal</h3>

<pre>public decimal ToDecimal();
</pre>

<p>Converts this value to a  <code>decimal</code>  under the Common Language Infrastructure (usually a.NET Framework decimal). Currently, converts this value to the precision and range of a.NET Framework decimal.</p>

<p><b>Return Value:</b></p>

<p>A  <code>decimal</code>  under the Common Language Infrastructure (usually a.NET Framework decimal).</p>

<p><a id="ToDouble"></a></p>

<h3>ToDouble</h3>

<pre>public double ToDouble();
</pre>

<p>Converts this value to a 64-bit floating-point number. The half-even rounding mode is used.</p>

<p><b>Return Value:</b></p>

<p>The closest 64-bit floating-point number to this value. The return value can be positive infinity or negative infinity if this value exceeds the range of a 64-bit floating point number.</p>

<p><a id="ToDoubleBits"></a></p>

<h3>ToDoubleBits</h3>

<pre>public long ToDoubleBits();
</pre>

<p>Converts this value to its closest equivalent as a 64-bit floating-point number, expressed as an integer in the IEEE 754 binary64 format. The half-even rounding mode is used. If this value is a NaN, sets the high bit of the 64-bit floating point number&#39;s significand area for a quiet NaN, and clears it for a signaling NaN. Then the other bits of the significand area are set to the lowest bits of this object&#39;s unsigned significand, and the next-highest bit of the significand area is set if those bits are all zeros and this is a signaling NaN.</p>

<p><b>Return Value:</b></p>

<p>The closest 64-bit binary floating-point number to this value, expressed as an integer in the IEEE 754 binary64 format. The return value can be positive infinity or negative infinity if this value exceeds the range of a 64-bit floating point number.</p>

<p><a id="ToEDecimal_PeterO_Numbers_EContext"></a></p>

<h3>ToEDecimal</h3>

<pre>public PeterO.Numbers.EDecimal ToEDecimal(
    PeterO.Numbers.EContext ctx);
</pre>

<p>Converts this rational number to an arbitrary-precision decimal number and rounds the result to the given precision.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>ctx</i>: An arithmetic context object to control the precision, rounding, and exponent range of the result. If HasFlags of the context is true, will also store the flags resulting from the operation (the flags are in addition to the pre-existing flags). Can be null, in which case the precision is unlimited and no rounding is needed.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The value of the rational number, rounded to the given precision. Returns not-a-number (NaN) if the context is null and the result can&#39;t be exact because it has a nonterminating decimal expansion.</p>

<p><a id="ToEDecimal"></a></p>

<h3>ToEDecimal</h3>

<pre>public PeterO.Numbers.EDecimal ToEDecimal();
</pre>

<p>Converts this rational number to an arbitrary-precision decimal number.</p>

<p><b>Return Value:</b></p>

<p>The exact value of the rational number, or not-a-number (NaN) if the result can&#39;t be exact because it has a nonterminating decimal expansion.</p>

<p><a id="ToEDecimalExactIfPossible_PeterO_Numbers_EContext"></a></p>

<h3>ToEDecimalExactIfPossible</h3>

<pre>public PeterO.Numbers.EDecimal ToEDecimalExactIfPossible(
    PeterO.Numbers.EContext ctx);
</pre>

<p>Converts this rational number to an arbitrary-precision decimal number, but if the result would have a nonterminating decimal expansion, rounds that result to the given precision.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>ctx</i>: An arithmetic context object to control the precision, rounding, and exponent range of the result. This context will be used only if the exact result would have a nonterminating decimal expansion. If HasFlags of the context is true, will also store the flags resulting from the operation (the flags are in addition to the pre-existing flags). Can be null, in which case the precision is unlimited and no rounding is needed.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The exact value of the rational number if possible; otherwise, the rounded version of the result if a context is given. Returns not-a-number (NaN) if the context is null and the result can&#39;t be exact because it has a nonterminating decimal expansion.</p>

<p><a id="ToEFloat_PeterO_Numbers_EContext"></a></p>

<h3>ToEFloat</h3>

<pre>public PeterO.Numbers.EFloat ToEFloat(
    PeterO.Numbers.EContext ctx);
</pre>

<p>Converts this rational number to a binary floating-point number and rounds that result to the given precision.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>ctx</i>: An arithmetic context object to control the precision, rounding, and exponent range of the result. If HasFlags of the context is true, will also store the flags resulting from the operation (the flags are in addition to the pre-existing flags). Can be null, in which case the precision is unlimited and no rounding is needed.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The value of the rational number, rounded to the given precision. Returns not-a-number (NaN) if the context is null and the result can&#39;t be exact because it has a nonterminating binary expansion.</p>

<p><a id="ToEFloat"></a></p>

<h3>ToEFloat</h3>

<pre>public PeterO.Numbers.EFloat ToEFloat();
</pre>

<p>Converts this rational number to a binary floating-point number.</p>

<p><b>Return Value:</b></p>

<p>The exact value of the rational number, or not-a-number (NaN) if the result can&#39;t be exact because it has a nonterminating binary expansion.</p>

<p><a id="ToEFloatExactIfPossible_PeterO_Numbers_EContext"></a></p>

<h3>ToEFloatExactIfPossible</h3>

<pre>public PeterO.Numbers.EFloat ToEFloatExactIfPossible(
    PeterO.Numbers.EContext ctx);
</pre>

<p>Converts this rational number to a binary floating-point number, but if the result would have a nonterminating binary expansion, rounds that result to the given precision.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>ctx</i>: An arithmetic context object to control the precision, rounding, and exponent range of the result. This context will be used only if the exact result would have a nonterminating binary expansion. If HasFlags of the context is true, will also store the flags resulting from the operation (the flags are in addition to the pre-existing flags). Can be null, in which case the precision is unlimited and no rounding is needed.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The exact value of the rational number if possible; otherwise, the rounded version of the result if a context is given. Returns not-a-number (NaN) if the context is null and the result can&#39;t be exact because it has a nonterminating binary expansion.</p>

<p><a id="ToEInteger"></a></p>

<h3>ToEInteger</h3>

<pre>public PeterO.Numbers.EInteger ToEInteger();
</pre>

<p>Converts this value to an arbitrary-precision integer by dividing the numerator by the denominator and discarding the fractional part of the result.</p>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.OverflowException:
This object&#39;s value is infinity or not-a-number (NaN).</li>
</ul>

<p><a id="ToEIntegerExact"></a></p>

<h3>ToEIntegerExact</h3>

<pre>public PeterO.Numbers.EInteger ToEIntegerExact();
</pre>

<p><b>Deprecated.</b> Renamed to ToEIntegerIfExact.</p>

<p>Converts this value to an arbitrary-precision integer, checking whether the value is an exact integer.</p>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.OverflowException:
This object&#39;s value is infinity or not-a-number (NaN).</li>
</ul>

<p><a id="ToEIntegerIfExact"></a></p>

<h3>ToEIntegerIfExact</h3>

<pre>public PeterO.Numbers.EInteger ToEIntegerIfExact();
</pre>

<p>Converts this value to an arbitrary-precision integer, checking whether the value is an exact integer.</p>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.OverflowException:
This object&#39;s value is infinity or not-a-number (NaN).</li>
</ul>

<p><a id="ToExtendedDecimal_PeterO_Numbers_EContext"></a></p>

<h3>ToExtendedDecimal</h3>

<pre>public PeterO.Numbers.EDecimal ToExtendedDecimal(
    PeterO.Numbers.EContext ctx);
</pre>

<p><b>Deprecated.</b> Renamed to ToEDecimal.</p>

<p>Converts this rational number to an arbitrary-precision decimal number and rounds the result to the given precision.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>ctx</i>: An arithmetic context object to control the precision, rounding, and exponent range of the result. If HasFlags of the context is true, will also store the flags resulting from the operation (the flags are in addition to the pre-existing flags). Can be null, in which case the precision is unlimited and no rounding is needed.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The value of the rational number, rounded to the given precision. Returns not-a-number (NaN) if the context is null and the result can&#39;t be exact because it has a nonterminating decimal expansion.</p>

<p><a id="ToExtendedDecimal"></a></p>

<h3>ToExtendedDecimal</h3>

<pre>public PeterO.Numbers.EDecimal ToExtendedDecimal();
</pre>

<p><b>Deprecated.</b> Renamed to ToEDecimal.</p>

<p>Converts this rational number to an arbitrary-precision decimal number.</p>

<p><b>Return Value:</b></p>

<p>The exact value of the rational number, or not-a-number (NaN) if the result can&#39;t be exact because it has a nonterminating decimal expansion.</p>

<p><a id="ToExtendedDecimalExactIfPossible_PeterO_Numbers_EContext"></a></p>

<h3>ToExtendedDecimalExactIfPossible</h3>

<pre>public PeterO.Numbers.EDecimal ToExtendedDecimalExactIfPossible(
    PeterO.Numbers.EContext ctx);
</pre>

<p><b>Deprecated.</b> Renamed to ToEDecimalExactIfPossible.</p>

<p>Converts this rational number to an arbitrary-precision decimal number, but if the result would have a nonterminating decimal expansion, rounds that result to the given precision.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>ctx</i>: An arithmetic context object to control the precision, rounding, and exponent range of the result. This context will be used only if the exact result would have a nonterminating decimal expansion. If HasFlags of the context is true, will also store the flags resulting from the operation (the flags are in addition to the pre-existing flags). Can be null, in which case the precision is unlimited and no rounding is needed.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The exact value of the rational number if possible; otherwise, the rounded version of the result if a context is given. Returns not-a-number (NaN) if the context is null and the result can&#39;t be exact because it has a nonterminating decimal expansion.</p>

<p><a id="ToExtendedFloat_PeterO_Numbers_EContext"></a></p>

<h3>ToExtendedFloat</h3>

<pre>public PeterO.Numbers.EFloat ToExtendedFloat(
    PeterO.Numbers.EContext ctx);
</pre>

<p><b>Deprecated.</b> Renamed to ToEFloat.</p>

<p>Converts this rational number to a binary floating-point number and rounds that result to the given precision.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>ctx</i>: An arithmetic context object to control the precision, rounding, and exponent range of the result. If HasFlags of the context is true, will also store the flags resulting from the operation (the flags are in addition to the pre-existing flags). Can be null, in which case the precision is unlimited and no rounding is needed.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The value of the rational number, rounded to the given precision. Returns not-a-number (NaN) if the context is null and the result can&#39;t be exact because it has a nonterminating binary expansion.</p>

<p><a id="ToExtendedFloat"></a></p>

<h3>ToExtendedFloat</h3>

<pre>public PeterO.Numbers.EFloat ToExtendedFloat();
</pre>

<p><b>Deprecated.</b> Renamed to ToEFloat.</p>

<p>Converts this rational number to a binary floating-point number.</p>

<p><b>Return Value:</b></p>

<p>The exact value of the rational number, or not-a-number (NaN) if the result can&#39;t be exact because it has a nonterminating binary expansion.</p>

<p><a id="ToExtendedFloatExactIfPossible_PeterO_Numbers_EContext"></a></p>

<h3>ToExtendedFloatExactIfPossible</h3>

<pre>public PeterO.Numbers.EFloat ToExtendedFloatExactIfPossible(
    PeterO.Numbers.EContext ctx);
</pre>

<p><b>Deprecated.</b> Renamed to ToEFloatExactIfPossible.</p>

<p>Converts this rational number to a binary floating-point number, but if the result would have a nonterminating binary expansion, rounds that result to the given precision.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>ctx</i>: An arithmetic context object to control the precision, rounding, and exponent range of the result. This context will be used only if the exact result would have a nonterminating binary expansion. If HasFlags of the context is true, will also store the flags resulting from the operation (the flags are in addition to the pre-existing flags). Can be null, in which case the precision is unlimited and no rounding is needed.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The exact value of the rational number if possible; otherwise, the rounded version of the result if a context is given. Returns not-a-number (NaN) if the context is null and the result can&#39;t be exact because it has a nonterminating binary expansion.</p>

<p><a id="ToHalfBits"></a></p>

<h3>ToHalfBits</h3>

<pre>public short ToHalfBits();
</pre>

<p>Converts this value to its closest equivalent as a binary floating-point number, expressed as an integer in the IEEE 754 binary16 format (also known as a &quot;half-precision&quot; floating-point number). The half-even rounding mode is used. If this value is a NaN, sets the high bit of the binary16 number&#39;s significand area for a quiet NaN, and clears it for a signaling NaN. Then the other bits of the significand area are set to the lowest bits of this object&#39;s unsigned significand, and the next-highest bit of the significand area is set if those bits are all zeros and this is a signaling NaN.</p>

<p><b>Return Value:</b></p>

<p>The closest binary floating-point number to this value, expressed as an integer in the IEEE 754 binary16 format. The return value can be positive infinity or negative infinity if this value exceeds the range of a floating-point number in the binary16 format.</p>

<p><a id="ToInt16Checked"></a></p>

<h3>ToInt16Checked</h3>

<pre>public short ToInt16Checked();
</pre>

<p>Converts this number&#39;s value to a 16-bit signed integer if it can fit in a 16-bit signed integer after converting it to an integer by discarding its fractional part.</p>

<p><b>Return Value:</b></p>

<p>This number&#39;s value, truncated to a 16-bit signed integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.OverflowException:
This value is infinity or not-a-number, or the number, once converted to an integer by discarding its fractional part, is less than -32768 or greater than 32767.</li>
</ul>

<p><a id="ToInt16IfExact"></a></p>

<h3>ToInt16IfExact</h3>

<pre>public short ToInt16IfExact();
</pre>

<p>Converts this number&#39;s value to a 16-bit signed integer if it can fit in a 16-bit signed integer without rounding to a different numerical value.</p>

<p><b>Return Value:</b></p>

<p>This number&#39;s value as a 16-bit signed integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArithmeticException:
This value is infinity or not-a-number, is not an exact integer, or is less than -32768 or greater than 32767.</li>
</ul>

<p><a id="ToInt16Unchecked"></a></p>

<h3>ToInt16Unchecked</h3>

<pre>public short ToInt16Unchecked();
</pre>

<p>Converts this number&#39;s value to an integer by discarding its fractional part, and returns the least-significant bits of its two&#39;s-complement form as a 16-bit signed integer.</p>

<p><b>Return Value:</b></p>

<p>This number, converted to a 16-bit signed integer. Returns 0 if this value is infinity or not-a-number.</p>

<p><a id="ToInt32Checked"></a></p>

<h3>ToInt32Checked</h3>

<pre>public int ToInt32Checked();
</pre>

<p>Converts this number&#39;s value to a 32-bit signed integer if it can fit in a 32-bit signed integer after converting it to an integer by discarding its fractional part.</p>

<p><b>Return Value:</b></p>

<p>This number&#39;s value, truncated to a 32-bit signed integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.OverflowException:
This value is infinity or not-a-number, or the number, once converted to an integer by discarding its fractional part, is less than -2147483648 or greater than 2147483647.</li>
</ul>

<p><a id="ToInt32IfExact"></a></p>

<h3>ToInt32IfExact</h3>

<pre>public int ToInt32IfExact();
</pre>

<p>Converts this number&#39;s value to a 32-bit signed integer if it can fit in a 32-bit signed integer without rounding to a different numerical value.</p>

<p><b>Return Value:</b></p>

<p>This number&#39;s value as a 32-bit signed integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArithmeticException:
This value is infinity or not-a-number, is not an exact integer, or is less than -2147483648 or greater than 2147483647.</li>
</ul>

<p><a id="ToInt32Unchecked"></a></p>

<h3>ToInt32Unchecked</h3>

<pre>public int ToInt32Unchecked();
</pre>

<p>Converts this number&#39;s value to an integer by discarding its fractional part, and returns the least-significant bits of its two&#39;s-complement form as a 32-bit signed integer.</p>

<p><b>Return Value:</b></p>

<p>This number, converted to a 32-bit signed integer. Returns 0 if this value is infinity or not-a-number.</p>

<p><a id="ToInt64Checked"></a></p>

<h3>ToInt64Checked</h3>

<pre>public long ToInt64Checked();
</pre>

<p>Converts this number&#39;s value to a 64-bit signed integer if it can fit in a 64-bit signed integer after converting it to an integer by discarding its fractional part.</p>

<p><b>Return Value:</b></p>

<p>This number&#39;s value, truncated to a 64-bit signed integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.OverflowException:
This value is infinity or not-a-number, or the number, once converted to an integer by discarding its fractional part, is less than -9223372036854775808 or greater than 9223372036854775807.</li>
</ul>

<p><a id="ToInt64IfExact"></a></p>

<h3>ToInt64IfExact</h3>

<pre>public long ToInt64IfExact();
</pre>

<p>Converts this number&#39;s value to a 64-bit signed integer if it can fit in a 64-bit signed integer without rounding to a different numerical value.</p>

<p><b>Return Value:</b></p>

<p>This number&#39;s value as a 64-bit signed integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArithmeticException:
This value is infinity or not-a-number, is not an exact integer, or is less than -9223372036854775808 or greater than 9223372036854775807.</li>
</ul>

<p><a id="ToInt64Unchecked"></a></p>

<h3>ToInt64Unchecked</h3>

<pre>public long ToInt64Unchecked();
</pre>

<p>Converts this number&#39;s value to an integer by discarding its fractional part, and returns the least-significant bits of its two&#39;s-complement form as a 64-bit signed integer.</p>

<p><b>Return Value:</b></p>

<p>This number, converted to a 64-bit signed integer. Returns 0 if this value is infinity or not-a-number.</p>

<p><a id="ToLowestTerms"></a></p>

<h3>ToLowestTerms</h3>

<pre>public PeterO.Numbers.ERational ToLowestTerms();
</pre>

<p>Converts this value to its form in lowest terms. For example, (8/4) becomes (4/1).</p>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision rational with the same value as this one but in lowest terms. Returns this object if it is infinity or NaN. Returns ERational.NegativeZero if this object is a negative zero. Returns ERational.Zero if this object is a positive zero.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.OverflowException:
This object&#39;s value is infinity or not-a-number (NaN).</li>
</ul>

<p><a id="ToSByteChecked"></a></p>

<h3>ToSByteChecked</h3>

<pre>public sbyte ToSByteChecked();
</pre>

<p><b>This API is not CLS-compliant.</b></p>

<p>Converts this number&#39;s value to an 8-bit signed integer if it can fit in an 8-bit signed integer after converting it to an integer by discarding its fractional part.</p>

<p><b>Return Value:</b></p>

<p>This number&#39;s value, truncated to an 8-bit signed integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.OverflowException:
This value is infinity or not-a-number, or the number, once converted to an integer by discarding its fractional part, is less than -128 or greater than 127.</li>
</ul>

<p><a id="ToSByteIfExact"></a></p>

<h3>ToSByteIfExact</h3>

<pre>public sbyte ToSByteIfExact();
</pre>

<p><b>This API is not CLS-compliant.</b></p>

<p>Converts this number&#39;s value to an 8-bit signed integer if it can fit in an 8-bit signed integer without rounding to a different numerical value.</p>

<p><b>Return Value:</b></p>

<p>This number&#39;s value as an 8-bit signed integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArithmeticException:
This value is infinity or not-a-number, is not an exact integer, or is less than -128 or greater than 127.</li>
</ul>

<p><a id="ToSByteUnchecked"></a></p>

<h3>ToSByteUnchecked</h3>

<pre>public sbyte ToSByteUnchecked();
</pre>

<p><b>This API is not CLS-compliant.</b></p>

<p>Converts this number&#39;s value to an integer by discarding its fractional part, and returns the least-significant bits of its two&#39;s-complement form as an 8-bit signed integer.</p>

<p><b>Return Value:</b></p>

<p>This number, converted to an 8-bit signed integer. Returns 0 if this value is infinity or not-a-number.</p>

<p><a id="ToSingle"></a></p>

<h3>ToSingle</h3>

<pre>public float ToSingle();
</pre>

<p>Converts this value to a 32-bit binary floating-point number. The half-even rounding mode is used.</p>

<p><b>Return Value:</b></p>

<p>The closest 32-bit binary floating-point number to this value. The return value can be positive infinity or negative infinity if this value exceeds the range of a 32-bit floating point number.</p>

<p><a id="ToSingleBits"></a></p>

<h3>ToSingleBits</h3>

<pre>public int ToSingleBits();
</pre>

<p>Converts this value to its closest equivalent as 32-bit floating-point number, expressed as an integer in the IEEE 754 binary32 format. The half-even rounding mode is used. If this value is a NaN, sets the high bit of the 32-bit floating point number&#39;s significand area for a quiet NaN, and clears it for a signaling NaN. Then the other bits of the significand area are set to the lowest bits of this object&#39;s unsigned significand, and the next-highest bit of the significand area is set if those bits are all zeros and this is a signaling NaN.</p>

<p><b>Return Value:</b></p>

<p>The closest 32-bit binary floating-point number to this value, expressed as an integer in the IEEE 754 binary32 format. The return value can be positive infinity or negative infinity if this value exceeds the range of a 32-bit floating point number.</p>

<p><a id="ToSizedEInteger_int"></a></p>

<h3>ToSizedEInteger</h3>

<pre>public PeterO.Numbers.EInteger ToSizedEInteger(
    int maxBitLength);
</pre>

<p>Converts this value to an arbitrary-precision integer by dividing the numerator by the denominator, discarding its fractional part, and checking whether the resulting integer overflows the given signed bit count.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>maxBitLength</i>: The maximum number of signed bits the integer can have. The integer&#39;s value may not be less than -(2^maxBitLength) or greater than (2^maxBitLength) - 1.</li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.OverflowException:
This object&#39;s value is infinity or not-a-number (NaN), or this number&#39;s value, once converted to an integer by dividing the numerator by the denominator and discarding its fractional part, is less than -(2^maxBitLength) or greater than (2^maxBitLength) - 1.</li>
</ul>

<p><a id="ToSizedEIntegerIfExact_int"></a></p>

<h3>ToSizedEIntegerIfExact</h3>

<pre>public PeterO.Numbers.EInteger ToSizedEIntegerIfExact(
    int maxBitLength);
</pre>

<p>Converts this value to an arbitrary-precision integer, only if this number&#39;s value is an exact integer and that integer does not overflow the given signed bit count.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>maxBitLength</i>: The maximum number of signed bits the integer can have. The integer&#39;s value may not be less than -(2^maxBitLength) or greater than (2^maxBitLength) - 1.</li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.OverflowException:
This object&#39;s value is infinity or not-a-number (NaN), or this number&#39;s value as an integer is less than -(2^maxBitLength) or greater than (2^maxBitLength) - 1.</p></li>
<li><p>System.ArithmeticException:
This object&#39;s value is not an exact integer.</p></li>
</ul>

<p><a id="ToString"></a></p>

<h3>ToString</h3>

<pre>public override string ToString();
</pre>

<p>Converts this object to a text string.</p>

<p><b>Return Value:</b></p>

<p>A string representation of this object. If this object&#39;s value is infinity or not-a-number, the result is the analogous return value of the  <code>EDecimal.ToString</code>  method. Otherwise, the return value has the following form:  <code>[-]numerator/denominator</code> .</p>

<p><a id="ToUInt16Checked"></a></p>

<h3>ToUInt16Checked</h3>

<pre>public ushort ToUInt16Checked();
</pre>

<p><b>This API is not CLS-compliant.</b></p>

<p>Converts this number&#39;s value to a 16-bit unsigned integer if it can fit in a 16-bit unsigned integer after converting it to an integer by discarding its fractional part.</p>

<p><b>Return Value:</b></p>

<p>This number&#39;s value, truncated to a 16-bit unsigned integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.OverflowException:
This value is infinity or not-a-number, or the number, once converted to an integer by discarding its fractional part, is less than 0 or greater than 65535.</li>
</ul>

<p><a id="ToUInt16IfExact"></a></p>

<h3>ToUInt16IfExact</h3>

<pre>public ushort ToUInt16IfExact();
</pre>

<p><b>This API is not CLS-compliant.</b></p>

<p>Converts this number&#39;s value to a 16-bit unsigned integer if it can fit in a 16-bit unsigned integer without rounding to a different numerical value.</p>

<p><b>Return Value:</b></p>

<p>This number&#39;s value as a 16-bit unsigned integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArithmeticException:
This value is infinity or not-a-number, is not an exact integer, or is less than 0 or greater than 65535.</li>
</ul>

<p><a id="ToUInt16Unchecked"></a></p>

<h3>ToUInt16Unchecked</h3>

<pre>public ushort ToUInt16Unchecked();
</pre>

<p><b>This API is not CLS-compliant.</b></p>

<p>Converts this number&#39;s value to an integer by discarding its fractional part, and returns the least-significant bits of its two&#39;s-complement form as a 16-bit unsigned integer.</p>

<p><b>Return Value:</b></p>

<p>This number, converted to a 16-bit unsigned integer. Returns 0 if this value is infinity or not-a-number.</p>

<p><a id="ToUInt32Checked"></a></p>

<h3>ToUInt32Checked</h3>

<pre>public uint ToUInt32Checked();
</pre>

<p><b>This API is not CLS-compliant.</b></p>

<p>Converts this number&#39;s value to a 32-bit signed integer if it can fit in a 32-bit signed integer after converting it to an integer by discarding its fractional part.</p>

<p><b>Return Value:</b></p>

<p>This number&#39;s value, truncated to a 32-bit signed integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.OverflowException:
This value is infinity or not-a-number, or the number, once converted to an integer by discarding its fractional part, is less than 0 or greater than 4294967295.</li>
</ul>

<p><a id="ToUInt32IfExact"></a></p>

<h3>ToUInt32IfExact</h3>

<pre>public uint ToUInt32IfExact();
</pre>

<p><b>This API is not CLS-compliant.</b></p>

<p>Converts this number&#39;s value to a 32-bit signed integer if it can fit in a 32-bit signed integer without rounding to a different numerical value.</p>

<p><b>Return Value:</b></p>

<p>This number&#39;s value as a 32-bit signed integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArithmeticException:
This value is infinity or not-a-number, is not an exact integer, or is less than 0 or greater than 4294967295.</li>
</ul>

<p><a id="ToUInt32Unchecked"></a></p>

<h3>ToUInt32Unchecked</h3>

<pre>public uint ToUInt32Unchecked();
</pre>

<p><b>This API is not CLS-compliant.</b></p>

<p>Converts this number&#39;s value to an integer by discarding its fractional part, and returns the least-significant bits of its two&#39;s-complement form as a 32-bit signed integer.</p>

<p><b>Return Value:</b></p>

<p>This number, converted to a 32-bit signed integer. Returns 0 if this value is infinity or not-a-number.</p>

<p><a id="ToUInt64Checked"></a></p>

<h3>ToUInt64Checked</h3>

<pre>public ulong ToUInt64Checked();
</pre>

<p><b>This API is not CLS-compliant.</b></p>

<p>Converts this number&#39;s value to a 64-bit unsigned integer if it can fit in a 64-bit unsigned integer after converting it to an integer by discarding its fractional part.</p>

<p><b>Return Value:</b></p>

<p>This number&#39;s value, truncated to a 64-bit unsigned integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.OverflowException:
This value is infinity or not-a-number, or the number, once converted to an integer by discarding its fractional part, is less than 0 or greater than 18446744073709551615.</li>
</ul>

<p><a id="ToUInt64IfExact"></a></p>

<h3>ToUInt64IfExact</h3>

<pre>public ulong ToUInt64IfExact();
</pre>

<p><b>This API is not CLS-compliant.</b></p>

<p>Converts this number&#39;s value to a 64-bit unsigned integer if it can fit in a 64-bit unsigned integer without rounding to a different numerical value.</p>

<p><b>Return Value:</b></p>

<p>This number&#39;s value as a 64-bit unsigned integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArithmeticException:
This value is infinity or not-a-number, is not an exact integer, or is less than 0 or greater than 18446744073709551615.</li>
</ul>

<p><a id="ToUInt64Unchecked"></a></p>

<h3>ToUInt64Unchecked</h3>

<pre>public ulong ToUInt64Unchecked();
</pre>

<p><b>This API is not CLS-compliant.</b></p>

<p>Converts this number&#39;s value to an integer by discarding its fractional part, and returns the least-significant bits of its two&#39;s-complement form as a 64-bit unsigned integer.</p>

<p><b>Return Value:</b></p>

<p>This number, converted to a 64-bit unsigned integer. Returns 0 if this value is infinity or not-a-number.</p>

<p><a href="/Numbers/">Back to Numbers start page.</a></p>
</div><nav id="navigation"><ul>
<li><a href="/">Back to start site.</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io">This site's repository (source code)</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io/issues">Post an issue or comment</a></ul>

<div class="noprint">
<p>
<a href="//twitter.com/intent/tweet">Share via Twitter</a>, <a href="//www.facebook.com/sharer/sharer.php" id="sharer">Share via Facebook</a>
</p>
</div>
</nav></body></html>
