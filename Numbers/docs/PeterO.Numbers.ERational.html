<!DOCTYPE html><html xmlns:dc="http://purl.org/dc/terms/"><head><meta http-equiv=Content-Type content="text/html; charset=utf-8"><title>PeterO.Numbers.ERational</title><meta name="viewport" content="width=device-width"><link rel=stylesheet type="text/css" href="/style.css">
            <script type="text/x-mathjax-config"> MathJax.Hub.Config({"HTML-CSS": { availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, preferredFont: "TeX" },
                    tex2jax: { displayMath: [ ["$$","$$"], ["\\[", "\\]"] ], inlineMath: [ ["$", "$"], ["\\\\(","\\\\)"] ], processEscapes: true } });
            </script><script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"></script></head><body>  <div class="header">
<nav><p><a href="#navigation">Menu</a> - <a href="#top">Top</a> - <a href="/">Home</a></nav></div>
<div class="mainarea" id="top">
<h1>PeterO.Numbers.ERational</h1>
<p>## PeterO.Numbers.ERational</p>

<pre>public sealed class ERational :
    System.IComparable,
    System.IEquatable
</pre>

<p>Represents an arbitrary-precision rational number. This class can’t be inherited. (The “E” stands for “extended”, meaning that instances of this class can be values other than numbers proper, such as infinity and not-a-number.) In this class, a rational number consists of a numerator and denominator, each an arbitrary-precision integer (EInteger), and this class does not automatically convert rational numbers to lowest terms. <b>Thread safety:</b> Instances of this class are immutable, so they are inherently safe for use by multiple threads. Multiple instances of this object with the same properties are interchangeable, so they should not be compared using the “==” operator (which might only check if each side of the operator is the same instance).</p>

<h3 id="member-summary">Member Summary</h3>
<ul>
  <li><code>[Abs()](#Abs)</code> - Returns the absolute value of this rational number, that is, a number with the same value as this one but as a nonnegative number.</li>
  <li><code>[Add(int)](#Add_int)</code> -</li>
  <li><code>[Add(long)](#Add_long)</code> -</li>
  <li><code>[Add(PeterO.Numbers.ERational)](#Add_PeterO_Numbers_ERational)</code> -</li>
  <li><code>[CompareTo(int)](#CompareTo_int)</code> -</li>
  <li><code>[CompareTo(long)](#CompareTo_long)</code> -</li>
  <li><code>[CompareTo(PeterO.Numbers.ERational)](#CompareTo_PeterO_Numbers_ERational)</code> -</li>
  <li><code>[CompareToBinary(PeterO.Numbers.EFloat)](#CompareToBinary_PeterO_Numbers_EFloat)</code> -</li>
  <li><code>[CompareToDecimal(PeterO.Numbers.EDecimal)](#CompareToDecimal_PeterO_Numbers_EDecimal)</code> -</li>
  <li><code>[CompareToTotal(PeterO.Numbers.ERational)](#CompareToTotal_PeterO_Numbers_ERational)</code> -</li>
  <li><code>[CompareToTotalMagnitude(PeterO.Numbers.ERational)](#CompareToTotalMagnitude_PeterO_Numbers_ERational)</code> -</li>
  <li><code>[CompareToValue(int)](#CompareToValue_int)</code> -</li>
  <li><code>[CompareToValue(long)](#CompareToValue_long)</code> -</li>
  <li><code>[CompareToValue(PeterO.Numbers.ERational)](#CompareToValue_PeterO_Numbers_ERational)</code> -</li>
  <li><code>[Copy()](#Copy)</code> - Creates a copy of this arbitrary-precision rational number.</li>
  <li><code>[CopySign(PeterO.Numbers.ERational)](#CopySign_PeterO_Numbers_ERational)</code> -</li>
  <li><code>[Create(int, int)](#Create_int_int)</code> -</li>
  <li><code>[Create(long, long)](#Create_long_long)</code> -</li>
  <li><code>[Create(PeterO.Numbers.EInteger, PeterO.Numbers.EInteger)](#Create_PeterO_Numbers_EInteger_PeterO_Numbers_EInteger)</code> -</li>
  <li><code>[CreateNaN(PeterO.Numbers.EInteger)](#CreateNaN_PeterO_Numbers_EInteger)</code> -</li>
  <li><code>[CreateNaN(PeterO.Numbers.EInteger, bool, bool)](#CreateNaN_PeterO_Numbers_EInteger_bool_bool)</code> -</li>
  <li><code>[Decrement()](#Decrement)</code> - Subtracts one from an arbitrary-precision rational number.</li>
  <li><code>[Denominator](#Denominator)</code> - Gets this object’s denominator.</li>
  <li><code>[Divide(int)](#Divide_int)</code> -</li>
  <li><code>[Divide(long)](#Divide_long)</code> -</li>
  <li><code>[Divide(PeterO.Numbers.ERational)](#Divide_PeterO_Numbers_ERational)</code> -</li>
  <li><code>[Equals(object)](#Equals_object)</code> -</li>
  <li><code>[Equals(PeterO.Numbers.ERational)](#Equals_PeterO_Numbers_ERational)</code> -</li>
  <li><code>[explicit operator byte(PeterO.Numbers.ERational)](#explicit_operator_byte_PeterO_Numbers_ERational)</code> -</li>
  <li><code>[explicit operator decimal(PeterO.Numbers.ERational)](#explicit_operator_decimal_PeterO_Numbers_ERational)</code> -</li>
  <li><code>[explicit operator double(PeterO.Numbers.ERational)](#explicit_operator_double_PeterO_Numbers_ERational)</code> -</li>
  <li><code>[explicit operator float(PeterO.Numbers.ERational)](#explicit_operator_float_PeterO_Numbers_ERational)</code> -</li>
  <li><code>[explicit operator int(PeterO.Numbers.ERational)](#explicit_operator_int_PeterO_Numbers_ERational)</code> -</li>
  <li><code>[explicit operator long(PeterO.Numbers.ERational)](#explicit_operator_long_PeterO_Numbers_ERational)</code> -</li>
  <li><code>[explicit operator PeterO.Numbers.EInteger(PeterO.Numbers.ERational)](#explicit_operator_PeterO_Numbers_EInteger_PeterO_Numbers_ERational)</code> -</li>
  <li><code>[explicit operator PeterO.Numbers.ERational(bool)](#explicit_operator_PeterO_Numbers_ERational_bool)</code> -</li>
  <li><code>[explicit operator sbyte(PeterO.Numbers.ERational)](#explicit_operator_sbyte_PeterO_Numbers_ERational)</code> -</li>
  <li><code>[explicit operator short(PeterO.Numbers.ERational)](#explicit_operator_short_PeterO_Numbers_ERational)</code> -</li>
  <li><code>[explicit operator uint(PeterO.Numbers.ERational)](#explicit_operator_uint_PeterO_Numbers_ERational)</code> -</li>
  <li><code>[explicit operator ulong(PeterO.Numbers.ERational)](#explicit_operator_ulong_PeterO_Numbers_ERational)</code> -</li>
  <li><code>[explicit operator ushort(PeterO.Numbers.ERational)](#explicit_operator_ushort_PeterO_Numbers_ERational)</code> -</li>
  <li><code>[FromBoolean(bool)](#FromBoolean_bool)</code> -</li>
  <li><code>[FromByte(byte)](#FromByte_byte)</code> -</li>
  <li><code>[FromDecimal(decimal)](#FromDecimal_decimal)</code> -</li>
  <li><code>[FromDouble(double)](#FromDouble_double)</code> -</li>
  <li><code>[FromDoubleBits(long)](#FromDoubleBits_long)</code> -</li>
  <li><code>[FromEDecimal(PeterO.Numbers.EDecimal)](#FromEDecimal_PeterO_Numbers_EDecimal)</code> -</li>
  <li><code>[FromEFloat(PeterO.Numbers.EFloat)](#FromEFloat_PeterO_Numbers_EFloat)</code> -</li>
  <li><code>[FromEInteger(PeterO.Numbers.EInteger)](#FromEInteger_PeterO_Numbers_EInteger)</code> -</li>
  <li><code>[FromExtendedDecimal(PeterO.Numbers.EDecimal)](#FromExtendedDecimal_PeterO_Numbers_EDecimal)</code> - <b>Deprecated:</b> Renamed to FromEDecimal.</li>
  <li><code>[FromExtendedFloat(PeterO.Numbers.EFloat)](#FromExtendedFloat_PeterO_Numbers_EFloat)</code> - <b>Deprecated:</b> Renamed to FromEFloat.</li>
  <li><code>[FromHalfBits(short)](#FromHalfBits_short)</code> -</li>
  <li><code>[FromInt16(short)](#FromInt16_short)</code> -</li>
  <li><code>[FromInt32(int)](#FromInt32_int)</code> -</li>
  <li><code>[FromInt64(long)](#FromInt64_long)</code> -</li>
  <li><code>[FromInt64AsUnsigned(long)](#FromInt64AsUnsigned_long)</code> -</li>
  <li><code>[FromSByte(sbyte)](#FromSByte_sbyte)</code> -</li>
  <li><code>[FromSingle(float)](#FromSingle_float)</code> -</li>
  <li><code>[FromSingleBits(int)](#FromSingleBits_int)</code> -</li>
  <li><code>[FromString(byte[])](#FromString_byte)</code> -</li>
  <li><code>[FromString(byte[], int, int)](#FromString_byte_int_int)</code> -</li>
  <li><code>[FromString(char[])](#FromString_char)</code> -</li>
  <li><code>[FromString(char[], int, int)](#FromString_char_int_int)</code> -</li>
  <li><code>[FromString(string)](#FromString_string)</code> -</li>
  <li><code>[FromString(string, int, int)](#FromString_string_int_int)</code> -</li>
  <li><code>[FromUInt16(ushort)](#FromUInt16_ushort)</code> -</li>
  <li><code>[FromUInt32(uint)](#FromUInt32_uint)</code> -</li>
  <li><code>[FromUInt64(ulong)](#FromUInt64_ulong)</code> -</li>
  <li><code>[GetHashCode()](#GetHashCode)</code> - Returns the hash code for this instance.</li>
  <li><code>[implicit operator PeterO.Numbers.ERational(byte)](#implicit_operator_PeterO_Numbers_ERational_byte)</code> -</li>
  <li><code>[implicit operator PeterO.Numbers.ERational(decimal)](#implicit_operator_PeterO_Numbers_ERational_decimal)</code> -</li>
  <li><code>[implicit operator PeterO.Numbers.ERational(double)](#implicit_operator_PeterO_Numbers_ERational_double)</code> -</li>
  <li><code>[implicit operator PeterO.Numbers.ERational(float)](#implicit_operator_PeterO_Numbers_ERational_float)</code> -</li>
  <li><code>[implicit operator PeterO.Numbers.ERational(int)](#implicit_operator_PeterO_Numbers_ERational_int)</code> -</li>
  <li><code>[implicit operator PeterO.Numbers.ERational(long)](#implicit_operator_PeterO_Numbers_ERational_long)</code> -</li>
  <li><code>[implicit operator PeterO.Numbers.ERational(PeterO.Numbers.EDecimal)](#implicit_operator_PeterO_Numbers_ERational_PeterO_Numbers_EDecimal)</code> -</li>
  <li><code>[implicit operator PeterO.Numbers.ERational(PeterO.Numbers.EFloat)](#implicit_operator_PeterO_Numbers_ERational_PeterO_Numbers_EFloat)</code> -</li>
  <li><code>[implicit operator PeterO.Numbers.ERational(PeterO.Numbers.EInteger)](#implicit_operator_PeterO_Numbers_ERational_PeterO_Numbers_EInteger)</code> -</li>
  <li><code>[implicit operator PeterO.Numbers.ERational(sbyte)](#implicit_operator_PeterO_Numbers_ERational_sbyte)</code> -</li>
  <li><code>[implicit operator PeterO.Numbers.ERational(short)](#implicit_operator_PeterO_Numbers_ERational_short)</code> -</li>
  <li><code>[implicit operator PeterO.Numbers.ERational(uint)](#implicit_operator_PeterO_Numbers_ERational_uint)</code> -</li>
  <li><code>[implicit operator PeterO.Numbers.ERational(ulong)](#implicit_operator_PeterO_Numbers_ERational_ulong)</code> -</li>
  <li><code>[implicit operator PeterO.Numbers.ERational(ushort)](#implicit_operator_PeterO_Numbers_ERational_ushort)</code> -</li>
  <li><code>[Increment()](#Increment)</code> - Adds one to an arbitrary-precision rational number.</li>
  <li><code>[IsFinite](#IsFinite)</code> - Gets a value indicating whether this object is finite (not infinity or NaN).</li>
  <li><code>[IsInfinity()](#IsInfinity)</code> - Gets a value indicating whether this object’s value is infinity.</li>
  <li><code>[IsInteger()](#IsInteger)</code> - Returns whether this object’s value is an integer.</li>
  <li><code>[IsNaN()](#IsNaN)</code> - Returns whether this object is a not-a-number value.</li>
  <li><code>[IsNegative](#IsNegative)</code> - Gets a value indicating whether this object’s value is negative (including negative zero).</li>
  <li><code>[IsNegativeInfinity()](#IsNegativeInfinity)</code> - Returns whether this object is negative infinity.</li>
  <li><code>[IsPositiveInfinity()](#IsPositiveInfinity)</code> - Returns whether this object is positive infinity.</li>
  <li><code>[IsQuietNaN()](#IsQuietNaN)</code> - Returns whether this object is a quiet not-a-number value.</li>
  <li><code>[IsSignalingNaN()](#IsSignalingNaN)</code> - Returns whether this object is a signaling not-a-number value (which causes an error if the value is passed to any arithmetic operation in this class).</li>
  <li><code>[IsZero](#IsZero)</code> - Gets a value indicating whether this object’s value equals 0.</li>
  <li><code>[Max(PeterO.Numbers.ERational, PeterO.Numbers.ERational)](#Max_PeterO_Numbers_ERational_PeterO_Numbers_ERational)</code> -</li>
  <li><code>[MaxMagnitude(PeterO.Numbers.ERational, PeterO.Numbers.ERational)](#MaxMagnitude_PeterO_Numbers_ERational_PeterO_Numbers_ERational)</code> -</li>
  <li><code>[Min(PeterO.Numbers.ERational, PeterO.Numbers.ERational)](#Min_PeterO_Numbers_ERational_PeterO_Numbers_ERational)</code> -</li>
  <li><code>[MinMagnitude(PeterO.Numbers.ERational, PeterO.Numbers.ERational)](#MinMagnitude_PeterO_Numbers_ERational_PeterO_Numbers_ERational)</code> -</li>
  <li><code>[Multiply(int)](#Multiply_int)</code> -</li>
  <li><code>[Multiply(long)](#Multiply_long)</code> -</li>
  <li><code>[Multiply(PeterO.Numbers.ERational)](#Multiply_PeterO_Numbers_ERational)</code> -</li>
  <li><code>[public static readonly PeterO.Numbers.ERational NaN;](#NaN)</code> - A not-a-number value.</li>
  <li><code>[Negate()](#Negate)</code> - Returns a rational number with the same value as this one but with the sign reversed.</li>
  <li><code>[public static readonly PeterO.Numbers.ERational NegativeInfinity;](#NegativeInfinity)</code> - Negative infinity, less than any other number.</li>
  <li><code>[public static readonly PeterO.Numbers.ERational NegativeZero;](#NegativeZero)</code> - A rational number for negative zero.</li>
  <li><code>[Numerator](#Numerator)</code> - Gets this object’s numerator.</li>
  <li><code>[public static readonly PeterO.Numbers.ERational One;](#One)</code> - The rational number one.</li>
  <li><code>[PeterO.Numbers.ERational operator +(PeterO.Numbers.ERational, PeterO.Numbers.ERational)](#op_Addition)</code> -</li>
  <li><code>[PeterO.Numbers.ERational operator --(PeterO.Numbers.ERational)](#op_Decrement)</code> -</li>
  <li><code>[PeterO.Numbers.ERational operator /(PeterO.Numbers.ERational, PeterO.Numbers.ERational)](#op_Division)</code> -</li>
  <li><code>[PeterO.Numbers.ERational operator ++(PeterO.Numbers.ERational)](#op_Increment)</code> -</li>
  <li><code>[PeterO.Numbers.ERational operator %(PeterO.Numbers.ERational, PeterO.Numbers.ERational)](#op_Modulus)</code> -</li>
  <li><code>[PeterO.Numbers.ERational operator &#x2a;(PeterO.Numbers.ERational, PeterO.Numbers.ERational)](#op_Multiply)</code> -</li>
  <li><code>[PeterO.Numbers.ERational operator -(PeterO.Numbers.ERational, PeterO.Numbers.ERational)](#op_Subtraction)</code> -</li>
  <li><code>[PeterO.Numbers.ERational operator -(PeterO.Numbers.ERational)](#op_UnaryNegation)</code> -</li>
  <li><code>[public static readonly PeterO.Numbers.ERational PositiveInfinity;](#PositiveInfinity)</code> - Positive infinity, greater than any other number.</li>
  <li><code>[Remainder(int)](#Remainder_int)</code> -</li>
  <li><code>[Remainder(long)](#Remainder_long)</code> -</li>
  <li><code>[Remainder(PeterO.Numbers.ERational)](#Remainder_PeterO_Numbers_ERational)</code> -</li>
  <li><code>[Sign](#Sign)</code> - Gets the sign of this rational number.</li>
  <li><code>[public static readonly PeterO.Numbers.ERational SignalingNaN;](#SignalingNaN)</code> - A signaling not-a-number value.</li>
  <li><code>[Subtract(int)](#Subtract_int)</code> -</li>
  <li><code>[Subtract(long)](#Subtract_long)</code> -</li>
  <li><code>[Subtract(PeterO.Numbers.ERational)](#Subtract_PeterO_Numbers_ERational)</code> -</li>
  <li><code>[public static readonly PeterO.Numbers.ERational Ten;](#Ten)</code> - The rational number ten.</li>
  <li><code>[ToByteChecked()](#ToByteChecked)</code> - Converts this number’s value to a byte (from 0 to 255) if it can fit in a byte (from 0 to 255) after converting it to an integer by discarding its fractional part.</li>
  <li><code>[ToByteIfExact()](#ToByteIfExact)</code> - Converts this number’s value to a byte (from 0 to 255) if it can fit in a byte (from 0 to 255) without rounding to a different numerical value.</li>
  <li><code>[ToByteUnchecked()](#ToByteUnchecked)</code> - Converts this number’s value to an integer (using ToEInteger), and returns the least-significant bits of that integer’s two’s-complement form as a byte (from 0 to 255).</li>
  <li><code>[ToDecimal()](#ToDecimal)</code> - Converts this value to a decimal under the Common Language Infrastructure (usually a.</li>
  <li><code>[ToDouble()](#ToDouble)</code> - Converts this value to a 64-bit floating-point number.</li>
  <li><code>[ToDoubleBits()](#ToDoubleBits)</code> - Converts this value to its closest equivalent as a 64-bit floating-point number, expressed as an integer in the IEEE 754 binary64 format.</li>
  <li><code>[ToEDecimal()](#ToEDecimal)</code> - Converts this rational number to an arbitrary-precision decimal number.</li>
  <li><code>[ToEDecimal(PeterO.Numbers.EContext)](#ToEDecimal_PeterO_Numbers_EContext)</code> -</li>
  <li><code>[ToEDecimalExactIfPossible(PeterO.Numbers.EContext)](#ToEDecimalExactIfPossible_PeterO_Numbers_EContext)</code> -</li>
  <li><code>[ToEFloat()](#ToEFloat)</code> - Converts this rational number to a binary floating-point number.</li>
  <li><code>[ToEFloat(PeterO.Numbers.EContext)](#ToEFloat_PeterO_Numbers_EContext)</code> -</li>
  <li><code>[ToEFloatExactIfPossible(PeterO.Numbers.EContext)](#ToEFloatExactIfPossible_PeterO_Numbers_EContext)</code> -</li>
  <li><code>[ToEInteger()](#ToEInteger)</code> - Converts this value to an arbitrary-precision integer by dividing the numerator by the denominator and discarding the fractional part of the result.</li>
  <li><code>[ToEIntegerExact()](#ToEIntegerExact)</code> - <b>Deprecated:</b> Renamed to ToEIntegerIfExact.</li>
  <li><code>[ToEIntegerIfExact()](#ToEIntegerIfExact)</code> - Converts this value to an arbitrary-precision integer, checking whether the value is an exact integer.</li>
  <li><code>[ToExtendedDecimal()](#ToExtendedDecimal)</code> - <b>Deprecated:</b> Renamed to ToEDecimal.</li>
  <li><code>[ToExtendedDecimal(PeterO.Numbers.EContext)](#ToExtendedDecimal_PeterO_Numbers_EContext)</code> - <b>Deprecated:</b> Renamed to ToEDecimal.</li>
  <li><code>[ToExtendedDecimalExactIfPossible(PeterO.Numbers.EContext)](#ToExtendedDecimalExactIfPossible_PeterO_Numbers_EContext)</code> - <b>Deprecated:</b> Renamed to ToEDecimalExactIfPossible.</li>
  <li><code>[ToExtendedFloat()](#ToExtendedFloat)</code> - <b>Deprecated:</b> Renamed to ToEFloat.</li>
  <li><code>[ToExtendedFloat(PeterO.Numbers.EContext)](#ToExtendedFloat_PeterO_Numbers_EContext)</code> - <b>Deprecated:</b> Renamed to ToEFloat.</li>
  <li><code>[ToExtendedFloatExactIfPossible(PeterO.Numbers.EContext)](#ToExtendedFloatExactIfPossible_PeterO_Numbers_EContext)</code> - <b>Deprecated:</b> Renamed to ToEFloatExactIfPossible.</li>
  <li><code>[ToHalfBits()](#ToHalfBits)</code> - Converts this value to its closest equivalent as a binary floating-point number, expressed as an integer in the IEEE 754 binary16 format (also known as a “half-precision” floating-point number).</li>
  <li><code>[ToInt16Checked()](#ToInt16Checked)</code> - Converts this number’s value to a 16-bit signed integer if it can fit in a 16-bit signed integer after converting it to an integer by discarding its fractional part.</li>
  <li><code>[ToInt16IfExact()](#ToInt16IfExact)</code> - Converts this number’s value to a 16-bit signed integer if it can fit in a 16-bit signed integer without rounding to a different numerical value.</li>
  <li><code>[ToInt16Unchecked()](#ToInt16Unchecked)</code> - Converts this number’s value to an integer by discarding its fractional part, and returns the least-significant bits of its two’s-complement form as a 16-bit signed integer.</li>
  <li><code>[ToInt32Checked()](#ToInt32Checked)</code> - Converts this number’s value to a 32-bit signed integer if it can fit in a 32-bit signed integer after converting it to an integer by discarding its fractional part.</li>
  <li><code>[ToInt32IfExact()](#ToInt32IfExact)</code> - Converts this number’s value to a 32-bit signed integer if it can fit in a 32-bit signed integer without rounding to a different numerical value.</li>
  <li><code>[ToInt32Unchecked()](#ToInt32Unchecked)</code> - Converts this number’s value to an integer by discarding its fractional part, and returns the least-significant bits of its two’s-complement form as a 32-bit signed integer.</li>
  <li><code>[ToInt64Checked()](#ToInt64Checked)</code> - Converts this number’s value to a 64-bit signed integer if it can fit in a 64-bit signed integer after converting it to an integer by discarding its fractional part.</li>
  <li><code>[ToInt64IfExact()](#ToInt64IfExact)</code> - Converts this number’s value to a 64-bit signed integer if it can fit in a 64-bit signed integer without rounding to a different numerical value.</li>
  <li><code>[ToInt64Unchecked()](#ToInt64Unchecked)</code> - Converts this number’s value to an integer by discarding its fractional part, and returns the least-significant bits of its two’s-complement form as a 64-bit signed integer.</li>
  <li><code>[ToLowestTerms()](#ToLowestTerms)</code> - Converts this value to its form in lowest terms.</li>
  <li><code>[ToSByteChecked()](#ToSByteChecked)</code> - Converts this number’s value to an 8-bit signed integer if it can fit in an 8-bit signed integer after converting it to an integer by discarding its fractional part.</li>
  <li><code>[ToSByteIfExact()](#ToSByteIfExact)</code> - Converts this number’s value to an 8-bit signed integer if it can fit in an 8-bit signed integer without rounding to a different numerical value.</li>
  <li><code>[ToSByteUnchecked()](#ToSByteUnchecked)</code> - Converts this number’s value to an integer by discarding its fractional part, and returns the least-significant bits of its two’s-complement form as an 8-bit signed integer.</li>
  <li><code>[ToSingle()](#ToSingle)</code> - Converts this value to a 32-bit binary floating-point number.</li>
  <li><code>[ToSingleBits()](#ToSingleBits)</code> - Converts this value to its closest equivalent as 32-bit floating-point number, expressed as an integer in the IEEE 754 binary32 format.</li>
  <li><code>[ToSizedEInteger(int)](#ToSizedEInteger_int)</code> -</li>
  <li><code>[ToSizedEIntegerIfExact(int)](#ToSizedEIntegerIfExact_int)</code> -</li>
  <li><code>[ToString()](#ToString)</code> - Converts this object to a text string.</li>
  <li><code>[ToUInt16Checked()](#ToUInt16Checked)</code> - Converts this number’s value to a 16-bit unsigned integer if it can fit in a 16-bit unsigned integer after converting it to an integer by discarding its fractional part.</li>
  <li><code>[ToUInt16IfExact()](#ToUInt16IfExact)</code> - Converts this number’s value to a 16-bit unsigned integer if it can fit in a 16-bit unsigned integer without rounding to a different numerical value.</li>
  <li><code>[ToUInt16Unchecked()](#ToUInt16Unchecked)</code> - Converts this number’s value to an integer by discarding its fractional part, and returns the least-significant bits of its two’s-complement form as a 16-bit unsigned integer.</li>
  <li><code>[ToUInt32Checked()](#ToUInt32Checked)</code> - Converts this number’s value to a 32-bit signed integer if it can fit in a 32-bit signed integer after converting it to an integer by discarding its fractional part.</li>
  <li><code>[ToUInt32IfExact()](#ToUInt32IfExact)</code> - Converts this number’s value to a 32-bit signed integer if it can fit in a 32-bit signed integer without rounding to a different numerical value.</li>
  <li><code>[ToUInt32Unchecked()](#ToUInt32Unchecked)</code> - Converts this number’s value to an integer by discarding its fractional part, and returns the least-significant bits of its two’s-complement form as a 32-bit signed integer.</li>
  <li><code>[ToUInt64Checked()](#ToUInt64Checked)</code> - Converts this number’s value to a 64-bit unsigned integer if it can fit in a 64-bit unsigned integer after converting it to an integer by discarding its fractional part.</li>
  <li><code>[ToUInt64IfExact()](#ToUInt64IfExact)</code> - Converts this number’s value to a 64-bit unsigned integer if it can fit in a 64-bit unsigned integer without rounding to a different numerical value.</li>
  <li><code>[ToUInt64Unchecked()](#ToUInt64Unchecked)</code> - Converts this number’s value to an integer by discarding its fractional part, and returns the least-significant bits of its two’s-complement form as a 64-bit unsigned integer.</li>
  <li><code>[UnsignedNumerator](#UnsignedNumerator)</code> - Gets this object’s numerator with the sign removed.</li>
  <li><code>[public static readonly PeterO.Numbers.ERational Zero;](#Zero)</code> - A rational number for zero.</li>
</ul>

<p><a id="Void_ctor_PeterO_Numbers_EInteger_PeterO_Numbers_EInteger"></a>
### ERational Constructor</p>

<pre>public ERational(
    PeterO.Numbers.EInteger numerator,
    PeterO.Numbers.EInteger denominator);
</pre>

<p><b>Deprecated.</b> Use the Create method instead.</p>

<p>Initializes a new instance of the <a href="PeterO.Numbers.ERational.html">PeterO.Numbers.ERational</a> class.</p>

<p><b>Parameters:</b></p>

<ul>
  <li>
    <p><i>numerator</i>: An arbitrary-precision integer serving as the numerator.</p>
  </li>
  <li>
    <p><i>denominator</i>: An arbitrary-precision integer serving as the denominator.</p>
  </li>
</ul>

<p><b>Exceptions:</b></p>

<ul>
  <li>
    <p>System.ArgumentNullException:
The parameter  <i>numerator</i>
 or  <i>denominator</i>
 is null.</p>
  </li>
  <li>
    <p>System.ArgumentException:
Denominator is zero.</p>
  </li>
</ul>

<p><a id="NaN"></a>
### NaN</p>

<pre>public static readonly PeterO.Numbers.ERational NaN;
</pre>

<p>A not-a-number value.</p>

<p><a id="NegativeInfinity"></a>
### NegativeInfinity</p>

<pre>public static readonly PeterO.Numbers.ERational NegativeInfinity;
</pre>

<p>Negative infinity, less than any other number.</p>

<p><a id="NegativeZero"></a>
### NegativeZero</p>

<pre>public static readonly PeterO.Numbers.ERational NegativeZero;
</pre>

<p>A rational number for negative zero.</p>

<p><a id="One"></a>
### One</p>

<pre>public static readonly PeterO.Numbers.ERational One;
</pre>

<p>The rational number one.</p>

<p><a id="PositiveInfinity"></a>
### PositiveInfinity</p>

<pre>public static readonly PeterO.Numbers.ERational PositiveInfinity;
</pre>

<p>Positive infinity, greater than any other number.</p>

<p><a id="SignalingNaN"></a>
### SignalingNaN</p>

<pre>public static readonly PeterO.Numbers.ERational SignalingNaN;
</pre>

<p>A signaling not-a-number value.</p>

<p><a id="Ten"></a>
### Ten</p>

<pre>public static readonly PeterO.Numbers.ERational Ten;
</pre>

<p>The rational number ten.</p>

<p><a id="Zero"></a>
### Zero</p>

<pre>public static readonly PeterO.Numbers.ERational Zero;
</pre>

<p>A rational number for zero.</p>

<p><a id="Denominator"></a>
### Denominator</p>

<pre>public PeterO.Numbers.EInteger Denominator { get; }
</pre>

<p>Gets this object’s denominator.</p>

<p><b>Returns:</b></p>

<p>This object’s denominator.</p>

<p><a id="IsFinite"></a>
### IsFinite</p>

<pre>public bool IsFinite { get; }
</pre>

<p>Gets a value indicating whether this object is finite (not infinity or NaN).</p>

<p><b>Returns:</b></p>

<p><code>true</code>  if this object is finite (not infinity or NaN); otherwise,  <code>false</code> .</p>

<p><a id="IsNegative"></a>
### IsNegative</p>

<pre>public bool IsNegative { get; }
</pre>

<p>Gets a value indicating whether this object’s value is negative (including negative zero).</p>

<p><b>Returns:</b></p>

<p><code>true</code>  if this object’s value is negative (including negative zero); otherwise,  <code>false</code> .  <code>true</code>  if this object’s value is negative; otherwise,  <code>false</code> .</p>

<p><a id="IsZero"></a>
### IsZero</p>

<pre>public bool IsZero { get; }
</pre>

<p>Gets a value indicating whether this object’s value equals 0.</p>

<p><b>Returns:</b></p>

<p><code>true</code>  if this object’s value equals 0; otherwise,  <code>false</code> .  <code>true</code>  if this object’s value equals 0; otherwise,  <code>false</code> .</p>

<p><a id="Numerator"></a>
### Numerator</p>

<pre>public PeterO.Numbers.EInteger Numerator { get; }
</pre>

<p>Gets this object’s numerator.</p>

<p><b>Returns:</b></p>

<p>This object’s numerator. If this object is a not-a-number value, returns the diagnostic information (which will be negative if this object is negative).</p>

<p><a id="Sign"></a>
### Sign</p>

<pre>public int Sign { get; }
</pre>

<p>Gets the sign of this rational number.</p>

<p><b>Returns:</b></p>

<p>The sign of this rational number.</p>

<p><a id="UnsignedNumerator"></a>
### UnsignedNumerator</p>

<pre>public PeterO.Numbers.EInteger UnsignedNumerator { get; }
</pre>

<p>Gets this object’s numerator with the sign removed.</p>

<p><b>Returns:</b></p>

<p>This object’s numerator. If this object is a not-a-number value, returns the diagnostic information.</p>

<p><a id="Abs"></a>
### Abs</p>

<pre>public PeterO.Numbers.ERational Abs();
</pre>

<p>Returns the absolute value of this rational number, that is, a number with the same value as this one but as a nonnegative number.</p>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision rational number.</p>

<p><a id="Copy"></a>
### Copy</p>

<pre>public PeterO.Numbers.ERational Copy();
</pre>

<p>Creates a copy of this arbitrary-precision rational number.</p>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision rational number.</p>

<p><a id="Decrement"></a>
### Decrement</p>

<pre>public PeterO.Numbers.ERational Decrement();
</pre>

<p>Subtracts one from an arbitrary-precision rational number.</p>

<p><b>Return Value:</b></p>

<p>The given arbitrary-precision rational number minus one.</p>

<p><a id="GetHashCode"></a>
### GetHashCode</p>

<pre>public override int GetHashCode();
</pre>

<p>Returns the hash code for this instance. No application or process IDs are used in the hash code calculation.</p>

<p><b>Return Value:</b></p>

<p>A 32-bit signed integer.</p>

<p><a id="Increment"></a>
### Increment</p>

<pre>public PeterO.Numbers.ERational Increment();
</pre>

<p>Adds one to an arbitrary-precision rational number.</p>

<p><b>Return Value:</b></p>

<p>The given arbitrary-precision rational number plus one.</p>

<p><a id="IsInfinity"></a>
### IsInfinity</p>

<pre>public bool IsInfinity();
</pre>

<p>Gets a value indicating whether this object’s value is infinity.</p>

<p><b>Return Value:</b></p>

<p><code>true</code>  if this object’s value is infinity; otherwise,  <code>false</code> .</p>

<p><a id="IsInteger"></a>
### IsInteger</p>

<pre>public bool IsInteger();
</pre>

<p>Returns whether this object’s value is an integer.</p>

<p><b>Return Value:</b></p>

<p><code>true</code>  if this object’s value is an integer; otherwise,  <code>false</code> .</p>

<p><a id="IsNaN"></a>
### IsNaN</p>

<pre>public bool IsNaN();
</pre>

<p>Returns whether this object is a not-a-number value.</p>

<p><b>Return Value:</b></p>

<p><code>true</code>  if this object is a not-a-number value; otherwise,  <code>false</code> .</p>

<p><a id="IsNegativeInfinity"></a>
### IsNegativeInfinity</p>

<pre>public bool IsNegativeInfinity();
</pre>

<p>Returns whether this object is negative infinity.</p>

<p><b>Return Value:</b></p>

<p><code>true</code>  if this object is negative infinity; otherwise,  <code>false</code> .</p>

<p><a id="IsPositiveInfinity"></a>
### IsPositiveInfinity</p>

<pre>public bool IsPositiveInfinity();
</pre>

<p>Returns whether this object is positive infinity.</p>

<p><b>Return Value:</b></p>

<p><code>true</code>  if this object is positive infinity; otherwise,  <code>false</code> .</p>

<p><a id="IsQuietNaN"></a>
### IsQuietNaN</p>

<pre>public bool IsQuietNaN();
</pre>

<p>Returns whether this object is a quiet not-a-number value.</p>

<p><b>Return Value:</b></p>

<p><code>true</code>  if this object is a quiet not-a-number value; otherwise,  <code>false</code> .</p>

<p><a id="IsSignalingNaN"></a>
### IsSignalingNaN</p>

<pre>public bool IsSignalingNaN();
</pre>

<p>Returns whether this object is a signaling not-a-number value (which causes an error if the value is passed to any arithmetic operation in this class).</p>

<p><b>Return Value:</b></p>

<p><code>true</code>  if this object is a signaling not-a-number value (which causes an error if the value is passed to any arithmetic operation in this class); otherwise,  <code>false</code> .</p>

<p><a id="Negate"></a>
### Negate</p>

<pre>public PeterO.Numbers.ERational Negate();
</pre>

<p>Returns a rational number with the same value as this one but with the sign reversed.</p>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision rational number.</p>

<p><a id="ToByteChecked"></a>
### ToByteChecked</p>

<pre>public byte ToByteChecked();
</pre>

<p>Converts this number’s value to a byte (from 0 to 255) if it can fit in a byte (from 0 to 255) after converting it to an integer by discarding its fractional part.</p>

<p><b>Return Value:</b></p>

<p>This number’s value, truncated to a byte (from 0 to 255).</p>

<p><b>Exceptions:</b></p>

<ul>
  <li>System.OverflowException:
This value is infinity or not-a-number, or the number, once converted to an integer by discarding its fractional part, is less than 0 or greater than 255.</li>
</ul>

<p><a id="ToByteIfExact"></a>
### ToByteIfExact</p>

<pre>public byte ToByteIfExact();
</pre>

<p>Converts this number’s value to a byte (from 0 to 255) if it can fit in a byte (from 0 to 255) without rounding to a different numerical value.</p>

<p><b>Return Value:</b></p>

<p>This number’s value as a byte (from 0 to 255).</p>

<p><b>Exceptions:</b></p>

<ul>
  <li>System.ArithmeticException:
This value is infinity or not-a-number, is not an exact integer, or is less than 0 or greater than 255.</li>
</ul>

<p><a id="ToByteUnchecked"></a>
### ToByteUnchecked</p>

<pre>public byte ToByteUnchecked();
</pre>

<p>Converts this number’s value to an integer (using ToEInteger), and returns the least-significant bits of that integer’s two’s-complement form as a byte (from 0 to 255).</p>

<p><b>Return Value:</b></p>

<p>This number, converted to a byte (from 0 to 255). Returns 0 if this value is infinity or not-a-number.</p>

<p><a id="ToDecimal"></a>
### ToDecimal</p>

<pre>public decimal ToDecimal();
</pre>

<p>Converts this value to a  <code>decimal</code>  under the Common Language Infrastructure (usually a.NET Framework decimal). Currently, converts this value to the precision and range of a.NET Framework decimal.</p>

<p><b>Return Value:</b></p>

<p>A  <code>decimal</code>  under the Common Language Infrastructure (usually a.NET Framework decimal).</p>

<p><a id="ToDouble"></a>
### ToDouble</p>

<pre>public double ToDouble();
</pre>

<p>Converts this value to a 64-bit floating-point number. The half-even rounding mode is used.</p>

<p><b>Return Value:</b></p>

<p>The closest 64-bit floating-point number to this value. The return value can be positive infinity or negative infinity if this value exceeds the range of a 64-bit floating point number.</p>

<p><a id="ToDoubleBits"></a>
### ToDoubleBits</p>

<pre>public long ToDoubleBits();
</pre>

<p>Converts this value to its closest equivalent as a 64-bit floating-point number, expressed as an integer in the IEEE 754 binary64 format. The half-even rounding mode is used. If this value is a NaN, sets the high bit of the 64-bit floating point number’s significand area for a quiet NaN, and clears it for a signaling NaN. Then the other bits of the significand area are set to the lowest bits of this object’s unsigned significand, and the next-highest bit of the significand area is set if those bits are all zeros and this is a signaling NaN.</p>

<p><b>Return Value:</b></p>

<p>The closest 64-bit binary floating-point number to this value, expressed as an integer in the IEEE 754 binary64 format. The return value can be positive infinity or negative infinity if this value exceeds the range of a 64-bit floating point number.</p>

<p><a id="ToEDecimal"></a>
### ToEDecimal</p>

<pre>public PeterO.Numbers.EDecimal ToEDecimal();
</pre>

<p>Converts this rational number to an arbitrary-precision decimal number.</p>

<p><b>Return Value:</b></p>

<p>The exact value of the rational number, or not-a-number (NaN) if the result can’t be exact because it has a nonterminating decimal expansion.</p>

<p><a id="ToEFloat"></a>
### ToEFloat</p>

<pre>public PeterO.Numbers.EFloat ToEFloat();
</pre>

<p>Converts this rational number to a binary floating-point number.</p>

<p><b>Return Value:</b></p>

<p>The exact value of the rational number, or not-a-number (NaN) if the result can’t be exact because it has a nonterminating binary expansion.</p>

<p><a id="ToEInteger"></a>
### ToEInteger</p>

<pre>public PeterO.Numbers.EInteger ToEInteger();
</pre>

<p>Converts this value to an arbitrary-precision integer by dividing the numerator by the denominator and discarding the fractional part of the result.</p>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision integer.</p>

<p><b>Exceptions:</b></p>

<ul>
  <li>System.OverflowException:
This object’s value is infinity or not-a-number (NaN).</li>
</ul>

<p><a id="ToEIntegerExact"></a>
### ToEIntegerExact</p>

<pre>public PeterO.Numbers.EInteger ToEIntegerExact();
</pre>

<p><b>Deprecated.</b> Renamed to ToEIntegerIfExact.</p>

<p>Converts this value to an arbitrary-precision integer, checking whether the value is an exact integer.</p>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision integer.</p>

<p><b>Exceptions:</b></p>

<ul>
  <li>System.OverflowException:
This object’s value is infinity or not-a-number (NaN).</li>
</ul>

<p><a id="ToEIntegerIfExact"></a>
### ToEIntegerIfExact</p>

<pre>public PeterO.Numbers.EInteger ToEIntegerIfExact();
</pre>

<p>Converts this value to an arbitrary-precision integer, checking whether the value is an exact integer.</p>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision integer.</p>

<p><b>Exceptions:</b></p>

<ul>
  <li>System.OverflowException:
This object’s value is infinity or not-a-number (NaN).</li>
</ul>

<p><a id="ToExtendedDecimal"></a>
### ToExtendedDecimal</p>

<pre>public PeterO.Numbers.EDecimal ToExtendedDecimal();
</pre>

<p><b>Deprecated.</b> Renamed to ToEDecimal.</p>

<p>Converts this rational number to an arbitrary-precision decimal number.</p>

<p><b>Return Value:</b></p>

<p>The exact value of the rational number, or not-a-number (NaN) if the result can’t be exact because it has a nonterminating decimal expansion.</p>

<p><a id="ToExtendedFloat"></a>
### ToExtendedFloat</p>

<pre>public PeterO.Numbers.EFloat ToExtendedFloat();
</pre>

<p><b>Deprecated.</b> Renamed to ToEFloat.</p>

<p>Converts this rational number to a binary floating-point number.</p>

<p><b>Return Value:</b></p>

<p>The exact value of the rational number, or not-a-number (NaN) if the result can’t be exact because it has a nonterminating binary expansion.</p>

<p><a id="ToHalfBits"></a>
### ToHalfBits</p>

<pre>public short ToHalfBits();
</pre>

<p>Converts this value to its closest equivalent as a binary floating-point number, expressed as an integer in the IEEE 754 binary16 format (also known as a “half-precision” floating-point number). The half-even rounding mode is used. If this value is a NaN, sets the high bit of the binary16 number’s significand area for a quiet NaN, and clears it for a signaling NaN. Then the other bits of the significand area are set to the lowest bits of this object’s unsigned significand, and the next-highest bit of the significand area is set if those bits are all zeros and this is a signaling NaN.</p>

<p><b>Return Value:</b></p>

<p>The closest binary floating-point number to this value, expressed as an integer in the IEEE 754 binary16 format. The return value can be positive infinity or negative infinity if this value exceeds the range of a floating-point number in the binary16 format.</p>

<p><a id="ToInt16Checked"></a>
### ToInt16Checked</p>

<pre>public short ToInt16Checked();
</pre>

<p>Converts this number’s value to a 16-bit signed integer if it can fit in a 16-bit signed integer after converting it to an integer by discarding its fractional part.</p>

<p><b>Return Value:</b></p>

<p>This number’s value, truncated to a 16-bit signed integer.</p>

<p><b>Exceptions:</b></p>

<ul>
  <li>System.OverflowException:
This value is infinity or not-a-number, or the number, once converted to an integer by discarding its fractional part, is less than -32768 or greater than 32767.</li>
</ul>

<p><a id="ToInt16IfExact"></a>
### ToInt16IfExact</p>

<pre>public short ToInt16IfExact();
</pre>

<p>Converts this number’s value to a 16-bit signed integer if it can fit in a 16-bit signed integer without rounding to a different numerical value.</p>

<p><b>Return Value:</b></p>

<p>This number’s value as a 16-bit signed integer.</p>

<p><b>Exceptions:</b></p>

<ul>
  <li>System.ArithmeticException:
This value is infinity or not-a-number, is not an exact integer, or is less than -32768 or greater than 32767.</li>
</ul>

<p><a id="ToInt16Unchecked"></a>
### ToInt16Unchecked</p>

<pre>public short ToInt16Unchecked();
</pre>

<p>Converts this number’s value to an integer by discarding its fractional part, and returns the least-significant bits of its two’s-complement form as a 16-bit signed integer.</p>

<p><b>Return Value:</b></p>

<p>This number, converted to a 16-bit signed integer. Returns 0 if this value is infinity or not-a-number.</p>

<p><a id="ToInt32Checked"></a>
### ToInt32Checked</p>

<pre>public int ToInt32Checked();
</pre>

<p>Converts this number’s value to a 32-bit signed integer if it can fit in a 32-bit signed integer after converting it to an integer by discarding its fractional part.</p>

<p><b>Return Value:</b></p>

<p>This number’s value, truncated to a 32-bit signed integer.</p>

<p><b>Exceptions:</b></p>

<ul>
  <li>System.OverflowException:
This value is infinity or not-a-number, or the number, once converted to an integer by discarding its fractional part, is less than -2147483648 or greater than 2147483647.</li>
</ul>

<p><a id="ToInt32IfExact"></a>
### ToInt32IfExact</p>

<pre>public int ToInt32IfExact();
</pre>

<p>Converts this number’s value to a 32-bit signed integer if it can fit in a 32-bit signed integer without rounding to a different numerical value.</p>

<p><b>Return Value:</b></p>

<p>This number’s value as a 32-bit signed integer.</p>

<p><b>Exceptions:</b></p>

<ul>
  <li>System.ArithmeticException:
This value is infinity or not-a-number, is not an exact integer, or is less than -2147483648 or greater than 2147483647.</li>
</ul>

<p><a id="ToInt32Unchecked"></a>
### ToInt32Unchecked</p>

<pre>public int ToInt32Unchecked();
</pre>

<p>Converts this number’s value to an integer by discarding its fractional part, and returns the least-significant bits of its two’s-complement form as a 32-bit signed integer.</p>

<p><b>Return Value:</b></p>

<p>This number, converted to a 32-bit signed integer. Returns 0 if this value is infinity or not-a-number.</p>

<p><a id="ToInt64Checked"></a>
### ToInt64Checked</p>

<pre>public long ToInt64Checked();
</pre>

<p>Converts this number’s value to a 64-bit signed integer if it can fit in a 64-bit signed integer after converting it to an integer by discarding its fractional part.</p>

<p><b>Return Value:</b></p>

<p>This number’s value, truncated to a 64-bit signed integer.</p>

<p><b>Exceptions:</b></p>

<ul>
  <li>System.OverflowException:
This value is infinity or not-a-number, or the number, once converted to an integer by discarding its fractional part, is less than -9223372036854775808 or greater than 9223372036854775807.</li>
</ul>

<p><a id="ToInt64IfExact"></a>
### ToInt64IfExact</p>

<pre>public long ToInt64IfExact();
</pre>

<p>Converts this number’s value to a 64-bit signed integer if it can fit in a 64-bit signed integer without rounding to a different numerical value.</p>

<p><b>Return Value:</b></p>

<p>This number’s value as a 64-bit signed integer.</p>

<p><b>Exceptions:</b></p>

<ul>
  <li>System.ArithmeticException:
This value is infinity or not-a-number, is not an exact integer, or is less than -9223372036854775808 or greater than 9223372036854775807.</li>
</ul>

<p><a id="ToInt64Unchecked"></a>
### ToInt64Unchecked</p>

<pre>public long ToInt64Unchecked();
</pre>

<p>Converts this number’s value to an integer by discarding its fractional part, and returns the least-significant bits of its two’s-complement form as a 64-bit signed integer.</p>

<p><b>Return Value:</b></p>

<p>This number, converted to a 64-bit signed integer. Returns 0 if this value is infinity or not-a-number.</p>

<p><a id="ToLowestTerms"></a>
### ToLowestTerms</p>

<pre>public PeterO.Numbers.ERational ToLowestTerms();
</pre>

<p>Converts this value to its form in lowest terms. For example, (8/4) becomes (4/1).</p>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision rational with the same value as this one but in lowest terms. Returns this object if it is infinity or NaN. Returns ERational.NegativeZero if this object is a negative zero. Returns ERational.Zero if this object is a positive zero.</p>

<p><b>Exceptions:</b></p>

<ul>
  <li>System.OverflowException:
This object’s value is infinity or not-a-number (NaN).</li>
</ul>

<p><a id="ToSByteChecked"></a>
### ToSByteChecked</p>

<pre>public sbyte ToSByteChecked();
</pre>

<p><b>This API is not CLS-compliant.</b></p>

<p>Converts this number’s value to an 8-bit signed integer if it can fit in an 8-bit signed integer after converting it to an integer by discarding its fractional part.</p>

<p><b>Return Value:</b></p>

<p>This number’s value, truncated to an 8-bit signed integer.</p>

<p><b>Exceptions:</b></p>

<ul>
  <li>System.OverflowException:
This value is infinity or not-a-number, or the number, once converted to an integer by discarding its fractional part, is less than -128 or greater than 127.</li>
</ul>

<p><a id="ToSByteIfExact"></a>
### ToSByteIfExact</p>

<pre>public sbyte ToSByteIfExact();
</pre>

<p><b>This API is not CLS-compliant.</b></p>

<p>Converts this number’s value to an 8-bit signed integer if it can fit in an 8-bit signed integer without rounding to a different numerical value.</p>

<p><b>Return Value:</b></p>

<p>This number’s value as an 8-bit signed integer.</p>

<p><b>Exceptions:</b></p>

<ul>
  <li>System.ArithmeticException:
This value is infinity or not-a-number, is not an exact integer, or is less than -128 or greater than 127.</li>
</ul>

<p><a id="ToSByteUnchecked"></a>
### ToSByteUnchecked</p>

<pre>public sbyte ToSByteUnchecked();
</pre>

<p><b>This API is not CLS-compliant.</b></p>

<p>Converts this number’s value to an integer by discarding its fractional part, and returns the least-significant bits of its two’s-complement form as an 8-bit signed integer.</p>

<p><b>Return Value:</b></p>

<p>This number, converted to an 8-bit signed integer. Returns 0 if this value is infinity or not-a-number.</p>

<p><a id="ToSingle"></a>
### ToSingle</p>

<pre>public float ToSingle();
</pre>

<p>Converts this value to a 32-bit binary floating-point number. The half-even rounding mode is used.</p>

<p><b>Return Value:</b></p>

<p>The closest 32-bit binary floating-point number to this value. The return value can be positive infinity or negative infinity if this value exceeds the range of a 32-bit floating point number.</p>

<p><a id="ToSingleBits"></a>
### ToSingleBits</p>

<pre>public int ToSingleBits();
</pre>

<p>Converts this value to its closest equivalent as 32-bit floating-point number, expressed as an integer in the IEEE 754 binary32 format. The half-even rounding mode is used. If this value is a NaN, sets the high bit of the 32-bit floating point number’s significand area for a quiet NaN, and clears it for a signaling NaN. Then the other bits of the significand area are set to the lowest bits of this object’s unsigned significand, and the next-highest bit of the significand area is set if those bits are all zeros and this is a signaling NaN.</p>

<p><b>Return Value:</b></p>

<p>The closest 32-bit binary floating-point number to this value, expressed as an integer in the IEEE 754 binary32 format. The return value can be positive infinity or negative infinity if this value exceeds the range of a 32-bit floating point number.</p>

<p><a id="ToString"></a>
### ToString</p>

<pre>public override string ToString();
</pre>

<p>Converts this object to a text string.</p>

<p><b>Return Value:</b></p>

<p>A string representation of this object. If this object’s value is infinity or not-a-number, the result is the analogous return value of the  <code>EDecimal.ToString</code>  method. Otherwise, the return value has the following form:  <code>[-]numerator/denominator</code> .</p>

<p><a id="ToUInt16Checked"></a>
### ToUInt16Checked</p>

<pre>public ushort ToUInt16Checked();
</pre>

<p><b>This API is not CLS-compliant.</b></p>

<p>Converts this number’s value to a 16-bit unsigned integer if it can fit in a 16-bit unsigned integer after converting it to an integer by discarding its fractional part.</p>

<p><b>Return Value:</b></p>

<p>This number’s value, truncated to a 16-bit unsigned integer.</p>

<p><b>Exceptions:</b></p>

<ul>
  <li>System.OverflowException:
This value is infinity or not-a-number, or the number, once converted to an integer by discarding its fractional part, is less than 0 or greater than 65535.</li>
</ul>

<p><a id="ToUInt16IfExact"></a>
### ToUInt16IfExact</p>

<pre>public ushort ToUInt16IfExact();
</pre>

<p><b>This API is not CLS-compliant.</b></p>

<p>Converts this number’s value to a 16-bit unsigned integer if it can fit in a 16-bit unsigned integer without rounding to a different numerical value.</p>

<p><b>Return Value:</b></p>

<p>This number’s value as a 16-bit unsigned integer.</p>

<p><b>Exceptions:</b></p>

<ul>
  <li>System.ArithmeticException:
This value is infinity or not-a-number, is not an exact integer, or is less than 0 or greater than 65535.</li>
</ul>

<p><a id="ToUInt16Unchecked"></a>
### ToUInt16Unchecked</p>

<pre>public ushort ToUInt16Unchecked();
</pre>

<p><b>This API is not CLS-compliant.</b></p>

<p>Converts this number’s value to an integer by discarding its fractional part, and returns the least-significant bits of its two’s-complement form as a 16-bit unsigned integer.</p>

<p><b>Return Value:</b></p>

<p>This number, converted to a 16-bit unsigned integer. Returns 0 if this value is infinity or not-a-number.</p>

<p><a id="ToUInt32Checked"></a>
### ToUInt32Checked</p>

<pre>public uint ToUInt32Checked();
</pre>

<p><b>This API is not CLS-compliant.</b></p>

<p>Converts this number’s value to a 32-bit signed integer if it can fit in a 32-bit signed integer after converting it to an integer by discarding its fractional part.</p>

<p><b>Return Value:</b></p>

<p>This number’s value, truncated to a 32-bit signed integer.</p>

<p><b>Exceptions:</b></p>

<ul>
  <li>System.OverflowException:
This value is infinity or not-a-number, or the number, once converted to an integer by discarding its fractional part, is less than 0 or greater than 4294967295.</li>
</ul>

<p><a id="ToUInt32IfExact"></a>
### ToUInt32IfExact</p>

<pre>public uint ToUInt32IfExact();
</pre>

<p><b>This API is not CLS-compliant.</b></p>

<p>Converts this number’s value to a 32-bit signed integer if it can fit in a 32-bit signed integer without rounding to a different numerical value.</p>

<p><b>Return Value:</b></p>

<p>This number’s value as a 32-bit signed integer.</p>

<p><b>Exceptions:</b></p>

<ul>
  <li>System.ArithmeticException:
This value is infinity or not-a-number, is not an exact integer, or is less than 0 or greater than 4294967295.</li>
</ul>

<p><a id="ToUInt32Unchecked"></a>
### ToUInt32Unchecked</p>

<pre>public uint ToUInt32Unchecked();
</pre>

<p><b>This API is not CLS-compliant.</b></p>

<p>Converts this number’s value to an integer by discarding its fractional part, and returns the least-significant bits of its two’s-complement form as a 32-bit signed integer.</p>

<p><b>Return Value:</b></p>

<p>This number, converted to a 32-bit signed integer. Returns 0 if this value is infinity or not-a-number.</p>

<p><a id="ToUInt64Checked"></a>
### ToUInt64Checked</p>

<pre>public ulong ToUInt64Checked();
</pre>

<p><b>This API is not CLS-compliant.</b></p>

<p>Converts this number’s value to a 64-bit unsigned integer if it can fit in a 64-bit unsigned integer after converting it to an integer by discarding its fractional part.</p>

<p><b>Return Value:</b></p>

<p>This number’s value, truncated to a 64-bit unsigned integer.</p>

<p><b>Exceptions:</b></p>

<ul>
  <li>System.OverflowException:
This value is infinity or not-a-number, or the number, once converted to an integer by discarding its fractional part, is less than 0 or greater than 18446744073709551615.</li>
</ul>

<p><a id="ToUInt64IfExact"></a>
### ToUInt64IfExact</p>

<pre>public ulong ToUInt64IfExact();
</pre>

<p><b>This API is not CLS-compliant.</b></p>

<p>Converts this number’s value to a 64-bit unsigned integer if it can fit in a 64-bit unsigned integer without rounding to a different numerical value.</p>

<p><b>Return Value:</b></p>

<p>This number’s value as a 64-bit unsigned integer.</p>

<p><b>Exceptions:</b></p>

<ul>
  <li>System.ArithmeticException:
This value is infinity or not-a-number, is not an exact integer, or is less than 0 or greater than 18446744073709551615.</li>
</ul>

<p><a id="ToUInt64Unchecked"></a>
### ToUInt64Unchecked</p>

<pre>public ulong ToUInt64Unchecked();
</pre>

<p><b>This API is not CLS-compliant.</b></p>

<p>Converts this number’s value to an integer by discarding its fractional part, and returns the least-significant bits of its two’s-complement form as a 64-bit unsigned integer.</p>

<p><b>Return Value:</b></p>

<p>This number, converted to a 64-bit unsigned integer. Returns 0 if this value is infinity or not-a-number.</p>

<p><a href="/Numbers/">Back to Numbers start page.</a></p>
</div><nav id="navigation"><ul>
<li><a href="/">Back to start site.</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io">This site's repository (source code)</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io/issues">Post an issue or comment</a></ul>

<div class="noprint">
<p>
<a href="//twitter.com/intent/tweet">Share via Twitter</a>, <a href="//www.facebook.com/sharer/sharer.php" id="sharer">Share via Facebook</a>
</p>
</div>
</nav></body></html>
