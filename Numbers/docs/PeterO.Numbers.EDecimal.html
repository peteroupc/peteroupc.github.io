<!DOCTYPE html><html><head><meta http-equiv=Content-Type content="text/html; charset=utf-8"><title>PeterO.Numbers.EDecimal</title><meta name="viewport" content="width=device-width"><link rel=stylesheet type="text/css" href="/style.css"></head><body>  <div class="header">
<p><a href="#navigation">Menu</a> - <a href="#top">Top</a> - <a href="/">Home</a> -
<a href="http://peteroupc.github.io/">Donate to Me</a></p></div>
<div class="mainarea" id="top">
<h1>PeterO.Numbers.EDecimal</h1>

<h2>PeterO.Numbers.EDecimal</h2>

<pre>public sealed class EDecimal :
    System.IComparable,
    System.IEquatable
</pre>

<p>Represents an arbitrary-precision decimal floating-point number. (The &quot;E&quot; tands for &quot;extended&quot;, meaning that instances of this class can be values ther than numbers proper, such as infinity and not-a-number.) <b>About decimal arithmetic</b></p>

<p>Decimal (base-10) arithmetic, such as that provided by this class, is ppropriate for calculations involving such real-world data as prices nd other sums of money, tax rates, and measurements. These calculations ften involve multiplying or dividing one decimal with another decimal, r performing other operations on decimal numbers. Many of these alculations also rely on rounding behavior in which the result after ounding is a decimal number (for example, multiplying a price by a remium rate, then rounding, should result in a decimal amount of oney).</p>

<p>On the other hand, most implementations of  <code>
          float
</code> and  <code>
          double
</code> , including in C# and Java, store numbers in a binary (base-2) loating-point format and use binary floating-point arithmetic. Many ecimal numbers can&#39;t be represented exactly in binary floating-point ormat (regardless of its length). Applying binary arithmetic to numbers ntended to be decimals can sometimes lead to unintuitive results, as is hown in the description for the FromDouble() method of this class.</p>

<p><b>About EDecimal instances</b></p>

<p>Each instance of this class consists of an integer mantissa significand) and an integer exponent, both arbitrary-precision. The alue of the number equals mantissa (significand) * 10^exponent.</p>

<p>The mantissa (significand) is the value of the digits that make up a umber, ignoring the decimal point and exponent. For example, in the umber 2356.78, the mantissa (significand) is 235678. The exponent is here the &quot;floating&quot; decimal point of the number is located. A positive xponent means &quot;move it to the right&quot;, and a negative exponent means move it to the left.&quot; In the example 2, 356.78, the exponent is -2, ince it has 2 decimal places and the decimal point is &quot;moved to the eft by 2.&quot; Therefore, in the arbitrary-precision decimal epresentation, this number would be stored as 235678 * 10^-2.</p>

<p>The mantissa (significand) and exponent format preserves trailing zeros n the number&#39;s value. This may give rise to multiple ways to store the ame value. For example, 1.00 and 1 would be stored differently, even hough they have the same value. In the first case, 100 * 10^-2 (100 ith decimal point moved left by 2), and in the second case, 1 * 10^0 (1 ith decimal point moved 0).</p>

<p>This class also supports values for negative zero, not-a-number (NaN) alues, and infinity. <b>Negative zero</b>is generally used when a negative number is rounded to 0; it has the ame mathematical value as positive zero. <b>Infinity</b>is generally used when a non-zero number is divided by zero, or when a ery high or very low number can&#39;t be represented in a given exponent ange. <b>Not-a-number</b>is generally used to signal errors.</p>

<p>This class implements the General Decimal Arithmetic Specification ersion 1.70 (except part of chapter 6):  <code>
          http://speleotrove.com/decimal/decarith.html
</code></p>

<p><b>Errors and Exceptions</b></p>

<p>Passing a signaling NaN to any arithmetic operation shown here will ignal the flag FlagInvalid and return a quiet NaN, even if another perand to that operation is a quiet NaN, unless noted otherwise.</p>

<p>Passing a quiet NaN to any arithmetic operation shown here will return quiet NaN, unless noted otherwise. Invalid operations will also return quiet NaN, as stated in the individual methods.</p>

<p>Unless noted otherwise,passing a null arbitrary-precision decimal rgument to any method here will throw an exception.</p>

<p>When an arithmetic operation signals the flag FlagInvalid, lagOverflow, or FlagDivideByZero, it will not throw an exception too, nless the flag&#39;s trap is enabled in the arithmetic context (see Context&#39;s Traps property).</p>

<p>If an operation requires creating an intermediate value that might be oo big to fit in memory (or might require more than 2 gigabytes of emory to store -- due to the current use of a 32-bit integer internally s a length), the operation may signal an invalid-operation flag and eturn not-a-number (NaN). In certain rare cases, the CompareTo method ay throw OutOfMemoryException (called OutOfMemoryError in Java) in the ame circumstances.</p>

<p><b>Serialization</b></p>

<p>An arbitrary-precision decimal value can be serialized (converted to a table format) in one of the following ways:</p>

<ul>
<li><p>By calling the toString() method, which will always return distinct trings for distinct arbitrary-precision decimal values.</p></li>
<li><p>By calling the UnsignedMantissa, Exponent, and IsNegative properties, nd calling the IsInfinity, IsQuietNaN, and IsSignalingNaN methods. he return values combined will uniquely identify a particular rbitrary-precision decimal value.</p></li>
</ul>

<p><b>Thread safety</b></p>

<p>Instances of this class are immutable, so they are inherently safe for se by multiple threads. Multiple instances of this object with the same roperties are interchangeable, so they should not be compared using the ==&quot; operator (which might only check if each side of the operator is he same instance).</p>

<p><b>Comparison considerations</b></p>

<p>This class&#39;s natural ordering (under the CompareTo method) is not onsistent with the Equals method. This means that two values that ompare as equal under the CompareTo method might not be equal under the quals method. The CompareTo method compares the mathematical values of he two instances passed to it (and considers two different NaN values s equal), while two instances with the same mathematical value, but ifferent exponents, will be considered unequal under the Equals method.</p>

<p><b>Forms of numbers</b></p>

<p>There are several other types of numbers that are mentioned in this lass and elsewhere in this documentation. For reference, they are pecified here.</p>

<p><b>Unsigned integer</b>: An integer that&#39;s always 0 or greater, with the following maximum alues:</p>

<ul>
<li><p>8-bit unsigned integer, or <i>byte </i>: 255.</p></li>
<li><p>16-bit unsigned integer: 65535.</p></li>
<li><p>32-bit unsigned integer: (2 <sup>32 </sup>-1).</p></li>
<li><p>64-bit unsigned integer: (2 <sup>64 </sup>-1).</p></li>
</ul>

<p><b>Signed integer</b>: An integer in <i>two&#39;s-complement form </i>, with the following ranges:</p>

<ul>
<li><p>8-bit signed integer: -128 to 127.</p></li>
<li><p>16-bit signed integer: -32768 to 32767.</p></li>
<li><p>32-bit signed integer: -2 <sup>31 </sup>to (2 <sup>31 </sup>- 1).</p></li>
<li><p>64-bit signed integer: -2 <sup>63 </sup>to (2 <sup>63 </sup>- 1).</p></li>
</ul>

<p><b>Two&#39;s complement form</b>: In <i>two&#39; s-complement form </i>, nonnegative numbers have the highest (most significant) bit set to ero, and negative numbers have that bit (and all bits beyond) set to ne, and a negative number is stored in such form by decreasing its bsolute value by 1 and swapping the bits of the resulting number.</p>

<p><b>64-bit floating-point number</b>: A 64-bit binary floating-point number, in the form <i>significand </i>* 2 <sup><i>exponent </i></sup>. The significand is 53 bits long (Precision) and the exponent ranges rom -1074 (EMin) to 971 (EMax). The number is stored in the following ormat (commonly called the IEEE 754 format):</p>

<pre>|C|BBB...BBB|AAAAAA...AAAAAA|
</pre>

<ul>
<li><p>A. Low 52 bits (Precision minus 1 bits): Lowest bits of the ignificand.</p></li>
<li><p>B. Next 11 bits: Exponent area:</p></li>
<li><p>If all bits are ones, this value is infinity if all bits in area are zeros, or not-a-number (NaN) otherwise.</p></li>
<li><p>If all bits are zeros, this is a subnormal number. The exponent s EMin and the highest bit of the significand is zero.</p></li>
<li><p>If any other number, the exponent is this value reduced by 1, hen raised by EMin, and the highest bit of the significand is ne.</p></li>
<li><p>C. Highest bit: If one, this is a negative number.</p></li>
</ul>

<p>The elements described above are in the same order as the order of each it of each element, that is, either most significant first or least ignificant first.</p>

<p><b>32-bit binary floating-point number</b>: A 32-bit binary number which is stored similarly to a <i>64-bit floating-point number </i>, except that:</p>

<ul>
<li><p>Precision is 24 bits.</p></li>
<li><p>EMin is -149.</p></li>
<li><p>EMax is 104.</p></li>
<li><p>A. The low 23 bits (Precision minus 1 bits) are the lowest bits of he significand.</p></li>
<li><p>B. The next 8 bits are the exponent area.</p></li>
<li><p>C. If the highest bit is one, this is a negative number.</p></li>
</ul>

<p><b>.NET Framework decimal</b>: A 128-bit decimal floating-point number, in the form <i>significand </i>* 10 <sup>- <i>scale </i></sup>, where the scale ranges from 0 to 28. The number is stored in the ollowing format:</p>

<ul>
<li><p>Low 96 bits are the significand, as a 96-bit unsigned integer (all 6-bit values are allowed, up to (2 <sup>96 </sup>-1)).</p></li>
<li><p>Next 16 bits are unused.</p></li>
<li><p>Next 8 bits are the scale, stored as an 8-bit unsigned integer.</p></li>
<li><p>Next 7 bits are unused.</p></li>
<li><p>If the highest bit is one, it&#39;s a negative number.</p></li>
</ul>

<p>The elements described above are in the same order as the order of each it of each element, that is, either most significant first or least ignificant first.</p>

<h3>NaN</h3>

<pre>public static readonly PeterO.Numbers.EDecimal NaN;
</pre>

<p>A not-a-number value.</p>

<h3>NegativeInfinity</h3>

<pre>public static readonly PeterO.Numbers.EDecimal NegativeInfinity;
</pre>

<p>Negative infinity, less than any other number.</p>

<h3>NegativeZero</h3>

<pre>public static readonly PeterO.Numbers.EDecimal NegativeZero;
</pre>

<p>Represents the number negative zero.</p>

<h3>One</h3>

<pre>public static readonly PeterO.Numbers.EDecimal One;
</pre>

<p>Represents the number 1.</p>

<h3>PositiveInfinity</h3>

<pre>public static readonly PeterO.Numbers.EDecimal PositiveInfinity;
</pre>

<p>Positive infinity, greater than any other number.</p>

<h3>SignalingNaN</h3>

<pre>public static readonly PeterO.Numbers.EDecimal SignalingNaN;
</pre>

<p>A not-a-number value that signals an invalid operation flag when it&#39;s assed as an argument to any arithmetic operation in arbitrary-precision ecimal.</p>

<h3>Ten</h3>

<pre>public static readonly PeterO.Numbers.EDecimal Ten;
</pre>

<p>Represents the number 10.</p>

<h3>Zero</h3>

<pre>public static readonly PeterO.Numbers.EDecimal Zero;
</pre>

<p>Represents the number 0.</p>

<h3>Exponent</h3>

<pre>public PeterO.Numbers.EInteger Exponent { get; }
</pre>

<p>Gets this object&#39;s exponent. This object&#39;s value will be an integer if he exponent is positive or zero.</p>

<p><b>Returns:</b></p>

<p>This object&#39;s exponent. This object&#39;s value will be an integer if the xponent is positive or zero.</p>

<h3>IsFinite</h3>

<pre>public bool IsFinite { get; }
</pre>

<p>Gets a value indicating whether this object is finite (not infinity or aN).</p>

<p><b>Returns:</b></p>

<p><code>
        true
</code> if this object is finite (not infinity or not-a-number (NaN)); otherwise,  <code>
        false
</code> .</p>

<h3>IsNegative</h3>

<pre>public bool IsNegative { get; }
</pre>

<p>Gets a value indicating whether this object is negative, including egative zero.</p>

<p><b>Returns:</b></p>

<p><code>
        true
</code> if this object is negative, including negative zero; otherwise,  <code>
        false
</code> .</p>

<h3>IsZero</h3>

<pre>public bool IsZero { get; }
</pre>

<p>Gets a value indicating whether this object&#39;s value equals 0.</p>

<p><b>Returns:</b></p>

<p><code>
        true
</code> if this object&#39;s value equals 0; otherwise, .  <code>
        false
</code> .</p>

<h3>Mantissa</h3>

<pre>public PeterO.Numbers.EInteger Mantissa { get; }
</pre>

<p>Gets this object&#39;s unscaled value.</p>

<p><b>Returns:</b></p>

<p>This object&#39;s unscaled value. Will be negative if this object&#39;s value is egative (including a negative NaN).</p>

<h3>Sign</h3>

<pre>public int Sign { get; }
</pre>

<p>Gets this value&#39;s sign: -1 if negative; 1 if positive; 0 if zero.</p>

<p><b>Returns:</b></p>

<p>This value&#39;s sign: -1 if negative; 1 if positive; 0 if zero.</p>

<h3>UnsignedMantissa</h3>

<pre>public PeterO.Numbers.EInteger UnsignedMantissa { get; }
</pre>

<p>Gets the absolute value of this object&#39;s unscaled value.</p>

<p><b>Returns:</b></p>

<p>The absolute value of this object&#39;s unscaled value.</p>

<h3>Abs</h3>

<pre>public PeterO.Numbers.EDecimal Abs(
    PeterO.Numbers.EContext context);
</pre>

<p>Finds the absolute value of this object (if it&#39;s negative, it becomes ositive).</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>context</i>: An arithmetic context to control precision, rounding, and exponent range f the result. If  <code>
    HasFlags
</code> of the context is true, will also store the flags resulting from the peration (the flags are in addition to the pre-existing flags). Can be ull, in which case the precision is unlimited and no rounding is needed.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The absolute value of this object. Signals FlagInvalid and returns quiet aN if this value is signaling NaN.</p>

<h3>Abs</h3>

<pre>public PeterO.Numbers.EDecimal Abs();
</pre>

<p>Finds the absolute value of this object (if it&#39;s negative, it becomes ositive).</p>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision decimal number. Returns signaling NaN if this alue is signaling NaN.</p>

<h3>Add</h3>

<pre>public PeterO.Numbers.EDecimal Add(
    PeterO.Numbers.EDecimal otherValue);
</pre>

<p>Adds this object and another decimal number and returns the result.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>otherValue</i>: An arbitrary-precision decimal number.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The sum of the two objects.</p>

<h3>Add</h3>

<pre>public PeterO.Numbers.EDecimal Add(
    PeterO.Numbers.EDecimal otherValue,
    PeterO.Numbers.EContext ctx);
</pre>

<p>Finds the sum of this object and another object. The result&#39;s exponent is et to the lower of the exponents of the two operands.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>otherValue</i>: The number to add to.</p></li>
<li><p><i>ctx</i>: An arithmetic context to control precision, rounding, and exponent range f the result. If  <code>
    HasFlags
</code> of the context is true, will also store the flags resulting from the peration (the flags are in addition to the pre-existing flags). Can be ull, in which case the precision is unlimited and no rounding is needed.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>The sum of thisValue and the other object.</p>

<h3>CompareTo</h3>

<pre>public sealed int CompareTo(
    PeterO.Numbers.EDecimal other);
</pre>

<p>Compares the mathematical values of this object and another object, ccepting NaN values. This method is not consistent with the Equals method because two ifferent numbers with the same mathematical value, but different xponents, will compare as equal.</p>

<p>In this method, negative zero and positive zero are considered equal.</p>

<p>If this object or the other object is a quiet NaN or signaling NaN, his method will not trigger an error. Instead, NaN will compare greater han any other number, including infinity. Two different NaN values will e considered equal.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>other</i>: An arbitrary-precision decimal number.</li>
</ul>

<p><b>Return Value:</b></p>

<p>Less than 0 if this object&#39;s value is less than the other value, or reater than 0 if this object&#39;s value is greater than the other value or f  <i>other</i>
is null, or 0 if both values are equal.</p>

<h3>CompareToBinary</h3>

<pre>public int CompareToBinary(
    PeterO.Numbers.EFloat other);
</pre>

<p>Compares an arbitrary-precision binary float with this instance.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>other</i>: The other object to compare. Can be null.</li>
</ul>

<p><b>Return Value:</b></p>

<p>Zero if the values are equal; a negative number if this instance is less, r a positive number if this instance is greater. Returns 0 if both values re NaN (even signaling NaN) and 1 if this value is NaN (even signaling aN) and the other isn&#39;t, or if the other value is null.</p>

<h3>CompareToSignal</h3>

<pre>public PeterO.Numbers.EDecimal CompareToSignal(
    PeterO.Numbers.EDecimal other,
    PeterO.Numbers.EContext ctx);
</pre>

<p>Compares the mathematical values of this object and another object, reating quiet NaN as signaling. In this method, negative zero and positive zero are considered equal.</p>

<p>If this object or the other object is a quiet NaN or signaling NaN, his method will return a quiet NaN and will signal a FlagInvalid flag.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>other</i>: An arbitrary-precision decimal number.</p></li>
<li><p><i>ctx</i>: An arithmetic context. The precision, rounding, and exponent range are gnored. If  <code>
    HasFlags
</code> of the context is true, will store the flags resulting from the operation the flags are in addition to the pre-existing flags). Can be null.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>Quiet NaN if this object or the other object is NaN, or 0 if both objects ave the same value, or -1 if this object is less than the other value, or if this object is greater.</p>

<h3>CompareToTotal</h3>

<pre>public int CompareToTotal(
    PeterO.Numbers.EDecimal other);
</pre>

<p>Compares the values of this object and another object, imposing a total rdering on all possible values. In this method:</p>

<ul>
<li><p>For objects with the same value, the one with the higher exponent has greater &quot;absolute value&quot;.</p></li>
<li><p>Negative zero is less than positive zero.</p></li>
<li><p>Quiet NaN has a higher &quot;absolute value&quot; than signaling NaN. If both bjects are quiet NaN or both are signaling NaN, the one with the igher diagnostic information has a greater &quot;absolute value&quot;.</p></li>
<li><p>NaN has a higher &quot;absolute value&quot; than infinity.</p></li>
<li><p>Infinity has a higher &quot;absolute value&quot; than any finite number.</p></li>
<li><p>Negative numbers are less than positive numbers.</p></li>
</ul>

<p><b>Parameters:</b></p>

<ul>
<li><i>other</i>: An arbitrary-precision decimal number to compare with this one.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The number 0 if both objects have the same value, or -1 if this object is ess than the other value, or 1 if this object is greater.</p>

<h3>CompareToTotal</h3>

<pre>public int CompareToTotal(
    PeterO.Numbers.EDecimal other,
    PeterO.Numbers.EContext ctx);
</pre>

<p>Compares the values of this object and another object, imposing a total rdering on all possible values. In this method:</p>

<ul>
<li><p>For objects with the same value, the one with the higher exponent has greater &quot;absolute value&quot;.</p></li>
<li><p>Negative zero is less than positive zero.</p></li>
<li><p>Quiet NaN has a higher &quot;absolute value&quot; than signaling NaN. If both bjects are quiet NaN or both are signaling NaN, the one with the igher diagnostic information has a greater &quot;absolute value&quot;.</p></li>
<li><p>NaN has a higher &quot;absolute value&quot; than infinity.</p></li>
<li><p>Infinity has a higher &quot;absolute value&quot; than any finite number.</p></li>
<li><p>Negative numbers are less than positive numbers.</p></li>
</ul>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>other</i>: An arbitrary-precision decimal number to compare with this one.</p></li>
<li><p><i>ctx</i>: An arithmetic context. Flags will be set in this context only if  <code>
    HasFlags
</code> and  <code>
    IsSimplified
</code> of the context are true and only if an operand needed to be rounded efore carrying out the operation. Can be null.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>The number 0 if both objects have the same value, or -1 if this object is ess than the other value, or 1 if this object is greater. Does not signal lags if either value is signaling NaN.</p>

<h3>CompareToTotalMagnitude</h3>

<pre>public int CompareToTotalMagnitude(
    PeterO.Numbers.EDecimal other);
</pre>

<p>Compares the absolute values of this object and another object, imposing total ordering on all possible values (ignoring their signs). In this ethod:</p>

<ul>
<li><p>For objects with the same value, the one with the higher exponent has greater &quot;absolute value&quot;.</p></li>
<li><p>Negative zero and positive zero are considered equal.</p></li>
<li><p>Quiet NaN has a higher &quot;absolute value&quot; than signaling NaN. If both bjects are quiet NaN or both are signaling NaN, the one with the igher diagnostic information has a greater &quot;absolute value&quot;.</p></li>
<li><p>NaN has a higher &quot;absolute value&quot; than infinity.</p></li>
<li><p>Infinity has a higher &quot;absolute value&quot; than any finite number.</p></li>
</ul>

<p><b>Parameters:</b></p>

<ul>
<li><i>other</i>: An arbitrary-precision decimal number to compare with this one.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The number 0 if both objects have the same value, or -1 if this object is ess than the other value, or 1 if this object is greater.</p>

<h3>CompareToWithContext</h3>

<pre>public PeterO.Numbers.EDecimal CompareToWithContext(
    PeterO.Numbers.EDecimal other,
    PeterO.Numbers.EContext ctx);
</pre>

<p>Compares the mathematical values of this object and another object. In this method, negative zero and positive zero are considered equal.</p>

<p>If this object or the other object is a quiet NaN or signaling NaN, his method returns a quiet NaN, and will signal a FlagInvalid flag if ither is a signaling NaN.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>other</i>: An arbitrary-precision decimal number.</p></li>
<li><p><i>ctx</i>: An arithmetic context. The precision, rounding, and exponent range are gnored. If  <code>
    HasFlags
</code> of the context is true, will store the flags resulting from the operation the flags are in addition to the pre-existing flags). Can be null.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>Quiet NaN if this object or the other object is NaN, or 0 if both objects ave the same value, or -1 if this object is less than the other value, or if this object is greater.</p>

<h3>CopySign</h3>

<pre>public PeterO.Numbers.EDecimal CopySign(
    PeterO.Numbers.EDecimal other);
</pre>

<p>Returns a number with the same value as this one, but copying the sign positive or negative) of another number.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>other</i>: A number whose sign will be copied.</li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision decimal number.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter  <i>other</i>
is null.</li>
</ul>

<h3>Create</h3>

<pre>public static PeterO.Numbers.EDecimal Create(
    int mantissaSmall,
    int exponentSmall);
</pre>

<p>Creates a number with the value  <code>
        exponent*10^mantissa
</code></p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>mantissaSmall</i>: Desired value for the mantissa.</p></li>
<li><p><i>exponentSmall</i>: Desired value for the exponent.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision decimal number.</p>

<h3>Create</h3>

<pre>public static PeterO.Numbers.EDecimal Create(
    PeterO.Numbers.EInteger mantissa,
    PeterO.Numbers.EInteger exponent);
</pre>

<p>Creates a number with the value  <code>
        exponent*10^mantissa
</code></p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>mantissa</i>: Desired value for the mantissa.</p></li>
<li><p><i>exponent</i>: Desired value for the exponent.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision decimal number.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter  <i>mantissa</i>
or  <i>exponent</i>
is null.</li>
</ul>

<h3>CreateNaN</h3>

<pre>public static PeterO.Numbers.EDecimal CreateNaN(
    PeterO.Numbers.EInteger diag);
</pre>

<p>Creates a not-a-number arbitrary-precision decimal number.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>diag</i>: A number to use as diagnostic information associated with this object. If one is needed, should be zero.</li>
</ul>

<p><b>Return Value:</b></p>

<p>A quiet not-a-number.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter  <i>diag</i>
is null or is less than 0.</li>
</ul>

<h3>CreateNaN</h3>

<pre>public static PeterO.Numbers.EDecimal CreateNaN(
    PeterO.Numbers.EInteger diag,
    bool signaling,
    bool negative,
    PeterO.Numbers.EContext ctx);
</pre>

<p>Creates a not-a-number arbitrary-precision decimal number.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>diag</i>: A number to use as diagnostic information associated with this object. If one is needed, should be zero.</p></li>
<li><p><i>signaling</i>: Whether the return value will be signaling (true) or quiet (false).</p></li>
<li><p><i>negative</i>: Whether the return value is negative.</p></li>
<li><p><i>ctx</i>: An arithmetic context to control the precision (in decimal digits) of the iagnostic information. The rounding and exponent range of this context ill be ignored. Can be null. The only flag that can be signaled in this ontext is FlagInvalid, which happens if diagnostic information needs to e truncated and too much memory is required to do so.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision decimal number.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter  <i>diag</i>
is null or is less than 0.</li>
</ul>

<h3>Divide</h3>

<pre>public PeterO.Numbers.EDecimal Divide(
    PeterO.Numbers.EDecimal divisor);
</pre>

<p>Divides this object by another decimal number and returns the result. hen possible, the result will be exact.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>divisor</i>: An arbitrary-precision decimal number to divide by.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The quotient of the two numbers. Returns infinity if the divisor is 0 and he dividend is nonzero. Returns not-a-number (NaN) if the divisor and the ividend are 0. Returns NaN if the result can&#39;t be exact because it would ave a nonterminating decimal expansion.</p>

<h3>Divide</h3>

<pre>public PeterO.Numbers.EDecimal Divide(
    PeterO.Numbers.EDecimal divisor,
    PeterO.Numbers.EContext ctx);
</pre>

<p>Divides this arbitrary-precision decimal number by another rbitrary-precision decimal number. The preferred exponent for the result s this object&#39;s exponent minus the divisor&#39;s exponent.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>divisor</i>: An arbitrary-precision decimal number to divide by.</p></li>
<li><p><i>ctx</i>: An arithmetic context to control precision, rounding, and exponent range f the result. If  <code>
    HasFlags
</code> of the context is true, will also store the flags resulting from the peration (the flags are in addition to the pre-existing flags). Can be ull, in which case the precision is unlimited and no rounding is needed.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>The quotient of the two objects. Signals FlagDivideByZero and returns nfinity if the divisor is 0 and the dividend is nonzero. Signals lagInvalid and returns not-a-number (NaN) if the divisor and the dividend re 0; or, either  <i>ctx</i>
is null or  <i>ctx</i>
&#39;s precision is 0, and the result would have a nonterminating decimal xpansion; or, the rounding mode is ERounding.None and the result is not xact.</p>

<h3>DivideAndRemainderNaturalScale</h3>

<pre>public PeterO.Numbers.EDecimal[] DivideAndRemainderNaturalScale(
    PeterO.Numbers.EDecimal divisor);
</pre>

<p><b>Deprecated.</b> Renamed to DivRemNaturalScale.</p>

<p>Calculates the quotient and remainder using the ivideToIntegerNaturalScale and the formula in RemainderNaturalScale.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>divisor</i>: An arbitrary-precision decimal number to divide by.</li>
</ul>

<p><b>Return Value:</b></p>

<p>A 2 element array consisting of the quotient and remainder in that order.</p>

<h3>DivideAndRemainderNaturalScale</h3>

<pre>public PeterO.Numbers.EDecimal[] DivideAndRemainderNaturalScale(
    PeterO.Numbers.EDecimal divisor,
    PeterO.Numbers.EContext ctx);
</pre>

<p><b>Deprecated.</b> Renamed to DivRemNaturalScale.</p>

<p>Calculates the quotient and remainder using the ivideToIntegerNaturalScale and the formula in RemainderNaturalScale.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>divisor</i>: An arbitrary-precision decimal number to divide by.</p></li>
<li><p><i>ctx</i>: An arithmetic context object to control the precision, rounding, and xponent range of the result. This context will be used only in the ivision portion of the remainder calculation; as a result, it&#39;s possible or the remainder to have a higher precision than given in this context. lags will be set on the given context only if the context&#39;s  <code>
    HasFlags
</code> is true and the integer part of the division result doesn&#39;t fit the recision and exponent range without rounding. Can be null, in which the recision is unlimited and no additional rounding, other than the rounding own to an integer after division, is needed.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>A 2 element array consisting of the quotient and remainder in that order.</p>

<h3>DivideToExponent</h3>

<pre>public PeterO.Numbers.EDecimal DivideToExponent(
    PeterO.Numbers.EDecimal divisor,
    int desiredExponentInt);
</pre>

<p>Divides two arbitrary-precision decimal numbers, and gives a particular xponent (expressed as a 32-bit signed integer) to the result, using the alf-even rounding mode.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>divisor</i>: An arbitrary-precision decimal number to divide by.</p></li>
<li><p><i>desiredExponentInt</i>: The desired exponent. A negative number places the cutoff point to the ight of the usual decimal point (so a negative number means the number of ecimal places to round to). A positive number places the cutoff point to he left of the usual decimal point.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>The quotient of the two objects. Signals FlagDivideByZero and returns nfinity if the divisor is 0 and the dividend is nonzero. Signals lagInvalid and returns not-a-number (NaN) if the divisor and the dividend re 0.</p>

<h3>DivideToExponent</h3>

<pre>public PeterO.Numbers.EDecimal DivideToExponent(
    PeterO.Numbers.EDecimal divisor,
    int desiredExponentInt,
    PeterO.Numbers.EContext ctx);
</pre>

<p>Divides two arbitrary-precision decimal numbers, and gives a particular xponent (expressed as a 32-bit signed integer) to the result, using the alf-even rounding mode.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>divisor</i>: An arbitrary-precision decimal number to divide by.</p></li>
<li><p><i>desiredExponentInt</i>: The desired exponent. A negative number places the cutoff point to the ight of the usual decimal point (so a negative number means the number of ecimal places to round to). A positive number places the cutoff point to he left of the usual decimal point.</p></li>
<li><p><i>ctx</i>: An arithmetic context object to control the rounding mode to use if the esult must be scaled down to have the same exponent as this value. If the recision given in the context is other than 0, calls the Quantize method ith both arguments equal to the result of the operation (and can signal lagInvalid and return NaN if the result doesn&#39;t fit the given precision). f  <code>
    HasFlags
</code> of the context is true, will also store the flags resulting from the peration (the flags are in addition to the pre-existing flags). Can be ull, in which case the default rounding mode is HalfEven.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>The quotient of the two objects. Signals FlagDivideByZero and returns nfinity if the divisor is 0 and the dividend is nonzero. Signals lagInvalid and returns not-a-number (NaN) if the divisor and the dividend re 0. Signals FlagInvalid and returns not-a-number (NaN) if the context efines an exponent range and the desired exponent is outside that range. ignals FlagInvalid and returns not-a-number (NaN) if the rounding mode is Rounding.None and the result is not exact.</p>

<h3>DivideToExponent</h3>

<pre>public PeterO.Numbers.EDecimal DivideToExponent(
    PeterO.Numbers.EDecimal divisor,
    int desiredExponentInt,
    PeterO.Numbers.ERounding rounding);
</pre>

<p>Divides two arbitrary-precision decimal numbers, and gives a particular xponent (expressed as a 32-bit signed integer) to the result, using the alf-even rounding mode.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>divisor</i>: An arbitrary-precision decimal number to divide by.</p></li>
<li><p><i>desiredExponentInt</i>: The desired exponent. A negative number places the cutoff point to the ight of the usual decimal point (so a negative number means the number of ecimal places to round to). A positive number places the cutoff point to he left of the usual decimal point.</p></li>
<li><p><i>rounding</i>: The rounding mode to use if the result must be scaled down to have the ame exponent as this value.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>The quotient of the two objects. Signals FlagDivideByZero and returns nfinity if the divisor is 0 and the dividend is nonzero. Signals lagInvalid and returns not-a-number (NaN) if the divisor and the dividend re 0. Signals FlagInvalid and returns not-a-number (NaN) if the rounding ode is ERounding.None and the result is not exact.</p>

<h3>DivideToExponent</h3>

<pre>public PeterO.Numbers.EDecimal DivideToExponent(
    PeterO.Numbers.EDecimal divisor,
    long desiredExponentSmall);
</pre>

<p>Divides two arbitrary-precision decimal numbers, and gives a particular xponent (expressed as a 64-bit signed integer) to the result, using the alf-even rounding mode.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>divisor</i>: An arbitrary-precision decimal number to divide by.</p></li>
<li><p><i>desiredExponentSmall</i>: The desired exponent. A negative number places the cutoff point to the ight of the usual decimal point (so a negative number means the number of ecimal places to round to). A positive number places the cutoff point to he left of the usual decimal point.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>The quotient of the two objects. Signals FlagDivideByZero and returns nfinity if the divisor is 0 and the dividend is nonzero. Signals lagInvalid and returns not-a-number (NaN) if the divisor and the dividend re 0.</p>

<h3>DivideToExponent</h3>

<pre>public PeterO.Numbers.EDecimal DivideToExponent(
    PeterO.Numbers.EDecimal divisor,
    long desiredExponentSmall,
    PeterO.Numbers.EContext ctx);
</pre>

<p>Divides two arbitrary-precision decimal numbers, and gives a particular xponent to the result.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>divisor</i>: An arbitrary-precision decimal number to divide by.</p></li>
<li><p><i>desiredExponentSmall</i>: The desired exponent. A negative number places the cutoff point to the ight of the usual decimal point (so a negative number means the number of ecimal places to round to). A positive number places the cutoff point to he left of the usual decimal point.</p></li>
<li><p><i>ctx</i>: An arithmetic context object to control the rounding mode to use if the esult must be scaled down to have the same exponent as this value. If the recision given in the context is other than 0, calls the Quantize method ith both arguments equal to the result of the operation (and can signal lagInvalid and return NaN if the result doesn&#39;t fit the given precision). f  <code>
    HasFlags
</code> of the context is true, will also store the flags resulting from the peration (the flags are in addition to the pre-existing flags). Can be ull, in which case the default rounding mode is HalfEven.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>The quotient of the two objects. Signals FlagDivideByZero and returns nfinity if the divisor is 0 and the dividend is nonzero. Signals lagInvalid and returns not-a-number (NaN) if the divisor and the dividend re 0. Signals FlagInvalid and returns not-a-number (NaN) if the context efines an exponent range and the desired exponent is outside that range. ignals FlagInvalid and returns not-a-number (NaN) if the rounding mode is Rounding.None and the result is not exact.</p>

<h3>DivideToExponent</h3>

<pre>public PeterO.Numbers.EDecimal DivideToExponent(
    PeterO.Numbers.EDecimal divisor,
    long desiredExponentSmall,
    PeterO.Numbers.ERounding rounding);
</pre>

<p>Divides two arbitrary-precision decimal numbers, and gives a particular xponent to the result.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>divisor</i>: An arbitrary-precision decimal number to divide by.</p></li>
<li><p><i>desiredExponentSmall</i>: The desired exponent. A negative number places the cutoff point to the ight of the usual decimal point (so a negative number means the number of ecimal places to round to). A positive number places the cutoff point to he left of the usual decimal point.</p></li>
<li><p><i>rounding</i>: The rounding mode to use if the result must be scaled down to have the ame exponent as this value.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>The quotient of the two objects. Signals FlagDivideByZero and returns nfinity if the divisor is 0 and the dividend is nonzero. Signals lagInvalid and returns not-a-number (NaN) if the divisor and the dividend re 0. Signals FlagInvalid and returns not-a-number (NaN) if the rounding ode is ERounding.None and the result is not exact.</p>

<h3>DivideToExponent</h3>

<pre>public PeterO.Numbers.EDecimal DivideToExponent(
    PeterO.Numbers.EDecimal divisor,
    PeterO.Numbers.EInteger desiredExponent,
    PeterO.Numbers.ERounding rounding);
</pre>

<p>Divides two arbitrary-precision decimal numbers, and gives a particular xponent to the result.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>divisor</i>: An arbitrary-precision decimal number to divide by.</p></li>
<li><p><i>desiredExponent</i>: The desired exponent. A negative number places the cutoff point to the ight of the usual decimal point (so a negative number means the number of ecimal places to round to). A positive number places the cutoff point to he left of the usual decimal point.</p></li>
<li><p><i>rounding</i>: The rounding mode to use if the result must be scaled down to have the ame exponent as this value.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>The quotient of the two objects. Signals FlagDivideByZero and returns nfinity if the divisor is 0 and the dividend is nonzero. Returns ot-a-number (NaN) if the divisor and the dividend are 0. Returns NaN if he rounding mode is ERounding.None and the result is not exact.</p>

<h3>DivideToExponent</h3>

<pre>public PeterO.Numbers.EDecimal DivideToExponent(
    PeterO.Numbers.EDecimal divisor,
    PeterO.Numbers.EInteger exponent);
</pre>

<p>Divides two arbitrary-precision decimal numbers, and gives a particular xponent to the result, using the half-even rounding mode.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>divisor</i>: An arbitrary-precision decimal number to divide by.</p></li>
<li><p><i>exponent</i>: The desired exponent. A negative number places the cutoff point to the ight of the usual decimal point (so a negative number means the number of ecimal places to round to). A positive number places the cutoff point to he left of the usual decimal point.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>The quotient of the two objects. Signals FlagDivideByZero and returns nfinity if the divisor is 0 and the dividend is nonzero. Signals lagInvalid and returns not-a-number (NaN) if the divisor and the dividend re 0.</p>

<h3>DivideToExponent</h3>

<pre>public PeterO.Numbers.EDecimal DivideToExponent(
    PeterO.Numbers.EDecimal divisor,
    PeterO.Numbers.EInteger exponent,
    PeterO.Numbers.EContext ctx);
</pre>

<p>Divides two arbitrary-precision decimal numbers, and gives a particular xponent to the result.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>divisor</i>: An arbitrary-precision decimal number to divide by.</p></li>
<li><p><i>exponent</i>: The desired exponent. A negative number places the cutoff point to the ight of the usual decimal point (so a negative number means the number of ecimal places to round to). A positive number places the cutoff point to he left of the usual decimal point.</p></li>
<li><p><i>ctx</i>: An arithmetic context object to control the rounding mode to use if the esult must be scaled down to have the same exponent as this value. If the recision given in the context is other than 0, calls the Quantize method ith both arguments equal to the result of the operation (and can signal lagInvalid and return NaN if the result doesn&#39;t fit the given precision). f  <code>
    HasFlags
</code> of the context is true, will also store the flags resulting from the peration (the flags are in addition to the pre-existing flags). Can be ull, in which case the default rounding mode is HalfEven.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>The quotient of the two objects. Signals FlagDivideByZero and returns nfinity if the divisor is 0 and the dividend is nonzero. Signals lagInvalid and returns not-a-number (NaN) if the divisor and the dividend re 0. Signals FlagInvalid and returns not-a-number (NaN) if the context efines an exponent range and the desired exponent is outside that range. ignals FlagInvalid and returns not-a-number (NaN) if the rounding mode is Rounding.None and the result is not exact.</p>

<h3>DivideToIntegerNaturalScale</h3>

<pre>public PeterO.Numbers.EDecimal DivideToIntegerNaturalScale(
    PeterO.Numbers.EDecimal divisor);
</pre>

<p>Divides two arbitrary-precision decimal numbers, and returns the integer art of the result, rounded down, with the preferred exponent set to this alue&#39;s exponent minus the divisor&#39;s exponent.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>divisor</i>: An arbitrary-precision decimal number to divide by.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The integer part of the quotient of the two objects. Signals lagDivideByZero and returns infinity if the divisor is 0 and the dividend s nonzero. Signals FlagInvalid and returns not-a-number (NaN) if the ivisor and the dividend are 0.</p>

<h3>DivideToIntegerNaturalScale</h3>

<pre>public PeterO.Numbers.EDecimal DivideToIntegerNaturalScale(
    PeterO.Numbers.EDecimal divisor,
    PeterO.Numbers.EContext ctx);
</pre>

<p>Divides this object by another object, and returns the integer part of he result (which is initially rounded down), with the preferred exponent et to this value&#39;s exponent minus the divisor&#39;s exponent.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>divisor</i>: The number to divide by.</p></li>
<li><p><i>ctx</i>: An arithmetic context object to control the precision, rounding, and xponent range of the integer part of the result. Flags will be set on the iven context only if the context&#39;s  <code>
    HasFlags
</code> is true and the integer part of the result doesn&#39;t fit the precision and xponent range without rounding. Can be null, in which the precision is nlimited and no additional rounding, other than the rounding down to an nteger after division, is needed.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>The integer part of the quotient of the two objects. Signals FlagInvalid nd returns not-a-number (NaN) if the return value would overflow the xponent range. Signals FlagDivideByZero and returns infinity if the ivisor is 0 and the dividend is nonzero. Signals FlagInvalid and returns ot-a-number (NaN) if the divisor and the dividend are 0. Signals lagInvalid and returns not-a-number (NaN) if the rounding mode is Rounding.None and the result is not exact.</p>

<h3>DivideToIntegerZeroScale</h3>

<pre>public PeterO.Numbers.EDecimal DivideToIntegerZeroScale(
    PeterO.Numbers.EDecimal divisor,
    PeterO.Numbers.EContext ctx);
</pre>

<p>Divides this object by another object, and returns the integer part of he result, with the exponent set to 0.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>divisor</i>: The number to divide by.</p></li>
<li><p><i>ctx</i>: An arithmetic context object to control the precision. The rounding and xponent range settings of this context are ignored. If  <code>
    HasFlags
</code> of the context is true, will also store the flags resulting from the peration (the flags are in addition to the pre-existing flags). Can be ull, in which case the precision is unlimited.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>The integer part of the quotient of the two objects. The exponent will be et to 0. Signals FlagDivideByZero and returns infinity if the divisor is and the dividend is nonzero. Signals FlagInvalid and returns ot-a-number (NaN) if the divisor and the dividend are 0, or if the result oesn&#39;t fit the given precision.</p>

<h3>DivideToSameExponent</h3>

<pre>public PeterO.Numbers.EDecimal DivideToSameExponent(
    PeterO.Numbers.EDecimal divisor,
    PeterO.Numbers.ERounding rounding);
</pre>

<p>Divides this object by another decimal number and returns a result with he same exponent as this object (the dividend).</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>divisor</i>: The number to divide by.</p></li>
<li><p><i>rounding</i>: The rounding mode to use if the result must be scaled down to have the ame exponent as this value.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>The quotient of the two numbers. Signals FlagDivideByZero and returns nfinity if the divisor is 0 and the dividend is nonzero. Signals lagInvalid and returns not-a-number (NaN) if the divisor and the dividend re 0. Signals FlagInvalid and returns not-a-number (NaN) if the rounding ode is ERounding.None and the result is not exact.</p>

<h3>DivRemNaturalScale</h3>

<pre>public PeterO.Numbers.EDecimal[] DivRemNaturalScale(
    PeterO.Numbers.EDecimal divisor);
</pre>

<p>Calculates the quotient and remainder using the ivideToIntegerNaturalScale and the formula in RemainderNaturalScale.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>divisor</i>: An arbitrary-precision decimal number to divide by.</li>
</ul>

<p><b>Return Value:</b></p>

<p>A 2 element array consisting of the quotient and remainder in that order.</p>

<h3>DivRemNaturalScale</h3>

<pre>public PeterO.Numbers.EDecimal[] DivRemNaturalScale(
    PeterO.Numbers.EDecimal divisor,
    PeterO.Numbers.EContext ctx);
</pre>

<p>Calculates the quotient and remainder using the ivideToIntegerNaturalScale and the formula in RemainderNaturalScale.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>divisor</i>: An arbitrary-precision decimal number to divide by.</p></li>
<li><p><i>ctx</i>: An arithmetic context object to control the precision, rounding, and xponent range of the result. This context will be used only in the ivision portion of the remainder calculation; as a result, it&#39;s possible or the remainder to have a higher precision than given in this context. lags will be set on the given context only if the context&#39;s  <code>
    HasFlags
</code> is true and the integer part of the division result doesn&#39;t fit the recision and exponent range without rounding. Can be null, in which the recision is unlimited and no additional rounding, other than the rounding own to an integer after division, is needed.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>A 2 element array consisting of the quotient and remainder in that order.</p>

<h3>Equals</h3>

<pre>public override bool Equals(
    object obj);
</pre>

<p>Determines whether this object&#39;s mantissa (significand), exponent, and roperties are equal to those of another object and that other object is n arbitrary-precision decimal number. Not-a-number values are considered qual if the rest of their properties are equal.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>obj</i>: The parameter  <i>obj</i>
is an arbitrary object.</li>
</ul>

<p><b>Return Value:</b></p>

<p><code>
        true
</code> if the objects are equal; otherwise,  <code>
        false
</code> .</p>

<h3>Equals</h3>

<pre>public sealed bool Equals(
    PeterO.Numbers.EDecimal other);
</pre>

<p>Determines whether this object&#39;s mantissa (significand), exponent, and roperties are equal to those of another object. Not-a-number values are onsidered equal if the rest of their properties are equal.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>other</i>: An arbitrary-precision decimal number.</li>
</ul>

<p><b>Return Value:</b></p>

<p><code>
        true
</code> if this object&#39;s mantissa (significand) and exponent are equal to those f another object; otherwise,  <code>
        false
</code> .</p>

<h3>Exp</h3>

<pre>public PeterO.Numbers.EDecimal Exp(
    PeterO.Numbers.EContext ctx);
</pre>

<p>Finds e (the base of natural logarithms) raised to the power of this bject&#39;s value.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>ctx</i>: An arithmetic context to control precision, rounding, and exponent range f the result. If  <code>
    HasFlags
</code> of the context is true, will also store the flags resulting from the peration (the flags are in addition to the pre-existing flags). <i>This parameter can&#39;t be null, as the exponential function&#39;s results are enerally not exact. </i>(Unlike in the General Decimal Arithmetic Specification, any rounding ode is allowed.).</li>
</ul>

<p><b>Return Value:</b></p>

<p>Exponential of this object. If this object&#39;s value is 1, returns an pproximation to &quot; e&quot; within the given precision. Signals FlagInvalid and eturns not-a-number (NaN) if the parameter  <i>ctx</i>
is null or the precision is unlimited (the context&#39;s Precision property s 0).</p>

<h3>FromByte</h3>

<pre>public static PeterO.Numbers.EDecimal FromByte(
    byte inputByte);
</pre>

<p>Converts a byte (from 0 to 255) to an arbitrary-precision decimal number.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>inputByte</i>: The number to convert as a byte (from 0 to 255).</li>
</ul>

<p><b>Return Value:</b></p>

<p>This number&#39;s value as an arbitrary-precision decimal number.</p>

<h3>FromDecimal</h3>

<pre>public static PeterO.Numbers.EDecimal FromDecimal(
    System.Decimal dec);
</pre>

<p>Converts a  <code>
        decimal
</code> under the Common Language Infrastructure (see <a href="PeterO.Numbers.EDecimal.html">
         &#x22;Forms of numbers&#x22;
      </a>) to an arbitrary-precision decimal.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>dec</i>: A  <code>
    decimal
</code> under the Common Language Infrastructure (usually a .NET Framework ecimal).</li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision decimal floating-point number.</p>

<h3>FromDouble</h3>

<pre>public static PeterO.Numbers.EDecimal FromDouble(
    double dbl);
</pre>

<p>Creates a decimal number from a 64-bit binary floating-point number. This ethod computes the exact value of the floating point number, not an pproximation, as is often the case by converting the floating point umber to a string first. Remember, though, that the exact value of a 4-bit binary floating-point number is not always the value that results hen passing a literal decimal number (for example, calling  <code>
        ExtendedDecimal.FromDouble(0.1f)
</code> ), since not all decimal numbers can be converted to exact binary numbers in the example given, the resulting arbitrary-precision decimal will be he value of the closest &quot;double&quot; to 0.1, not 0.1 exactly). To create an rbitrary-precision decimal number from a decimal number, use FromString nstead in most cases (for example:  <code>
        ExtendedDecimal.FromString(&quot;0.1&quot;)
</code> ).</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>dbl</i>: The parameter  <i>dbl</i>
is a 64-bit floating-point number.</li>
</ul>

<p><b>Return Value:</b></p>

<p>A decimal number with the same value as  <i>dbl</i>
.</p>

<h3>FromEFloat</h3>

<pre>public static PeterO.Numbers.EDecimal FromEFloat(
    PeterO.Numbers.EFloat bigfloat);
</pre>

<p>Creates a decimal number from an arbitrary-precision binary loating-point number.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>bigfloat</i>: An arbitrary-precision binary floating-point number.</li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision decimal number.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter  <i>bigfloat</i>
is null.</li>
</ul>

<h3>FromEInteger</h3>

<pre>public static PeterO.Numbers.EDecimal FromEInteger(
    PeterO.Numbers.EInteger bigint);
</pre>

<p>Converts an arbitrary-precision integer to an arbitrary precision ecimal.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>bigint</i>: An arbitrary-precision integer.</li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision decimal number with the exponent set to 0.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter  <i>bigint</i>
is null.</li>
</ul>

<h3>FromExtendedFloat</h3>

<pre>public static PeterO.Numbers.EDecimal FromExtendedFloat(
    PeterO.Numbers.EFloat ef);
</pre>

<p><b>Deprecated.</b> Renamed to FromEFloat.</p>

<p>Converts an arbitrary-precision binary floating-point number to an rbitrary precision decimal.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>ef</i>: An arbitrary-precision binary floating-point number.</li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision decimal number.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter  <i>ef</i>
is null.</li>
</ul>

<h3>FromInt16</h3>

<pre>public static PeterO.Numbers.EDecimal FromInt16(
    short inputInt16);
</pre>

<p>Converts a 16-bit signed integer to an arbitrary-precision decimal umber.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>inputInt16</i>: The number to convert as a 16-bit signed integer.</li>
</ul>

<p><b>Return Value:</b></p>

<p>This number&#39;s value as an arbitrary-precision decimal number.</p>

<h3>FromInt32</h3>

<pre>public static PeterO.Numbers.EDecimal FromInt32(
    int valueSmaller);
</pre>

<p>Creates a decimal number from a 32-bit signed integer.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>valueSmaller</i>: The parameter  <i>valueSmaller</i>
is a 32-bit signed integer.</li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision decimal number with the exponent set to 0.</p>

<h3>FromInt64</h3>

<pre>public static PeterO.Numbers.EDecimal FromInt64(
    long valueSmall);
</pre>

<p>Creates a decimal number from a 64-bit signed integer.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>valueSmall</i>: The parameter  <i>valueSmall</i>
is a 64-bit signed integer.</li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision decimal number with the exponent set to 0.</p>

<h3>FromSByte</h3>

<pre>public static PeterO.Numbers.EDecimal FromSByte(
    sbyte inputSByte);
</pre>

<p>Converts an 8-bit signed integer to an arbitrary-precision decimal umber.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>inputSByte</i>: The number to convert as an 8-bit signed integer.</li>
</ul>

<p><b>Return Value:</b></p>

<p>This number&#39;s value as an arbitrary-precision decimal number.</p>

<h3>FromSingle</h3>

<pre>public static PeterO.Numbers.EDecimal FromSingle(
    float flt);
</pre>

<p>Creates a decimal number from a 32-bit binary floating-point number. This ethod computes the exact value of the floating point number, not an pproximation, as is often the case by converting the floating point umber to a string first. Remember, though, that the exact value of a 2-bit binary floating-point number is not always the value that results hen passing a literal decimal number (for example, calling  <code>
        ExtendedDecimal.FromSingle(0.1f)
</code> ), since not all decimal numbers can be converted to exact binary numbers in the example given, the resulting arbitrary-precision decimal will be he the value of the closest &quot;float&quot; to 0.1, not 0.1 exactly). To create n arbitrary-precision decimal number from a decimal number, use romString instead in most cases (for example:  <code>
        ExtendedDecimal.FromString(&quot;0.1&quot;)
</code> ).</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>flt</i>: The parameter  <i>flt</i>
is a 32-bit binary floating-point number.</li>
</ul>

<p><b>Return Value:</b></p>

<p>A decimal number with the same value as  <i>flt</i>
.</p>

<h3>FromString</h3>

<pre>public static PeterO.Numbers.EDecimal FromString(
    string str);
</pre>

<p>Creates a decimal number from a text string that represents a number. See  <code>
        FromString(String, int, int, EContext)
</code> for more information.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>str</i>: A string that represents a number.</li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision decimal number with the same value as the given tring.</p>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.ArgumentNullException:
The parameter  <i>str</i>
is null.</p></li>
<li><p>System.FormatException:
The parameter  <i>str</i>
is not a correctly formatted number string.</p></li>
</ul>

<h3>FromString</h3>

<pre>public static PeterO.Numbers.EDecimal FromString(
    string str,
    int offset,
    int length);
</pre>

<p>Creates a decimal number from a text string that represents a number. See  <code>
        FromString(String, int, int, EContext)
</code> for more information.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>str</i>: A string that represents a number.</p></li>
<li><p><i>offset</i>: A zero-based index showing where the desired portion of  <i>str</i>
begins.</p></li>
<li><p><i>length</i>: The length, in code units, of the desired portion of  <i>str</i>
(but not more than  <i>str</i>
&#39;s length).</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision decimal number with the same value as the given tring.</p>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.ArgumentNullException:
The parameter  <i>str</i>
is null.</p></li>
<li><p>System.FormatException:
The parameter  <i>str</i>
is not a correctly formatted number string.</p></li>
</ul>

<h3>FromString</h3>

<pre>public static PeterO.Numbers.EDecimal FromString(
    string str,
    int offset,
    int length,
    PeterO.Numbers.EContext ctx);
</pre>

<p>Creates a decimal number from a text string that represents a number.</p>

<p>The format of the string generally consists of:</p>

<ul>
<li><p>An optional plus sign (&quot;+&quot; , U+002B) or minus sign (&quot;-&quot;, U+002D) (if he minus sign, the value is negative.)</p></li>
<li><p>One or more digits, with a single optional decimal point after the irst digit and before the last digit.</p></li>
<li><p>Optionally, &quot;E&quot;/&quot;e&quot; followed by an optional (positive exponent) or -&quot; (negative exponent) and followed by one or more digits specifying he exponent.</p></li>
</ul>

<p>The string can also be &quot;-INF&quot;, &quot;-Infinity&quot;, &quot;Infinity&quot;, &quot;INF&quot;, quiet aN (&quot;NaN&quot; /&quot;-NaN&quot;) followed by any number of digits, or signaling NaN &quot;sNaN&quot; /&quot;-sNaN&quot;) followed by any number of digits, all in any ombination of upper and lower case.</p>

<p>All characters mentioned above are the corresponding characters in the asic Latin range. In particular, the digits must be the basic digits 0 o 9 (U+0030 to U+0039). The string is not allowed to contain white pace characters, including spaces.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>str</i>: A text string, a portion of which represents a number.</p></li>
<li><p><i>offset</i>: A zero-based index that identifies the start of the number.</p></li>
<li><p><i>length</i>: The length of the number within the string.</p></li>
<li><p><i>ctx</i>: An arithmetic context to control precision, rounding, and exponent range f the result. If  <code>
    HasFlags
</code> of the context is true, will also store the flags resulting from the peration (the flags are in addition to the pre-existing flags). Can be ull, in which case the precision is unlimited and rounding isn&#39;t needed.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision decimal number with the same value as the given tring.</p>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.ArgumentNullException:
The parameter  <i>str</i>
is null.</p></li>
<li><p>System.FormatException:
The parameter  <i>str</i>
is not a correctly formatted number string.</p></li>
</ul>

<h3>FromString</h3>

<pre>public static PeterO.Numbers.EDecimal FromString(
    string str,
    PeterO.Numbers.EContext ctx);
</pre>

<p>Creates a decimal number from a text string that represents a number. See  <code>
        FromString(String, int, int, EContext)
</code> for more information.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>str</i>: A string that represents a number.</p></li>
<li><p><i>ctx</i>: An arithmetic context to control precision, rounding, and exponent range f the result. If  <code>
    HasFlags
</code> of the context is true, will also store the flags resulting from the peration (the flags are in addition to the pre-existing flags). Can be ull, in which case the precision is unlimited and rounding isn&#39;t needed.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision decimal number with the same value as the given tring.</p>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.ArgumentNullException:
The parameter  <i>str</i>
is null.</p></li>
<li><p>System.FormatException:
The parameter  <i>str</i>
is not a correctly formatted number string.</p></li>
</ul>

<h3>FromUInt16</h3>

<pre>public static PeterO.Numbers.EDecimal FromUInt16(
    ushort inputUInt16);
</pre>

<p>Converts a 16-bit unsigned integer to an arbitrary-precision decimal umber.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>inputUInt16</i>: The number to convert as a 16-bit unsigned integer.</li>
</ul>

<p><b>Return Value:</b></p>

<p>This number&#39;s value as an arbitrary-precision decimal number.</p>

<h3>FromUInt32</h3>

<pre>public static PeterO.Numbers.EDecimal FromUInt32(
    uint inputUInt32);
</pre>

<p>Converts a 32-bit signed integer to an arbitrary-precision decimal umber.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>inputUInt32</i>: The number to convert as a 32-bit signed integer.</li>
</ul>

<p><b>Return Value:</b></p>

<p>This number&#39;s value as an arbitrary-precision decimal number.</p>

<h3>FromUInt64</h3>

<pre>public static PeterO.Numbers.EDecimal FromUInt64(
    ulong inputUInt64);
</pre>

<p>Converts a 64-bit unsigned integer to an arbitrary-precision decimal umber.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>inputUInt64</i>: The number to convert as a 64-bit unsigned integer.</li>
</ul>

<p><b>Return Value:</b></p>

<p>This number&#39;s value as an arbitrary-precision decimal number.</p>

<h3>GetHashCode</h3>

<pre>public override int GetHashCode();
</pre>

<p>Calculates this object&#39;s hash code. No application or process IDs are sed in the hash code calculation.</p>

<p><b>Return Value:</b></p>

<p>This object&#39;s hash code.</p>

<h3>IsInfinity</h3>

<pre>public bool IsInfinity();
</pre>

<p>Gets a value indicating whether this object is positive or negative nfinity.</p>

<p><b>Return Value:</b></p>

<p><code>
        true
</code> if this object is positive or negative infinity; otherwise,  <code>
        false
</code> .</p>

<h3>IsNaN</h3>

<pre>public bool IsNaN();
</pre>

<p>Gets a value indicating whether this object is not a number (NaN).</p>

<p><b>Return Value:</b></p>

<p><code>
        true
</code> if this object is not a number (NaN); otherwise,  <code>
        false
</code> .</p>

<h3>IsNegativeInfinity</h3>

<pre>public bool IsNegativeInfinity();
</pre>

<p>Returns whether this object is negative infinity.</p>

<p><b>Return Value:</b></p>

<p><code>
        true
</code> if this object is negative infinity; otherwise,  <code>
        false
</code> .</p>

<h3>IsPositiveInfinity</h3>

<pre>public bool IsPositiveInfinity();
</pre>

<p>Returns whether this object is positive infinity.</p>

<p><b>Return Value:</b></p>

<p><code>
        true
</code> if this object is positive infinity; otherwise,  <code>
        false
</code> .</p>

<h3>IsQuietNaN</h3>

<pre>public bool IsQuietNaN();
</pre>

<p>Gets a value indicating whether this object is a quiet not-a-number alue.</p>

<p><b>Return Value:</b></p>

<p><code>
        true
</code> if this object is a quiet not-a-number value; otherwise,  <code>
        false
</code> .</p>

<h3>IsSignalingNaN</h3>

<pre>public bool IsSignalingNaN();
</pre>

<p>Gets a value indicating whether this object is a signaling not-a-number alue.</p>

<p><b>Return Value:</b></p>

<p><code>
        true
</code> if this object is a signaling not-a-number value; otherwise,  <code>
        false
</code> .</p>

<h3>Log</h3>

<pre>public PeterO.Numbers.EDecimal Log(
    PeterO.Numbers.EContext ctx);
</pre>

<p>Finds the natural logarithm of this object, that is, the power (exponent) hat e (the base of natural logarithms) must be raised to in order to qual this object&#39;s value.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>ctx</i>: An arithmetic context to control precision, rounding, and exponent range f the result. If  <code>
    HasFlags
</code> of the context is true, will also store the flags resulting from the peration (the flags are in addition to the pre-existing flags). <i>This parameter can&#39;t be null, as the ln function&#39;s results are enerally not exact. </i>(Unlike in the General Decimal Arithmetic Specification, any rounding ode is allowed.).</li>
</ul>

<p><b>Return Value:</b></p>

<p>Ln(this object). Signals the flag FlagInvalid and returns NaN if this bject is less than 0 (the result would be a complex number with a real art equal to Ln of this object&#39;s absolute value and an imaginary part qual to pi, but the return value is still NaN.). Signals FlagInvalid and eturns not-a-number (NaN) if the parameter  <i>ctx</i>
is null or the precision is unlimited (the context&#39;s Precision property s 0). Signals no flags and returns negative infinity if this object&#39;s alue is 0.</p>

<h3>Log10</h3>

<pre>public PeterO.Numbers.EDecimal Log10(
    PeterO.Numbers.EContext ctx);
</pre>

<p>Finds the base-10 logarithm of this object, that is, the power (exponent) hat the number 10 must be raised to in order to equal this object&#39;s alue.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>ctx</i>: An arithmetic context to control precision, rounding, and exponent range f the result. If  <code>
    HasFlags
</code> of the context is true, will also store the flags resulting from the peration (the flags are in addition to the pre-existing flags). <i>This parameter can&#39;t be null, as the ln function&#39;s results are enerally not exact. </i>(Unlike in the General Decimal Arithmetic Specification, any rounding ode is allowed.).</li>
</ul>

<p><b>Return Value:</b></p>

<p>Ln(this object)/Ln(10). Signals the flag FlagInvalid and returns ot-a-number (NaN) if this object is less than 0. Signals FlagInvalid and eturns not-a-number (NaN) if the parameter  <i>ctx</i>
is null or the precision is unlimited (the context&#39;s Precision property s 0).</p>

<h3>Max</h3>

<pre>public static PeterO.Numbers.EDecimal Max(
    PeterO.Numbers.EDecimal first,
    PeterO.Numbers.EDecimal second);
</pre>

<p>Gets the greater value between two decimal numbers.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>first</i>: An arbitrary-precision decimal number.</p></li>
<li><p><i>second</i>: Another arbitrary-precision decimal number.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>The larger value of the two numbers.</p>

<h3>Max</h3>

<pre>public static PeterO.Numbers.EDecimal Max(
    PeterO.Numbers.EDecimal first,
    PeterO.Numbers.EDecimal second,
    PeterO.Numbers.EContext ctx);
</pre>

<p>Gets the greater value between two decimal numbers.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>first</i>: The first value to compare.</p></li>
<li><p><i>second</i>: The second value to compare.</p></li>
<li><p><i>ctx</i>: An arithmetic context to control precision, rounding, and exponent range f the result. If  <code>
    HasFlags
</code> of the context is true, will also store the flags resulting from the peration (the flags are in addition to the pre-existing flags). Can be ull, in which case the precision is unlimited and rounding isn&#39;t needed.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>The larger value of the two numbers.</p>

<h3>MaxMagnitude</h3>

<pre>public static PeterO.Numbers.EDecimal MaxMagnitude(
    PeterO.Numbers.EDecimal first,
    PeterO.Numbers.EDecimal second);
</pre>

<p>Gets the greater value between two values, ignoring their signs. If the bsolute values are equal, has the same effect as Max.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>first</i>: The first value to compare.</p></li>
<li><p><i>second</i>: The second value to compare.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision decimal number.</p>

<h3>MaxMagnitude</h3>

<pre>public static PeterO.Numbers.EDecimal MaxMagnitude(
    PeterO.Numbers.EDecimal first,
    PeterO.Numbers.EDecimal second,
    PeterO.Numbers.EContext ctx);
</pre>

<p>Gets the greater value between two values, ignoring their signs. If the bsolute values are equal, has the same effect as Max.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>first</i>: The first value to compare.</p></li>
<li><p><i>second</i>: The second value to compare.</p></li>
<li><p><i>ctx</i>: An arithmetic context to control precision, rounding, and exponent range f the result. If  <code>
    HasFlags
</code> of the context is true, will also store the flags resulting from the peration (the flags are in addition to the pre-existing flags). Can be ull, in which case the precision is unlimited and rounding isn&#39;t needed.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision decimal number.</p>

<h3>Min</h3>

<pre>public static PeterO.Numbers.EDecimal Min(
    PeterO.Numbers.EDecimal first,
    PeterO.Numbers.EDecimal second);
</pre>

<p>Gets the lesser value between two decimal numbers.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>first</i>: The first value to compare.</p></li>
<li><p><i>second</i>: The second value to compare.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>The smaller value of the two numbers.</p>

<h3>Min</h3>

<pre>public static PeterO.Numbers.EDecimal Min(
    PeterO.Numbers.EDecimal first,
    PeterO.Numbers.EDecimal second,
    PeterO.Numbers.EContext ctx);
</pre>

<p>Gets the lesser value between two decimal numbers.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>first</i>: The first value to compare.</p></li>
<li><p><i>second</i>: The second value to compare.</p></li>
<li><p><i>ctx</i>: An arithmetic context to control precision, rounding, and exponent range f the result. If  <code>
    HasFlags
</code> of the context is true, will also store the flags resulting from the peration (the flags are in addition to the pre-existing flags). Can be ull, in which case the precision is unlimited and rounding isn&#39;t needed.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>The smaller value of the two numbers.</p>

<h3>MinMagnitude</h3>

<pre>public static PeterO.Numbers.EDecimal MinMagnitude(
    PeterO.Numbers.EDecimal first,
    PeterO.Numbers.EDecimal second);
</pre>

<p>Gets the lesser value between two values, ignoring their signs. If the bsolute values are equal, has the same effect as Min.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>first</i>: The first value to compare.</p></li>
<li><p><i>second</i>: The second value to compare.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision decimal number.</p>

<h3>MinMagnitude</h3>

<pre>public static PeterO.Numbers.EDecimal MinMagnitude(
    PeterO.Numbers.EDecimal first,
    PeterO.Numbers.EDecimal second,
    PeterO.Numbers.EContext ctx);
</pre>

<p>Gets the lesser value between two values, ignoring their signs. If the bsolute values are equal, has the same effect as Min.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>first</i>: The first value to compare.</p></li>
<li><p><i>second</i>: The second value to compare.</p></li>
<li><p><i>ctx</i>: An arithmetic context to control precision, rounding, and exponent range f the result. If  <code>
    HasFlags
</code> of the context is true, will also store the flags resulting from the peration (the flags are in addition to the pre-existing flags). Can be ull, in which case the precision is unlimited and rounding isn&#39;t needed.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision decimal number.</p>

<h3>MovePointLeft</h3>

<pre>public PeterO.Numbers.EDecimal MovePointLeft(
    int places);
</pre>

<p>Returns a number similar to this number but with the decimal point moved o the left.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>places</i>: The number of decimal places to move the decimal point to the left. If his number is negative, instead moves the decimal point to the right by his number&#39;s absolute value.</li>
</ul>

<p><b>Return Value:</b></p>

<p>A number whose exponent is decreased by  <i>places</i>
, but not to more than 0.</p>

<h3>MovePointLeft</h3>

<pre>public PeterO.Numbers.EDecimal MovePointLeft(
    int places,
    PeterO.Numbers.EContext ctx);
</pre>

<p>Returns a number similar to this number but with the decimal point moved o the left.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>places</i>: The number of decimal places to move the decimal point to the left. If his number is negative, instead moves the decimal point to the right by his number&#39;s absolute value.</p></li>
<li><p><i>ctx</i>: An arithmetic context to control precision, rounding, and exponent range f the result. If  <code>
    HasFlags
</code> of the context is true, will also store the flags resulting from the peration (the flags are in addition to the pre-existing flags). Can be ull, in which case the precision is unlimited and rounding isn&#39;t needed.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>A number whose exponent is decreased by  <i>places</i>
, but not to more than 0.</p>

<h3>MovePointLeft</h3>

<pre>public PeterO.Numbers.EDecimal MovePointLeft(
    PeterO.Numbers.EInteger bigPlaces);
</pre>

<p>Returns a number similar to this number but with the decimal point moved o the left.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>bigPlaces</i>: The number of decimal places to move the decimal point to the left. If his number is negative, instead moves the decimal point to the right by his number&#39;s absolute value.</li>
</ul>

<p><b>Return Value:</b></p>

<p>A number whose exponent is decreased by  <i>bigPlaces</i>
, but not to more than 0.</p>

<h3>MovePointLeft</h3>

<pre>public PeterO.Numbers.EDecimal MovePointLeft(
    PeterO.Numbers.EInteger bigPlaces,
    PeterO.Numbers.EContext ctx);
</pre>

<p>Returns a number similar to this number but with the decimal point moved o the left.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>bigPlaces</i>: The number of decimal places to move the decimal point to the left. If his number is negative, instead moves the decimal point to the right by his number&#39;s absolute value.</p></li>
<li><p><i>ctx</i>: An arithmetic context to control precision, rounding, and exponent range f the result. If  <code>
    HasFlags
</code> of the context is true, will also store the flags resulting from the peration (the flags are in addition to the pre-existing flags). Can be ull, in which case the precision is unlimited and rounding isn&#39;t needed.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>A number whose exponent is decreased by  <i>bigPlaces</i>
, but not to more than 0.</p>

<h3>MovePointRight</h3>

<pre>public PeterO.Numbers.EDecimal MovePointRight(
    int places);
</pre>

<p>Returns a number similar to this number but with the decimal point moved o the right.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>places</i>: The number of decimal places to move the decimal point to the right. If his number is negative, instead moves the decimal point to the left by his number&#39;s absolute value.</li>
</ul>

<p><b>Return Value:</b></p>

<p>A number whose exponent is increased by  <i>places</i>
, but not to more than 0.</p>

<h3>MovePointRight</h3>

<pre>public PeterO.Numbers.EDecimal MovePointRight(
    int places,
    PeterO.Numbers.EContext ctx);
</pre>

<p>Returns a number similar to this number but with the decimal point moved o the right.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>places</i>: The number of decimal places to move the decimal point to the right. If his number is negative, instead moves the decimal point to the left by his number&#39;s absolute value.</p></li>
<li><p><i>ctx</i>: An arithmetic context to control precision, rounding, and exponent range f the result. If  <code>
    HasFlags
</code> of the context is true, will also store the flags resulting from the peration (the flags are in addition to the pre-existing flags). Can be ull, in which case the precision is unlimited and rounding isn&#39;t needed.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>A number whose exponent is increased by  <i>places</i>
, but not to more than 0.</p>

<h3>MovePointRight</h3>

<pre>public PeterO.Numbers.EDecimal MovePointRight(
    PeterO.Numbers.EInteger bigPlaces);
</pre>

<p>Returns a number similar to this number but with the decimal point moved o the right.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>bigPlaces</i>: The number of decimal places to move the decimal point to the right. If his number is negative, instead moves the decimal point to the left by his number&#39;s absolute value.</li>
</ul>

<p><b>Return Value:</b></p>

<p>A number whose exponent is increased by  <i>bigPlaces</i>
, but not to more than 0.</p>

<h3>MovePointRight</h3>

<pre>public PeterO.Numbers.EDecimal MovePointRight(
    PeterO.Numbers.EInteger bigPlaces,
    PeterO.Numbers.EContext ctx);
</pre>

<p>Returns a number similar to this number but with the decimal point moved o the right.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>bigPlaces</i>: The number of decimal places to move the decimal point to the right. If his number is negative, instead moves the decimal point to the left by his number&#39;s absolute value.</p></li>
<li><p><i>ctx</i>: An arithmetic context to control precision, rounding, and exponent range f the result. If  <code>
    HasFlags
</code> of the context is true, will also store the flags resulting from the peration (the flags are in addition to the pre-existing flags). Can be ull, in which case the precision is unlimited and rounding isn&#39;t needed.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>A number whose exponent is increased by  <i>bigPlaces</i>
, but not to more than 0.</p>

<h3>Multiply</h3>

<pre>public PeterO.Numbers.EDecimal Multiply(
    PeterO.Numbers.EDecimal op,
    PeterO.Numbers.EContext ctx);
</pre>

<p>Multiplies two decimal numbers. The resulting scale will be the sum of he scales of the two decimal numbers. The result&#39;s sign is positive if oth operands have the same sign, and negative if they have different igns.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>op</i>: Another decimal number.</p></li>
<li><p><i>ctx</i>: An arithmetic context to control precision, rounding, and exponent range f the result. If  <code>
    HasFlags
</code> of the context is true, will also store the flags resulting from the peration (the flags are in addition to the pre-existing flags). Can be ull, in which case the precision is unlimited and rounding isn&#39;t needed.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>The product of the two decimal numbers.</p>

<h3>Multiply</h3>

<pre>public PeterO.Numbers.EDecimal Multiply(
    PeterO.Numbers.EDecimal otherValue);
</pre>

<p>Multiplies two decimal numbers. The resulting exponent will be the sum of he exponents of the two decimal numbers.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>otherValue</i>: Another decimal number.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The product of the two decimal numbers.</p>

<h3>MultiplyAndAdd</h3>

<pre>public PeterO.Numbers.EDecimal MultiplyAndAdd(
    PeterO.Numbers.EDecimal multiplicand,
    PeterO.Numbers.EDecimal augend);
</pre>

<p>Multiplies by one decimal number, and then adds another decimal number.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>multiplicand</i>: The value to multiply.</p></li>
<li><p><i>augend</i>: The value to add.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>The result this *  <i>multiplicand</i></p>

<ul>
<li> <i>augend</i>
.</li>
</ul>

<h3>MultiplyAndAdd</h3>

<pre>public PeterO.Numbers.EDecimal MultiplyAndAdd(
    PeterO.Numbers.EDecimal op,
    PeterO.Numbers.EDecimal augend,
    PeterO.Numbers.EContext ctx);
</pre>

<p>Multiplies by one value, and then adds another value.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>op</i>: The value to multiply.</p></li>
<li><p><i>augend</i>: The value to add.</p></li>
<li><p><i>ctx</i>: An arithmetic context to control precision, rounding, and exponent range f the result. If  <code>
    HasFlags
</code> of the context is true, will also store the flags resulting from the peration (the flags are in addition to the pre-existing flags). Can be ull, in which case the precision is unlimited and rounding isn&#39;t needed. f the precision doesn&#39;t indicate a simplified arithmetic, rounding and recision/exponent adjustment is done only once, namely, after multiplying nd adding.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>The result thisValue * multiplicand + augend.</p>

<h3>MultiplyAndSubtract</h3>

<pre>public PeterO.Numbers.EDecimal MultiplyAndSubtract(
    PeterO.Numbers.EDecimal op,
    PeterO.Numbers.EDecimal subtrahend,
    PeterO.Numbers.EContext ctx);
</pre>

<p>Multiplies by one value, and then subtracts another value.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>op</i>: The value to multiply.</p></li>
<li><p><i>subtrahend</i>: The value to subtract.</p></li>
<li><p><i>ctx</i>: An arithmetic context to control precision, rounding, and exponent range f the result. If  <code>
    HasFlags
</code> of the context is true, will also store the flags resulting from the peration (the flags are in addition to the pre-existing flags). Can be ull, in which case the precision is unlimited and rounding isn&#39;t needed. f the precision doesn&#39;t indicate a simplified arithmetic, rounding and recision/exponent adjustment is done only once, namely, after multiplying nd subtracting.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>The result thisValue * multiplicand - subtrahend.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter  <i>op</i>
or  <i>subtrahend</i>
is null.</li>
</ul>

<h3>Negate</h3>

<pre>public PeterO.Numbers.EDecimal Negate(
    PeterO.Numbers.EContext context);
</pre>

<p>Returns a decimal number with the same value as this object but with the ign reversed.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>context</i>: An arithmetic context to control precision, rounding, and exponent range f the result. If  <code>
    HasFlags
</code> of the context is true, will also store the flags resulting from the peration (the flags are in addition to the pre-existing flags). Can be ull, in which case the precision is unlimited and rounding isn&#39;t needed.</li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision decimal number. If this value is positive zero, eturns positive zero. Signals FlagInvalid and returns quiet NaN if this alue is signaling NaN.</p>

<h3>Negate</h3>

<pre>public PeterO.Numbers.EDecimal Negate();
</pre>

<p>Gets an object with the same value as this one, but with the sign eversed.</p>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision decimal number. If this value is positive zero, eturns negative zero. Returns signaling NaN if this value is signaling aN.</p>

<h3>NextMinus</h3>

<pre>public PeterO.Numbers.EDecimal NextMinus(
    PeterO.Numbers.EContext ctx);
</pre>

<p>Finds the largest value that&#39;s smaller than the given value.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>ctx</i>: An arithmetic context object to control the precision and exponent range f the result. The rounding mode from this context is ignored. If  <code>
    HasFlags
</code> of the context is true, will also store the flags resulting from the peration (the flags are in addition to the pre-existing flags).</li>
</ul>

<p><b>Return Value:</b></p>

<p>Returns the largest value that&#39;s less than the given value. Returns egative infinity if the result is negative infinity. Signals FlagInvalid nd returns not-a-number (NaN) if the parameter  <i>ctx</i>
is null, the precision is 0, or  <i>ctx</i>
has an unlimited exponent range.</p>

<h3>NextPlus</h3>

<pre>public PeterO.Numbers.EDecimal NextPlus(
    PeterO.Numbers.EContext ctx);
</pre>

<p>Finds the smallest value that&#39;s greater than the given value.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>ctx</i>: An arithmetic context object to control the precision and exponent range f the result. The rounding mode from this context is ignored. If  <code>
    HasFlags
</code> of the context is true, will also store the flags resulting from the peration (the flags are in addition to the pre-existing flags).</li>
</ul>

<p><b>Return Value:</b></p>

<p>Returns the smallest value that&#39;s greater than the given value.Signals lagInvalid and returns not-a-number (NaN) if the parameter  <i>ctx</i>
is null, the precision is 0, or  <i>ctx</i>
has an unlimited exponent range.</p>

<h3>NextToward</h3>

<pre>public PeterO.Numbers.EDecimal NextToward(
    PeterO.Numbers.EDecimal otherValue,
    PeterO.Numbers.EContext ctx);
</pre>

<p>Finds the next value that is closer to the other object&#39;s value than this bject&#39;s value. Returns a copy of this value with the same sign as the ther value if both values are equal.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>otherValue</i>: An arbitrary-precision decimal number that the return value will pproach.</p></li>
<li><p><i>ctx</i>: An arithmetic context object to control the precision and exponent range f the result. The rounding mode from this context is ignored. If  <code>
    HasFlags
</code> of the context is true, will also store the flags resulting from the peration (the flags are in addition to the pre-existing flags).</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>Returns the next value that is closer to the other object&#39; s value than his object&#39;s value. Signals FlagInvalid and returns NaN if the parameter  <i>ctx</i>
is null, the precision is 0, or  <i>ctx</i>
has an unlimited exponent range.</p>

<h3>Operator <code>+</code></h3>

<pre>public static PeterO.Numbers.EDecimal operator +(
    PeterO.Numbers.EDecimal bthis,
    PeterO.Numbers.EDecimal otherValue);
</pre>

<p>Adds two arbitrary-precision decimal floating-point numbers and returns he result.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>bthis</i>: The first arbitrary-precision decimal floating-point number.</p></li>
<li><p><i>otherValue</i>: The second decimal binary floating-point number.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>The sum of the two objects.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter  <i>bthis</i>
or  <i>otherValue</i>
is null.</li>
</ul>

<h3>Operator <code>/</code></h3>

<pre>public static PeterO.Numbers.EDecimal operator /(
    PeterO.Numbers.EDecimal dividend,
    PeterO.Numbers.EDecimal divisor);
</pre>

<p>Divides this object by another decimal number and returns the result. hen possible, the result will be exact.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>dividend</i>: The number that will be divided by the divisor.</p></li>
<li><p><i>divisor</i>: The number to divide by.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>The quotient of the two numbers. Returns infinity if the divisor is 0 and he dividend is nonzero. Returns not-a-number (NaN) if the divisor and the ividend are 0. Returns NaN if the result can&#39;t be exact because it would ave a nonterminating decimal expansion.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter  <i>dividend</i>
is null.</li>
</ul>

<h3>Operator <code>%</code></h3>

<pre>public static PeterO.Numbers.EDecimal operator %(
    PeterO.Numbers.EDecimal dividend,
    PeterO.Numbers.EDecimal divisor);
</pre>

<p>Finds the remainder when dividing one arbitrary-precision decimal number y another.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>dividend</i>: The number that will be divided by the divisor.</p></li>
<li><p><i>divisor</i>: The number to divide by.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>The result of the operation.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter  <i>dividend</i>
is null.</li>
</ul>

<h3>Operator <code>*</code></h3>

<pre>public static PeterO.Numbers.EDecimal operator *(
    PeterO.Numbers.EDecimal operand1,
    PeterO.Numbers.EDecimal operand2);
</pre>

<p>Multiplies two decimal numbers. The resulting exponent will be the sum of he exponents of the two decimal numbers.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>operand1</i>: The first operand.</p></li>
<li><p><i>operand2</i>: The second operand.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>The product of the two decimal numbers.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter  <i>operand1</i>
or  <i>operand2</i>
is null.</li>
</ul>

<h3>Operator <code>-</code></h3>

<pre>public static PeterO.Numbers.EDecimal operator -(
    PeterO.Numbers.EDecimal bthis,
    PeterO.Numbers.EDecimal subtrahend);
</pre>

<p>Subtracts one arbitrary-precision decimal number from another and returns he result.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>bthis</i>: The first operand.</p></li>
<li><p><i>subtrahend</i>: The second operand.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>The difference of the two decimal numbers.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter  <i>bthis</i>
or  <i>subtrahend</i>
is null.</li>
</ul>

<h3>Operator <code>-</code></h3>

<pre>public static PeterO.Numbers.EDecimal operator -(
    PeterO.Numbers.EDecimal bigValue);
</pre>

<p>Gets an arbitrary-precision decimal number with the same value as the iven one, but with the sign reversed.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>bigValue</i>: An arbitrary-precision decimal number to negate.</li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision decimal number. If this value is positive zero, eturns negative zero. Returns signaling NaN if this value is signaling aN.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter  <i>bigValue</i>
is null.</li>
</ul>

<h3>PI</h3>

<pre>public static PeterO.Numbers.EDecimal PI(
    PeterO.Numbers.EContext ctx);
</pre>

<p>Finds the constant , the circumference of a circle divided by its iameter.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>ctx</i>: An arithmetic context to control precision, rounding, and exponent range f the result. If  <code>
    HasFlags
</code> of the context is true, will also store the flags resulting from the peration (the flags are in addition to the pre-existing flags). <i>This parameter can&#39;t be null, as  can never be represented exactly. </i>.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The constant  rounded to the given precision. Signals FlagInvalid and eturns not-a-number (NaN) if the parameter  <i>ctx</i>
is null or the precision is unlimited (the context&#39;s Precision property s 0).</p>

<h3>Plus</h3>

<pre>public PeterO.Numbers.EDecimal Plus(
    PeterO.Numbers.EContext ctx);
</pre>

<p>Rounds this object&#39;s value to a given precision, using the given rounding ode and range of exponent, and also converts negative zero to positive ero.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>ctx</i>: A context for controlling the precision, rounding mode, and exponent ange. Can be null, in which case the precision is unlimited and rounding sn&#39;t needed.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The closest value to this object&#39;s value, rounded to the specified recision. Returns the same value as this object if  <i>ctx</i>
is null or the precision and exponent range are unlimited.</p>

<h3>Pow</h3>

<pre>public PeterO.Numbers.EDecimal Pow(
    int exponentSmall);
</pre>

<p>Raises this object&#39;s value to the given exponent.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>exponentSmall</i>: The exponent to raise this object&#39;s value to.</li>
</ul>

<p><b>Return Value:</b></p>

<p>This^exponent. Returns not-a-number (NaN) if this object and exponent are oth 0.</p>

<h3>Pow</h3>

<pre>public PeterO.Numbers.EDecimal Pow(
    int exponentSmall,
    PeterO.Numbers.EContext ctx);
</pre>

<p>Raises this object&#39;s value to the given exponent.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>exponentSmall</i>: The exponent to raise this object&#39;s value to.</p></li>
<li><p><i>ctx</i>: An arithmetic context to control precision, rounding, and exponent range f the result. If  <code>
    HasFlags
</code> of the context is true, will also store the flags resulting from the peration (the flags are in addition to the pre-existing flags). Can be ull, in which case the precision is unlimited and rounding isn&#39;t needed.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>This^exponent. Signals the flag FlagInvalid and returns NaN if this bject and exponent are both 0.</p>

<h3>Pow</h3>

<pre>public PeterO.Numbers.EDecimal Pow(
    PeterO.Numbers.EDecimal exponent,
    PeterO.Numbers.EContext ctx);
</pre>

<p>Raises this object&#39;s value to the given exponent.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>exponent</i>: An arbitrary-precision decimal number expressing the exponent to raise his object&#39;s value to.</p></li>
<li><p><i>ctx</i>: An arithmetic context to control precision, rounding, and exponent range f the result. If  <code>
    HasFlags
</code> of the context is true, will also store the flags resulting from the peration (the flags are in addition to the pre-existing flags). Can be ull, in which case the precision is unlimited and rounding isn&#39;t needed.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>This^exponent. Signals the flag FlagInvalid and returns NaN if this bject and exponent are both 0; or if this value is less than 0 and the xponent either has a fractional part or is infinity. Signals FlagInvalid nd returns not-a-number (NaN) if the parameter  <i>ctx</i>
is null or the precision is unlimited (the context&#39;s Precision property s 0), and the exponent has a fractional part.</p>

<h3>Precision</h3>

<pre>public PeterO.Numbers.EInteger Precision();
</pre>

<p>Finds the number of digits in this number&#39;s mantissa (significand). eturns 1 if this value is 0, and 0 if this value is infinity or ot-a-number (NaN).</p>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision integer.</p>

<h3>Quantize</h3>

<pre>public PeterO.Numbers.EDecimal Quantize(
    int desiredExponentInt,
    PeterO.Numbers.EContext ctx);
</pre>

<p>Returns a decimal number with the same value but a new exponent. Note that this is not always the same as rounding to a given number of ecimal places, since it can fail if the difference between this value&#39;s xponent and the desired exponent is too big, depending on the maximum recision. If rounding to a number of decimal places is desired, it&#39;s etter to use the RoundToExponent and RoundToIntegral methods instead.</p>

<p><b>Remark:</b>This method can be used to implement fixed-point decimal arithmetic, in hich each decimal number has a fixed number of digits after the decimal oint. The following code example returns a fixed-point number with up o 20 digits before and exactly 5 digits after the decimal point:</p>

<pre>// After performing arithmetic operations, adjust // the number to 5
igits after the decimal point number = number.Quantize(-5, // five
igits after the decimal point EContext.ForPrecision(25) // 25-digit
recision);
</pre>

<p>A fixed-point decimal arithmetic in which no digits come after the ecimal point (a desired exponent of 0) is considered an &quot;integer rithmetic&quot;.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>desiredExponentInt</i>: The desired exponent for the result. The exponent is the number of ractional digits in the result, expressed as a negative number. Can also e positive, which eliminates lower-order places from the number. For xample, -3 means round to the thousandth (10^-3, 0.0001), and 3 means ound to the thousand (10^3, 1000). A value of 0 rounds the number to an nteger.</p></li>
<li><p><i>ctx</i>: An arithmetic context to control precision and rounding of the result. If  <code>
    HasFlags
</code> of the context is true, will also store the flags resulting from the peration (the flags are in addition to the pre-existing flags). Can be ull, in which case the default rounding mode is HalfEven.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>A decimal number with the same value as this object but with the exponent hanged. Signals FlagInvalid and returns not-a-number (NaN) if this object s infinity, if the rounded result can&#39;t fit the given precision, or if he context defines an exponent range and the given exponent is outside hat range.</p>

<h3>Quantize</h3>

<pre>public PeterO.Numbers.EDecimal Quantize(
    int desiredExponentInt,
    PeterO.Numbers.ERounding rounding);
</pre>

<p>Returns a decimal number with the same value as this one but a new xponent. <b>Remark:</b>This method can be used to implement fixed-point decimal arithmetic, in hich a fixed number of digits come after the decimal point. A ixed-point decimal arithmetic in which no digits come after the decimal oint (a desired exponent of 0) is considered an &quot;integer arithmetic&quot;.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>desiredExponentInt</i>: The desired exponent for the result. The exponent is the number of ractional digits in the result, expressed as a negative number. Can also e positive, which eliminates lower-order places from the number. For xample, -3 means round to the thousandth (10^-3, 0.0001), and 3 means ound to the thousand (10^3, 1000). A value of 0 rounds the number to an nteger.</p></li>
<li><p><i>rounding</i>: A rounding mode to use in case the result needs to be rounded to fit the iven exponent.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>A decimal number with the same value as this object but with the exponent hanged. Returns not-a-number (NaN) if this object is infinity, or if the ounding mode is ERounding.None and the result is not exact.</p>

<h3>Quantize</h3>

<pre>public PeterO.Numbers.EDecimal Quantize(
    PeterO.Numbers.EDecimal otherValue,
    PeterO.Numbers.EContext ctx);
</pre>

<p>Returns a decimal number with the same value as this object but with the ame exponent as another decimal number. Note that this is not always the same as rounding to a given number of ecimal places, since it can fail if the difference between this value&#39;s xponent and the desired exponent is too big, depending on the maximum recision. If rounding to a number of decimal places is desired, it&#39;s etter to use the RoundToExponent and RoundToIntegral methods instead.</p>

<p><b>Remark:</b>This method can be used to implement fixed-point decimal arithmetic, in hich a fixed number of digits come after the decimal point. A ixed-point decimal arithmetic in which no digits come after the decimal oint (a desired exponent of 0) is considered an &quot;integer arithmetic&quot;.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>otherValue</i>: A decimal number containing the desired exponent of the result. The antissa (significand) is ignored. The exponent is the number of ractional digits in the result, expressed as a negative number. Can also e positive, which eliminates lower-order places from the number. For xample, -3 means round to the sixteenth (10b^-3, 0.0001b), and 3 means ound to the sixteen-place (10b^3, 1000b). A value of 0 rounds the number o an integer.</p></li>
<li><p><i>ctx</i>: An arithmetic context to control precision and rounding of the result. If  <code>
    HasFlags
</code> of the context is true, will also store the flags resulting from the peration (the flags are in addition to the pre-existing flags). Can be ull, in which case the default rounding mode is HalfEven.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>A decimal number with the same value as this object but with the exponent hanged. Signals FlagInvalid and returns not-a-number (NaN) if the result an&#39;t fit the given precision without rounding, or if the arithmetic ontext defines an exponent range and the given exponent is outside that ange.</p>

<h3>Quantize</h3>

<pre>public PeterO.Numbers.EDecimal Quantize(
    PeterO.Numbers.EInteger desiredExponent,
    PeterO.Numbers.EContext ctx);
</pre>

<p>Returns a decimal number with the same value but a new exponent. Note that this is not always the same as rounding to a given number of ecimal places, since it can fail if the difference between this value&#39;s xponent and the desired exponent is too big, depending on the maximum recision. If rounding to a number of decimal places is desired, it&#39;s etter to use the RoundToExponent and RoundToIntegral methods instead.</p>

<p><b>Remark:</b>This method can be used to implement fixed-point decimal arithmetic, in hich each decimal number has a fixed number of digits after the decimal oint. The following code example returns a fixed-point number with up o 20 digits before and exactly 5 digits after the decimal point:</p>

<pre>// After performing arithmetic operations, adjust // the number to 5 //
igits after the decimal point number = number.Quantize(
Integer.FromInt32(-5), // five digits after the decimal point
Context.ForPrecision(25) // 25-digit precision);
</pre>

<p>A fixed-point decimal arithmetic in which no digits come after the ecimal point (a desired exponent of 0) is considered an &quot;integer rithmetic&quot;.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>desiredExponent</i>: The desired exponent for the result. The exponent is the number of ractional digits in the result, expressed as a negative number. Can also e positive, which eliminates lower-order places from the number. For xample, -3 means round to the thousandth (10^-3, 0.0001), and 3 means ound to the thousand (10^3, 1000). A value of 0 rounds the number to an nteger.</p></li>
<li><p><i>ctx</i>: An arithmetic context to control precision and rounding of the result. If  <code>
    HasFlags
</code> of the context is true, will also store the flags resulting from the peration (the flags are in addition to the pre-existing flags). Can be ull, in which case the default rounding mode is HalfEven.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>A decimal number with the same value as this object but with the exponent hanged. Signals FlagInvalid and returns not-a-number (NaN) if this object s infinity, if the rounded result can&#39;t fit the given precision, or if he context defines an exponent range and the given exponent is outside hat range.</p>

<h3>Reduce</h3>

<pre>public PeterO.Numbers.EDecimal Reduce(
    PeterO.Numbers.EContext ctx);
</pre>

<p>Removes trailing zeros from this object&#39;s mantissa (significand). For xample, 1.00 becomes 1. If this object&#39;s value is 0, changes the exponent to 0.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>ctx</i>: An arithmetic context to control precision, rounding, and exponent range f the result. If  <code>
    HasFlags
</code> of the context is true, will also store the flags resulting from the peration (the flags are in addition to the pre-existing flags). Can be ull, in which case the precision is unlimited and rounding isn&#39;t needed.</li>
</ul>

<p><b>Return Value:</b></p>

<p>This value with trailing zeros removed. Note that if the result has a ery high exponent and the context says to clamp high exponents, there may till be some trailing zeros in the mantissa (significand).</p>

<h3>Remainder</h3>

<pre>public PeterO.Numbers.EDecimal Remainder(
    PeterO.Numbers.EDecimal divisor,
    PeterO.Numbers.EContext ctx);
</pre>

<p>Finds the remainder that results when dividing two arbitrary-precision ecimal numbers. The remainder is the value that remains when the absolute alue of this object is divided by the absolute value of the other object; he remainder has the same sign (positive or negative) as this object&#39;s alue.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>divisor</i>: The number to divide by.</p></li>
<li><p><i>ctx</i>: An arithmetic context object to control the precision, rounding, and xponent range of the result. This context will be used both in the ivision portion and in the remainder portion of the remainder alculation. If  <code>
    HasFlags
</code> of the context is true, will also store the flags resulting from the peration (the flags are in addition to the pre-existing flags). Can be ull, in which case the precision is unlimited and no additional rounding other than the rounding from integer division) is needed.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>The remainder of the two numbers. Signals FlagInvalid and returns ot-a-number (NaN) if the divisor is 0, or if the result doesn&#39;t fit the iven precision.</p>

<h3>RemainderNaturalScale</h3>

<pre>public PeterO.Numbers.EDecimal RemainderNaturalScale(
    PeterO.Numbers.EDecimal divisor);
</pre>

<p>Calculates the remainder of a number by the formula  <code>
        &quot;this&quot; - ((&quot;this&quot; / &quot;divisor&quot;) * &quot;divisor&quot;)
</code></p>

<p><b>Parameters:</b></p>

<ul>
<li><i>divisor</i>: The number to divide by.</li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision decimal number.</p>

<h3>RemainderNaturalScale</h3>

<pre>public PeterO.Numbers.EDecimal RemainderNaturalScale(
    PeterO.Numbers.EDecimal divisor,
    PeterO.Numbers.EContext ctx);
</pre>

<p>Calculates the remainder of a number by the formula &quot;this&quot; - ((&quot;this&quot; / divisor&quot;) * &quot;divisor&quot;).</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>divisor</i>: The number to divide by.</p></li>
<li><p><i>ctx</i>: An arithmetic context object to control the precision, rounding, and xponent range of the result. This context will be used only in the ivision portion of the remainder calculation; as a result, it&#39;s possible or the return value to have a higher precision than given in this ontext. Flags will be set on the given context only if the context&#39;s  <code>
    HasFlags
</code> is true and the integer part of the division result doesn&#39;t fit the recision and exponent range without rounding. Can be null, in which the recision is unlimited and no additional rounding, other than the rounding own to an integer after division, is needed.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision decimal number.</p>

<h3>RemainderNear</h3>

<pre>public PeterO.Numbers.EDecimal RemainderNear(
    PeterO.Numbers.EDecimal divisor,
    PeterO.Numbers.EContext ctx);
</pre>

<p>Finds the distance to the closest multiple of the given divisor, based on he result of dividing this object&#39;s value by another object&#39;s value.</p>

<ul>
<li><p>If this and the other object divide evenly, the result is 0.</p></li>
<li><p>If the remainder&#39;s absolute value is less than half of the divisor&#39;s bsolute value, the result has the same sign as this object and will e the distance to the closest multiple.</p></li>
<li><p>If the remainder&#39;s absolute value is more than half of the divisor&#39; s bsolute value, the result has the opposite sign of this object and ill be the distance to the closest multiple.</p></li>
<li><p>If the remainder&#39;s absolute value is exactly half of the divisor&#39;s bsolute value, the result has the opposite sign of this object if the uotient, rounded down, is odd, and has the same sign as this object f the quotient, rounded down, is even, and the result&#39;s absolute alue is half of the divisor&#39;s absolute value.</p></li>
</ul>

<p>This function is also known as the &quot;IEEE Remainder&quot; function.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>divisor</i>: The number to divide by.</p></li>
<li><p><i>ctx</i>: An arithmetic context object to control the precision. The rounding and xponent range settings of this context are ignored (the rounding mode is lways treated as HalfEven). If  <code>
    HasFlags
</code> of the context is true, will also store the flags resulting from the peration (the flags are in addition to the pre-existing flags). Can be ull, in which the precision is unlimited.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>The distance of the closest multiple. Signals FlagInvalid and returns ot-a-number (NaN) if the divisor is 0, or either the result of integer ivision (the quotient) or the remainder wouldn&#39;t fit the given precision.</p>

<h3>RoundToExponent</h3>

<pre>public PeterO.Numbers.EDecimal RoundToExponent(
    int exponentSmall);
</pre>

<p>Returns a decimal number with the same value as this object but rounded o a new exponent if necessary, using the HalfEven rounding mode.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>exponentSmall</i>: The minimum exponent the result can have. This is the maximum number of ractional digits in the result, expressed as a negative number. Can also e positive, which eliminates lower-order places from the number. For xample, -3 means round to the thousandth (10^-3, 0.0001), and 3 means ound to the thousand (10^3, 1000). A value of 0 rounds the number to an nteger.</li>
</ul>

<p><b>Return Value:</b></p>

<p>A decimal number rounded to the closest value representable for the given xponent.</p>

<h3>RoundToExponent</h3>

<pre>public PeterO.Numbers.EDecimal RoundToExponent(
    int exponentSmall,
    PeterO.Numbers.EContext ctx);
</pre>

<p>Returns a decimal number with the same value as this object but rounded o a new exponent if necessary.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>exponentSmall</i>: The minimum exponent the result can have. This is the maximum number of ractional digits in the result, expressed as a negative number. Can also e positive, which eliminates lower-order places from the number. For xample, -3 means round to the thousandth (10^-3, 0.0001), and 3 means ound to the thousand (10^3, 1000). A value of 0 rounds the number to an nteger.</p></li>
<li><p><i>ctx</i>: An arithmetic context to control precision, rounding, and exponent range f the result. If  <code>
    HasFlags
</code> of the context is true, will also store the flags resulting from the peration (the flags are in addition to the pre-existing flags). Can be ull, in which case the default rounding mode is HalfEven.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>A decimal number rounded to the closest value representable in the given recision. If the result can&#39;t fit the precision, additional digits are iscarded to make it fit. Signals FlagInvalid and returns not-a-number NaN) if the precision context defines an exponent range, the new exponent ust be changed to the given exponent when rounding, and the given xponent is outside of the valid range of the arithmetic context.</p>

<h3>RoundToExponent</h3>

<pre>public PeterO.Numbers.EDecimal RoundToExponent(
    int exponentSmall,
    PeterO.Numbers.ERounding rounding);
</pre>

<p>Returns a decimal number with the same value as this object but rounded o a new exponent if necessary.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>exponentSmall</i>: The minimum exponent the result can have. This is the maximum number of ractional digits in the result, expressed as a negative number. Can also e positive, which eliminates lower-order places from the number. For xample, -3 means round to the thousandth (10^-3, 0.0001), and 3 means ound to the thousand (10^3, 1000). A value of 0 rounds the number to an nteger.</p></li>
<li><p><i>rounding</i>: The desired mode to use to round the given number to the given exponent.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>A decimal number rounded to the given negative number of decimal places.</p>

<h3>RoundToExponent</h3>

<pre>public PeterO.Numbers.EDecimal RoundToExponent(
    PeterO.Numbers.EInteger exponent);
</pre>

<p>Returns a decimal number with the same value as this object but rounded o a new exponent if necessary, using the HalfEven rounding mode.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>exponent</i>: The minimum exponent the result can have. This is the maximum number of ractional digits in the result, expressed as a negative number. Can also e positive, which eliminates lower-order places from the number. For xample, -3 means round to the thousandth (10^-3, 0.0001), and 3 means ound to the thousand (10^3, 1000). A value of 0 rounds the number to an nteger.</li>
</ul>

<p><b>Return Value:</b></p>

<p>A decimal number rounded to the closest value representable for the given xponent.</p>

<h3>RoundToExponent</h3>

<pre>public PeterO.Numbers.EDecimal RoundToExponent(
    PeterO.Numbers.EInteger exponent,
    PeterO.Numbers.EContext ctx);
</pre>

<p>Returns a decimal number with the same value as this object but rounded o a new exponent if necessary.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>exponent</i>: The minimum exponent the result can have. This is the maximum number of ractional digits in the result, expressed as a negative number. Can also e positive, which eliminates lower-order places from the number. For xample, -3 means round to the thousandth (10^-3, 0.0001), and 3 means ound to the thousand (10^3, 1000). A value of 0 rounds the number to an nteger.</p></li>
<li><p><i>ctx</i>: An arithmetic context to control precision, rounding, and exponent range f the result. If  <code>
    HasFlags
</code> of the context is true, will also store the flags resulting from the peration (the flags are in addition to the pre-existing flags). Can be ull, in which case the default rounding mode is HalfEven.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>A decimal number rounded to the closest value representable in the given recision. If the result can&#39;t fit the precision, additional digits are iscarded to make it fit. Signals FlagInvalid and returns not-a-number NaN) if the precision context defines an exponent range, the new exponent ust be changed to the given exponent when rounding, and the given xponent is outside of the valid range of the arithmetic context.</p>

<h3>RoundToExponent</h3>

<pre>public PeterO.Numbers.EDecimal RoundToExponent(
    PeterO.Numbers.EInteger exponent,
    PeterO.Numbers.ERounding rounding);
</pre>

<p>Returns a decimal number with the same value as this object but rounded o a new exponent if necessary, using the given rounding mode.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>exponent</i>: The minimum exponent the result can have. This is the maximum number of ractional digits in the result, expressed as a negative number. Can also e positive, which eliminates lower-order places from the number. For xample, -3 means round to the thousandth (10^-3, 0.0001), and 3 means ound to the thousand (10^3, 1000). A value of 0 rounds the number to an nteger.</p></li>
<li><p><i>rounding</i>: Desired mode for rounding this number&#39;s value.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>A decimal number rounded to the closest value representable for the given xponent.</p>

<h3>RoundToExponentExact</h3>

<pre>public PeterO.Numbers.EDecimal RoundToExponentExact(
    int exponentSmall,
    PeterO.Numbers.EContext ctx);
</pre>

<p>Returns a decimal number with the same value as this object but rounded o an integer, and signals an inexact flag if the result would be inexact.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>exponentSmall</i>: The minimum exponent the result can have. This is the maximum number of ractional digits in the result, expressed as a negative number. Can also e positive, which eliminates lower-order places from the number. For xample, -3 means round to the thousandth (10^-3, 0.0001), and 3 means ound to the thousand (10^3, 1000). A value of 0 rounds the number to an nteger.</p></li>
<li><p><i>ctx</i>: An arithmetic context to control precision, rounding, and exponent range f the result. If  <code>
    HasFlags
</code> of the context is true, will also store the flags resulting from the peration (the flags are in addition to the pre-existing flags). Can be ull, in which case the default rounding mode is HalfEven.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>A decimal number rounded to the closest value representable in the given recision. Signals FlagInvalid and returns not-a-number (NaN) if the esult can&#39;t fit the given precision without rounding. Signals FlagInvalid nd returns not-a-number (NaN) if the arithmetic context defines an xponent range, the new exponent must be changed to the given exponent hen rounding, and the given exponent is outside of the valid range of the rithmetic context.</p>

<h3>RoundToExponentExact</h3>

<pre>public PeterO.Numbers.EDecimal RoundToExponentExact(
    int exponentSmall,
    PeterO.Numbers.ERounding rounding);
</pre>

<p>Returns a decimal number with the same value as this object but rounded o an integer, and signals an inexact flag if the result would be inexact.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>exponentSmall</i>: The minimum exponent the result can have. This is the maximum number of ractional digits in the result, expressed as a negative number. Can also e positive, which eliminates lower-order places from the number. For xample, -3 means round to the thousandth (10^-3, 0.0001), and 3 means ound to the thousand (10^3, 1000). A value of 0 rounds the number to an nteger.</p></li>
<li><p><i>rounding</i>: Desired mode for rounding this object&#39;s value.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>A decimal number rounded to the closest value representable using the iven exponent.</p>

<h3>RoundToExponentExact</h3>

<pre>public PeterO.Numbers.EDecimal RoundToExponentExact(
    PeterO.Numbers.EInteger exponent,
    PeterO.Numbers.EContext ctx);
</pre>

<p>Returns a decimal number with the same value as this object but rounded o the given exponent, and signals an inexact flag if the result would be nexact.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>exponent</i>: The minimum exponent the result can have. This is the maximum number of ractional digits in the result, expressed as a negative number. Can also e positive, which eliminates lower-order places from the number. For xample, -3 means round to the thousandth (10^-3, 0.0001), and 3 means ound to the thousand (10^3, 1000). A value of 0 rounds the number to an nteger.</p></li>
<li><p><i>ctx</i>: An arithmetic context to control precision, rounding, and exponent range f the result. If  <code>
    HasFlags
</code> of the context is true, will also store the flags resulting from the peration (the flags are in addition to the pre-existing flags). Can be ull, in which case the default rounding mode is HalfEven.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>A decimal number rounded to the closest value representable in the given recision. Signals FlagInvalid and returns not-a-number (NaN) if the esult can&#39;t fit the given precision without rounding. Signals FlagInvalid nd returns not-a-number (NaN) if the arithmetic context defines an xponent range, the new exponent must be changed to the given exponent hen rounding, and the given exponent is outside of the valid range of the rithmetic context.</p>

<h3>RoundToIntegerExact</h3>

<pre>public PeterO.Numbers.EDecimal RoundToIntegerExact(
    PeterO.Numbers.EContext ctx);
</pre>

<p>Returns a decimal number with the same value as this object but rounded o an integer, and signals an inexact flag if the result would be inexact.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>ctx</i>: An arithmetic context to control precision, rounding, and exponent range f the result. If  <code>
    HasFlags
</code> of the context is true, will also store the flags resulting from the peration (the flags are in addition to the pre-existing flags). Can be ull, in which case the default rounding mode is HalfEven.</li>
</ul>

<p><b>Return Value:</b></p>

<p>A decimal number rounded to the closest integer representable in the iven precision. Signals FlagInvalid and returns not-a-number (NaN) if the esult can&#39;t fit the given precision without rounding. Signals FlagInvalid nd returns not-a-number (NaN) if the arithmetic context defines an xponent range, the new exponent must be changed to 0 when rounding, and 0 s outside of the valid range of the arithmetic context.</p>

<h3>RoundToIntegerNoRoundedFlag</h3>

<pre>public PeterO.Numbers.EDecimal RoundToIntegerNoRoundedFlag(
    PeterO.Numbers.EContext ctx);
</pre>

<p>Returns a decimal number with the same value as this object but rounded o an integer, without adding the  <code>
        FlagInexact
</code> or  <code>
        FlagRounded
</code> flags.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>ctx</i>: An arithmetic context to control precision and rounding of the result. If  <code>
    HasFlags
</code> of the context is true, will also store the flags resulting from the peration (the flags are in addition to the pre-existing flags), except hat this function will never add the  <code>
    FlagRounded
</code> and  <code>
    FlagInexact
</code> flags (the only difference between this and RoundToExponentExact). Can be ull, in which case the default rounding mode is HalfEven.</li>
</ul>

<p><b>Return Value:</b></p>

<p>A decimal number rounded to the closest integer representable in the iven precision. If the result can&#39;t fit the precision, additional digits re discarded to make it fit. Signals FlagInvalid and returns not-a-number NaN) if the precision context defines an exponent range, the new exponent ust be changed to 0 when rounding, and 0 is outside of the valid range of he arithmetic context.</p>

<h3>RoundToIntegralExact</h3>

<pre>public PeterO.Numbers.EDecimal RoundToIntegralExact(
    PeterO.Numbers.EContext ctx);
</pre>

<p><b>Deprecated.</b> Renamed to RoundToIntegerExact.</p>

<p>Returns a decimal number with the same value as this object but rounded o an integer, and signals an inexact flag if the result would be inexact.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>ctx</i>: An arithmetic context to control precision, rounding, and exponent range f the result. If  <code>
    HasFlags
</code> of the context is true, will also store the flags resulting from the peration (the flags are in addition to the pre-existing flags). Can be ull, in which case the default rounding mode is HalfEven.</li>
</ul>

<p><b>Return Value:</b></p>

<p>A decimal number rounded to the closest integer representable in the iven precision. Signals FlagInvalid and returns not-a-number (NaN) if the esult can&#39;t fit the given precision without rounding. Signals FlagInvalid nd returns not-a-number (NaN) if the arithmetic context defines an xponent range, the new exponent must be changed to 0 when rounding, and 0 s outside of the valid range of the arithmetic context.</p>

<h3>RoundToIntegralNoRoundedFlag</h3>

<pre>public PeterO.Numbers.EDecimal RoundToIntegralNoRoundedFlag(
    PeterO.Numbers.EContext ctx);
</pre>

<p><b>Deprecated.</b> Renamed to RoundToIntegerNoRoundedFlag.</p>

<p>Returns a decimal number with the same value as this object but rounded o an integer, without adding the  <code>
        FlagInexact
</code> or  <code>
        FlagRounded
</code> flags.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>ctx</i>: An arithmetic context to control precision and rounding of the result. If  <code>
    HasFlags
</code> of the context is true, will also store the flags resulting from the peration (the flags are in addition to the pre-existing flags), except hat this function will never add the  <code>
    FlagRounded
</code> and  <code>
    FlagInexact
</code> flags (the only difference between this and RoundToExponentExact). Can be ull, in which case the default rounding mode is HalfEven.</li>
</ul>

<p><b>Return Value:</b></p>

<p>A decimal number rounded to the closest integer representable in the iven precision. If the result can&#39;t fit the precision, additional digits re discarded to make it fit. Signals FlagInvalid and returns not-a-number NaN) if the precision context defines an exponent range, the new exponent ust be changed to 0 when rounding, and 0 is outside of the valid range of he arithmetic context.</p>

<h3>RoundToPrecision</h3>

<pre>public PeterO.Numbers.EDecimal RoundToPrecision(
    PeterO.Numbers.EContext ctx);
</pre>

<p>Rounds this object&#39;s value to a given precision, using the given rounding ode and range of exponent.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>ctx</i>: An arithmetic context to control precision, rounding, and exponent range f the result. If  <code>
    HasFlags
</code> of the context is true, will also store the flags resulting from the peration (the flags are in addition to the pre-existing flags). Can be ull, in which case the precision is unlimited and no rounding is needed.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The closest value to this object&#39;s value, rounded to the specified recision. Returns the same value as this object if  <i>ctx</i>
is null or the precision and exponent range are unlimited.</p>

<h3>ScaleByPowerOfTen</h3>

<pre>public PeterO.Numbers.EDecimal ScaleByPowerOfTen(
    int places);
</pre>

<p>Returns a number similar to this number but with the scale adjusted.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>places</i>: The power of 10 to scale by.</li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision decimal number.</p>

<h3>ScaleByPowerOfTen</h3>

<pre>public PeterO.Numbers.EDecimal ScaleByPowerOfTen(
    int places,
    PeterO.Numbers.EContext ctx);
</pre>

<p>Returns a number similar to this number but with the scale adjusted.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>places</i>: The power of 10 to scale by.</p></li>
<li><p><i>ctx</i>: An arithmetic context to control precision, rounding, and exponent range f the result. If  <code>
    HasFlags
</code> of the context is true, will also store the flags resulting from the peration (the flags are in addition to the pre-existing flags). Can be ull, in which case the precision is unlimited and no rounding is needed.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision decimal number.</p>

<h3>ScaleByPowerOfTen</h3>

<pre>public PeterO.Numbers.EDecimal ScaleByPowerOfTen(
    PeterO.Numbers.EInteger bigPlaces);
</pre>

<p>Returns a number similar to this number but with the scale adjusted.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>bigPlaces</i>: The power of 10 to scale by.</li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision decimal number.</p>

<h3>ScaleByPowerOfTen</h3>

<pre>public PeterO.Numbers.EDecimal ScaleByPowerOfTen(
    PeterO.Numbers.EInteger bigPlaces,
    PeterO.Numbers.EContext ctx);
</pre>

<p>Returns a number similar to this number but with its scale adjusted.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>bigPlaces</i>: The power of 10 to scale by.</p></li>
<li><p><i>ctx</i>: An arithmetic context to control precision, rounding, and exponent range f the result. If  <code>
    HasFlags
</code> of the context is true, will also store the flags resulting from the peration (the flags are in addition to the pre-existing flags). Can be ull, in which case the precision is unlimited and no rounding is needed.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>A number whose exponent is increased by  <i>bigPlaces</i>
.</p>

<h3>Sqrt</h3>

<pre>public PeterO.Numbers.EDecimal Sqrt(
    PeterO.Numbers.EContext ctx);
</pre>

<p>Finds the square root of this object&#39;s value.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>ctx</i>: An arithmetic context to control precision, rounding, and exponent range f the result. If  <code>
    HasFlags
</code> of the context is true, will also store the flags resulting from the peration (the flags are in addition to the pre-existing flags). <i>This parameter can&#39;t be null, as the square root function&#39;s results are enerally not exact for many inputs. </i>(Unlike in the General Decimal Arithmetic Specification, any rounding ode is allowed.).</li>
</ul>

<p><b>Return Value:</b></p>

<p>The square root. Signals the flag FlagInvalid and returns NaN if this bject is less than 0 (the square root would be a complex number, but the eturn value is still NaN). Signals FlagInvalid and returns not-a-number NaN) if the parameter  <i>ctx</i>
is null or the precision is unlimited (the context&#39;s Precision property s 0).</p>

<h3>SquareRoot</h3>

<pre>public PeterO.Numbers.EDecimal SquareRoot(
    PeterO.Numbers.EContext ctx);
</pre>

<p><b>Deprecated.</b> Renamed to Sqrt.</p>

<p>Finds the square root of this object&#39;s value.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>ctx</i>: An arithmetic context to control precision, rounding, and exponent range f the result. If  <code>
    HasFlags
</code> of the context is true, will also store the flags resulting from the peration (the flags are in addition to the pre-existing flags). <i>This parameter can&#39;t be null, as the square root function&#39;s results are enerally not exact for many inputs. </i>(Unlike in the General Decimal Arithmetic Specification, any rounding ode is allowed.).</li>
</ul>

<p><b>Return Value:</b></p>

<p>The square root. Signals the flag FlagInvalid and returns NaN if this bject is less than 0 (the square root would be a complex number, but the eturn value is still NaN). Signals FlagInvalid and returns not-a-number NaN) if the parameter  <i>ctx</i>
is null or the precision is unlimited (the context&#39;s Precision property s 0).</p>

<h3>Subtract</h3>

<pre>public PeterO.Numbers.EDecimal Subtract(
    PeterO.Numbers.EDecimal otherValue);
</pre>

<p>Subtracts an arbitrary-precision decimal number from this instance and eturns the result.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>otherValue</i>: The number to subtract from this instance&#39;s value.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The difference of the two objects.</p>

<h3>Subtract</h3>

<pre>public PeterO.Numbers.EDecimal Subtract(
    PeterO.Numbers.EDecimal otherValue,
    PeterO.Numbers.EContext ctx);
</pre>

<p>Subtracts an arbitrary-precision decimal number from this instance.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>otherValue</i>: The number to subtract from this instance&#39;s value.</p></li>
<li><p><i>ctx</i>: An arithmetic context to control precision, rounding, and exponent range f the result. If  <code>
    HasFlags
</code> of the context is true, will also store the flags resulting from the peration (the flags are in addition to the pre-existing flags). Can be ull, in which case the precision is unlimited and no rounding is needed.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>The difference of the two objects.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter  <i>otherValue</i>
is null.</li>
</ul>

<h3>ToByteChecked</h3>

<pre>public byte ToByteChecked();
</pre>

<p>Converts this number&#39;s value to a byte (from 0 to 255) if it can fit in a yte (from 0 to 255) after truncating to an integer.</p>

<p><b>Return Value:</b></p>

<p>This number&#39;s value, truncated to a byte (from 0 to 255).</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.OverflowException:
This value is infinity or not-a-number, or the truncated integer is less han 0 or greater than 255.</li>
</ul>

<h3>ToByteIfExact</h3>

<pre>public byte ToByteIfExact();
</pre>

<p>Converts this number&#39;s value to a byte (from 0 to 255) if it can fit in a yte (from 0 to 255) without rounding to a different numerical value.</p>

<p><b>Return Value:</b></p>

<p>This number&#39;s value as a byte (from 0 to 255).</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArithmeticException:
This value is infinity or not-a-number, is not an exact integer, or is ess than 0 or greater than 255.</li>
</ul>

<h3>ToByteUnchecked</h3>

<pre>public byte ToByteUnchecked();
</pre>

<p>Truncates this number&#39;s value to an integer and returns the east-significant bits of its two&#39;s-complement form as a byte (from 0 to 55).</p>

<p><b>Return Value:</b></p>

<p>This number, converted to a byte (from 0 to 255). Returns 0 if this value s infinity or not-a-number.</p>

<h3>ToDecimal</h3>

<pre>public System.Decimal ToDecimal();
</pre>

<p>Converts this value to a  <code>
        decimal
</code> under the Common Language Infrastructure (see <a href="PeterO.Numbers.EDecimal.html">
         &#x22;Forms of numbers&#x22;
      </a>), using the half-even rounding mode.</p>

<p><b>Return Value:</b></p>

<p>A  <code>
        decimal
</code> under the Common Language Infrastructure (usually a .NET Framework ecimal).</p>

<h3>ToDouble</h3>

<pre>public double ToDouble();
</pre>

<p>Converts this value to its closest equivalent as a 64-bit floating-point umber. The half-even rounding mode is used. If this value is a NaN, sets the high bit of the 64-bit floating point umber&#39;s significand area for a quiet NaN, and clears it for a signaling aN. Then the other bits of the significand area are set to the lowest its of this object&#39;s unsigned mantissa (significand), and the ext-highest bit of the significand area is set if those bits are all eros and this is a signaling NaN. Unfortunately, in the .NET mplementation, the return value of this method may be a quiet NaN even f a signaling NaN would otherwise be generated.</p>

<p><b>Return Value:</b></p>

<p>The closest 64-bit floating-point number to this value. The return value an be positive infinity or negative infinity if this value exceeds the ange of a 64-bit floating point number.</p>

<h3>ToEFloat</h3>

<pre>public PeterO.Numbers.EFloat ToEFloat(
    PeterO.Numbers.EContext ec);
</pre>

<p>Creates a binary floating-point number from this object&#39;s value. Note hat if the binary floating-point number contains a negative exponent, the esulting value might not be exact, in which case the resulting binary loat will be an approximation of this decimal number&#39;s value.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>ec</i>: An arithmetic context to control precision, rounding, and exponent range f the result. If  <code>
    HasFlags
</code> of the context is true, will also store the flags resulting from the peration (the flags are in addition to the pre-existing flags).</li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision float floating-point number.</p>

<h3>ToEFloat</h3>

<pre>public PeterO.Numbers.EFloat ToEFloat();
</pre>

<p>Creates a binary floating-point number from this object&#39;s value. Note hat if the binary floating-point number contains a negative exponent, the esulting value might not be exact, in which case the resulting binary loat will be an approximation of this decimal number&#39;s value.</p>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision binary float.</p>

<h3>ToEInteger</h3>

<pre>public PeterO.Numbers.EInteger ToEInteger();
</pre>

<p>Converts this value to an arbitrary-precision integer. Any fractional art in this value will be discarded when converting to an rbitrary-precision integer.</p>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.OverflowException:
This object&#39;s value is infinity or not-a-number (NaN).</li>
</ul>

<h3>ToEIntegerExact</h3>

<pre>public PeterO.Numbers.EInteger ToEIntegerExact();
</pre>

<p><b>Deprecated.</b> Renamed to ToEIntegerIfExact.</p>

<p>Converts this value to an arbitrary-precision integer, checking whether he fractional part of the value would be lost.</p>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.OverflowException:
This object&#39;s value is infinity or not-a-number (NaN).</p></li>
<li><p>System.ArithmeticException:
This object&#39;s value is not an exact integer.</p></li>
</ul>

<h3>ToEIntegerIfExact</h3>

<pre>public PeterO.Numbers.EInteger ToEIntegerIfExact();
</pre>

<p>Converts this value to an arbitrary-precision integer, checking whether he fractional part of the value would be lost.</p>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.OverflowException:
This object&#39;s value is infinity or not-a-number (NaN).</p></li>
<li><p>System.ArithmeticException:
This object&#39;s value is not an exact integer.</p></li>
</ul>

<h3>ToEngineeringString</h3>

<pre>public string ToEngineeringString();
</pre>

<p>Same as ToString(), except that when an exponent is used it will be a ultiple of 3.</p>

<p><b>Return Value:</b></p>

<p>A text string.</p>

<h3>ToExtendedFloat</h3>

<pre>public PeterO.Numbers.EFloat ToExtendedFloat();
</pre>

<p><b>Deprecated.</b> Renamed to ToEFloat.</p>

<p>Creates a binary floating-point number from this object&#39;s value. Note hat if the binary floating-point number contains a negative exponent, the esulting value might not be exact, in which case the resulting binary loat will be an approximation of this decimal number&#39;s value.</p>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision binary float.</p>

<h3>ToInt16Checked</h3>

<pre>public short ToInt16Checked();
</pre>

<p>Converts this number&#39;s value to a 16-bit signed integer if it can fit in 16-bit signed integer after truncating to an integer.</p>

<p><b>Return Value:</b></p>

<p>This number&#39;s value, truncated to a 16-bit signed integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.OverflowException:
This value is infinity or not-a-number, or the truncated integer is less han -32768 or greater than 32767.</li>
</ul>

<h3>ToInt16IfExact</h3>

<pre>public short ToInt16IfExact();
</pre>

<p>Converts this number&#39;s value to a 16-bit signed integer if it can fit in 16-bit signed integer without rounding to a different numerical value.</p>

<p><b>Return Value:</b></p>

<p>This number&#39;s value as a 16-bit signed integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArithmeticException:
This value is infinity or not-a-number, is not an exact integer, or is ess than -32768 or greater than 32767.</li>
</ul>

<h3>ToInt16Unchecked</h3>

<pre>public short ToInt16Unchecked();
</pre>

<p>Truncates this number&#39;s value to an integer and returns the east-significant bits of its two&#39;s-complement form as a 16-bit signed nteger.</p>

<p><b>Return Value:</b></p>

<p>This number, converted to a 16-bit signed integer. Returns 0 if this alue is infinity or not-a-number.</p>

<h3>ToInt32Checked</h3>

<pre>public int ToInt32Checked();
</pre>

<p>Converts this number&#39;s value to a 32-bit signed integer if it can fit in 32-bit signed integer after truncating to an integer.</p>

<p><b>Return Value:</b></p>

<p>This number&#39;s value, truncated to a 32-bit signed integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.OverflowException:
This value is infinity or not-a-number, or the truncated integer is less han -2147483648 or greater than 2147483647.</li>
</ul>

<h3>ToInt32IfExact</h3>

<pre>public int ToInt32IfExact();
</pre>

<p>Converts this number&#39;s value to a 32-bit signed integer if it can fit in 32-bit signed integer without rounding to a different numerical value.</p>

<p><b>Return Value:</b></p>

<p>This number&#39;s value as a 32-bit signed integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArithmeticException:
This value is infinity or not-a-number, is not an exact integer, or is ess than -2147483648 or greater than 2147483647.</li>
</ul>

<h3>ToInt32Unchecked</h3>

<pre>public int ToInt32Unchecked();
</pre>

<p>Truncates this number&#39;s value to an integer and returns the east-significant bits of its two&#39;s-complement form as a 32-bit signed nteger.</p>

<p><b>Return Value:</b></p>

<p>This number, converted to a 32-bit signed integer. Returns 0 if this alue is infinity or not-a-number.</p>

<h3>ToInt64Checked</h3>

<pre>public long ToInt64Checked();
</pre>

<p>Converts this number&#39;s value to a 64-bit signed integer if it can fit in 64-bit signed integer after truncating to an integer.</p>

<p><b>Return Value:</b></p>

<p>This number&#39;s value, truncated to a 64-bit signed integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.OverflowException:
This value is infinity or not-a-number, or the truncated integer is less han -9223372036854775808 or greater than 9223372036854775807.</li>
</ul>

<h3>ToInt64IfExact</h3>

<pre>public long ToInt64IfExact();
</pre>

<p>Converts this number&#39;s value to a 64-bit signed integer if it can fit in 64-bit signed integer without rounding to a different numerical value.</p>

<p><b>Return Value:</b></p>

<p>This number&#39;s value as a 64-bit signed integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArithmeticException:
This value is infinity or not-a-number, is not an exact integer, or is ess than -9223372036854775808 or greater than 9223372036854775807.</li>
</ul>

<h3>ToInt64Unchecked</h3>

<pre>public long ToInt64Unchecked();
</pre>

<p>Truncates this number&#39;s value to an integer and returns the east-significant bits of its two&#39;s-complement form as a 64-bit signed nteger.</p>

<p><b>Return Value:</b></p>

<p>This number, converted to a 64-bit signed integer. Returns 0 if this alue is infinity or not-a-number.</p>

<h3>ToPlainString</h3>

<pre>public string ToPlainString();
</pre>

<p>Converts this value to a string, but without using exponential notation.</p>

<p><b>Return Value:</b></p>

<p>A text string.</p>

<h3>ToSByteChecked</h3>

<pre>public sbyte ToSByteChecked();
</pre>

<p>Converts this number&#39;s value to an 8-bit signed integer if it can fit in n 8-bit signed integer after truncating to an integer.</p>

<p><b>Return Value:</b></p>

<p>This number&#39;s value, truncated to an 8-bit signed integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.OverflowException:
This value is infinity or not-a-number, or the truncated integer is less han -128 or greater than 127.</li>
</ul>

<h3>ToSByteIfExact</h3>

<pre>public sbyte ToSByteIfExact();
</pre>

<p>Converts this number&#39;s value to an 8-bit signed integer if it can fit in n 8-bit signed integer without rounding to a different numerical value.</p>

<p><b>Return Value:</b></p>

<p>This number&#39;s value as an 8-bit signed integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArithmeticException:
This value is infinity or not-a-number, is not an exact integer, or is ess than -128 or greater than 127.</li>
</ul>

<h3>ToSByteUnchecked</h3>

<pre>public sbyte ToSByteUnchecked();
</pre>

<p>Truncates this number&#39;s value to an integer and returns the east-significant bits of its two&#39;s-complement form as an 8-bit signed nteger.</p>

<p><b>Return Value:</b></p>

<p>This number, converted to an 8-bit signed integer. Returns 0 if this alue is infinity or not-a-number.</p>

<h3>ToSingle</h3>

<pre>public float ToSingle();
</pre>

<p>Converts this value to its closest equivalent as a 32-bit floating-point umber. The half-even rounding mode is used. If this value is a NaN, sets the high bit of the 32-bit floating point umber&#39;s significand area for a quiet NaN, and clears it for a signaling aN. Then the other bits of the significand area are set to the lowest its of this object&#39;s unsigned mantissa (significand), and the ext-highest bit of the significand area is set if those bits are all eros and this is a signaling NaN. Unfortunately, in the .NET mplementation, the return value of this method may be a quiet NaN even f a signaling NaN would otherwise be generated.</p>

<p><b>Return Value:</b></p>

<p>The closest 32-bit binary floating-point number to this value. The return alue can be positive infinity or negative infinity if this value exceeds he range of a 32-bit floating point number.</p>

<h3>ToString</h3>

<pre>public override string ToString();
</pre>

<p>Converts this value to a string. Returns a value compatible with this lass&#39;s FromString method.</p>

<p><b>Return Value:</b></p>

<p>A string representation of this object. The text string will be in xponential notation if the exponent is greater than 0 or if the number&#39;s irst nonzero digit is more than five digits after the decimal point.</p>

<h3>ToUInt16Checked</h3>

<pre>public ushort ToUInt16Checked();
</pre>

<p>Converts this number&#39;s value to a 16-bit unsigned integer if it can fit n a 16-bit unsigned integer after truncating to an integer.</p>

<p><b>Return Value:</b></p>

<p>This number&#39;s value, truncated to a 16-bit unsigned integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.OverflowException:
This value is infinity or not-a-number, or the truncated integer is less han 0 or greater than 65535.</li>
</ul>

<h3>ToUInt16IfExact</h3>

<pre>public ushort ToUInt16IfExact();
</pre>

<p>Converts this number&#39;s value to a 16-bit unsigned integer if it can fit n a 16-bit unsigned integer without rounding to a different numerical alue.</p>

<p><b>Return Value:</b></p>

<p>This number&#39;s value as a 16-bit unsigned integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArithmeticException:
This value is infinity or not-a-number, is not an exact integer, or is ess than 0 or greater than 65535.</li>
</ul>

<h3>ToUInt16Unchecked</h3>

<pre>public ushort ToUInt16Unchecked();
</pre>

<p>Truncates this number&#39;s value to an integer and returns the east-significant bits of its two&#39;s-complement form as a 16-bit unsigned nteger.</p>

<p><b>Return Value:</b></p>

<p>This number, converted to a 16-bit unsigned integer. Returns 0 if this alue is infinity or not-a-number.</p>

<h3>ToUInt32Checked</h3>

<pre>public uint ToUInt32Checked();
</pre>

<p>Converts this number&#39;s value to a 32-bit signed integer if it can fit in 32-bit signed integer after truncating to an integer.</p>

<p><b>Return Value:</b></p>

<p>This number&#39;s value, truncated to a 32-bit signed integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.OverflowException:
This value is infinity or not-a-number, or the truncated integer is less han 0 or greater than 4294967295.</li>
</ul>

<h3>ToUInt32IfExact</h3>

<pre>public uint ToUInt32IfExact();
</pre>

<p>Converts this number&#39;s value to a 32-bit signed integer if it can fit in 32-bit signed integer without rounding to a different numerical value.</p>

<p><b>Return Value:</b></p>

<p>This number&#39;s value as a 32-bit signed integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArithmeticException:
This value is infinity or not-a-number, is not an exact integer, or is ess than 0 or greater than 4294967295.</li>
</ul>

<h3>ToUInt32Unchecked</h3>

<pre>public uint ToUInt32Unchecked();
</pre>

<p>Truncates this number&#39;s value to an integer and returns the east-significant bits of its two&#39;s-complement form as a 32-bit signed nteger.</p>

<p><b>Return Value:</b></p>

<p>This number, converted to a 32-bit signed integer. Returns 0 if this alue is infinity or not-a-number.</p>

<h3>ToUInt64Checked</h3>

<pre>public ulong ToUInt64Checked();
</pre>

<p>Converts this number&#39;s value to a 64-bit unsigned integer if it can fit n a 64-bit unsigned integer after truncating to an integer.</p>

<p><b>Return Value:</b></p>

<p>This number&#39;s value, truncated to a 64-bit unsigned integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.OverflowException:
This value is infinity or not-a-number, or the truncated integer is less han 0 or greater than 18446744073709551615.</li>
</ul>

<h3>ToUInt64IfExact</h3>

<pre>public ulong ToUInt64IfExact();
</pre>

<p>Converts this number&#39;s value to a 64-bit unsigned integer if it can fit n a 64-bit unsigned integer without rounding to a different numerical alue.</p>

<p><b>Return Value:</b></p>

<p>This number&#39;s value as a 64-bit unsigned integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArithmeticException:
This value is infinity or not-a-number, is not an exact integer, or is ess than 0 or greater than 18446744073709551615.</li>
</ul>

<h3>ToUInt64Unchecked</h3>

<pre>public ulong ToUInt64Unchecked();
</pre>

<p>Truncates this number&#39;s value to an integer and returns the east-significant bits of its two&#39;s-complement form as a 64-bit unsigned nteger.</p>

<p><b>Return Value:</b></p>

<p>This number, converted to a 64-bit unsigned integer. Returns 0 if this alue is infinity or not-a-number.</p>

<h3>Ulp</h3>

<pre>public PeterO.Numbers.EDecimal Ulp();
</pre>

<p>Returns the unit in the last place. The mantissa (significand) will be 1 nd the exponent will be this number&#39;s exponent. Returns 1 with an xponent of 0 if this number is infinity or not-a-number (NaN).</p>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision decimal number.</p>

<p><a href="/Numbers/">Back to Numbers start page.</a></p>
</div><nav id="navigation"><ul>
<li><a href="/">Back to start site.</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io">This site's repository (source code)</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io/issues">Post an issue or comment</a></ul>
<p>
If you like this software, you should consider donating to me, Peter O., at the link below:</p>
<p class="printonly"><b>peteroupc.github.io</b></p>
<div class="noprint">
<a href="https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=56E5T4FH7KD2S">
<img src="https://www.paypalobjects.com/en_US/i/btn/btn_donateCC_LG.gif"
name="submit" border="2" alt="PayPal - The safer, easier way to pay online!"></a>
<p>
<a href="//twitter.com/share" class="twitter-share-button" data-count="horizontal" data-lang="en">Share via Twitter</a>
<script type="text/javascript" charset="UTF-8" src="https://platform.twitter.com/widgets.js"></script>
<span><g:plusone size="medium"></g:plusone></span><br/>
<span><a href="//www.facebook.com/sharer/sharer.php" id="sharer">Share via Facebook</a></span>
</p>
</div>
</nav><script>
if(document.location.href.indexOf("file://")!=0){
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = '//apis.google.com/js/plusone.js';
    var s = xExtra(document).getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
}
document.getElementById("sharer").href="//www.facebook.com/sharer/sharer.php?u="+
    encodeURIComponent(document.location.href)
</script>
</body></html>
