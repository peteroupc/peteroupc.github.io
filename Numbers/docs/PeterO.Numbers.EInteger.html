<!DOCTYPE html><html><head><meta http-equiv=Content-Type content="text/html; charset=utf-8"><title>PeterO.Numbers.EInteger</title><meta name="viewport" content="width=device-width"><link rel=stylesheet type="text/css" href="/style.css"></head><body>  <div class="header">
<p><a href="#navigation">Menu</a> - <a href="#top">Top</a> - <a href="/">Home</a> -
<a href="http://peteroupc.github.io/">Donate to Me</a></p></div>
<div class="mainarea" id="top">
<h1>PeterO.Numbers.EInteger</h1>

<h2>PeterO.Numbers.EInteger</h2>

<pre>public sealed class EInteger :
    System.IComparable,
    System.IEquatable
</pre>

<p>Represents an arbitrary-precision integer. (The &quot;E&quot; stands for &quot;extended&quot;, and has this prefix to group it with the other classes common to this library, particularly EDecimal, EFloat, and ERational.)Instances of this class are immutable, so they are inherently safe for use by multiple threads. Multiple instances of this object with the same value are interchangeable, but they should be compared using the &quot;Equals&quot; method rather than the &quot;==&quot; operator.</p>

<p><b>Security note</b></p>

<p>It is not recommended to implement security-sensitive algorithms using the methods in this class, for several reasons:</p>

<ul>
<li><p><code>EInteger</code> objects are immutable, so they can&#39;t be modified, and the memory they ccupy is not guaranteed to be cleared in a timely fashion due to arbage collection. This is relevant for applications that use any-bit-long numbers as secret parameters.</p></li>
<li><p>The methods in this class (especially those that involve arithmetic) are not guaranteed to run in constant time for all relevant inputs. Certain attacks that involve encrypted communications have exploited the timing and other aspects of such communications to derive keying material or cleartext indirectly.</p></li>
</ul>

<p>Applications should instead use dedicated security libraries to handle big numbers in security-sensitive algorithms.</p>

<h3>Member Summary</h3>

<ul>
<li><code><a href="#Abs">Abs()</a></code> - Returns the absolute value of this object&#39;s value.</li>
<li><code><a href="#Add_PeterO_Numbers_EInteger">Add(PeterO.Numbers.EInteger)</a></code> - Adds this object and another object.</li>
<li><code><a href="#Add_int">Add(int)</a></code> - Adds this object and another object.</li>
<li><code><a href="#And_PeterO_Numbers_EInteger_PeterO_Numbers_EInteger">And(PeterO.Numbers.EInteger, PeterO.Numbers.EInteger)</a></code> - Does an AND operation between two arbitrary-precision integer values.</li>
<li><code><a href="#AsInt32Checked">AsInt32Checked()</a></code> - Converts this object&#39;s value to a 32-bit signed integer, throwing an exception if it can&#39;t fit.</li>
<li><code><a href="#AsInt32Unchecked">AsInt32Unchecked()</a></code> - Converts this object&#39;s value to a 32-bit signed integer.</li>
<li><code><a href="#AsInt64Checked">AsInt64Checked()</a></code> - Converts this object&#39;s value to a 64-bit signed integer, throwing an exception if it can&#39;t fit.</li>
<li><code><a href="#AsInt64Unchecked">AsInt64Unchecked()</a></code> - Converts this object&#39;s value to a 64-bit signed integer.</li>
<li><code><a href="#CanFitInInt32">CanFitInInt32()</a></code> - Returns whether this object&#39;s value can fit in a 32-bit signed integer.</li>
<li><code><a href="#CanFitInInt64">CanFitInInt64()</a></code> - Returns whether this object&#39;s value can fit in a 64-bit signed integer.</li>
<li><code><a href="#CompareTo_PeterO_Numbers_EInteger">CompareTo(PeterO.Numbers.EInteger)</a></code> - Compares an arbitrary-precision integer with this instance.</li>
<li><code><a href="#CompareTo_int">CompareTo(int)</a></code> - Compares an arbitrary-precision integer with this instance.</li>
<li><code><a href="#DivRem_PeterO_Numbers_EInteger">DivRem(PeterO.Numbers.EInteger)</a></code> - Divides this object by another arbitrary-precision integer and returns the quotient and remainder.</li>
<li><code><a href="#Divide_PeterO_Numbers_EInteger">Divide(PeterO.Numbers.EInteger)</a></code> - Divides this instance by the value of an arbitrary-precision integer.</li>
<li><code><a href="#Divide_int">Divide(int)</a></code> - Divides this instance by the value of an arbitrary-precision integer.</li>
<li><code><a href="#Equals_PeterO_Numbers_EInteger">Equals(PeterO.Numbers.EInteger)</a></code> - Determines whether this object and another object are equal.</li>
<li><code><a href="#Equals_object">Equals(object)</a></code> - Determines whether this object and another object are equal and have the same type.</li>
<li><code><a href="#FromByte_byte">FromByte(byte)</a></code> - Converts a byte (from 0 to 255) to an arbitrary-precision integer.</li>
<li><code><a href="#FromBytes_byte_bool">FromBytes(byte[], bool)</a></code> - Initializes an arbitrary-precision integer from an array of bytes.</li>
<li><code><a href="#FromInt16_short">FromInt16(short)</a></code> - Converts a 16-bit signed integer to an arbitrary-precision integer.</li>
<li><code><a href="#FromInt32_int">FromInt32(int)</a></code> - Converts a 32-bit signed integer to an arbitrary-precision integer.</li>
<li><code><a href="#FromInt64_long">FromInt64(long)</a></code> - Converts a 64-bit signed integer to an arbitrary-precision integer.</li>
<li><code><a href="#FromRadixString_string_int">FromRadixString(string, int)</a></code> - Converts a string to an arbitrary-precision integer in a given radix.</li>
<li><code><a href="#FromRadixSubstring_string_int_int_int">FromRadixSubstring(string, int, int, int)</a></code> - Converts a portion of a string to an arbitrary-precision integer in a given radix.</li>
<li><code><a href="#FromSByte_sbyte">FromSByte(sbyte)</a></code> - Converts an 8-bit signed integer to an arbitrary-precision integer.</li>
<li><code><a href="#FromString_string">FromString(string)</a></code> - Converts a string to an arbitrary-precision integer.</li>
<li><code><a href="#FromSubstring_string_int_int">FromSubstring(string, int, int)</a></code> - Converts a portion of a string to an arbitrary-precision integer.</li>
<li><code><a href="#FromUInt16_ushort">FromUInt16(ushort)</a></code> - Converts a 16-bit unsigned integer to an arbitrary-precision integer.</li>
<li><code><a href="#FromUInt32_uint">FromUInt32(uint)</a></code> - Converts a 32-bit signed integer to an arbitrary-precision integer.</li>
<li><code><a href="#FromUInt64_ulong">FromUInt64(ulong)</a></code> - Converts a 64-bit unsigned integer to an arbitrary-precision integer.</li>
<li><code><a href="#Gcd_PeterO_Numbers_EInteger">Gcd(PeterO.Numbers.EInteger)</a></code> - Returns the greatest common divisor of this integer and the given integer.</li>
<li><code><a href="#GetBits_int_int">GetBits(int, int)</a></code> - Retrieves bits from this integer&#39;s two&#39; s-complement form.</li>
<li><code><a href="#GetDigitCount">GetDigitCount()</a></code> - Returns the number of decimal digits used by this integer.</li>
<li><code><a href="#GetHashCode">GetHashCode()</a></code> - Returns the hash code for this instance.</li>
<li><code><a href="#GetLowBit">GetLowBit()</a></code> - Gets the lowest set bit in this number&#39;s absolute value.</li>
<li><code><a href="#GetLowBitAsEInteger">GetLowBitAsEInteger()</a></code> - Gets the lowest set bit in this number&#39;s absolute value.</li>
<li><code><a href="#GetSignedBitLength">GetSignedBitLength()</a></code> - Finds the minimum number of bits needed to represent this object&#39;s value, except for its sign.</li>
<li><code><a href="#GetSignedBit_int">GetSignedBit(int)</a></code> - Returns whether a bit is set in the two&#39;s-complement form (seePeterO.</li>
<li><code><a href="#GetUnsignedBitLength">GetUnsignedBitLength()</a></code> - Finds the minimum number of bits needed to represent this number&#39;s absolute value.</li>
<li><code><a href="#GetUnsignedBitLengthAsEInteger">GetUnsignedBitLengthAsEInteger()</a></code> - Finds the minimum number of bits needed to represent this number&#39;s absolute value.</li>
<li><code><a href="#GetUnsignedBit_int">GetUnsignedBit(int)</a></code> - Returns whether a bit is set in this number&#39;s absolute value.</li>
<li><code><a href="#IsEven">IsEven</a></code> - Gets a value indicating whether this value is even.</li>
<li><code><a href="#IsPowerOfTwo">IsPowerOfTwo</a></code> - Gets a value indicating whether this object&#39;s value is a power of two.</li>
<li><code><a href="#IsZero">IsZero</a></code> - Gets a value indicating whether this value is 0.</li>
<li><code><a href="#ModPow_PeterO_Numbers_EInteger_PeterO_Numbers_EInteger">ModPow(PeterO.Numbers.EInteger, PeterO.Numbers.EInteger)</a></code> - Calculates the remainder when this arbitrary-precision integer raised to a certain power is divided by another arbitrary-precision integer.</li>
<li><code><a href="#ModPow_PeterO_Numbers_EInteger_PeterO_Numbers_EInteger_PeterO_Numbers_EInteger">ModPow(PeterO.Numbers.EInteger, PeterO.Numbers.EInteger, PeterO.Numbers.EInteger)</a></code> - Calculates the remainder when an arbitrary-precision integer raised to a certain power is divided by another arbitrary-precision integer.</li>
<li><code><a href="#Mod_PeterO_Numbers_EInteger">Mod(PeterO.Numbers.EInteger)</a></code> - Finds the modulus remainder that results when this instance is divided by the value of an arbitrary-precision integer.</li>
<li><code><a href="#Multiply_PeterO_Numbers_EInteger">Multiply(PeterO.Numbers.EInteger)</a></code> - Multiplies this instance by the value of an arbitrary-precision integer object.</li>
<li><code><a href="#Multiply_int">Multiply(int)</a></code> - Multiplies this instance by the value of an arbitrary-precision integer object.</li>
<li><code><a href="#Negate">Negate()</a></code> - Gets the value of this object with the sign reversed.</li>
<li><code><a href="#Not_PeterO_Numbers_EInteger">Not(PeterO.Numbers.EInteger)</a></code> - Returns an arbitrary-precision integer with every bit flipped.</li>
<li><code><a href="#One">One</a></code> - Gets the number 1 as an arbitrary-precision integer.</li>
<li><code><a href="#Or_PeterO_Numbers_EInteger_PeterO_Numbers_EInteger">Or(PeterO.Numbers.EInteger, PeterO.Numbers.EInteger)</a></code> - Does an OR operation between two arbitrary-precision integer instances.</li>
<li><code><a href="#PowBigIntVar_PeterO_Numbers_EInteger">PowBigIntVar(PeterO.Numbers.EInteger)</a></code> - Raises an arbitrary-precision integer to a power, which is given as another arbitrary-precision integer.</li>
<li><code><a href="#Pow_int">Pow(int)</a></code> - Raises an arbitrary-precision integer to a power.</li>
<li><code><a href="#Remainder_PeterO_Numbers_EInteger">Remainder(PeterO.Numbers.EInteger)</a></code> - Finds the remainder that results when this instance is divided by the value of an arbitrary-precision integer.</li>
<li><code><a href="#Remainder_int">Remainder(int)</a></code> - Finds the remainder that results when this instance is divided by the value of an arbitrary-precision integer.</li>
<li><code><a href="#ShiftLeft_int">ShiftLeft(int)</a></code> - Returns an arbitrary-precision integer with the bits shifted to the left by a number of bits.</li>
<li><code><a href="#ShiftRight_int">ShiftRight(int)</a></code> - Returns an arbitrary-precision integer with the bits shifted to the right.</li>
<li><code><a href="#Sign">Sign</a></code> - Gets the sign of this object&#39;s value.</li>
<li><code><a href="#Sqrt">Sqrt()</a></code> - Finds the square root of this instance&#39;s value, rounded down.</li>
<li><code><a href="#SqrtRem">SqrtRem()</a></code> - Calculates the square root and the remainder.</li>
<li><code><a href="#Subtract_PeterO_Numbers_EInteger">Subtract(PeterO.Numbers.EInteger)</a></code> - Subtracts an arbitrary-precision integer from this arbitrary-precision integer.</li>
<li><code><a href="#Subtract_int">Subtract(int)</a></code> - Subtracts an arbitrary-precision integer from this arbitrary-precision integer.</li>
<li><code><a href="#Ten">Ten</a></code> - Gets the number 10 as an arbitrary-precision integer.</li>
<li><code><a href="#ToByteChecked">ToByteChecked()</a></code> - Converts this number&#39;s value to a byte (from 0 to 255) if it can fit in a byte (from 0 to 255).</li>
<li><code><a href="#ToByteUnchecked">ToByteUnchecked()</a></code> - Converts this number to a byte (from 0 to 255), returning the least-significant bits of this number&#39;s two&#39;s-complement form.</li>
<li><code><a href="#ToBytes_bool">ToBytes(bool)</a></code> - Returns a byte array of this integer&#39;s value.</li>
<li><code><a href="#ToInt16Checked">ToInt16Checked()</a></code> - Converts this number&#39;s value to a 16-bit signed integer if it can fit in a 16-bit signed integer.</li>
<li><code><a href="#ToInt16Unchecked">ToInt16Unchecked()</a></code> - Converts this number to a 16-bit signed integer, returning the least-significant bits of this number&#39;s two&#39;s-complement form.</li>
<li><code><a href="#ToInt32Checked">ToInt32Checked()</a></code> - Converts this object&#39;s value to a 32-bit signed integer, throwing an exception if it can&#39;t fit.</li>
<li><code><a href="#ToInt32Unchecked">ToInt32Unchecked()</a></code> - Converts this object&#39;s value to a 32-bit signed integer.</li>
<li><code><a href="#ToInt64Checked">ToInt64Checked()</a></code> - Converts this object&#39;s value to a 64-bit signed integer, throwing an exception if it can&#39;t fit.</li>
<li><code><a href="#ToInt64Unchecked">ToInt64Unchecked()</a></code> - Converts this object&#39;s value to a 64-bit signed integer.</li>
<li><code><a href="#ToRadixString_int">ToRadixString(int)</a></code> - Generates a string representing the value of this object, in the given radix.</li>
<li><code><a href="#ToSByteChecked">ToSByteChecked()</a></code> - Converts this number&#39;s value to an 8-bit signed integer if it can fit in an 8-bit signed integer.</li>
<li><code><a href="#ToSByteUnchecked">ToSByteUnchecked()</a></code> - Converts this number to an 8-bit signed integer, returning the least-significant bits of this number&#39;s two&#39;s-complement form.</li>
<li><code><a href="#ToString">ToString()</a></code> - Converts this object to a text string in base 10.</li>
<li><code><a href="#ToUInt16Checked">ToUInt16Checked()</a></code> - Converts this number&#39;s value to a 16-bit unsigned integer if it can fit in a 16-bit unsigned integer.</li>
<li><code><a href="#ToUInt16Unchecked">ToUInt16Unchecked()</a></code> - Converts this number to a 16-bit unsigned integer, returning the least-significant bits of this number&#39;s two&#39;s-complement form.</li>
<li><code><a href="#ToUInt32Checked">ToUInt32Checked()</a></code> - Converts this number&#39;s value to a 32-bit signed integer if it can fit in a 32-bit signed integer.</li>
<li><code><a href="#ToUInt32Unchecked">ToUInt32Unchecked()</a></code> - Converts this number to a 32-bit signed integer, returning the least-significant bits of this number&#39;s two&#39;s-complement form.</li>
<li><code><a href="#ToUInt64Checked">ToUInt64Checked()</a></code> - Converts this number&#39;s value to a 64-bit signed integer if it can fit in a 64-bit signed integer.</li>
<li><code><a href="#ToUInt64Unchecked">ToUInt64Unchecked()</a></code> - Converts this number to a 64-bit signed integer, returning the least-significant bits of this number&#39;s two&#39; s-complement form.</li>
<li><code><a href="#Xor_PeterO_Numbers_EInteger_PeterO_Numbers_EInteger">Xor(PeterO.Numbers.EInteger, PeterO.Numbers.EInteger)</a></code> - Finds the exclusive &quot;or&quot; of two arbitrary-precision integer objects.</li>
<li><code><a href="#Zero">Zero</a></code> - Gets the number zero as an arbitrary-precision integer.</li>
<li><code><a href="#op_Addition">PeterO.Numbers.EInteger operator +(PeterO.Numbers.EInteger, PeterO.Numbers.EInteger)</a></code> - Adds two arbitrary-precision integer objects and returns the result.</li>
<li><code><a href="#op_BitwiseAnd">PeterO.Numbers.EInteger operator &amp;(PeterO.Numbers.EInteger, PeterO.Numbers.EInteger)</a></code> - Does an AND operation between two arbitrary-precision integer values.</li>
<li><code><a href="#op_BitwiseOr">PeterO.Numbers.EInteger operator |(PeterO.Numbers.EInteger, PeterO.Numbers.EInteger)</a></code> - Does an OR operation between two arbitrary-precision integer instances.</li>
<li><code><a href="#op_Division">PeterO.Numbers.EInteger operator /(PeterO.Numbers.EInteger, PeterO.Numbers.EInteger)</a></code> - Divides an arbitrary-precision integer by the value of an arbitrary-precision integer object.</li>
<li><code><a href="#op_ExclusiveOr">PeterO.Numbers.EInteger operator ^(PeterO.Numbers.EInteger, PeterO.Numbers.EInteger)</a></code> - Finds the exclusive &quot;or&quot; of two arbitrary-precision integer objects.</li>
<li><code><a href="#op_GreaterThan">bool operator &gt;(PeterO.Numbers.EInteger, PeterO.Numbers.EInteger)</a></code> - Determines whether an arbitrary-precision integer is greater than another arbitrary-precision integer.</li>
<li><code><a href="#op_GreaterThanOrEqual">bool operator &gt;=(PeterO.Numbers.EInteger, PeterO.Numbers.EInteger)</a></code> - Determines whether an arbitrary-precision integer value is greater than another arbitrary-precision integer.</li>
<li><code><a href="#op_LeftShift">PeterO.Numbers.EInteger operator &lt;&lt;(PeterO.Numbers.EInteger, int)</a></code> - Returns an arbitrary-precision integer with the bits shifted to the left by a number of bits.</li>
<li><code><a href="#op_LessThan">bool operator &lt;(PeterO.Numbers.EInteger, PeterO.Numbers.EInteger)</a></code> - Determines whether an arbitrary-precision integer is less than another arbitrary-precision integer.</li>
<li><code><a href="#op_LessThanOrEqual">bool operator &lt;=(PeterO.Numbers.EInteger, PeterO.Numbers.EInteger)</a></code> - Determines whether an arbitrary-precision integer is up to another arbitrary-precision integer.</li>
<li><code><a href="#op_Modulus">PeterO.Numbers.EInteger operator %(PeterO.Numbers.EInteger, PeterO.Numbers.EInteger)</a></code> - Finds the remainder that results when an arbitrary-precision integer is divided by the value of another arbitrary-precision integer.</li>
<li><code><a href="#op_Multiply">PeterO.Numbers.EInteger operator *(PeterO.Numbers.EInteger, PeterO.Numbers.EInteger)</a></code> - Multiplies an arbitrary-precision integer by the value of an arbitrary-precision integer.</li>
<li><code><a href="#op_OnesComplement">PeterO.Numbers.EInteger operator ~(PeterO.Numbers.EInteger)</a></code> - Returns an arbitrary-precision integer with every bit flipped.</li>
<li><code><a href="#op_RightShift">PeterO.Numbers.EInteger operator &gt;&gt;(PeterO.Numbers.EInteger, int)</a></code> - Shifts the bits of an arbitrary-precision integer to the right.</li>
<li><code><a href="#op_Subtraction">PeterO.Numbers.EInteger operator -(PeterO.Numbers.EInteger, PeterO.Numbers.EInteger)</a></code> - Subtracts two arbitrary-precision integer values.</li>
<li><code><a href="#op_UnaryNegation">PeterO.Numbers.EInteger operator -(PeterO.Numbers.EInteger)</a></code> - Negates an arbitrary-precision integer.</li>
</ul>

<p><a id="IsEven"></a></p>

<h3>IsEven</h3>

<pre>public bool IsEven { get; }
</pre>

<p>Gets a value indicating whether this value is even.</p>

<p><b>Returns:</b></p>

<p><code>true</code> if this value is even; otherwise,  <code>false</code> .</p>

<p><a id="IsPowerOfTwo"></a></p>

<h3>IsPowerOfTwo</h3>

<pre>public bool IsPowerOfTwo { get; }
</pre>

<p>Gets a value indicating whether this object&#39;s value is a power of two.</p>

<p><b>Returns:</b></p>

<p><code>true</code> if this object&#39;s value is a power of two; otherwise,  <code>false</code> . <code>true</code> if this object&#39; s value is a power of two; otherwise,  <code>false</code> .</p>

<p><a id="IsZero"></a></p>

<h3>IsZero</h3>

<pre>public bool IsZero { get; }
</pre>

<p>Gets a value indicating whether this value is 0.</p>

<p><b>Returns:</b></p>

<p><code>true</code> if this value is 0; otherwise,  <code>false</code> .</p>

<p><a id="One"></a></p>

<h3>One</h3>

<pre>public static PeterO.Numbers.EInteger One { get; }
</pre>

<p>Gets the number 1 as an arbitrary-precision integer.</p>

<p><b>Returns:</b></p>

<p>The number 1 as an arbitrary-precision integer.</p>

<p><a id="Sign"></a></p>

<h3>Sign</h3>

<pre>public int Sign { get; }
</pre>

<p>Gets the sign of this object&#39;s value.</p>

<p><b>Returns:</b></p>

<p>The sign of this object&#39; s value.</p>

<p><a id="Ten"></a></p>

<h3>Ten</h3>

<pre>public static PeterO.Numbers.EInteger Ten { get; }
</pre>

<p>Gets the number 10 as an arbitrary-precision integer.</p>

<p><b>Returns:</b></p>

<p>The number 10 as an arbitrary-precision integer.</p>

<p><a id="Zero"></a></p>

<h3>Zero</h3>

<pre>public static PeterO.Numbers.EInteger Zero { get; }
</pre>

<p>Gets the number zero as an arbitrary-precision integer.</p>

<p><b>Returns:</b></p>

<p>The number zero as an arbitrary-precision integer.</p>

<p><a id="Abs"></a></p>

<h3>Abs</h3>

<pre>public PeterO.Numbers.EInteger Abs();
</pre>

<p>Returns the absolute value of this object&#39;s value.</p>

<p><b>Return Value:</b></p>

<p>This object&#39;s value with the sign removed.</p>

<p><a id="Add_int"></a></p>

<h3>Add</h3>

<pre>public PeterO.Numbers.EInteger Add(
    int intValue);
</pre>

<p>Adds this object and another object.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>intValue</i>: The parameter <i>intValue</i>
is a 32-bit signed integer.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The sum of the two objects.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter <i>bigintAugend</i>
is null.</li>
</ul>

<p><a id="Add_PeterO_Numbers_EInteger"></a></p>

<h3>Add</h3>

<pre>public PeterO.Numbers.EInteger Add(
    PeterO.Numbers.EInteger bigintAugend);
</pre>

<p>Adds this object and another object.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>bigintAugend</i>: Another arbitrary-precision integer.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The sum of the two objects.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter <i>bigintAugend</i>
is null.</li>
</ul>

<p><a id="And_PeterO_Numbers_EInteger_PeterO_Numbers_EInteger"></a></p>

<h3>And</h3>

<pre>public static PeterO.Numbers.EInteger And(
    PeterO.Numbers.EInteger a,
    PeterO.Numbers.EInteger b);
</pre>

<p>Does an AND operation between two arbitrary-precision integer values.</p>

<p>Each arbitrary-precision integer is treated as a two&#39;s-complement form see<a href="PeterO.Numbers.EDecimal.html">
         &#x22;Forms of numbers&#x22;
      </a>) for the purposes of this operator.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>a</i>: The first arbitrary-precision integer.</p></li>
<li><p><i>b</i>: The second arbitrary-precision integer.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter <i>a</i>
or <i>b</i>
is null.</li>
</ul>

<p><a id="AsInt32Checked"></a></p>

<h3>AsInt32Checked</h3>

<pre>public int AsInt32Checked();
</pre>

<p><b>Deprecated.</b> Renamed to ToInt32Checked.</p>

<p>Converts this object&#39;s value to a 32-bit signed integer, throwing an exception if it can&#39;t fit.</p>

<p><b>Return Value:</b></p>

<p>A 32-bit signed integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li> T:System.OverflowException:
This object&#39; s value is too big to fit a 32-bit signed integer.</li>
</ul>

<p><a id="AsInt32Unchecked"></a></p>

<h3>AsInt32Unchecked</h3>

<pre>public int AsInt32Unchecked();
</pre>

<p><b>Deprecated.</b> Renamed to ToInt32Unchecked.</p>

<p>Converts this object&#39;s value to a 32-bit signed integer. If the value can&#39;t fit in a 32-bit integer, returns the lower 32 bits of this object&#39;s two&#39; s-complement form (see<a href="PeterO.Numbers.EDecimal.html">
         &#x22;Forms of numbers&#x22;
      </a>) (in which case the return value might have a different sign than this bject&#39;s value).</p>

<p><b>Return Value:</b></p>

<p>A 32-bit signed integer.</p>

<p><a id="AsInt64Checked"></a></p>

<h3>AsInt64Checked</h3>

<pre>public long AsInt64Checked();
</pre>

<p><b>Deprecated.</b> Renamed to ToInt64Checked.</p>

<p>Converts this object&#39;s value to a 64-bit signed integer, throwing an exception if it can&#39;t fit.</p>

<p><b>Return Value:</b></p>

<p>A 64-bit signed integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li> T:System.OverflowException:
This object&#39; s value is too big to fit a 64-bit signed integer.</li>
</ul>

<p><a id="AsInt64Unchecked"></a></p>

<h3>AsInt64Unchecked</h3>

<pre>public long AsInt64Unchecked();
</pre>

<p><b>Deprecated.</b> Renamed to ToInt64Unchecked.</p>

<p>Converts this object&#39;s value to a 64-bit signed integer. If the value can&#39;t fit in a 64-bit integer, returns the lower 64 bits of this object&#39;s two&#39; s-complement form (see<a href="PeterO.Numbers.EDecimal.html">
         &#x22;Forms of numbers&#x22;
      </a>) (in which case the return value might have a different sign than this bject&#39;s value).</p>

<p><b>Return Value:</b></p>

<p>A 64-bit signed integer.</p>

<p><a id="CanFitInInt32"></a></p>

<h3>CanFitInInt32</h3>

<pre>public bool CanFitInInt32();
</pre>

<p>Returns whether this object&#39;s value can fit in a 32-bit signed integer.</p>

<p><b>Return Value:</b></p>

<p><code>true</code> if this object&#39;s value is from -2147483648 through 2147483647; otherwise,  <code>false</code> .</p>

<p><a id="CanFitInInt64"></a></p>

<h3>CanFitInInt64</h3>

<pre>public bool CanFitInInt64();
</pre>

<p>Returns whether this object&#39;s value can fit in a 64-bit signed integer.</p>

<p><b>Return Value:</b></p>

<p><code>true</code> if this object&#39;s value is from -9223372036854775808 through 223372036854775807; otherwise,  <code>false</code> .</p>

<p><a id="CompareTo_int"></a></p>

<h3>CompareTo</h3>

<pre>public int CompareTo(
    int intValue);
</pre>

<p>Compares an arbitrary-precision integer with this instance.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>intValue</i>: The parameter <i>intValue</i>
is a 32-bit signed integer.</li>
</ul>

<p><b>Return Value:</b></p>

<p>Zero if the values are equal; a negative number if this instance is less, or a positive number if this instance is greater.</p>

<p><a id="CompareTo_PeterO_Numbers_EInteger"></a></p>

<h3>CompareTo</h3>

<pre>public sealed int CompareTo(
    PeterO.Numbers.EInteger other);
</pre>

<p>Compares an arbitrary-precision integer with this instance.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>other</i>: The integer to compare to this value.</li>
</ul>

<p><b>Return Value:</b></p>

<p>Zero if the values are equal; a negative number if this instance is less, or a positive number if this instance is greater.</p>

<p><a id="Divide_int"></a></p>

<h3>Divide</h3>

<pre>public PeterO.Numbers.EInteger Divide(
    int intValue);
</pre>

<p>Divides this instance by the value of an arbitrary-precision integer. The result is rounded down (the fractional part is discarded). Except if the result is 0, it will be negative if this object is positive and the other is negative, or vice versa, and will be positive if both are positive or both are negative.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>intValue</i>: The parameter <i>intValue</i>
is a 32-bit signed integer.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The quotient of the two objects.</p>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.ArgumentNullException:
The parameter <i>bigintDivisor</i>
is null.</p></li>
<li><p>System.DivideByZeroException:
Attempted to divide by zero.</p></li>
</ul>

<p><a id="Divide_PeterO_Numbers_EInteger"></a></p>

<h3>Divide</h3>

<pre>public PeterO.Numbers.EInteger Divide(
    PeterO.Numbers.EInteger bigintDivisor);
</pre>

<p>Divides this instance by the value of an arbitrary-precision integer. The result is rounded down (the fractional part is discarded). Except if the result is 0, it will be negative if this object is positive and the other is negative, or vice versa, and will be positive if both are positive or both are negative.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>bigintDivisor</i>: Another arbitrary-precision integer.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The quotient of the two objects.</p>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.ArgumentNullException:
The parameter <i>bigintDivisor</i>
is null.</p></li>
<li><p>System.DivideByZeroException:
Attempted to divide by zero.</p></li>
</ul>

<p><a id="DivRem_PeterO_Numbers_EInteger"></a></p>

<h3>DivRem</h3>

<pre>public PeterO.Numbers.EInteger[] DivRem(
    PeterO.Numbers.EInteger divisor);
</pre>

<p>Divides this object by another arbitrary-precision integer and returns the quotient and remainder.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>divisor</i>: The number to divide by.</li>
</ul>

<p><b>Return Value:</b></p>

<p>An array with two arbitrary-precision integers: the first is the quotient, and the second is the remainder.</p>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.DivideByZeroException:
The parameter divisor is 0.</p></li>
<li><p>System.ArgumentNullException:
The parameter <i>divisor</i>
is null.</p></li>
</ul>

<p><a id="Equals_object"></a></p>

<h3>Equals</h3>

<pre>public override bool Equals(
    object obj);
</pre>

<p>Determines whether this object and another object are equal and have the same type.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>obj</i>: The parameter <i>obj</i>
is an arbitrary object.</li>
</ul>

<p><b>Return Value:</b></p>

<p><code>true</code> if this object and another object are equal; otherwise,  <code>false</code> .</p>

<p><a id="Equals_PeterO_Numbers_EInteger"></a></p>

<h3>Equals</h3>

<pre>public sealed bool Equals(
    PeterO.Numbers.EInteger other);
</pre>

<p>Determines whether this object and another object are equal.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>other</i>: Another arbitrary-precision integer.</li>
</ul>

<p><b>Return Value:</b></p>

<p><code>true</code> if this object and another object are equal; otherwise,  <code>false</code> .</p>

<p><a id="FromByte_byte"></a></p>

<h3>FromByte</h3>

<pre>public static PeterO.Numbers.EInteger FromByte(
    byte inputByte);
</pre>

<p>Converts a byte (from 0 to 255) to an arbitrary-precision integer.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>inputByte</i>: The number to convert as a byte (from 0 to 255).</li>
</ul>

<p><b>Return Value:</b></p>

<p>This number&#39;s value as an arbitrary-precision integer.</p>

<p><a id="FromBytes_byte_bool"></a></p>

<h3>FromBytes</h3>

<pre>public static PeterO.Numbers.EInteger FromBytes(
    byte[] bytes,
    bool littleEndian);
</pre>

<p>Initializes an arbitrary-precision integer from an array of bytes.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>bytes</i>: A byte array consisting of the two&#39;s-complement form (see<a href="PeterO.Numbers.EDecimal.html">
    &#x22;Forms of numbers&#x22;
  </a>) of the arbitrary-precision integer to create. The byte array is encoded sing the following rules:</p></li>
<li><p>Positive numbers have the first byte&#39;s highest bit cleared, and negative numbers have the bit set.</p></li>
<li><p>The last byte contains the lowest 8-bits, the next-to-last contains the next lowest 8 bits, and so on. For example, the number 300 can be encoded as <code>0x01, 0x2C</code> and 200 as <code>0x00, 0xC8</code> . (Note that the second example contains a set high bit in <code>0xC8</code> , so an additional 0 is added at the start to ensure it&#39;s interpreted as positive.)</p></li>
<li><p>To encode negative numbers, take the absolute value of the number, subtract by 1, encode the number into bytes, and toggle each bit of each byte. Any further bits that appear beyond the most significant bit of the number will be all ones. For example, the number -450 can be encoded as <code>0xfe, 0x70</code> and -52869 as <code>0xff, 0x31, 0x7B</code> . (Note that the second example contains a cleared high bit in <code>0x31, 0x7B</code> , so an additional 0xff is added at the start to ensure it&#39;s interpreted as negative.)</p></li>
</ul>

<p>For little-endian, the byte order is reversed from the byte order just discussed.</p>

<p>.</p>

<ul>
<li><i>littleEndian</i>: If true, the byte order is little-endian, or least-significant-byte first. If false, the byte order is big-endian, or most-significant-byte first.</li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision integer. Returns 0 if the byte array&#39;s length is 0.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter <i>bytes</i>
is null.</li>
</ul>

<p><a id="FromInt16_short"></a></p>

<h3>FromInt16</h3>

<pre>public static PeterO.Numbers.EInteger FromInt16(
    short inputInt16);
</pre>

<p>Converts a 16-bit signed integer to an arbitrary-precision integer.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>inputInt16</i>: The number to convert as a 16-bit signed integer.</li>
</ul>

<p><b>Return Value:</b></p>

<p>This number&#39;s value as an arbitrary-precision integer.</p>

<p><a id="FromInt32_int"></a></p>

<h3>FromInt32</h3>

<pre>public static PeterO.Numbers.EInteger FromInt32(
    int intValue);
</pre>

<p>Converts a 32-bit signed integer to an arbitrary-precision integer.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>intValue</i>: The parameter <i>intValue</i>
is a 32-bit signed integer.</li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision integer with the same value as the 64-bit number.</p>

<p><a id="FromInt64_long"></a></p>

<h3>FromInt64</h3>

<pre>public static PeterO.Numbers.EInteger FromInt64(
    long longerValue);
</pre>

<p>Converts a 64-bit signed integer to an arbitrary-precision integer.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>longerValue</i>: The parameter <i>longerValue</i>
is a 64-bit signed integer.</li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision integer with the same value as the 64-bit number.</p>

<p><a id="FromRadixString_string_int"></a></p>

<h3>FromRadixString</h3>

<pre>public static PeterO.Numbers.EInteger FromRadixString(
    string str,
    int radix);
</pre>

<p>Converts a string to an arbitrary-precision integer in a given radix.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>str</i>: A string described by the FromRadixSubstring method.</p></li>
<li><p><i>radix</i>: A base from 2 to 36. Depending on the radix, the string can use the basic digits 0 to 9 (U+0030 to U+0039) and then the basic letters A to Z (U+0041 to U+005A). For example, 0-9 in radix 10, and 0-9, then A-F in radix 16.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision integer with the same value as the given string.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter <i>str</i>
is null.</li>
</ul>

<p><a id="FromRadixSubstring_string_int_int_int"></a></p>

<h3>FromRadixSubstring</h3>

<pre>public static PeterO.Numbers.EInteger FromRadixSubstring(
    string str,
    int radix,
    int index,
    int endIndex);
</pre>

<p>Converts a portion of a string to an arbitrary-precision integer in a given radix.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>str</i>: A text string. The desired portion of the string must contain only characters allowed by the given radix, except that it may start with a minus sign (&quot;-&quot;, U+002D) to indicate a negative number. The desired portion is not allowed to contain white space characters, including spaces.</p></li>
<li><p><i>radix</i>: A base from 2 to 36. Depending on the radix, the string can use the basic digits 0 to 9 (U+0030 to U+0039) and then the basic letters A to Z (U+0041 to U+005A). For example, 0-9 in radix 10, and 0-9, then A-F in radix 16.</p></li>
<li><p><i>index</i>: The index of the string that starts the string portion.</p></li>
<li><p><i>endIndex</i>: The index of the string that ends the string portion. The length will be index + endIndex - 1.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision integer with the same value as given in the string portion.</p>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.ArgumentNullException:
The parameter <i>str</i>
is null.</p></li>
<li><p>System.FormatException:
The string portion is empty or in an invalid format.</p></li>
<li><p>System.ArgumentException:
&quot;Doesn&#39;t satisfy (endIndex - index) % 4 == 0&quot;.</p></li>
</ul>

<p><a id="FromSByte_sbyte"></a></p>

<h3>FromSByte</h3>

<pre>public static PeterO.Numbers.EInteger FromSByte(
    sbyte inputSByte);
</pre>

<p>Converts an 8-bit signed integer to an arbitrary-precision integer.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>inputSByte</i>: The number to convert as an 8-bit signed integer.</li>
</ul>

<p><b>Return Value:</b></p>

<p>This number&#39;s value as an arbitrary-precision integer.</p>

<p><a id="FromString_string"></a></p>

<h3>FromString</h3>

<pre>public static PeterO.Numbers.EInteger FromString(
    string str);
</pre>

<p>Converts a string to an arbitrary-precision integer.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>str</i>: A text string. The string must contain only basic digits 0 to 9 (U+0030 to U+0039), except that it may start with a minus sign (&quot;-&quot;, U+002D) to indicate a negative number. The string is not allowed to contain white space characters, including spaces.</li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision integer with the same value as given in the string.</p>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.FormatException:
The parameter <i>str</i>
is in an invalid format.</p></li>
<li><p>System.ArgumentNullException:
The parameter <i>str</i>
is null.</p></li>
</ul>

<p><a id="FromSubstring_string_int_int"></a></p>

<h3>FromSubstring</h3>

<pre>public static PeterO.Numbers.EInteger FromSubstring(
    string str,
    int index,
    int endIndex);
</pre>

<p>Converts a portion of a string to an arbitrary-precision integer.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>str</i>: A text string. The desired portion of the string must contain only basic digits 0 to 9 (U+0030 to U+0039), except that it may start with a minus sign (&quot;-&quot;, U+002D) to indicate a negative number. The desired portion is not allowed to contain white space characters, including spaces.</p></li>
<li><p><i>index</i>: The index of the string that starts the string portion.</p></li>
<li><p><i>endIndex</i>: The index of the string that ends the string portion. The length will be index + endIndex - 1.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision integer with the same value as given in the string portion.</p>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.ArgumentException:
The parameter <i>index</i>
is less than 0, <i>endIndex</i>
is less than 0, or either is greater than the string&#39;s length, or <i>endIndex</i>
is less than <i>index</i>
.</p></li>
<li><p>System.ArgumentNullException:
The parameter <i>str</i>
is null.</p></li>
</ul>

<p><a id="FromUInt16_ushort"></a></p>

<h3>FromUInt16</h3>

<pre>public static PeterO.Numbers.EInteger FromUInt16(
    ushort inputUInt16);
</pre>

<p>Converts a 16-bit unsigned integer to an arbitrary-precision integer.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>inputUInt16</i>: The number to convert as a 16-bit unsigned integer.</li>
</ul>

<p><b>Return Value:</b></p>

<p>This number&#39;s value as an arbitrary-precision integer.</p>

<p><a id="FromUInt32_uint"></a></p>

<h3>FromUInt32</h3>

<pre>public static PeterO.Numbers.EInteger FromUInt32(
    uint inputUInt32);
</pre>

<p>Converts a 32-bit signed integer to an arbitrary-precision integer.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>inputUInt32</i>: The number to convert as a 32-bit signed integer.</li>
</ul>

<p><b>Return Value:</b></p>

<p>This number&#39;s value as an arbitrary-precision integer.</p>

<p><a id="FromUInt64_ulong"></a></p>

<h3>FromUInt64</h3>

<pre>public static PeterO.Numbers.EInteger FromUInt64(
    ulong ulongValue);
</pre>

<p>Converts a 64-bit unsigned integer to an arbitrary-precision integer.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>ulongValue</i>: The number to convert as a 64-bit unsigned integer.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The value of <i>ulongValue</i>
as an arbitrary-precision integer.</p>

<p><a id="Gcd_PeterO_Numbers_EInteger"></a></p>

<h3>Gcd</h3>

<pre>public PeterO.Numbers.EInteger Gcd(
    PeterO.Numbers.EInteger bigintSecond);
</pre>

<p>Returns the greatest common divisor of this integer and the given integer. The greatest common divisor (GCD) is also known as the greatest common factor (GCF).</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>bigintSecond</i>: Another arbitrary-precision integer.</li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter <i>bigintSecond</i>
is null.</li>
</ul>

<p><a id="GetBits_int_int"></a></p>

<h3>GetBits</h3>

<pre>public long GetBits(
    int index,
    int numberBits);
</pre>

<p>Retrieves bits from this integer&#39;s two&#39; s-complement form.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>index</i>: Zero-based index of the first bit to retrieve, where 0 is the least-significant bit of the number.</p></li>
<li><p><i>numberBits</i>: The number of bits to retrieve, starting with the first. Must be from 0 through 64.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>A 64-bit signed integer containing the bits from this integer&#39;s two&#39; s-complement form. The least significant bit is the first bit, and any unused bits are set to 0.</p>

<p><a id="GetDigitCount"></a></p>

<h3>GetDigitCount</h3>

<pre>public int GetDigitCount();
</pre>

<p>Returns the number of decimal digits used by this integer.</p>

<p><b>Return Value:</b></p>

<p>The number of digits in the decimal form of this integer. Returns 1 if this number is 0.</p>

<p><a id="GetHashCode"></a></p>

<h3>GetHashCode</h3>

<pre>public override int GetHashCode();
</pre>

<p>Returns the hash code for this instance. No application or process IDs are used in the hash code calculation.</p>

<p><b>Return Value:</b></p>

<p>A 32-bit signed integer.</p>

<p><a id="GetLowBit"></a></p>

<h3>GetLowBit</h3>

<pre>public int GetLowBit();
</pre>

<p>Gets the lowest set bit in this number&#39;s absolute value. (This will also be the lowest set bit in the number&#39;s two&#39;s-complement form (see<a href="PeterO.Numbers.EDecimal.html">
         &#x22;Forms of numbers&#x22;
      </a>).).</p>

<p><b>Return Value:</b></p>

<p>The lowest bit set in the number, starting at 0. Returns -1 if this value is 0 or odd.</p>

<p><a id="GetLowBitAsEInteger"></a></p>

<h3>GetLowBitAsEInteger</h3>

<pre>public PeterO.Numbers.EInteger GetLowBitAsEInteger();
</pre>

<p>Gets the lowest set bit in this number&#39;s absolute value. (This will also be the lowest set bit in the number&#39;s two&#39;s-complement form (see<a href="PeterO.Numbers.EDecimal.html">
         &#x22;Forms of numbers&#x22;
      </a>).).</p>

<p><b>Return Value:</b></p>

<p>The lowest bit set in the number, starting at 0. Returns -1 if this value is 0 or odd.</p>

<p><a id="GetSignedBit_int"></a></p>

<h3>GetSignedBit</h3>

<pre>public bool GetSignedBit(
    int index);
</pre>

<p>Returns whether a bit is set in the two&#39;s-complement form (see<a href="PeterO.Numbers.EDecimal.html">
         &#x22;Forms of numbers&#x22;
      </a>) of this object&#39; s value.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>index</i>: The parameter <i>index</i>
is a 32-bit signed integer.</li>
</ul>

<p><b>Return Value:</b></p>

<p><code>true</code> if a bit is set in the two&#39; s-complement form (see<a href="PeterO.Numbers.EDecimal.html">
         &#x22;Forms of numbers&#x22;
      </a>) of this object&#39; s value; otherwise,  <code>false</code> .</p>

<p><a id="GetSignedBitLength"></a></p>

<h3>GetSignedBitLength</h3>

<pre>public int GetSignedBitLength();
</pre>

<p>Finds the minimum number of bits needed to represent this object&#39;s value, except for its sign. If the value is negative, finds the number of bits in the value equal to this object&#39;s absolute value minus 1.</p>

<p><b>Return Value:</b></p>

<p>The number of bits in this object&#39;s value. Returns 0 if this object&#39;s value is 0 or negative 1.</p>

<p><a id="GetUnsignedBit_int"></a></p>

<h3>GetUnsignedBit</h3>

<pre>public bool GetUnsignedBit(
    int index);
</pre>

<p>Returns whether a bit is set in this number&#39;s absolute value.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>index</i>: Zero based index of the bit to test. 0 means the least significant bit.</li>
</ul>

<p><b>Return Value:</b></p>

<p><code>true</code> if a bit is set in this number&#39;s absolute value.</p>

<p><a id="GetUnsignedBitLength"></a></p>

<h3>GetUnsignedBitLength</h3>

<pre>public int GetUnsignedBitLength();
</pre>

<p>Finds the minimum number of bits needed to represent this number&#39;s absolute value.</p>

<p><b>Return Value:</b></p>

<p>The number of bits in this object&#39;s value. Returns 0 if this object&#39;s value is 0, and returns 1 if the value is negative 1.</p>

<p><a id="GetUnsignedBitLengthAsEInteger"></a></p>

<h3>GetUnsignedBitLengthAsEInteger</h3>

<pre>public PeterO.Numbers.EInteger GetUnsignedBitLengthAsEInteger();
</pre>

<p>Finds the minimum number of bits needed to represent this number&#39;s absolute value.</p>

<p><b>Return Value:</b></p>

<p>The number of bits in this object&#39;s value. Returns 0 if this object&#39;s value is 0, and returns 1 if the value is negative 1.</p>

<p><a id="Mod_PeterO_Numbers_EInteger"></a></p>

<h3>Mod</h3>

<pre>public PeterO.Numbers.EInteger Mod(
    PeterO.Numbers.EInteger divisor);
</pre>

<p>Finds the modulus remainder that results when this instance is divided by the value of an arbitrary-precision integer. The modulus remainder is the same as the normal remainder if the normal remainder is positive, and equals divisor plus normal remainder if the normal remainder is negative.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>divisor</i>: The number to divide by.</li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter <i>divisor</i>
is null.</li>
</ul>

<p><a id="ModPow_PeterO_Numbers_EInteger_PeterO_Numbers_EInteger"></a></p>

<h3>ModPow</h3>

<pre>public PeterO.Numbers.EInteger ModPow(
    PeterO.Numbers.EInteger pow,
    PeterO.Numbers.EInteger mod);
</pre>

<p>Calculates the remainder when this arbitrary-precision integer raised to a certain power is divided by another arbitrary-precision integer.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>pow</i>: The power to raise this integer by.</p></li>
<li><p><i>mod</i>: The integer to divide the raised number by.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter <i>pow</i>
or <i>mod</i>
is null.</li>
</ul>

<p><a id="ModPow_PeterO_Numbers_EInteger_PeterO_Numbers_EInteger_PeterO_Numbers_EInteger"></a></p>

<h3>ModPow</h3>

<pre>public static PeterO.Numbers.EInteger ModPow(
    PeterO.Numbers.EInteger bigintValue,
    PeterO.Numbers.EInteger pow,
    PeterO.Numbers.EInteger mod);
</pre>

<p>Calculates the remainder when an arbitrary-precision integer raised to a certain power is divided by another arbitrary-precision integer.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>bigintValue</i>: The starting operand.</p></li>
<li><p><i>pow</i>: The power to raise this integer by.</p></li>
<li><p><i>mod</i>: The integer to divide the raised number by.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>The value ( <i>bigintValue</i>
^ <i>pow</i>
)% <i>mod</i>
.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter <i>bigintValue</i>
is null.</li>
</ul>

<p><a id="Multiply_int"></a></p>

<h3>Multiply</h3>

<pre>public PeterO.Numbers.EInteger Multiply(
    int intValue);
</pre>

<p>Multiplies this instance by the value of an arbitrary-precision integer object.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>intValue</i>: The parameter <i>intValue</i>
is a 32-bit signed integer.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The product of the two numbers.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter <i>bigintMult</i>
is null.</li>
</ul>

<p><a id="Multiply_PeterO_Numbers_EInteger"></a></p>

<h3>Multiply</h3>

<pre>public PeterO.Numbers.EInteger Multiply(
    PeterO.Numbers.EInteger bigintMult);
</pre>

<p>Multiplies this instance by the value of an arbitrary-precision integer object.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>bigintMult</i>: Another arbitrary-precision integer.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The product of the two numbers.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter <i>bigintMult</i>
is null.</li>
</ul>

<p><a id="Negate"></a></p>

<h3>Negate</h3>

<pre>public PeterO.Numbers.EInteger Negate();
</pre>

<p>Gets the value of this object with the sign reversed.</p>

<p><b>Return Value:</b></p>

<p>This object&#39;s value with the sign reversed.</p>

<p><a id="Not_PeterO_Numbers_EInteger"></a></p>

<h3>Not</h3>

<pre>public static PeterO.Numbers.EInteger Not(
    PeterO.Numbers.EInteger valueA);
</pre>

<p>Returns an arbitrary-precision integer with every bit flipped.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>valueA</i>: The operand as an arbitrary-precision integer.</li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter <i>valueA</i>
is null.</li>
</ul>

<p><a id="op_Addition"></a></p>

<h3>Operator <code>+</code></h3>

<pre>public static PeterO.Numbers.EInteger operator +(
    PeterO.Numbers.EInteger bthis,
    PeterO.Numbers.EInteger augend);
</pre>

<p>Adds two arbitrary-precision integer objects and returns the result.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>bthis</i>: The first operand.</p></li>
<li><p><i>augend</i>: The second operand.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>The sum of the two objects.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter <i>bthis</i>
is null.</li>
</ul>

<p><a id="op_BitwiseAnd"></a></p>

<h3>Operator <code>&amp;</code></h3>

<pre>public static PeterO.Numbers.EInteger operator &amp;(
    PeterO.Numbers.EInteger thisValue,
    PeterO.Numbers.EInteger otherValue);
</pre>

<p>Does an AND operation between two arbitrary-precision integer values.</p>

<p>Each arbitrary-precision integer is treated as a two&#39;s-complement form see<a href="PeterO.Numbers.EDecimal.html">
         &#x22;Forms of numbers&#x22;
      </a>) for the purposes of this operator.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>thisValue</i>: The first operand.</p></li>
<li><p><i>otherValue</i>: The second operand.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>The result of the operation.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter &quot;a&quot; or &quot;b&quot; is null.</li>
</ul>

<p><a id="op_BitwiseOr"></a></p>

<h3>Operator <code>|</code></h3>

<pre>public static PeterO.Numbers.EInteger operator |(
    PeterO.Numbers.EInteger thisValue,
    PeterO.Numbers.EInteger otherValue);
</pre>

<p>Does an OR operation between two arbitrary-precision integer instances.</p>

<p>Each arbitrary-precision integer is treated as a two&#39;s-complement form see<a href="PeterO.Numbers.EDecimal.html">
         &#x22;Forms of numbers&#x22;
      </a>) for the purposes of this operator.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>thisValue</i>: An arbitrary-precision integer.</p></li>
<li><p><i>otherValue</i>: Another arbitrary-precision integer.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>The result of the operation.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter &quot;first&quot; or &quot;second&quot; is null.</li>
</ul>

<p><a id="op_Division"></a></p>

<h3>Operator <code>/</code></h3>

<pre>public static PeterO.Numbers.EInteger operator /(
    PeterO.Numbers.EInteger dividend,
    PeterO.Numbers.EInteger divisor);
</pre>

<p>Divides an arbitrary-precision integer by the value of an arbitrary-precision integer object.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>dividend</i>: The number that will be divided by the divisor.</p></li>
<li><p><i>divisor</i>: The number to divide by.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>The quotient of the two objects.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter <i>dividend</i>
is null.</li>
</ul>

<p><a id="op_ExclusiveOr"></a></p>

<h3>Operator <code>^</code></h3>

<pre>public static PeterO.Numbers.EInteger operator ^(
    PeterO.Numbers.EInteger a,
    PeterO.Numbers.EInteger b);
</pre>

<p>Finds the exclusive &quot;or&quot; of two arbitrary-precision integer objects.Each arbitrary-precision integer is treated as a two&#39;s-complement form (see<a href="PeterO.Numbers.EDecimal.html">
           &#x22;Forms of numbers&#x22;
        </a>) for the purposes of this operator.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>a</i>: The first arbitrary-precision integer.</p></li>
<li><p><i>b</i>: The second arbitrary-precision integer.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision integer in which each bit is set if it&#39;s set in one input integer but not the other.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter <i>a</i>
or <i>b</i>
is null.</li>
</ul>

<p><a id="op_GreaterThan"></a></p>

<h3>Operator <code>&gt;</code></h3>

<pre>public static bool operator &gt;(
    PeterO.Numbers.EInteger thisValue,
    PeterO.Numbers.EInteger otherValue);
</pre>

<p>Determines whether an arbitrary-precision integer is greater than another arbitrary-precision integer.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>thisValue</i>: The first arbitrary-precision integer.</p></li>
<li><p><i>otherValue</i>: The second arbitrary-precision integer.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p><code>true</code> if <i>thisValue</i>
is greater than <i>otherValue</i>
; otherwise,  <code>false</code> .</p>

<p><a id="op_GreaterThanOrEqual"></a></p>

<h3>Operator <code>&gt;=</code></h3>

<pre>public static bool operator &gt;=(
    PeterO.Numbers.EInteger thisValue,
    PeterO.Numbers.EInteger otherValue);
</pre>

<p>Determines whether an arbitrary-precision integer value is greater than another arbitrary-precision integer.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>thisValue</i>: The first arbitrary-precision integer.</p></li>
<li><p><i>otherValue</i>: The second arbitrary-precision integer.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p><code>true</code> if <i>thisValue</i>
is at least <i>otherValue</i>
; otherwise,  <code>false</code> .</p>

<p><a id="op_LeftShift"></a></p>

<h3>Operator <code>&lt;&lt;</code></h3>

<pre>public static PeterO.Numbers.EInteger operator &lt;&lt;(
    PeterO.Numbers.EInteger bthis,
    int bitCount);
</pre>

<p>Returns an arbitrary-precision integer with the bits shifted to the left by a number of bits. A value of 1 doubles this value, a value of 2 multiplies it by 4, a value of 3 by 8, a value of 4 by 16, and so on.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>bthis</i>: The arbitrary-precision integer to shift left.</p></li>
<li><p><i>bitCount</i>: The number of bits to shift. Can be negative, in which case this is the same as shiftRight with the absolute value of this parameter.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter <i>bthis</i>
is null.</li>
</ul>

<p><a id="op_LessThan"></a></p>

<h3>Operator <code>&lt;</code></h3>

<pre>public static bool operator &lt;(
    PeterO.Numbers.EInteger thisValue,
    PeterO.Numbers.EInteger otherValue);
</pre>

<p>Determines whether an arbitrary-precision integer is less than another arbitrary-precision integer.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>thisValue</i>: The first arbitrary-precision integer.</p></li>
<li><p><i>otherValue</i>: The second arbitrary-precision integer.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p><code>true</code> if <i>thisValue</i>
is less than <i>otherValue</i>
; otherwise,  <code>false</code> .</p>

<p><a id="op_LessThanOrEqual"></a></p>

<h3>Operator <code>&lt;=</code></h3>

<pre>public static bool operator &lt;=(
    PeterO.Numbers.EInteger thisValue,
    PeterO.Numbers.EInteger otherValue);
</pre>

<p>Determines whether an arbitrary-precision integer is up to another arbitrary-precision integer.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>thisValue</i>: The first arbitrary-precision integer.</p></li>
<li><p><i>otherValue</i>: The second arbitrary-precision integer.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p><code>true</code> if <i>thisValue</i>
is up to <i>otherValue</i>
; otherwise,  <code>false</code> .</p>

<p><a id="op_Modulus"></a></p>

<h3>Operator <code>%</code></h3>

<pre>public static PeterO.Numbers.EInteger operator %(
    PeterO.Numbers.EInteger dividend,
    PeterO.Numbers.EInteger divisor);
</pre>

<p>Finds the remainder that results when an arbitrary-precision integer is divided by the value of another arbitrary-precision integer.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>dividend</i>: The first operand.</p></li>
<li><p><i>divisor</i>: The number to divide by.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>The remainder of the two numbers.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter <i>dividend</i>
is null.</li>
</ul>

<p><a id="op_Multiply"></a></p>

<h3>Operator <code>*</code></h3>

<pre>public static PeterO.Numbers.EInteger operator *(
    PeterO.Numbers.EInteger operand1,
    PeterO.Numbers.EInteger operand2);
</pre>

<p>Multiplies an arbitrary-precision integer by the value of an arbitrary-precision integer.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>operand1</i>: The first operand.</p></li>
<li><p><i>operand2</i>: The second operand.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>The product of the two numbers.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter <i>operand1</i>
is null.</li>
</ul>

<p><a id="op_OnesComplement"></a></p>

<h3>Operator <code>~</code></h3>

<pre>public static PeterO.Numbers.EInteger operator ~(
    PeterO.Numbers.EInteger thisValue);
</pre>

<p>Returns an arbitrary-precision integer with every bit flipped.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>thisValue</i>: The operand as an arbitrary-precision integer.</li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter <i>thisValue</i>
is null.</li>
</ul>

<p><a id="op_RightShift"></a></p>

<h3>Operator <code>&gt;&gt;</code></h3>

<pre>public static PeterO.Numbers.EInteger operator &gt;&gt;(
    PeterO.Numbers.EInteger bthis,
    int smallValue);
</pre>

<p>Shifts the bits of an arbitrary-precision integer to the right.</p>

<p>For this operation, the arbitrary-precision integer is treated as a wo&#39;s-complement form (see<a href="PeterO.Numbers.EDecimal.html">
         &#x22;Forms of numbers&#x22;
      </a>). Thus, for negative values, the arbitrary-precision integer is ign-extended.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>bthis</i>: Another arbitrary-precision integer.</p></li>
<li><p><i>smallValue</i>: The parameter <i>smallValue</i>
is a 32-bit signed integer.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter <i>bthis</i>
is null.</li>
</ul>

<p><a id="op_Subtraction"></a></p>

<h3>Operator <code>-</code></h3>

<pre>public static PeterO.Numbers.EInteger operator -(
    PeterO.Numbers.EInteger bthis,
    PeterO.Numbers.EInteger subtrahend);
</pre>

<p>Subtracts two arbitrary-precision integer values.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>bthis</i>: An arbitrary-precision integer.</p></li>
<li><p><i>subtrahend</i>: Another arbitrary-precision integer.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>The difference of the two objects.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter <i>bthis</i>
is null.</li>
</ul>

<p><a id="op_UnaryNegation"></a></p>

<h3>Operator <code>-</code></h3>

<pre>public static PeterO.Numbers.EInteger operator -(
    PeterO.Numbers.EInteger bigValue);
</pre>

<p>Negates an arbitrary-precision integer.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>bigValue</i>: An arbitrary-precision integer to negate.</li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter <i>bigValue</i>
is null.</li>
</ul>

<p><a id="Or_PeterO_Numbers_EInteger_PeterO_Numbers_EInteger"></a></p>

<h3>Or</h3>

<pre>public static PeterO.Numbers.EInteger Or(
    PeterO.Numbers.EInteger first,
    PeterO.Numbers.EInteger second);
</pre>

<p>Does an OR operation between two arbitrary-precision integer instances.</p>

<p>Each arbitrary-precision integer is treated as a two&#39;s-complement form see<a href="PeterO.Numbers.EDecimal.html">
         &#x22;Forms of numbers&#x22;
      </a>) for the purposes of this operator.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>first</i>: The first operand.</p></li>
<li><p><i>second</i>: The second operand.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter <i>first</i>
or <i>second</i>
is null.</li>
</ul>

<p><a id="Pow_int"></a></p>

<h3>Pow</h3>

<pre>public PeterO.Numbers.EInteger Pow(
    int powerSmall);
</pre>

<p>Raises an arbitrary-precision integer to a power.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>powerSmall</i>: The exponent to raise to.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The result. Returns 1 if &quot;powerSmall&quot; is 0.</p>

<p><a id="PowBigIntVar_PeterO_Numbers_EInteger"></a></p>

<h3>PowBigIntVar</h3>

<pre>public PeterO.Numbers.EInteger PowBigIntVar(
    PeterO.Numbers.EInteger power);
</pre>

<p>Raises an arbitrary-precision integer to a power, which is given as another arbitrary-precision integer.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>power</i>: The exponent to raise to.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The result. Returns 1 if &quot;power&quot; is 0.</p>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.ArgumentException:
The parameter <i>power</i>
is less than 0.</p></li>
<li><p>System.ArgumentNullException:
The parameter <i>power</i>
is null.</p></li>
</ul>

<p><a id="Remainder_int"></a></p>

<h3>Remainder</h3>

<pre>public PeterO.Numbers.EInteger Remainder(
    int intValue);
</pre>

<p>Finds the remainder that results when this instance is divided by the value of an arbitrary-precision integer. The remainder is the value that remains when the absolute value of this object is divided by the absolute value of the other object; the remainder has the same sign (positive or negative) as this object.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>intValue</i>: The parameter <i>intValue</i>
is a 32-bit signed integer.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The remainder of the two numbers.</p>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.DivideByZeroException:
Attempted to divide by zero.</p></li>
<li><p>System.ArgumentNullException:
The parameter <i>divisor</i>
is null.</p></li>
</ul>

<p><a id="Remainder_PeterO_Numbers_EInteger"></a></p>

<h3>Remainder</h3>

<pre>public PeterO.Numbers.EInteger Remainder(
    PeterO.Numbers.EInteger divisor);
</pre>

<p>Finds the remainder that results when this instance is divided by the value of an arbitrary-precision integer. The remainder is the value that remains when the absolute value of this object is divided by the absolute value of the other object; the remainder has the same sign (positive or negative) as this object.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>divisor</i>: The number to divide by.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The remainder of the two numbers.</p>

<p><b>Exceptions:</b></p>

<ul>
<li><p>System.DivideByZeroException:
Attempted to divide by zero.</p></li>
<li><p>System.ArgumentNullException:
The parameter <i>divisor</i>
is null.</p></li>
</ul>

<p><a id="ShiftLeft_int"></a></p>

<h3>ShiftLeft</h3>

<pre>public PeterO.Numbers.EInteger ShiftLeft(
    int numberBits);
</pre>

<p>Returns an arbitrary-precision integer with the bits shifted to the left by a number of bits. A value of 1 doubles this value, a value of 2 multiplies it by 4, a value of 3 by 8, a value of 4 by 16, and so on.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>numberBits</i>: The number of bits to shift. Can be negative, in which case this is the same as shiftRight with the absolute value of this parameter.</li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision integer.</p>

<p><a id="ShiftRight_int"></a></p>

<h3>ShiftRight</h3>

<pre>public PeterO.Numbers.EInteger ShiftRight(
    int numberBits);
</pre>

<p>Returns an arbitrary-precision integer with the bits shifted to the right. For this operation, the arbitrary-precision integer is treated as a two&#39;s-complement form (see<a href="PeterO.Numbers.EDecimal.html">
         &#x22;Forms of numbers&#x22;
      </a>). Thus, for negative values, the arbitrary-precision integer is ign-extended.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>numberBits</i>: Number of bits to shift right.</li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision integer.</p>

<p><a id="Sqrt"></a></p>

<h3>Sqrt</h3>

<pre>public PeterO.Numbers.EInteger Sqrt();
</pre>

<p>Finds the square root of this instance&#39;s value, rounded down.</p>

<p><b>Return Value:</b></p>

<p>The square root of this object&#39;s value. Returns 0 if this value is 0 or less.</p>

<p><a id="SqrtRem"></a></p>

<h3>SqrtRem</h3>

<pre>public PeterO.Numbers.EInteger[] SqrtRem();
</pre>

<p>Calculates the square root and the remainder.</p>

<p><b>Return Value:</b></p>

<p>An array of two arbitrary-precision integers: the first integer is the square root, and the second is the difference between this value and the square of the first integer. Returns two zeros if this value is 0 or less, or one and zero if this value equals 1.</p>

<p><a id="Subtract_int"></a></p>

<h3>Subtract</h3>

<pre>public PeterO.Numbers.EInteger Subtract(
    int intValue);
</pre>

<p>Subtracts an arbitrary-precision integer from this arbitrary-precision integer.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>intValue</i>: The parameter <i>intValue</i>
is a 32-bit signed integer.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The difference of the two objects.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter <i>subtrahend</i>
is null.</li>
</ul>

<p><a id="Subtract_PeterO_Numbers_EInteger"></a></p>

<h3>Subtract</h3>

<pre>public PeterO.Numbers.EInteger Subtract(
    PeterO.Numbers.EInteger subtrahend);
</pre>

<p>Subtracts an arbitrary-precision integer from this arbitrary-precision integer.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>subtrahend</i>: Another arbitrary-precision integer.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The difference of the two objects.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter <i>subtrahend</i>
is null.</li>
</ul>

<p><a id="ToByteChecked"></a></p>

<h3>ToByteChecked</h3>

<pre>public byte ToByteChecked();
</pre>

<p>Converts this number&#39;s value to a byte (from 0 to 255) if it can fit in a byte (from 0 to 255).</p>

<p><b>Return Value:</b></p>

<p>This number&#39;s value as a byte (from 0 to 255).</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.OverflowException:
This value is less than 0 or greater than 255.</li>
</ul>

<p><a id="ToBytes_bool"></a></p>

<h3>ToBytes</h3>

<pre>public byte[] ToBytes(
    bool littleEndian);
</pre>

<p>Returns a byte array of this integer&#39;s value. The byte array will take the number&#39;s two&#39; s-complement form (see<a href="PeterO.Numbers.EDecimal.html">&#x22;Forms of numbers&#x22;</a> ), using the fewest bytes necessary to store its value unambiguously. If this value is negative, the bits that appear beyond the most significant bit of the number will be all ones. The resulting byte array can be passed to the  <code>FromBytes()</code>  method (with the same byte order) to reconstruct this integer&#39;s value.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>littleEndian</i>: Either  <code>true</code>  or  <code>false</code> .</li>
</ul>

<p><b>Return Value:</b></p>

<p>A byte array. If this value is 0, returns a byte array with the single element 0.</p>

<p><a id="ToByteUnchecked"></a></p>

<h3>ToByteUnchecked</h3>

<pre>public byte ToByteUnchecked();
</pre>

<p>Converts this number to a byte (from 0 to 255), returning the least-significant bits of this number&#39;s two&#39;s-complement form.</p>

<p><b>Return Value:</b></p>

<p>This number, converted to a byte (from 0 to 255).</p>

<p><a id="ToInt16Checked"></a></p>

<h3>ToInt16Checked</h3>

<pre>public short ToInt16Checked();
</pre>

<p>Converts this number&#39;s value to a 16-bit signed integer if it can fit in a 16-bit signed integer.</p>

<p><b>Return Value:</b></p>

<p>This number&#39;s value as a 16-bit signed integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.OverflowException:
This value is less than -32768 or greater than 32767.</li>
</ul>

<p><a id="ToInt16Unchecked"></a></p>

<h3>ToInt16Unchecked</h3>

<pre>public short ToInt16Unchecked();
</pre>

<p>Converts this number to a 16-bit signed integer, returning the least-significant bits of this number&#39;s two&#39;s-complement form.</p>

<p><b>Return Value:</b></p>

<p>This number, converted to a 16-bit signed integer.</p>

<p><a id="ToInt32Checked"></a></p>

<h3>ToInt32Checked</h3>

<pre>public int ToInt32Checked();
</pre>

<p>Converts this object&#39;s value to a 32-bit signed integer, throwing an exception if it can&#39;t fit.</p>

<p><b>Return Value:</b></p>

<p>A 32-bit signed integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li> T:System.OverflowException:
This object&#39; s value is too big to fit a 32-bit signed integer.</li>
</ul>

<p><a id="ToInt32Unchecked"></a></p>

<h3>ToInt32Unchecked</h3>

<pre>public int ToInt32Unchecked();
</pre>

<p>Converts this object&#39;s value to a 32-bit signed integer. If the value can&#39;t fit in a 32-bit integer, returns the lower 32 bits of this object&#39;s two&#39; s-complement form (see<a href="PeterO.Numbers.EDecimal.html">
         &#x22;Forms of numbers&#x22;
      </a>) (in which case the return value might have a different sign than this bject&#39;s value).</p>

<p><b>Return Value:</b></p>

<p>A 32-bit signed integer.</p>

<p><a id="ToInt64Checked"></a></p>

<h3>ToInt64Checked</h3>

<pre>public long ToInt64Checked();
</pre>

<p>Converts this object&#39;s value to a 64-bit signed integer, throwing an exception if it can&#39;t fit.</p>

<p><b>Return Value:</b></p>

<p>A 64-bit signed integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li> T:System.OverflowException:
This object&#39; s value is too big to fit a 64-bit signed integer.</li>
</ul>

<p><a id="ToInt64Unchecked"></a></p>

<h3>ToInt64Unchecked</h3>

<pre>public long ToInt64Unchecked();
</pre>

<p>Converts this object&#39;s value to a 64-bit signed integer. If the value can&#39;t fit in a 64-bit integer, returns the lower 64 bits of this object&#39;s two&#39; s-complement form (see<a href="PeterO.Numbers.EDecimal.html">
         &#x22;Forms of numbers&#x22;
      </a>) (in which case the return value might have a different sign than this bject&#39;s value).</p>

<p><b>Return Value:</b></p>

<p>A 64-bit signed integer.</p>

<p><a id="ToRadixString_int"></a></p>

<h3>ToRadixString</h3>

<pre>public string ToRadixString(
    int radix);
</pre>

<p>Generates a string representing the value of this object, in the given radix.</p>

<p><b>Parameters:</b></p>

<ul>
<li><i>radix</i>: A radix from 2 through 36. For example, to generate a hexadecimal (base-16) string, specify 16. To generate a decimal (base-10) string, specify 10.</li>
</ul>

<p><b>Return Value:</b></p>

<p>A string representing the value of this object. If this value is 0, returns &quot;0&quot;. If negative, the string will begin with a minus sign (&quot;-&quot;, U+002D). Depending on the radix, the string will use the basic digits 0 to 9 (U+0030 to U+0039) and then the basic letters A to Z (U+0041 to U+005A). For example, 0-9 in radix 10, and 0-9, then A-F in radix 16.</p>

<p><a id="ToSByteChecked"></a></p>

<h3>ToSByteChecked</h3>

<pre>public sbyte ToSByteChecked();
</pre>

<p>Converts this number&#39;s value to an 8-bit signed integer if it can fit in an 8-bit signed integer.</p>

<p><b>Return Value:</b></p>

<p>This number&#39;s value as an 8-bit signed integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.OverflowException:
This value is less than -128 or greater than 127.</li>
</ul>

<p><a id="ToSByteUnchecked"></a></p>

<h3>ToSByteUnchecked</h3>

<pre>public sbyte ToSByteUnchecked();
</pre>

<p>Converts this number to an 8-bit signed integer, returning the least-significant bits of this number&#39;s two&#39;s-complement form.</p>

<p><b>Return Value:</b></p>

<p>This number, converted to an 8-bit signed integer.</p>

<p><a id="ToString"></a></p>

<h3>ToString</h3>

<pre>public override string ToString();
</pre>

<p>Converts this object to a text string in base 10.</p>

<p><b>Return Value:</b></p>

<p>A string representation of this object. If negative, the string will begin with a minus sign (&quot;-&quot;, U+002D). The string will use the basic digits 0 to 9 (U+0030 to U+0039).</p>

<p><a id="ToUInt16Checked"></a></p>

<h3>ToUInt16Checked</h3>

<pre>public ushort ToUInt16Checked();
</pre>

<p>Converts this number&#39;s value to a 16-bit unsigned integer if it can fit in a 16-bit unsigned integer.</p>

<p><b>Return Value:</b></p>

<p>This number&#39;s value as a 16-bit unsigned integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.OverflowException:
This value is less than 0 or greater than 65535.</li>
</ul>

<p><a id="ToUInt16Unchecked"></a></p>

<h3>ToUInt16Unchecked</h3>

<pre>public ushort ToUInt16Unchecked();
</pre>

<p>Converts this number to a 16-bit unsigned integer, returning the least-significant bits of this number&#39;s two&#39;s-complement form.</p>

<p><b>Return Value:</b></p>

<p>This number, converted to a 16-bit unsigned integer.</p>

<p><a id="ToUInt32Checked"></a></p>

<h3>ToUInt32Checked</h3>

<pre>public uint ToUInt32Checked();
</pre>

<p>Converts this number&#39;s value to a 32-bit signed integer if it can fit in a 32-bit signed integer.</p>

<p><b>Return Value:</b></p>

<p>This number&#39;s value as a 32-bit signed integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.OverflowException:
This value is less than 0 or greater than 4294967295.</li>
</ul>

<p><a id="ToUInt32Unchecked"></a></p>

<h3>ToUInt32Unchecked</h3>

<pre>public uint ToUInt32Unchecked();
</pre>

<p>Converts this number to a 32-bit signed integer, returning the least-significant bits of this number&#39;s two&#39;s-complement form.</p>

<p><b>Return Value:</b></p>

<p>This number, converted to a 32-bit signed integer.</p>

<p><a id="ToUInt64Checked"></a></p>

<h3>ToUInt64Checked</h3>

<pre>public ulong ToUInt64Checked();
</pre>

<p>Converts this number&#39;s value to a 64-bit signed integer if it can fit in a 64-bit signed integer.</p>

<p><b>Return Value:</b></p>

<p>This number&#39;s value as a 64-bit signed integer.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.OverflowException:
This value is outside the range of a 64-bit signed integer.</li>
</ul>

<p><a id="ToUInt64Unchecked"></a></p>

<h3>ToUInt64Unchecked</h3>

<pre>public ulong ToUInt64Unchecked();
</pre>

<p>Converts this number to a 64-bit signed integer, returning the least-significant bits of this number&#39;s two&#39; s-complement form.</p>

<p><b>Return Value:</b></p>

<p>This number, converted to a 64-bit signed integer.</p>

<p><a id="Xor_PeterO_Numbers_EInteger_PeterO_Numbers_EInteger"></a></p>

<h3>Xor</h3>

<pre>public static PeterO.Numbers.EInteger Xor(
    PeterO.Numbers.EInteger a,
    PeterO.Numbers.EInteger b);
</pre>

<p>Finds the exclusive &quot;or&quot; of two arbitrary-precision integer objects.Each arbitrary-precision integer is treated as a two&#39;s-complement form (see<a href="PeterO.Numbers.EDecimal.html">
           &#x22;Forms of numbers&#x22;
        </a>) for the purposes of this operator.</p>

<p><b>Parameters:</b></p>

<ul>
<li><p><i>a</i>: The first arbitrary-precision integer.</p></li>
<li><p><i>b</i>: The second arbitrary-precision integer.</p></li>
</ul>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision integer in which each bit is set if it&#39;s set in one input integer but not the other.</p>

<p><b>Exceptions:</b></p>

<ul>
<li>System.ArgumentNullException:
The parameter <i>a</i>
or <i>b</i>
is null.</li>
</ul>

<p><a href="/Numbers/">Back to Numbers start page.</a></p>
</div><nav id="navigation"><ul>
<li><a href="/">Back to start site.</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io">This site's repository (source code)</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io/issues">Post an issue or comment</a></ul>
<p>
If you like this software, you should consider donating to me, Peter O., at the link below:</p>
<p class="printonly"><b>peteroupc.github.io</b></p>
<div class="noprint">
<a href="https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=56E5T4FH7KD2S">
<img src="https://www.paypalobjects.com/en_US/i/btn/btn_donateCC_LG.gif"
name="submit" border="2" alt="PayPal - The safer, easier way to pay online!"></a>
<p>
<a href="//twitter.com/share" class="twitter-share-button" data-count="horizontal" data-lang="en">Share via Twitter</a>
<script type="text/javascript" charset="UTF-8" src="https://platform.twitter.com/widgets.js"></script>
<span><g:plusone size="medium"></g:plusone></span><br/>
<span><a href="//www.facebook.com/sharer/sharer.php" id="sharer">Share via Facebook</a></span>
</p>
</div>
</nav><script>
if(document.location.href.indexOf("file://")!=0){
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = '//apis.google.com/js/plusone.js';
    var s = xExtra(document).getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
}
document.getElementById("sharer").href="//www.facebook.com/sharer/sharer.php?u="+
    encodeURIComponent(document.location.href)
</script>
</body></html>
