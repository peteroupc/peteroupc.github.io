<!DOCTYPE html><html xmlns:dc="http://purl.org/dc/terms/"><head><meta http-equiv=Content-Type content="text/html; charset=utf-8"><title>PeterO.Numbers.EInteger</title><meta name="viewport" content="width=device-width"><link rel=stylesheet type="text/css" href="/style.css">
            <script type="text/x-mathjax-config"> MathJax.Hub.Config({"HTML-CSS": { availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, preferredFont: "TeX" },
                    tex2jax: { displayMath: [ ["$$","$$"], ["\\[", "\\]"] ], inlineMath: [ ["$", "$"], ["\\\\(","\\\\)"] ], processEscapes: true } });
            </script><script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"></script></head><body>  <div class="header">
<nav><p><a href="#navigation">Menu</a> - <a href="#top">Top</a> - <a href="/">Home</a></nav></div>
<div class="mainarea" id="top">
<h1>PeterO.Numbers.EInteger</h1>
<p>## PeterO.Numbers.EInteger</p>

<pre>public sealed class EInteger :
    System.IComparable,
    System.IEquatable
</pre>

<p>Represents an arbitrary-precision integer. (The “E” stands for “extended”, and has this prefix to group it with the other classes common to this library, particularly EDecimal, EFloat, and ERational.) Instances of this class are immutable, so they are inherently safe for use by multiple threads. Multiple instances of this object with the same value are interchangeable, but they should be compared using the “Equals” method rather than the “==” operator.</p>

<p><b>Security note</b></p>

<p>It is not recommended to implement security-sensitive algorithms using the methods in this class, for several reasons:</p>

<ul>
  <li>
    <p><code>EInteger</code>  objects are immutable, so they can’t be modified, and the memory they occupy is not guaranteed to be cleared in a timely fashion due to garbage collection. This is relevant for applications that use many-bit-long numbers as secret parameters.</p>
  </li>
  <li>
    <p>The methods in this class (especially those that involve arithmetic) are not guaranteed to be “constant-time” (nondata-dependent) for all relevant inputs. Certain attacks that involve encrypted communications have exploited the timing and other aspects of such communications to derive keying material or cleartext indirectly.</p>
  </li>
</ul>

<p>Applications should instead use dedicated security libraries to handle big numbers in security-sensitive algorithms.</p>

<h3 id="member-summary">Member Summary</h3>
<ul>
  <li><code>[Abs()](#Abs)</code> - Returns the absolute value of this object’s value.</li>
  <li><code>[Add(int)](#Add_int)</code> -</li>
  <li><code>[Add(long)](#Add_long)</code> -</li>
  <li><code>[Add(PeterO.Numbers.EInteger)](#Add_PeterO_Numbers_EInteger)</code> -</li>
  <li><code>[And(PeterO.Numbers.EInteger)](#And_PeterO_Numbers_EInteger)</code> -</li>
  <li><code>[And(PeterO.Numbers.EInteger, PeterO.Numbers.EInteger)](#And_PeterO_Numbers_EInteger_PeterO_Numbers_EInteger)</code> -</li>
  <li><code>[AndNot(PeterO.Numbers.EInteger)](#AndNot_PeterO_Numbers_EInteger)</code> -</li>
  <li><code>[AsInt32Checked()](#AsInt32Checked)</code> - <b>Deprecated:</b> Renamed to ToInt32Checked.</li>
  <li><code>[AsInt32Unchecked()](#AsInt32Unchecked)</code> - <b>Deprecated:</b> Renamed to ToInt32Unchecked.</li>
  <li><code>[AsInt64Checked()](#AsInt64Checked)</code> - <b>Deprecated:</b> Renamed to ToInt64Checked.</li>
  <li><code>[AsInt64Unchecked()](#AsInt64Unchecked)</code> - <b>Deprecated:</b> Renamed to ToInt64Unchecked.</li>
  <li><code>[CanFitInInt32()](#CanFitInInt32)</code> - Returns whether this object’s value can fit in a 32-bit signed integer.</li>
  <li><code>[CanFitInInt64()](#CanFitInInt64)</code> - Returns whether this object’s value can fit in a 64-bit signed integer.</li>
  <li><code>[CompareTo(int)](#CompareTo_int)</code> -</li>
  <li><code>[CompareTo(long)](#CompareTo_long)</code> -</li>
  <li><code>[CompareTo(PeterO.Numbers.EInteger)](#CompareTo_PeterO_Numbers_EInteger)</code> -</li>
  <li><code>[Decrement()](#Decrement)</code> - Returns one subtracted from this arbitrary-precision integer.</li>
  <li><code>[Divide(int)](#Divide_int)</code> -</li>
  <li><code>[Divide(long)](#Divide_long)</code> -</li>
  <li><code>[Divide(PeterO.Numbers.EInteger)](#Divide_PeterO_Numbers_EInteger)</code> -</li>
  <li><code>[DivRem(int)](#DivRem_int)</code> -</li>
  <li><code>[DivRem(long)](#DivRem_long)</code> -</li>
  <li><code>[DivRem(PeterO.Numbers.EInteger)](#DivRem_PeterO_Numbers_EInteger)</code> -</li>
  <li><code>[DivRem(PeterO.Numbers.EInteger, PeterO.Numbers.EInteger, PeterO.Numbers.EInteger&amp;)](#DivRem_PeterO_Numbers_EInteger_PeterO_Numbers_EInteger_PeterO_Numbers_EInteger)</code> - <b>Deprecated:</b> Use the DivRem instance method instead.</li>
  <li><code>[Equals(object)](#Equals_object)</code> -</li>
  <li><code>[Equals(PeterO.Numbers.EInteger)](#Equals_PeterO_Numbers_EInteger)</code> -</li>
  <li><code>[Eqv(PeterO.Numbers.EInteger)](#Eqv_PeterO_Numbers_EInteger)</code> -</li>
  <li><code>[explicit operator byte(PeterO.Numbers.EInteger)](#explicit_operator_byte_PeterO_Numbers_EInteger)</code> -</li>
  <li><code>[explicit operator int(PeterO.Numbers.EInteger)](#explicit_operator_int_PeterO_Numbers_EInteger)</code> -</li>
  <li><code>[explicit operator long(PeterO.Numbers.EInteger)](#explicit_operator_long_PeterO_Numbers_EInteger)</code> -</li>
  <li><code>[explicit operator PeterO.Numbers.EInteger(bool)](#explicit_operator_PeterO_Numbers_EInteger_bool)</code> -</li>
  <li><code>[explicit operator sbyte(PeterO.Numbers.EInteger)](#explicit_operator_sbyte_PeterO_Numbers_EInteger)</code> -</li>
  <li><code>[explicit operator short(PeterO.Numbers.EInteger)](#explicit_operator_short_PeterO_Numbers_EInteger)</code> -</li>
  <li><code>[explicit operator uint(PeterO.Numbers.EInteger)](#explicit_operator_uint_PeterO_Numbers_EInteger)</code> -</li>
  <li><code>[explicit operator ulong(PeterO.Numbers.EInteger)](#explicit_operator_ulong_PeterO_Numbers_EInteger)</code> -</li>
  <li><code>[explicit operator ushort(PeterO.Numbers.EInteger)](#explicit_operator_ushort_PeterO_Numbers_EInteger)</code> -</li>
  <li><code>[FromBoolean(bool)](#FromBoolean_bool)</code> -</li>
  <li><code>[FromByte(byte)](#FromByte_byte)</code> -</li>
  <li><code>[FromBytes(byte[], bool)](#FromBytes_byte_bool)</code> -</li>
  <li><code>[FromBytes(byte[], int, int, bool)](#FromBytes_byte_int_int_bool)</code> -</li>
  <li><code>[FromInt16(short)](#FromInt16_short)</code> -</li>
  <li><code>[FromInt32(int)](#FromInt32_int)</code> -</li>
  <li><code>[FromInt64(long)](#FromInt64_long)</code> -</li>
  <li><code>[FromInt64AsUnsigned(long)](#FromInt64AsUnsigned_long)</code> -</li>
  <li><code>[FromRadixString(byte[], int)](#FromRadixString_byte_int)</code> -</li>
  <li><code>[FromRadixString(char[], int)](#FromRadixString_char_int)</code> -</li>
  <li><code>[FromRadixString(string, int)](#FromRadixString_string_int)</code> -</li>
  <li><code>[FromRadixSubstring(byte[], int, int, int)](#FromRadixSubstring_byte_int_int_int)</code> -</li>
  <li><code>[FromRadixSubstring(char[], int, int, int)](#FromRadixSubstring_char_int_int_int)</code> -</li>
  <li><code>[FromRadixSubstring(string, int, int, int)](#FromRadixSubstring_string_int_int_int)</code> -</li>
  <li><code>[FromSByte(sbyte)](#FromSByte_sbyte)</code> -</li>
  <li><code>[FromString(byte[])](#FromString_byte)</code> -</li>
  <li><code>[FromString(char[])](#FromString_char)</code> -</li>
  <li><code>[FromString(string)](#FromString_string)</code> -</li>
  <li><code>[FromSubstring(byte[], int, int)](#FromSubstring_byte_int_int)</code> -</li>
  <li><code>[FromSubstring(char[], int, int)](#FromSubstring_char_int_int)</code> -</li>
  <li><code>[FromSubstring(string, int, int)](#FromSubstring_string_int_int)</code> -</li>
  <li><code>[FromUInt16(ushort)](#FromUInt16_ushort)</code> -</li>
  <li><code>[FromUInt32(uint)](#FromUInt32_uint)</code> -</li>
  <li><code>[FromUInt64(ulong)](#FromUInt64_ulong)</code> -</li>
  <li><code>[Gcd(PeterO.Numbers.EInteger)](#Gcd_PeterO_Numbers_EInteger)</code> -</li>
  <li><code>[GetBits(int, int)](#GetBits_int_int)</code> -</li>
  <li><code>[GetDigitCount()](#GetDigitCount)</code> - <b>Deprecated:</b> This method may overflow. Use GetDigitCountAsEInteger instead.</li>
  <li><code>[GetDigitCountAsEInteger()](#GetDigitCountAsEInteger)</code> - Returns the number of decimal digits used by this integer, in the form of an arbitrary-precision integer.</li>
  <li><code>[GetDigitCountAsInt64()](#GetDigitCountAsInt64)</code> - Returns the number of decimal digits used by this integer, in the form of a 64-bit signed integer.</li>
  <li><code>[GetHashCode()](#GetHashCode)</code> - Returns the hash code for this instance.</li>
  <li><code>[GetLowBit()](#GetLowBit)</code> - <b>Deprecated:</b> This method may overflow. Use GetLowBitAsEInteger instead.</li>
  <li><code>[GetLowBitAsEInteger()](#GetLowBitAsEInteger)</code> - Gets the bit position of the lowest set bit in this number’s absolute value, in the form of an arbitrary-precision integer.</li>
  <li><code>[GetLowBitAsInt64()](#GetLowBitAsInt64)</code> - Gets the bit position of the lowest set bit in this number’s absolute value, in the form of a 64-bit signed integer.</li>
  <li><code>[GetSignedBit(int)](#GetSignedBit_int)</code> -</li>
  <li><code>[GetSignedBit(PeterO.Numbers.EInteger)](#GetSignedBit_PeterO_Numbers_EInteger)</code> -</li>
  <li><code>[GetSignedBitLength()](#GetSignedBitLength)</code> - <b>Deprecated:</b> This method may overflow. Use GetSignedBitLengthAsEInteger instead.</li>
  <li><code>[GetSignedBitLengthAsEInteger()](#GetSignedBitLengthAsEInteger)</code> - Finds the minimum number of bits needed to represent this object’s value, except for its sign, and returns that number of bits as an arbitrary-precision integer.</li>
  <li><code>[GetSignedBitLengthAsInt64()](#GetSignedBitLengthAsInt64)</code> - Finds the minimum number of bits needed to represent this object’s value, except for its sign, and returns that number of bits as a 64-bit signed integer.</li>
  <li><code>[GetUnsignedBit(int)](#GetUnsignedBit_int)</code> -</li>
  <li><code>[GetUnsignedBit(PeterO.Numbers.EInteger)](#GetUnsignedBit_PeterO_Numbers_EInteger)</code> -</li>
  <li><code>[GetUnsignedBitLength()](#GetUnsignedBitLength)</code> - <b>Deprecated:</b> This method may overflow. Use GetUnsignedBitLengthAsEInteger instead.</li>
  <li><code>[GetUnsignedBitLengthAsEInteger()](#GetUnsignedBitLengthAsEInteger)</code> - Finds the minimum number of bits needed to represent this number’s absolute value, and returns that number of bits as an arbitrary-precision integer.</li>
  <li><code>[GetUnsignedBitLengthAsInt64()](#GetUnsignedBitLengthAsInt64)</code> - Finds the minimum number of bits needed to represent this number’s absolute value, and returns that number of bits as a 64-bit signed integer.</li>
  <li><code>[Imp(PeterO.Numbers.EInteger)](#Imp_PeterO_Numbers_EInteger)</code> - <b>Deprecated:</b> Does the incorrect implication operation. Use Imply instead.</li>
  <li><code>[implicit operator PeterO.Numbers.EInteger(byte)](#implicit_operator_PeterO_Numbers_EInteger_byte)</code> -</li>
  <li><code>[implicit operator PeterO.Numbers.EInteger(int)](#implicit_operator_PeterO_Numbers_EInteger_int)</code> -</li>
  <li><code>[implicit operator PeterO.Numbers.EInteger(long)](#implicit_operator_PeterO_Numbers_EInteger_long)</code> -</li>
  <li><code>[implicit operator PeterO.Numbers.EInteger(sbyte)](#implicit_operator_PeterO_Numbers_EInteger_sbyte)</code> -</li>
  <li><code>[implicit operator PeterO.Numbers.EInteger(short)](#implicit_operator_PeterO_Numbers_EInteger_short)</code> -</li>
  <li><code>[implicit operator PeterO.Numbers.EInteger(uint)](#implicit_operator_PeterO_Numbers_EInteger_uint)</code> -</li>
  <li><code>[implicit operator PeterO.Numbers.EInteger(ulong)](#implicit_operator_PeterO_Numbers_EInteger_ulong)</code> -</li>
  <li><code>[implicit operator PeterO.Numbers.EInteger(ushort)](#implicit_operator_PeterO_Numbers_EInteger_ushort)</code> -</li>
  <li><code>[Increment()](#Increment)</code> - Returns one added to this arbitrary-precision integer.</li>
  <li><code>[IsEven](#IsEven)</code> - Gets a value indicating whether this value is even.</li>
  <li><code>[IsPowerOfTwo](#IsPowerOfTwo)</code> - Gets a value indicating whether this object’s value is a power of two, and greater than 0.</li>
  <li><code>[IsZero](#IsZero)</code> - Gets a value indicating whether this value is 0.</li>
  <li><code>[LowBits(int)](#LowBits_int)</code> -</li>
  <li><code>[LowBits(long)](#LowBits_long)</code> -</li>
  <li><code>[LowBits(PeterO.Numbers.EInteger)](#LowBits_PeterO_Numbers_EInteger)</code> -</li>
  <li><code>[Max(PeterO.Numbers.EInteger, PeterO.Numbers.EInteger)](#Max_PeterO_Numbers_EInteger_PeterO_Numbers_EInteger)</code> -</li>
  <li><code>[MaxMagnitude(PeterO.Numbers.EInteger, PeterO.Numbers.EInteger)](#MaxMagnitude_PeterO_Numbers_EInteger_PeterO_Numbers_EInteger)</code> -</li>
  <li><code>[Min(PeterO.Numbers.EInteger, PeterO.Numbers.EInteger)](#Min_PeterO_Numbers_EInteger_PeterO_Numbers_EInteger)</code> -</li>
  <li><code>[MinMagnitude(PeterO.Numbers.EInteger, PeterO.Numbers.EInteger)](#MinMagnitude_PeterO_Numbers_EInteger_PeterO_Numbers_EInteger)</code> -</li>
  <li><code>[Mod(int)](#Mod_int)</code> -</li>
  <li><code>[Mod(PeterO.Numbers.EInteger)](#Mod_PeterO_Numbers_EInteger)</code> -</li>
  <li><code>[ModPow(PeterO.Numbers.EInteger, PeterO.Numbers.EInteger)](#ModPow_PeterO_Numbers_EInteger_PeterO_Numbers_EInteger)</code> -</li>
  <li><code>[ModPow(PeterO.Numbers.EInteger, PeterO.Numbers.EInteger, PeterO.Numbers.EInteger)](#ModPow_PeterO_Numbers_EInteger_PeterO_Numbers_EInteger_PeterO_Numbers_EInteger)</code> -</li>
  <li><code>[Multiply(int)](#Multiply_int)</code> -</li>
  <li><code>[Multiply(long)](#Multiply_long)</code> -</li>
  <li><code>[Multiply(PeterO.Numbers.EInteger)](#Multiply_PeterO_Numbers_EInteger)</code> -</li>
  <li><code>[Negate()](#Negate)</code> - Gets the value of this object with the sign reversed.</li>
  <li><code>[Not()](#Not)</code> - Returns an arbitrary-precision integer with every bit flipped from this one (also called an inversion or NOT operation).</li>
  <li><code>[Not(PeterO.Numbers.EInteger)](#Not_PeterO_Numbers_EInteger)</code> -</li>
  <li><code>[One](#One)</code> - Gets the number 1 as an arbitrary-precision integer.</li>
  <li><code>[PeterO.Numbers.EInteger operator +(PeterO.Numbers.EInteger, PeterO.Numbers.EInteger)](#op_Addition)</code> -</li>
  <li><code>[PeterO.Numbers.EInteger operator &amp;(PeterO.Numbers.EInteger, PeterO.Numbers.EInteger)](#op_BitwiseAnd)</code> -</li>
  <li><code>[PeterO.Numbers.EInteger operator |(PeterO.Numbers.EInteger, PeterO.Numbers.EInteger)](#op_BitwiseOr)</code> -</li>
  <li><code>[PeterO.Numbers.EInteger operator --(PeterO.Numbers.EInteger)](#op_Decrement)</code> -</li>
  <li><code>[PeterO.Numbers.EInteger operator /(PeterO.Numbers.EInteger, PeterO.Numbers.EInteger)](#op_Division)</code> -</li>
  <li><code>[PeterO.Numbers.EInteger operator ^(PeterO.Numbers.EInteger, PeterO.Numbers.EInteger)](#op_ExclusiveOr)</code> -</li>
  <li><code>[bool operator &gt;(PeterO.Numbers.EInteger, PeterO.Numbers.EInteger)](#op_GreaterThan)</code> -</li>
  <li><code>[bool operator &gt;=(PeterO.Numbers.EInteger, PeterO.Numbers.EInteger)](#op_GreaterThanOrEqual)</code> -</li>
  <li><code>[PeterO.Numbers.EInteger operator ++(PeterO.Numbers.EInteger)](#op_Increment)</code> -</li>
  <li><code>[PeterO.Numbers.EInteger operator &lt;&lt;(PeterO.Numbers.EInteger, int)](#op_LeftShift)</code> -</li>
  <li><code>[bool operator &lt;(PeterO.Numbers.EInteger, PeterO.Numbers.EInteger)](#op_LessThan)</code> -</li>
  <li><code>[bool operator &lt;=(PeterO.Numbers.EInteger, PeterO.Numbers.EInteger)](#op_LessThanOrEqual)</code> -</li>
  <li><code>[PeterO.Numbers.EInteger operator %(PeterO.Numbers.EInteger, PeterO.Numbers.EInteger)](#op_Modulus)</code> -</li>
  <li><code>[PeterO.Numbers.EInteger operator &#x2a;(PeterO.Numbers.EInteger, PeterO.Numbers.EInteger)](#op_Multiply)</code> -</li>
  <li><code>[PeterO.Numbers.EInteger operator ~(PeterO.Numbers.EInteger)](#op_OnesComplement)</code> -</li>
  <li><code>[PeterO.Numbers.EInteger operator &gt;&gt;(PeterO.Numbers.EInteger, int)](#op_RightShift)</code> -</li>
  <li><code>[PeterO.Numbers.EInteger operator -(PeterO.Numbers.EInteger, PeterO.Numbers.EInteger)](#op_Subtraction)</code> -</li>
  <li><code>[PeterO.Numbers.EInteger operator -(PeterO.Numbers.EInteger)](#op_UnaryNegation)</code> -</li>
  <li><code>[Or(PeterO.Numbers.EInteger)](#Or_PeterO_Numbers_EInteger)</code> -</li>
  <li><code>[Or(PeterO.Numbers.EInteger, PeterO.Numbers.EInteger)](#Or_PeterO_Numbers_EInteger_PeterO_Numbers_EInteger)</code> -</li>
  <li><code>[OrNot(PeterO.Numbers.EInteger)](#OrNot_PeterO_Numbers_EInteger)</code> -</li>
  <li><code>[Pow(int)](#Pow_int)</code> -</li>
  <li><code>[Pow(long)](#Pow_long)</code> -</li>
  <li><code>[Pow(PeterO.Numbers.EInteger)](#Pow_PeterO_Numbers_EInteger)</code> -</li>
  <li><code>[PowBigIntVar(PeterO.Numbers.EInteger)](#PowBigIntVar_PeterO_Numbers_EInteger)</code> - <b>Deprecated:</b> Use Pow instead.</li>
  <li><code>[Remainder(int)](#Remainder_int)</code> -</li>
  <li><code>[Remainder(long)](#Remainder_long)</code> -</li>
  <li><code>[Remainder(PeterO.Numbers.EInteger)](#Remainder_PeterO_Numbers_EInteger)</code> -</li>
  <li><code>[Root(int)](#Root_int)</code> -</li>
  <li><code>[Root(PeterO.Numbers.EInteger)](#Root_PeterO_Numbers_EInteger)</code> -</li>
  <li><code>[RootRem(int)](#RootRem_int)</code> -</li>
  <li><code>[RootRem(PeterO.Numbers.EInteger)](#RootRem_PeterO_Numbers_EInteger)</code> -</li>
  <li><code>[ShiftLeft(int)](#ShiftLeft_int)</code> -</li>
  <li><code>[ShiftLeft(PeterO.Numbers.EInteger)](#ShiftLeft_PeterO_Numbers_EInteger)</code> -</li>
  <li><code>[ShiftRight(int)](#ShiftRight_int)</code> -</li>
  <li><code>[ShiftRight(PeterO.Numbers.EInteger)](#ShiftRight_PeterO_Numbers_EInteger)</code> -</li>
  <li><code>[Sign](#Sign)</code> - Gets the sign of this object’s value.</li>
  <li><code>[Sqrt()](#Sqrt)</code> - Finds the square root of this instance’s value, rounded down.</li>
  <li><code>[SqrtRem()](#SqrtRem)</code> - Calculates the square root and the remainder.</li>
  <li><code>[Subtract(int)](#Subtract_int)</code> -</li>
  <li><code>[Subtract(long)](#Subtract_long)</code> -</li>
  <li><code>[Subtract(PeterO.Numbers.EInteger)](#Subtract_PeterO_Numbers_EInteger)</code> -</li>
  <li><code>[Ten](#Ten)</code> - Gets the number 10 as an arbitrary-precision integer.</li>
  <li><code>[ToByteChecked()](#ToByteChecked)</code> - Converts this number’s value to a byte (from 0 to 255) if it can fit in a byte (from 0 to 255).</li>
  <li><code>[ToBytes(bool)](#ToBytes_bool)</code> -</li>
  <li><code>[ToByteUnchecked()](#ToByteUnchecked)</code> - Converts this number to a byte (from 0 to 255), returning the least-significant bits of this number’s two’s-complement form.</li>
  <li><code>[ToInt16Checked()](#ToInt16Checked)</code> - Converts this number’s value to a 16-bit signed integer if it can fit in a 16-bit signed integer.</li>
  <li><code>[ToInt16Unchecked()](#ToInt16Unchecked)</code> - Converts this number to a 16-bit signed integer, returning the least-significant bits of this number’s two’s-complement form.</li>
  <li><code>[ToInt32Checked()](#ToInt32Checked)</code> - Converts this object’s value to a 32-bit signed integer, throwing an exception if it can’t fit.</li>
  <li><code>[ToInt32Unchecked()](#ToInt32Unchecked)</code> - Converts this object’s value to a 32-bit signed integer.</li>
  <li><code>[ToInt64Checked()](#ToInt64Checked)</code> - Converts this object’s value to a 64-bit signed integer, throwing an exception if it can’t fit.</li>
  <li><code>[ToInt64Unchecked()](#ToInt64Unchecked)</code> - Converts this object’s value to a 64-bit signed integer.</li>
  <li><code>[ToRadixString(int)](#ToRadixString_int)</code> -</li>
  <li><code>[ToSByteChecked()](#ToSByteChecked)</code> - Converts this number’s value to an 8-bit signed integer if it can fit in an 8-bit signed integer.</li>
  <li><code>[ToSByteUnchecked()](#ToSByteUnchecked)</code> - Converts this number to an 8-bit signed integer, returning the least-significant bits of this number’s two’s-complement form.</li>
  <li><code>[ToString()](#ToString)</code> - Converts this object to a text string in base 10.</li>
  <li><code>[ToUInt16Checked()](#ToUInt16Checked)</code> - Converts this number’s value to a 16-bit unsigned integer if it can fit in a 16-bit unsigned integer.</li>
  <li><code>[ToUInt16Unchecked()](#ToUInt16Unchecked)</code> - Converts this number to a 16-bit unsigned integer, returning the least-significant bits of this number’s two’s-complement form.</li>
  <li><code>[ToUInt32Checked()](#ToUInt32Checked)</code> - Converts this number’s value to a 32-bit signed integer if it can fit in a 32-bit signed integer.</li>
  <li><code>[ToUInt32Unchecked()](#ToUInt32Unchecked)</code> - Converts this number to a 32-bit signed integer, returning the least-significant bits of this number’s two’s-complement form.</li>
  <li><code>[ToUInt64Checked()](#ToUInt64Checked)</code> - Converts this number’s value to a 64-bit signed integer if it can fit in a 64-bit signed integer.</li>
  <li><code>[ToUInt64Unchecked()](#ToUInt64Unchecked)</code> - Converts this number to a 64-bit signed integer, returning the least-significant bits of this number’s two’s-complement form.</li>
  <li><code>[Xor(PeterO.Numbers.EInteger)](#Xor_PeterO_Numbers_EInteger)</code> -</li>
  <li><code>[Xor(PeterO.Numbers.EInteger, PeterO.Numbers.EInteger)](#Xor_PeterO_Numbers_EInteger_PeterO_Numbers_EInteger)</code> -</li>
  <li><code>[XorNot(PeterO.Numbers.EInteger)](#XorNot_PeterO_Numbers_EInteger)</code> -</li>
  <li><code>[Zero](#Zero)</code> - Gets the number zero as an arbitrary-precision integer.</li>
</ul>

<p><a id="IsEven"></a>
### IsEven</p>

<pre>public bool IsEven { get; }
</pre>

<p>Gets a value indicating whether this value is even.</p>

<p><b>Returns:</b></p>

<p><code>true</code>  if this value is even; otherwise,  <code>false</code> .</p>

<p><a id="IsPowerOfTwo"></a>
### IsPowerOfTwo</p>

<pre>public bool IsPowerOfTwo { get; }
</pre>

<p>Gets a value indicating whether this object’s value is a power of two, and greater than 0.</p>

<p><b>Returns:</b></p>

<p><code>true</code>  if this object’s value is a power of two, and greater than 0; otherwise,  <code>false</code> .</p>

<p><a id="IsZero"></a>
### IsZero</p>

<pre>public bool IsZero { get; }
</pre>

<p>Gets a value indicating whether this value is 0.</p>

<p><b>Returns:</b></p>

<p><code>true</code>  if this value is 0; otherwise,  <code>false</code> .</p>

<p><a id="One"></a>
### One</p>

<pre>public static PeterO.Numbers.EInteger One { get; }
</pre>

<p>Gets the number 1 as an arbitrary-precision integer.</p>

<p><b>Returns:</b></p>

<p>The number 1 as an arbitrary-precision integer.</p>

<p><a id="Sign"></a>
### Sign</p>

<pre>public int Sign { get; }
</pre>

<p>Gets the sign of this object’s value.</p>

<p><b>Returns:</b></p>

<p>The sign of this object’s value.</p>

<p><a id="Ten"></a>
### Ten</p>

<pre>public static PeterO.Numbers.EInteger Ten { get; }
</pre>

<p>Gets the number 10 as an arbitrary-precision integer.</p>

<p><b>Returns:</b></p>

<p>The number 10 as an arbitrary-precision integer.</p>

<p><a id="Zero"></a>
### Zero</p>

<pre>public static PeterO.Numbers.EInteger Zero { get; }
</pre>

<p>Gets the number zero as an arbitrary-precision integer.</p>

<p><b>Returns:</b></p>

<p>The number zero as an arbitrary-precision integer.</p>

<p><a id="Abs"></a>
### Abs</p>

<pre>public PeterO.Numbers.EInteger Abs();
</pre>

<p>Returns the absolute value of this object’s value.</p>

<p><b>Return Value:</b></p>

<p>This object’s value with the sign removed.</p>

<p><a id="AsInt32Checked"></a>
### AsInt32Checked</p>

<pre>public int AsInt32Checked();
</pre>

<p><b>Deprecated.</b> Renamed to ToInt32Checked.</p>

<p>Converts this object’s value to a 32-bit signed integer, throwing an exception if it can’t fit.</p>

<p><b>Return Value:</b></p>

<p>A 32-bit signed integer.</p>

<p><b>Exceptions:</b></p>

<ul>
  <li>T:System.OverflowException:
This object’s value is too big to fit a 32-bit signed integer.</li>
</ul>

<p><a id="AsInt32Unchecked"></a>
### AsInt32Unchecked</p>

<pre>public int AsInt32Unchecked();
</pre>

<p><b>Deprecated.</b> Renamed to ToInt32Unchecked.</p>

<p>Converts this object’s value to a 32-bit signed integer. If the value can’t fit in a 32-bit integer, returns the lower 32 bits of this object’s two’s-complement form (see <a href="PeterO.Numbers.EDecimal.html">"Forms of numbers"</a>“Forms of numbers” ) (in which case the return value might have a different sign than this object’s value).</p>

<p><b>Return Value:</b></p>

<p>A 32-bit signed integer.</p>

<p><a id="AsInt64Checked"></a>
### AsInt64Checked</p>

<pre>public long AsInt64Checked();
</pre>

<p><b>Deprecated.</b> Renamed to ToInt64Checked.</p>

<p>Converts this object’s value to a 64-bit signed integer, throwing an exception if it can’t fit.</p>

<p><b>Return Value:</b></p>

<p>A 64-bit signed integer.</p>

<p><b>Exceptions:</b></p>

<ul>
  <li>T:System.OverflowException:
This object’s value is too big to fit a 64-bit signed integer.</li>
</ul>

<p><a id="AsInt64Unchecked"></a>
### AsInt64Unchecked</p>

<pre>public long AsInt64Unchecked();
</pre>

<p><b>Deprecated.</b> Renamed to ToInt64Unchecked.</p>

<p>Converts this object’s value to a 64-bit signed integer. If the value can’t fit in a 64-bit integer, returns the lower 64 bits of this object’s two’s-complement form (see <a href="PeterO.Numbers.EDecimal.html">"Forms of numbers"</a>“Forms of numbers” ) (in which case the return value might have a different sign than this object’s value).</p>

<p><b>Return Value:</b></p>

<p>A 64-bit signed integer.</p>

<p><a id="CanFitInInt32"></a>
### CanFitInInt32</p>

<pre>public bool CanFitInInt32();
</pre>

<p>Returns whether this object’s value can fit in a 32-bit signed integer.</p>

<p><b>Return Value:</b></p>

<p><code>true</code>  if this object’s value is from -2147483648 through 2147483647; otherwise,  <code>false</code> .</p>

<p><a id="CanFitInInt64"></a>
### CanFitInInt64</p>

<pre>public bool CanFitInInt64();
</pre>

<p>Returns whether this object’s value can fit in a 64-bit signed integer.</p>

<p><b>Return Value:</b></p>

<p><code>true</code>  if this object’s value is from -9223372036854775808 through 9223372036854775807; otherwise,  <code>false</code> .</p>

<p><a id="Decrement"></a>
### Decrement</p>

<pre>public PeterO.Numbers.EInteger Decrement();
</pre>

<p>Returns one subtracted from this arbitrary-precision integer.</p>

<p><b>Return Value:</b></p>

<p>The given arbitrary-precision integer minus one.</p>

<p><a id="GetDigitCount"></a>
### GetDigitCount</p>

<pre>public int GetDigitCount();
</pre>

<p><b>Deprecated.</b> This method may overflow. Use GetDigitCountAsEInteger instead.</p>

<p>Returns the number of decimal digits used by this integer.</p>

<p><b>Return Value:</b></p>

<p>The number of digits in the decimal form of this integer. Returns 1 if this number is 0.</p>

<p><b>Exceptions:</b></p>

<ul>
  <li>System.OverflowException:
The return value would exceed the range of a 32-bit signed integer.</li>
</ul>

<p><a id="GetDigitCountAsEInteger"></a>
### GetDigitCountAsEInteger</p>

<pre>public PeterO.Numbers.EInteger GetDigitCountAsEInteger();
</pre>

<p>Returns the number of decimal digits used by this integer, in the form of an arbitrary-precision integer.</p>

<p><b>Return Value:</b></p>

<p>The number of digits in the decimal form of this integer. Returns 1 if this number is 0.</p>

<p><a id="GetDigitCountAsInt64"></a>
### GetDigitCountAsInt64</p>

<pre>public long GetDigitCountAsInt64();
</pre>

<p>Returns the number of decimal digits used by this integer, in the form of a 64-bit signed integer.</p>

<p><b>Return Value:</b></p>

<p>The number of digits in the decimal form of this integer. Returns 1 if this number is 0. Returns 2^63 - 1(  <code>Int64.MaxValue</code>  in.NET or  <code>Long.MAX_VALUE</code>  in Java) if the number of decimal digits is 2^63 - 1 or greater. (Use  <code>GetDigitCountAsEInteger</code>  instead if the application relies on the exact number of decimal digits.).</p>

<p><a id="GetHashCode"></a>
### GetHashCode</p>

<pre>public override int GetHashCode();
</pre>

<p>Returns the hash code for this instance. No application or process IDs are used in the hash code calculation.</p>

<p><b>Return Value:</b></p>

<p>A 32-bit signed integer.</p>

<p><a id="GetLowBit"></a>
### GetLowBit</p>

<pre>public int GetLowBit();
</pre>

<p><b>Deprecated.</b> This method may overflow. Use GetLowBitAsEInteger instead.</p>

<p>Gets the bit position of the lowest set bit in this number’s absolute value. (This will also be the position of the lowest set bit in the number’s two’s-complement form (see <a href="PeterO.Numbers.EDecimal.html">"Forms of numbers"</a>“Forms of numbers” ).).</p>

<p><b>Return Value:</b></p>

<p>The bit position of the lowest bit set in the number’s absolute value, starting at 0. Returns -1 if this value is 0.</p>

<p><a id="GetLowBitAsEInteger"></a>
### GetLowBitAsEInteger</p>

<pre>public PeterO.Numbers.EInteger GetLowBitAsEInteger();
</pre>

<p>Gets the bit position of the lowest set bit in this number’s absolute value, in the form of an arbitrary-precision integer. (This will also be the position of the lowest set bit in the number’s two’s-complement form (see <a href="PeterO.Numbers.EDecimal.html">"Forms of numbers"</a>“Forms of numbers” ).).</p>

<p><b>Return Value:</b></p>

<p>The bit position of the lowest bit set in the number’s absolute value, starting at 0. Returns -1 if this value is 0 or odd.</p>

<p><a id="GetLowBitAsInt64"></a>
### GetLowBitAsInt64</p>

<pre>public long GetLowBitAsInt64();
</pre>

<p>Gets the bit position of the lowest set bit in this number’s absolute value, in the form of a 64-bit signed integer. (This will also be the position of the lowest set bit in the number’s two’s-complement form (see <a href="PeterO.Numbers.EDecimal.html">"Forms of numbers"</a>“Forms of numbers” ).).</p>

<p><b>Return Value:</b></p>

<p>The bit position of the lowest bit set in the number’s absolute value, starting at 0. Returns -1 if this value is 0 or odd. Returns 2^63 - 1 (  <code>Int64.MaxValue</code>  in.NET or  <code>Long.MAX_VALUE</code>  in Java) if this number is other than zero but the lowest set bit is at 2^63 - 1 or greater. (Use  <code>GetLowBitAsEInteger</code>  instead if the application relies on the exact value of the lowest set bit position.).</p>

<p><a id="GetSignedBitLength"></a>
### GetSignedBitLength</p>

<pre>public int GetSignedBitLength();
</pre>

<p><b>Deprecated.</b> This method may overflow. Use GetSignedBitLengthAsEInteger instead.</p>

<p>Finds the minimum number of bits needed to represent this object’s value, except for its sign. If the value is negative, finds the number of bits in the value equal to this object’s absolute value minus 1. For example, all integers in the interval [-(2^63), (2^63) - 1], which is the same as the range of integers in Java’s and.NET’s  <code>long</code>  type, have a signed bit length of 63 or less, and all other integers have a signed bit length of greater than 63.</p>

<p><b>Return Value:</b></p>

<p>The number of bits in this object’s value, except for its sign. Returns 0 if this object’s value is 0 or negative 1.</p>

<p><b>Exceptions:</b></p>

<ul>
  <li>System.OverflowException:
The return value would exceed the range of a 32-bit signed integer.</li>
</ul>

<p><a id="GetSignedBitLengthAsEInteger"></a>
### GetSignedBitLengthAsEInteger</p>

<pre>public PeterO.Numbers.EInteger GetSignedBitLengthAsEInteger();
</pre>

<p>Finds the minimum number of bits needed to represent this object’s value, except for its sign, and returns that number of bits as an arbitrary-precision integer. If the value is negative, finds the number of bits in the value equal to this object’s absolute value minus 1. For example, all integers in the interval [-(2^63), (2^63) - 1], which is the same as the range of integers in Java’s and.NET’s  <code>long</code>  type, have a signed bit length of 63 or less, and all other integers have a signed bit length of greater than 63.</p>

<p><b>Return Value:</b></p>

<p>The number of bits in this object’s value, except for its sign. Returns 0 if this object’s value is 0 or negative 1.</p>

<p><a id="GetSignedBitLengthAsInt64"></a>
### GetSignedBitLengthAsInt64</p>

<pre>public long GetSignedBitLengthAsInt64();
</pre>

<p>Finds the minimum number of bits needed to represent this object’s value, except for its sign, and returns that number of bits as a 64-bit signed integer. If the value is negative, finds the number of bits in the value equal to this object’s absolute value minus 1. For example, all integers in the interval [-(2^63), (2^63) - 1], which is the same as the range of integers in Java’s and.NET’s  <code>long</code>  type, have a signed bit length of 63 or less, and all other integers have a signed bit length of greater than 63.</p>

<p><b>Return Value:</b></p>

<p>The number of bits in this object’s value, except for its sign. Returns 0 if this object’s value is 0 or negative 1. If the return value would be greater than 2^63 - 1 (  <code>Int64.MaxValue</code>  in.NET or  <code>Long.MAX_VALUE</code>  in Java), returns 2^63 - 1 instead. (Use  <code>GetSignedBitLengthAsEInteger</code>  instead of this method if the application relies on the exact number of bits.).</p>

<p><a id="GetUnsignedBitLength"></a>
### GetUnsignedBitLength</p>

<pre>public int GetUnsignedBitLength();
</pre>

<p><b>Deprecated.</b> This method may overflow. Use GetUnsignedBitLengthAsEInteger instead.</p>

<p>Finds the minimum number of bits needed to represent this number’s absolute value. For example, all integers in the interval [-((2^63) - 1), (2^63) - 1] have an unsigned bit length of 63 or less, and all other integers have an unsigned bit length of greater than 63. This interval is not the same as the range of integers in Java’s and.NET’s  <code>long</code>  type.</p>

<p><b>Return Value:</b></p>

<p>The number of bits in this object’s absolute value. Returns 0 if this object’s value is 0, and returns 1 if the value is negative 1.</p>

<p><b>Exceptions:</b></p>

<ul>
  <li>System.OverflowException:
The return value would exceed the range of a 32-bit signed integer.</li>
</ul>

<p><a id="GetUnsignedBitLengthAsEInteger"></a>
### GetUnsignedBitLengthAsEInteger</p>

<pre>public PeterO.Numbers.EInteger GetUnsignedBitLengthAsEInteger();
</pre>

<p>Finds the minimum number of bits needed to represent this number’s absolute value, and returns that number of bits as an arbitrary-precision integer. For example, all integers in the interval [-((2^63) - 1), (2^63) - 1] have an unsigned bit length of 63 or less, and all other integers have an unsigned bit length of greater than 63. This interval is not the same as the range of integers in Java’s and.NET’s  <code>long</code>  type.</p>

<p><b>Return Value:</b></p>

<p>The number of bits in this object’s absolute value. Returns 0 if this object’s value is 0, and returns 1 if the value is negative 1.</p>

<p><a id="GetUnsignedBitLengthAsInt64"></a>
### GetUnsignedBitLengthAsInt64</p>

<pre>public long GetUnsignedBitLengthAsInt64();
</pre>

<p>Finds the minimum number of bits needed to represent this number’s absolute value, and returns that number of bits as a 64-bit signed integer. For example, all integers in the interval [-((2^63) - 1), (2^63) - 1] have an unsigned bit length of 63 or less, and all other integers have an unsigned bit length of greater than 63. This interval is not the same as the range of integers in Java’s and.NET’s  <code>long</code>  type.</p>

<p><b>Return Value:</b></p>

<p>The number of bits in this object’s absolute value. Returns 0 if this object’s value is 0, and returns 1 if the value is negative 1. If the return value would be greater than 2^63 - 1(  <code>Int64.MaxValue</code>  in.NET or  <code>Long.MAX_VALUE</code>  in Java), returns 2^63 - 1 instead. (Use  <code>GetUnsignedBitLengthAsEInteger</code>  instead of this method if the application relies on the exact number of bits.).</p>

<p><a id="Increment"></a>
### Increment</p>

<pre>public PeterO.Numbers.EInteger Increment();
</pre>

<p>Returns one added to this arbitrary-precision integer.</p>

<p><b>Return Value:</b></p>

<p>The given arbitrary-precision integer plus one.</p>

<p><a id="Negate"></a>
### Negate</p>

<pre>public PeterO.Numbers.EInteger Negate();
</pre>

<p>Gets the value of this object with the sign reversed.</p>

<p><b>Return Value:</b></p>

<p>This object’s value with the sign reversed.</p>

<p><a id="Not"></a>
### Not</p>

<pre>public PeterO.Numbers.EInteger Not();
</pre>

<p>Returns an arbitrary-precision integer with every bit flipped from this one (also called an inversion or NOT operation).</p>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision integer in which each bit in its two’s complement representation is set if the corresponding bit of this integer is clear, and vice versa. Returns -1 if this integer is 0. If this integer is positive, the return value is negative, and vice versa. This method uses the two’s complement form of negative integers (see <a href="PeterO.Numbers.EDecimal.html">"Forms of numbers"</a>“Forms of numbers” ). For example, in binary, NOT 10100 = …11101011 (or in decimal, NOT 20 = -21). In binary, NOT …11100110 = 11001 (or in decimal, NOT -26 = 25).</p>

<p><a id="Sqrt"></a>
### Sqrt</p>

<pre>public PeterO.Numbers.EInteger Sqrt();
</pre>

<p>Finds the square root of this instance’s value, rounded down.</p>

<p><b>Return Value:</b></p>

<p>The square root of this object’s value. Returns 0 if this value is 0 or less.</p>

<p><a id="SqrtRem"></a>
### SqrtRem</p>

<pre>public PeterO.Numbers.EInteger[] SqrtRem();
</pre>

<p>Calculates the square root and the remainder.</p>

<p><b>Return Value:</b></p>

<p>An array of two arbitrary-precision integers: the first integer is the square root, and the second is the difference between this value and the square of the first integer. Returns two zeros if this value is 0 or less, or one and zero if this value equals 1.</p>

<p><a id="ToByteChecked"></a>
### ToByteChecked</p>

<pre>public byte ToByteChecked();
</pre>

<p>Converts this number’s value to a byte (from 0 to 255) if it can fit in a byte (from 0 to 255).</p>

<p><b>Return Value:</b></p>

<p>This number’s value as a byte (from 0 to 255).</p>

<p><b>Exceptions:</b></p>

<ul>
  <li>System.OverflowException:
This value is less than 0 or greater than 255.</li>
</ul>

<p><a id="ToByteUnchecked"></a>
### ToByteUnchecked</p>

<pre>public byte ToByteUnchecked();
</pre>

<p>Converts this number to a byte (from 0 to 255), returning the least-significant bits of this number’s two’s-complement form.</p>

<p><b>Return Value:</b></p>

<p>This number, converted to a byte (from 0 to 255).</p>

<p><a id="ToInt16Checked"></a>
### ToInt16Checked</p>

<pre>public short ToInt16Checked();
</pre>

<p>Converts this number’s value to a 16-bit signed integer if it can fit in a 16-bit signed integer.</p>

<p><b>Return Value:</b></p>

<p>This number’s value as a 16-bit signed integer.</p>

<p><b>Exceptions:</b></p>

<ul>
  <li>System.OverflowException:
This value is less than -32768 or greater than 32767.</li>
</ul>

<p><a id="ToInt16Unchecked"></a>
### ToInt16Unchecked</p>

<pre>public short ToInt16Unchecked();
</pre>

<p>Converts this number to a 16-bit signed integer, returning the least-significant bits of this number’s two’s-complement form.</p>

<p><b>Return Value:</b></p>

<p>This number, converted to a 16-bit signed integer.</p>

<p><a id="ToInt32Checked"></a>
### ToInt32Checked</p>

<pre>public int ToInt32Checked();
</pre>

<p>Converts this object’s value to a 32-bit signed integer, throwing an exception if it can’t fit.</p>

<p><b>Return Value:</b></p>

<p>A 32-bit signed integer.</p>

<p><b>Exceptions:</b></p>

<ul>
  <li>T:System.OverflowException:
This object’s value is too big to fit a 32-bit signed integer.</li>
</ul>

<p><a id="ToInt32Unchecked"></a>
### ToInt32Unchecked</p>

<pre>public int ToInt32Unchecked();
</pre>

<p>Converts this object’s value to a 32-bit signed integer. If the value can’t fit in a 32-bit integer, returns the lower 32 bits of this object’s two’s-complement form (see <a href="PeterO.Numbers.EDecimal.html">"Forms of numbers"</a>“Forms of numbers” ) (in which case the return value might have a different sign than this object’s value).</p>

<p><b>Return Value:</b></p>

<p>A 32-bit signed integer.</p>

<p><a id="ToInt64Checked"></a>
### ToInt64Checked</p>

<pre>public long ToInt64Checked();
</pre>

<p>Converts this object’s value to a 64-bit signed integer, throwing an exception if it can’t fit.</p>

<p><b>Return Value:</b></p>

<p>A 64-bit signed integer.</p>

<p><b>Exceptions:</b></p>

<ul>
  <li>T:System.OverflowException:
This object’s value is too big to fit a 64-bit signed integer.</li>
</ul>

<p><a id="ToInt64Unchecked"></a>
### ToInt64Unchecked</p>

<pre>public long ToInt64Unchecked();
</pre>

<p>Converts this object’s value to a 64-bit signed integer. If the value can’t fit in a 64-bit integer, returns the lower 64 bits of this object’s two’s-complement form (see <a href="PeterO.Numbers.EDecimal.html">"Forms of numbers"</a>“Forms of numbers” ) (in which case the return value might have a different sign than this object’s value).</p>

<p><b>Return Value:</b></p>

<p>A 64-bit signed integer.</p>

<p><a id="ToSByteChecked"></a>
### ToSByteChecked</p>

<pre>public sbyte ToSByteChecked();
</pre>

<p><b>This API is not CLS-compliant.</b></p>

<p>Converts this number’s value to an 8-bit signed integer if it can fit in an 8-bit signed integer.</p>

<p><b>Return Value:</b></p>

<p>This number’s value as an 8-bit signed integer.</p>

<p><b>Exceptions:</b></p>

<ul>
  <li>System.OverflowException:
This value is less than -128 or greater than 127.</li>
</ul>

<p><a id="ToSByteUnchecked"></a>
### ToSByteUnchecked</p>

<pre>public sbyte ToSByteUnchecked();
</pre>

<p><b>This API is not CLS-compliant.</b></p>

<p>Converts this number to an 8-bit signed integer, returning the least-significant bits of this number’s two’s-complement form.</p>

<p><b>Return Value:</b></p>

<p>This number, converted to an 8-bit signed integer.</p>

<p><a id="ToString"></a>
### ToString</p>

<pre>public override string ToString();
</pre>

<p>Converts this object to a text string in base 10.</p>

<p><b>Return Value:</b></p>

<p>A string representation of this object. If this value is 0, returns “0”. If negative, the string will begin with a minus sign (“-“, U+002D). The string will use the basic digits 0 to 9 (U+0030 to U+0039).</p>

<p><a id="ToUInt16Checked"></a>
### ToUInt16Checked</p>

<pre>public ushort ToUInt16Checked();
</pre>

<p><b>This API is not CLS-compliant.</b></p>

<p>Converts this number’s value to a 16-bit unsigned integer if it can fit in a 16-bit unsigned integer.</p>

<p><b>Return Value:</b></p>

<p>This number’s value as a 16-bit unsigned integer.</p>

<p><b>Exceptions:</b></p>

<ul>
  <li>System.OverflowException:
This value is less than 0 or greater than 65535.</li>
</ul>

<p><a id="ToUInt16Unchecked"></a>
### ToUInt16Unchecked</p>

<pre>public ushort ToUInt16Unchecked();
</pre>

<p><b>This API is not CLS-compliant.</b></p>

<p>Converts this number to a 16-bit unsigned integer, returning the least-significant bits of this number’s two’s-complement form.</p>

<p><b>Return Value:</b></p>

<p>This number, converted to a 16-bit unsigned integer.</p>

<p><a id="ToUInt32Checked"></a>
### ToUInt32Checked</p>

<pre>public uint ToUInt32Checked();
</pre>

<p><b>This API is not CLS-compliant.</b></p>

<p>Converts this number’s value to a 32-bit signed integer if it can fit in a 32-bit signed integer.</p>

<p><b>Return Value:</b></p>

<p>This number’s value as a 32-bit signed integer.</p>

<p><b>Exceptions:</b></p>

<ul>
  <li>System.OverflowException:
This value is less than 0 or greater than 4294967295.</li>
</ul>

<p><a id="ToUInt32Unchecked"></a>
### ToUInt32Unchecked</p>

<pre>public uint ToUInt32Unchecked();
</pre>

<p><b>This API is not CLS-compliant.</b></p>

<p>Converts this number to a 32-bit signed integer, returning the least-significant bits of this number’s two’s-complement form.</p>

<p><b>Return Value:</b></p>

<p>This number, converted to a 32-bit signed integer.</p>

<p><a id="ToUInt64Checked"></a>
### ToUInt64Checked</p>

<pre>public ulong ToUInt64Checked();
</pre>

<p><b>This API is not CLS-compliant.</b></p>

<p>Converts this number’s value to a 64-bit signed integer if it can fit in a 64-bit signed integer.</p>

<p><b>Return Value:</b></p>

<p>This number’s value as a 64-bit signed integer.</p>

<p><b>Exceptions:</b></p>

<ul>
  <li>System.OverflowException:
This value is outside the range of a 64-bit signed integer.</li>
</ul>

<p><a id="ToUInt64Unchecked"></a>
### ToUInt64Unchecked</p>

<pre>public ulong ToUInt64Unchecked();
</pre>

<p><b>This API is not CLS-compliant.</b></p>

<p>Converts this number to a 64-bit signed integer, returning the least-significant bits of this number’s two’s-complement form.</p>

<p><b>Return Value:</b></p>

<p>This number, converted to a 64-bit signed integer.</p>

<p><a href="/Numbers/">Back to Numbers start page.</a></p>
</div><nav id="navigation"><ul>
<li><a href="/">Back to start site.</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io">This site's repository (source code)</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io/issues">Post an issue or comment</a></ul>

<div class="noprint">
<p>
<a href="//twitter.com/intent/tweet">Share via Twitter</a>, <a href="//www.facebook.com/sharer/sharer.php" id="sharer">Share via Facebook</a>
</p>
</div>
</nav></body></html>
