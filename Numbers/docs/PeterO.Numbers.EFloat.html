<!DOCTYPE html><html xmlns:dc="http://purl.org/dc/terms/"><head><meta http-equiv=Content-Type content="text/html; charset=utf-8"><title>PeterO.Numbers.EFloat</title><meta name="viewport" content="width=device-width"><link rel=stylesheet type="text/css" href="/style.css">
            <script type="text/x-mathjax-config"> MathJax.Hub.Config({"HTML-CSS": { availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, preferredFont: "TeX" },
                    tex2jax: { displayMath: [ ["$$","$$"], ["\\[", "\\]"] ], inlineMath: [ ["$", "$"], ["\\\\(","\\\\)"] ], processEscapes: true } });
            </script><script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"></script></head><body>  <div class="header">
<nav><p><a href="#navigation">Menu</a> - <a href="#top">Top</a> - <a href="/">Home</a></nav></div>
<div class="mainarea" id="top">
<h1>PeterO.Numbers.EFloat</h1>
<p>## PeterO.Numbers.EFloat</p>

<pre>public sealed class EFloat :
    System.IComparable,
    System.IEquatable
</pre>

<p>Represents an arbitrary-precision binary floating-point number. (The “E” stands for “extended”, meaning that instances of this class can be values other than numbers proper, such as infinity and not-a-number.) Each number consists of an integer significand and an integer exponent, both arbitrary-precision. The value of the number equals significand * 2^exponent. This class also supports values for negative zero, not-a-number (NaN) values, and infinity. Passing a signaling NaN to any arithmetic operation shown here will signal the flag FlagInvalid and return a quiet NaN, even if another operand to that operation is a quiet NaN, unless the operation’s documentation expressly states that another result happens when a signaling NaN is passed to that operation.</p>

<p>Passing a quiet NaN to any arithmetic operation shown here will return a quiet NaN, unless the operation’s documentation expressly states that another result happens when a quiet NaN is passed to that operation.</p>

<p>Unless noted otherwise, passing a null arbitrary-precision binary floating-point number argument to any method here will throw an exception.</p>

<p>When an arithmetic operation signals the flag FlagInvalid, FlagOverflow, or FlagDivideByZero, it will not throw an exception too, unless the operation’s trap is enabled in the arithmetic context (see EContext’s Traps property).</p>

<p>An arbitrary-precision binary floating-point number value can be serialized in one of the following ways:</p>

<ul>
  <li>
    <p>By calling the toString() method. However, not all strings can be converted back to an arbitrary-precision binary floating-point number without loss, especially if the string has a fractional part.</p>
  </li>
  <li>
    <p>By calling the UnsignedMantissa, Exponent, and IsNegative properties, and calling the IsInfinity, IsQuietNaN, and IsSignalingNaN methods. The return values combined will uniquely identify a particular arbitrary-precision binary floating-point number value.</p>
  </li>
</ul>

<p>If an operation requires creating an intermediate value that might be too big to fit in memory (or might require more than 2 gigabytes of memory to store – due to the current use of a 32-bit integer internally as a length), the operation may signal an invalid-operation flag and return not-a-number (NaN). In certain rare cases, the CompareTo method may throw OutOfMemoryException (called OutOfMemoryError in Java) in the same circumstances.</p>

<p><b>Thread safety</b></p>

<p>Instances of this class are immutable, so they are inherently safe for use by multiple threads. Multiple instances of this object with the same properties are interchangeable, so they should not be compared using the “==” operator (which might only check if each side of the operator is the same instance).</p>

<p><b>Comparison considerations</b></p>

<p>This class’s natural ordering (under the CompareTo method) is not consistent with the Equals method. This means that two values that compare as equal under the CompareTo method might not be equal under the Equals method. The CompareTo method compares the mathematical values of the two instances passed to it (and considers two different NaN values as equal), while two instances with the same mathematical value, but different exponents, will be considered unequal under the Equals method.</p>

<p><b>Security note</b></p>

<p>It is not recommended to implement security-sensitive algorithms using the methods in this class, for several reasons:</p>

<ul>
  <li>
    <p><code>EFloat</code>  objects are immutable, so they can’t be modified, and the memory they occupy is not guaranteed to be cleared in a timely fashion due to garbage collection. This is relevant for applications that use many-bit-long numbers as secret parameters.</p>
  </li>
  <li>
    <p>The methods in this class (especially those that involve arithmetic) are not guaranteed to be “constant-time” (nondata-dependent) for all relevant inputs. Certain attacks that involve encrypted communications have exploited the timing and other aspects of such communications to derive keying material or cleartext indirectly.</p>
  </li>
</ul>

<p>Applications should instead use dedicated security libraries to handle big numbers in security-sensitive algorithms.</p>

<p><b>Reproducibility note</b></p>

<p>See the reproducibility note in the EDecimal class’s documentation.</p>

<h3 id="member-summary">Member Summary</h3>
<ul>
  <li><code>[Abs()](#Abs)</code> - Finds the absolute value of this object (if it’s negative, it becomes positive).</li>
  <li><code>[Abs(PeterO.Numbers.EContext)](#Abs_PeterO_Numbers_EContext)</code> -</li>
  <li><code>[Add(int)](#Add_int)</code> -</li>
  <li><code>[Add(long)](#Add_long)</code> -</li>
  <li><code>[Add(PeterO.Numbers.EFloat)](#Add_PeterO_Numbers_EFloat)</code> -</li>
  <li><code>[Add(PeterO.Numbers.EFloat, PeterO.Numbers.EContext)](#Add_PeterO_Numbers_EFloat_PeterO_Numbers_EContext)</code> -</li>
  <li><code>[CompareTo(int)](#CompareTo_int)</code> -</li>
  <li><code>[CompareTo(long)](#CompareTo_long)</code> -</li>
  <li><code>[CompareTo(PeterO.Numbers.EFloat)](#CompareTo_PeterO_Numbers_EFloat)</code> -</li>
  <li><code>[CompareToSignal(PeterO.Numbers.EFloat, PeterO.Numbers.EContext)](#CompareToSignal_PeterO_Numbers_EFloat_PeterO_Numbers_EContext)</code> -</li>
  <li><code>[CompareToTotal(PeterO.Numbers.EFloat)](#CompareToTotal_PeterO_Numbers_EFloat)</code> -</li>
  <li><code>[CompareToTotal(PeterO.Numbers.EFloat, PeterO.Numbers.EContext)](#CompareToTotal_PeterO_Numbers_EFloat_PeterO_Numbers_EContext)</code> -</li>
  <li><code>[CompareToTotalMagnitude(PeterO.Numbers.EFloat)](#CompareToTotalMagnitude_PeterO_Numbers_EFloat)</code> -</li>
  <li><code>[CompareToTotalMagnitude(PeterO.Numbers.EFloat, PeterO.Numbers.EContext)](#CompareToTotalMagnitude_PeterO_Numbers_EFloat_PeterO_Numbers_EContext)</code> -</li>
  <li><code>[CompareToValue(int)](#CompareToValue_int)</code> -</li>
  <li><code>[CompareToValue(long)](#CompareToValue_long)</code> -</li>
  <li><code>[CompareToValue(PeterO.Numbers.EFloat)](#CompareToValue_PeterO_Numbers_EFloat)</code> -</li>
  <li><code>[CompareToWithContext(PeterO.Numbers.EFloat, PeterO.Numbers.EContext)](#CompareToWithContext_PeterO_Numbers_EFloat_PeterO_Numbers_EContext)</code> -</li>
  <li><code>[Copy()](#Copy)</code> - Creates a copy of this arbitrary-precision binary number.</li>
  <li><code>[CopySign(PeterO.Numbers.EFloat)](#CopySign_PeterO_Numbers_EFloat)</code> -</li>
  <li><code>[Create(int, int)](#Create_int_int)</code> -</li>
  <li><code>[Create(long, int)](#Create_long_int)</code> -</li>
  <li><code>[Create(long, long)](#Create_long_long)</code> -</li>
  <li><code>[Create(PeterO.Numbers.EInteger, int)](#Create_PeterO_Numbers_EInteger_int)</code> -</li>
  <li><code>[Create(PeterO.Numbers.EInteger, long)](#Create_PeterO_Numbers_EInteger_long)</code> -</li>
  <li><code>[Create(PeterO.Numbers.EInteger, PeterO.Numbers.EInteger)](#Create_PeterO_Numbers_EInteger_PeterO_Numbers_EInteger)</code> -</li>
  <li><code>[CreateNaN(PeterO.Numbers.EInteger)](#CreateNaN_PeterO_Numbers_EInteger)</code> -</li>
  <li><code>[CreateNaN(PeterO.Numbers.EInteger, bool, bool, PeterO.Numbers.EContext)](#CreateNaN_PeterO_Numbers_EInteger_bool_bool_PeterO_Numbers_EContext)</code> -</li>
  <li><code>[Decrement()](#Decrement)</code> - Returns one subtracted from this arbitrary-precision binary floating-point number.</li>
  <li><code>[Divide(int)](#Divide_int)</code> -</li>
  <li><code>[Divide(long)](#Divide_long)</code> -</li>
  <li><code>[Divide(PeterO.Numbers.EFloat)](#Divide_PeterO_Numbers_EFloat)</code> -</li>
  <li><code>[Divide(PeterO.Numbers.EFloat, PeterO.Numbers.EContext)](#Divide_PeterO_Numbers_EFloat_PeterO_Numbers_EContext)</code> -</li>
  <li><code>[DivideAndRemainderNaturalScale(PeterO.Numbers.EFloat)](#DivideAndRemainderNaturalScale_PeterO_Numbers_EFloat)</code> - <b>Deprecated:</b> Renamed to DivRemNaturalScale.</li>
  <li><code>[DivideAndRemainderNaturalScale(PeterO.Numbers.EFloat, PeterO.Numbers.EContext)](#DivideAndRemainderNaturalScale_PeterO_Numbers_EFloat_PeterO_Numbers_EContext)</code> - <b>Deprecated:</b> Renamed to DivRemNaturalScale.</li>
  <li><code>[DivideToExponent(PeterO.Numbers.EFloat, long, PeterO.Numbers.EContext)](#DivideToExponent_PeterO_Numbers_EFloat_long_PeterO_Numbers_EContext)</code> -</li>
  <li><code>[DivideToExponent(PeterO.Numbers.EFloat, long, PeterO.Numbers.ERounding)](#DivideToExponent_PeterO_Numbers_EFloat_long_PeterO_Numbers_ERounding)</code> -</li>
  <li><code>[DivideToExponent(PeterO.Numbers.EFloat, PeterO.Numbers.EInteger, PeterO.Numbers.EContext)](#DivideToExponent_PeterO_Numbers_EFloat_PeterO_Numbers_EInteger_PeterO_Numbers_EContext)</code> -</li>
  <li><code>[DivideToExponent(PeterO.Numbers.EFloat, PeterO.Numbers.EInteger, PeterO.Numbers.ERounding)](#DivideToExponent_PeterO_Numbers_EFloat_PeterO_Numbers_EInteger_PeterO_Numbers_ERounding)</code> -</li>
  <li><code>[DivideToIntegerNaturalScale(PeterO.Numbers.EFloat)](#DivideToIntegerNaturalScale_PeterO_Numbers_EFloat)</code> -</li>
  <li><code>[DivideToIntegerNaturalScale(PeterO.Numbers.EFloat, PeterO.Numbers.EContext)](#DivideToIntegerNaturalScale_PeterO_Numbers_EFloat_PeterO_Numbers_EContext)</code> -</li>
  <li><code>[DivideToIntegerZeroScale(PeterO.Numbers.EFloat, PeterO.Numbers.EContext)](#DivideToIntegerZeroScale_PeterO_Numbers_EFloat_PeterO_Numbers_EContext)</code> -</li>
  <li><code>[DivideToSameExponent(PeterO.Numbers.EFloat, PeterO.Numbers.ERounding)](#DivideToSameExponent_PeterO_Numbers_EFloat_PeterO_Numbers_ERounding)</code> -</li>
  <li><code>[DivRemNaturalScale(PeterO.Numbers.EFloat)](#DivRemNaturalScale_PeterO_Numbers_EFloat)</code> -</li>
  <li><code>[DivRemNaturalScale(PeterO.Numbers.EFloat, PeterO.Numbers.EContext)](#DivRemNaturalScale_PeterO_Numbers_EFloat_PeterO_Numbers_EContext)</code> -</li>
  <li><code>[Equals(object)](#Equals_object)</code> -</li>
  <li><code>[Equals(PeterO.Numbers.EFloat)](#Equals_PeterO_Numbers_EFloat)</code> -</li>
  <li><code>[EqualsInternal(PeterO.Numbers.EFloat)](#EqualsInternal_PeterO_Numbers_EFloat)</code> -</li>
  <li><code>[Exp(PeterO.Numbers.EContext)](#Exp_PeterO_Numbers_EContext)</code> -</li>
  <li><code>[explicit operator byte(PeterO.Numbers.EFloat)](#explicit_operator_byte_PeterO_Numbers_EFloat)</code> -</li>
  <li><code>[explicit operator double(PeterO.Numbers.EFloat)](#explicit_operator_double_PeterO_Numbers_EFloat)</code> -</li>
  <li><code>[explicit operator float(PeterO.Numbers.EFloat)](#explicit_operator_float_PeterO_Numbers_EFloat)</code> -</li>
  <li><code>[explicit operator int(PeterO.Numbers.EFloat)](#explicit_operator_int_PeterO_Numbers_EFloat)</code> -</li>
  <li><code>[explicit operator long(PeterO.Numbers.EFloat)](#explicit_operator_long_PeterO_Numbers_EFloat)</code> -</li>
  <li><code>[explicit operator PeterO.Numbers.EFloat(bool)](#explicit_operator_PeterO_Numbers_EFloat_bool)</code> -</li>
  <li><code>[explicit operator PeterO.Numbers.EInteger(PeterO.Numbers.EFloat)](#explicit_operator_PeterO_Numbers_EInteger_PeterO_Numbers_EFloat)</code> -</li>
  <li><code>[explicit operator sbyte(PeterO.Numbers.EFloat)](#explicit_operator_sbyte_PeterO_Numbers_EFloat)</code> -</li>
  <li><code>[explicit operator short(PeterO.Numbers.EFloat)](#explicit_operator_short_PeterO_Numbers_EFloat)</code> -</li>
  <li><code>[explicit operator uint(PeterO.Numbers.EFloat)](#explicit_operator_uint_PeterO_Numbers_EFloat)</code> -</li>
  <li><code>[explicit operator ulong(PeterO.Numbers.EFloat)](#explicit_operator_ulong_PeterO_Numbers_EFloat)</code> -</li>
  <li><code>[explicit operator ushort(PeterO.Numbers.EFloat)](#explicit_operator_ushort_PeterO_Numbers_EFloat)</code> -</li>
  <li><code>[ExpM1(PeterO.Numbers.EContext)](#ExpM1_PeterO_Numbers_EContext)</code> -</li>
  <li><code>[Exponent](#Exponent)</code> - Gets this object’s exponent.</li>
  <li><code>[FromBoolean(bool)](#FromBoolean_bool)</code> -</li>
  <li><code>[FromByte(byte)](#FromByte_byte)</code> -</li>
  <li><code>[FromDouble(double)](#FromDouble_double)</code> -</li>
  <li><code>[FromDoubleBits(long)](#FromDoubleBits_long)</code> -</li>
  <li><code>[FromEInteger(PeterO.Numbers.EInteger)](#FromEInteger_PeterO_Numbers_EInteger)</code> -</li>
  <li><code>[FromHalfBits(short)](#FromHalfBits_short)</code> -</li>
  <li><code>[FromInt16(short)](#FromInt16_short)</code> -</li>
  <li><code>[FromInt32(int)](#FromInt32_int)</code> -</li>
  <li><code>[FromInt64(long)](#FromInt64_long)</code> -</li>
  <li><code>[FromInt64AsUnsigned(long)](#FromInt64AsUnsigned_long)</code> -</li>
  <li><code>[FromSByte(sbyte)](#FromSByte_sbyte)</code> -</li>
  <li><code>[FromSingle(float)](#FromSingle_float)</code> -</li>
  <li><code>[FromSingleBits(int)](#FromSingleBits_int)</code> -</li>
  <li><code>[FromString(byte[])](#FromString_byte)</code> -</li>
  <li><code>[FromString(byte[], int, int)](#FromString_byte_int_int)</code> -</li>
  <li><code>[FromString(byte[], int, int, PeterO.Numbers.EContext)](#FromString_byte_int_int_PeterO_Numbers_EContext)</code> -</li>
  <li><code>[FromString(byte[], PeterO.Numbers.EContext)](#FromString_byte_PeterO_Numbers_EContext)</code> -</li>
  <li><code>[FromString(char[])](#FromString_char)</code> -</li>
  <li><code>[FromString(char[], int, int)](#FromString_char_int_int)</code> -</li>
  <li><code>[FromString(char[], int, int, PeterO.Numbers.EContext)](#FromString_char_int_int_PeterO_Numbers_EContext)</code> -</li>
  <li><code>[FromString(char[], PeterO.Numbers.EContext)](#FromString_char_PeterO_Numbers_EContext)</code> -</li>
  <li><code>[FromString(string)](#FromString_string)</code> -</li>
  <li><code>[FromString(string, int, int)](#FromString_string_int_int)</code> -</li>
  <li><code>[FromString(string, int, int, PeterO.Numbers.EContext)](#FromString_string_int_int_PeterO_Numbers_EContext)</code> -</li>
  <li><code>[FromString(string, PeterO.Numbers.EContext)](#FromString_string_PeterO_Numbers_EContext)</code> -</li>
  <li><code>[FromUInt16(ushort)](#FromUInt16_ushort)</code> -</li>
  <li><code>[FromUInt32(uint)](#FromUInt32_uint)</code> -</li>
  <li><code>[FromUInt64(ulong)](#FromUInt64_ulong)</code> -</li>
  <li><code>[GetHashCode()](#GetHashCode)</code> - Calculates this object’s hash code.</li>
  <li><code>[implicit operator PeterO.Numbers.EFloat(byte)](#implicit_operator_PeterO_Numbers_EFloat_byte)</code> -</li>
  <li><code>[implicit operator PeterO.Numbers.EFloat(double)](#implicit_operator_PeterO_Numbers_EFloat_double)</code> -</li>
  <li><code>[implicit operator PeterO.Numbers.EFloat(float)](#implicit_operator_PeterO_Numbers_EFloat_float)</code> -</li>
  <li><code>[implicit operator PeterO.Numbers.EFloat(int)](#implicit_operator_PeterO_Numbers_EFloat_int)</code> -</li>
  <li><code>[implicit operator PeterO.Numbers.EFloat(long)](#implicit_operator_PeterO_Numbers_EFloat_long)</code> -</li>
  <li><code>[implicit operator PeterO.Numbers.EFloat(PeterO.Numbers.EInteger)](#implicit_operator_PeterO_Numbers_EFloat_PeterO_Numbers_EInteger)</code> -</li>
  <li><code>[implicit operator PeterO.Numbers.EFloat(sbyte)](#implicit_operator_PeterO_Numbers_EFloat_sbyte)</code> -</li>
  <li><code>[implicit operator PeterO.Numbers.EFloat(short)](#implicit_operator_PeterO_Numbers_EFloat_short)</code> -</li>
  <li><code>[implicit operator PeterO.Numbers.EFloat(uint)](#implicit_operator_PeterO_Numbers_EFloat_uint)</code> -</li>
  <li><code>[implicit operator PeterO.Numbers.EFloat(ulong)](#implicit_operator_PeterO_Numbers_EFloat_ulong)</code> -</li>
  <li><code>[implicit operator PeterO.Numbers.EFloat(ushort)](#implicit_operator_PeterO_Numbers_EFloat_ushort)</code> -</li>
  <li><code>[Increment()](#Increment)</code> - Returns one added to this arbitrary-precision binary floating-point number.</li>
  <li><code>[IsFinite](#IsFinite)</code> - Gets a value indicating whether this object is finite (not infinity or not-a-number, NaN).</li>
  <li><code>[IsInfinity()](#IsInfinity)</code> - Gets a value indicating whether this object is positive or negative infinity.</li>
  <li><code>[IsInteger()](#IsInteger)</code> - Returns whether this object’s value is an integer.</li>
  <li><code>[IsNaN()](#IsNaN)</code> - Gets a value indicating whether this object is not a number (NaN).</li>
  <li><code>[IsNegative](#IsNegative)</code> - Gets a value indicating whether this object is negative, including negative zero.</li>
  <li><code>[IsNegativeInfinity()](#IsNegativeInfinity)</code> - Returns whether this object is negative infinity.</li>
  <li><code>[IsPositiveInfinity()](#IsPositiveInfinity)</code> - Returns whether this object is positive infinity.</li>
  <li><code>[IsQuietNaN()](#IsQuietNaN)</code> - Gets a value indicating whether this object is a quiet not-a-number value.</li>
  <li><code>[IsSignalingNaN()](#IsSignalingNaN)</code> - Gets a value indicating whether this object is a signaling not-a-number value.</li>
  <li><code>[IsZero](#IsZero)</code> - Gets a value indicating whether this object’s value equals 0.</li>
  <li><code>[Log(PeterO.Numbers.EContext)](#Log_PeterO_Numbers_EContext)</code> -</li>
  <li><code>[Log10(PeterO.Numbers.EContext)](#Log10_PeterO_Numbers_EContext)</code> -</li>
  <li><code>[Log1P(PeterO.Numbers.EContext)](#Log1P_PeterO_Numbers_EContext)</code> -</li>
  <li><code>[LogN(PeterO.Numbers.EFloat, PeterO.Numbers.EContext)](#LogN_PeterO_Numbers_EFloat_PeterO_Numbers_EContext)</code> -</li>
  <li><code>[Mantissa](#Mantissa)</code> - Gets this object’s unscaled value, or significand, and makes it negative if this object is negative.</li>
  <li><code>[Max(PeterO.Numbers.EFloat, PeterO.Numbers.EFloat)](#Max_PeterO_Numbers_EFloat_PeterO_Numbers_EFloat)</code> -</li>
  <li><code>[Max(PeterO.Numbers.EFloat, PeterO.Numbers.EFloat, PeterO.Numbers.EContext)](#Max_PeterO_Numbers_EFloat_PeterO_Numbers_EFloat_PeterO_Numbers_EContext)</code> -</li>
  <li><code>[MaxMagnitude(PeterO.Numbers.EFloat, PeterO.Numbers.EFloat)](#MaxMagnitude_PeterO_Numbers_EFloat_PeterO_Numbers_EFloat)</code> -</li>
  <li><code>[MaxMagnitude(PeterO.Numbers.EFloat, PeterO.Numbers.EFloat, PeterO.Numbers.EContext)](#MaxMagnitude_PeterO_Numbers_EFloat_PeterO_Numbers_EFloat_PeterO_Numbers_EContext)</code> -</li>
  <li><code>[Min(PeterO.Numbers.EFloat, PeterO.Numbers.EFloat)](#Min_PeterO_Numbers_EFloat_PeterO_Numbers_EFloat)</code> -</li>
  <li><code>[Min(PeterO.Numbers.EFloat, PeterO.Numbers.EFloat, PeterO.Numbers.EContext)](#Min_PeterO_Numbers_EFloat_PeterO_Numbers_EFloat_PeterO_Numbers_EContext)</code> -</li>
  <li><code>[MinMagnitude(PeterO.Numbers.EFloat, PeterO.Numbers.EFloat)](#MinMagnitude_PeterO_Numbers_EFloat_PeterO_Numbers_EFloat)</code> -</li>
  <li><code>[MinMagnitude(PeterO.Numbers.EFloat, PeterO.Numbers.EFloat, PeterO.Numbers.EContext)](#MinMagnitude_PeterO_Numbers_EFloat_PeterO_Numbers_EFloat_PeterO_Numbers_EContext)</code> -</li>
  <li><code>[MovePointLeft(int)](#MovePointLeft_int)</code> -</li>
  <li><code>[MovePointLeft(int, PeterO.Numbers.EContext)](#MovePointLeft_int_PeterO_Numbers_EContext)</code> -</li>
  <li><code>[MovePointLeft(PeterO.Numbers.EInteger)](#MovePointLeft_PeterO_Numbers_EInteger)</code> -</li>
  <li><code>[MovePointLeft(PeterO.Numbers.EInteger, PeterO.Numbers.EContext)](#MovePointLeft_PeterO_Numbers_EInteger_PeterO_Numbers_EContext)</code> -</li>
  <li><code>[MovePointRight(int)](#MovePointRight_int)</code> -</li>
  <li><code>[MovePointRight(int, PeterO.Numbers.EContext)](#MovePointRight_int_PeterO_Numbers_EContext)</code> -</li>
  <li><code>[MovePointRight(PeterO.Numbers.EInteger)](#MovePointRight_PeterO_Numbers_EInteger)</code> -</li>
  <li><code>[MovePointRight(PeterO.Numbers.EInteger, PeterO.Numbers.EContext)](#MovePointRight_PeterO_Numbers_EInteger_PeterO_Numbers_EContext)</code> -</li>
  <li><code>[Multiply(int)](#Multiply_int)</code> -</li>
  <li><code>[Multiply(long)](#Multiply_long)</code> -</li>
  <li><code>[Multiply(PeterO.Numbers.EFloat)](#Multiply_PeterO_Numbers_EFloat)</code> -</li>
  <li><code>[Multiply(PeterO.Numbers.EFloat, PeterO.Numbers.EContext)](#Multiply_PeterO_Numbers_EFloat_PeterO_Numbers_EContext)</code> -</li>
  <li><code>[MultiplyAndAdd(PeterO.Numbers.EFloat, PeterO.Numbers.EFloat)](#MultiplyAndAdd_PeterO_Numbers_EFloat_PeterO_Numbers_EFloat)</code> -</li>
  <li><code>[MultiplyAndAdd(PeterO.Numbers.EFloat, PeterO.Numbers.EFloat, PeterO.Numbers.EContext)](#MultiplyAndAdd_PeterO_Numbers_EFloat_PeterO_Numbers_EFloat_PeterO_Numbers_EContext)</code> -</li>
  <li><code>[MultiplyAndSubtract(PeterO.Numbers.EFloat, PeterO.Numbers.EFloat, PeterO.Numbers.EContext)](#MultiplyAndSubtract_PeterO_Numbers_EFloat_PeterO_Numbers_EFloat_PeterO_Numbers_EContext)</code> -</li>
  <li><code>[public static readonly PeterO.Numbers.EFloat NaN;](#NaN)</code> - A not-a-number value.</li>
  <li><code>[Negate()](#Negate)</code> - Gets an object with the same value as this one, but with the sign reversed.</li>
  <li><code>[Negate(PeterO.Numbers.EContext)](#Negate_PeterO_Numbers_EContext)</code> -</li>
  <li><code>[public static readonly PeterO.Numbers.EFloat NegativeInfinity;](#NegativeInfinity)</code> - Negative infinity, less than any other number.</li>
  <li><code>[public static readonly PeterO.Numbers.EFloat NegativeZero;](#NegativeZero)</code> - Represents the number negative zero.</li>
  <li><code>[NextMinus(PeterO.Numbers.EContext)](#NextMinus_PeterO_Numbers_EContext)</code> -</li>
  <li><code>[NextPlus(PeterO.Numbers.EContext)](#NextPlus_PeterO_Numbers_EContext)</code> -</li>
  <li><code>[NextToward(PeterO.Numbers.EFloat, PeterO.Numbers.EContext)](#NextToward_PeterO_Numbers_EFloat_PeterO_Numbers_EContext)</code> -</li>
  <li><code>[public static readonly PeterO.Numbers.EFloat One;](#One)</code> - Represents the number 1.</li>
  <li><code>[PeterO.Numbers.EFloat operator +(PeterO.Numbers.EFloat, PeterO.Numbers.EFloat)](#op_Addition)</code> -</li>
  <li><code>[PeterO.Numbers.EFloat operator --(PeterO.Numbers.EFloat)](#op_Decrement)</code> -</li>
  <li><code>[PeterO.Numbers.EFloat operator /(PeterO.Numbers.EFloat, PeterO.Numbers.EFloat)](#op_Division)</code> -</li>
  <li><code>[PeterO.Numbers.EFloat operator ++(PeterO.Numbers.EFloat)](#op_Increment)</code> -</li>
  <li><code>[PeterO.Numbers.EFloat operator %(PeterO.Numbers.EFloat, PeterO.Numbers.EFloat)](#op_Modulus)</code> -</li>
  <li><code>[PeterO.Numbers.EFloat operator &#x2a;(PeterO.Numbers.EFloat, PeterO.Numbers.EFloat)](#op_Multiply)</code> -</li>
  <li><code>[PeterO.Numbers.EFloat operator -(PeterO.Numbers.EFloat, PeterO.Numbers.EFloat)](#op_Subtraction)</code> -</li>
  <li><code>[PeterO.Numbers.EFloat operator -(PeterO.Numbers.EFloat)](#op_UnaryNegation)</code> -</li>
  <li><code>[PI(PeterO.Numbers.EContext)](#PI_PeterO_Numbers_EContext)</code> -</li>
  <li><code>[Plus(PeterO.Numbers.EContext)](#Plus_PeterO_Numbers_EContext)</code> -</li>
  <li><code>[public static readonly PeterO.Numbers.EFloat PositiveInfinity;](#PositiveInfinity)</code> - Positive infinity, greater than any other number.</li>
  <li><code>[Pow(int)](#Pow_int)</code> -</li>
  <li><code>[Pow(int, PeterO.Numbers.EContext)](#Pow_int_PeterO_Numbers_EContext)</code> -</li>
  <li><code>[Pow(PeterO.Numbers.EFloat)](#Pow_PeterO_Numbers_EFloat)</code> -</li>
  <li><code>[Pow(PeterO.Numbers.EFloat, PeterO.Numbers.EContext)](#Pow_PeterO_Numbers_EFloat_PeterO_Numbers_EContext)</code> -</li>
  <li><code>[Precision()](#Precision)</code> - Finds the number of digits in this number’s significand.</li>
  <li><code>[PreRound(PeterO.Numbers.EContext)](#PreRound_PeterO_Numbers_EContext)</code> -</li>
  <li><code>[Quantize(int, PeterO.Numbers.EContext)](#Quantize_int_PeterO_Numbers_EContext)</code> -</li>
  <li><code>[Quantize(PeterO.Numbers.EFloat, PeterO.Numbers.EContext)](#Quantize_PeterO_Numbers_EFloat_PeterO_Numbers_EContext)</code> -</li>
  <li><code>[Quantize(PeterO.Numbers.EInteger, PeterO.Numbers.EContext)](#Quantize_PeterO_Numbers_EInteger_PeterO_Numbers_EContext)</code> -</li>
  <li><code>[Reduce(PeterO.Numbers.EContext)](#Reduce_PeterO_Numbers_EContext)</code> -</li>
  <li><code>[Remainder(PeterO.Numbers.EFloat, PeterO.Numbers.EContext)](#Remainder_PeterO_Numbers_EFloat_PeterO_Numbers_EContext)</code> -</li>
  <li><code>[RemainderNaturalScale(PeterO.Numbers.EFloat)](#RemainderNaturalScale_PeterO_Numbers_EFloat)</code> -</li>
  <li><code>[RemainderNaturalScale(PeterO.Numbers.EFloat, PeterO.Numbers.EContext)](#RemainderNaturalScale_PeterO_Numbers_EFloat_PeterO_Numbers_EContext)</code> -</li>
  <li><code>[RemainderNear(PeterO.Numbers.EFloat, PeterO.Numbers.EContext)](#RemainderNear_PeterO_Numbers_EFloat_PeterO_Numbers_EContext)</code> -</li>
  <li><code>[RemainderNoRoundAfterDivide(PeterO.Numbers.EFloat, PeterO.Numbers.EContext)](#RemainderNoRoundAfterDivide_PeterO_Numbers_EFloat_PeterO_Numbers_EContext)</code> -</li>
  <li><code>[RoundToExponent(int, PeterO.Numbers.EContext)](#RoundToExponent_int_PeterO_Numbers_EContext)</code> -</li>
  <li><code>[RoundToExponent(PeterO.Numbers.EInteger, PeterO.Numbers.EContext)](#RoundToExponent_PeterO_Numbers_EInteger_PeterO_Numbers_EContext)</code> -</li>
  <li><code>[RoundToExponentExact(int, PeterO.Numbers.EContext)](#RoundToExponentExact_int_PeterO_Numbers_EContext)</code> -</li>
  <li><code>[RoundToExponentExact(PeterO.Numbers.EInteger, PeterO.Numbers.EContext)](#RoundToExponentExact_PeterO_Numbers_EInteger_PeterO_Numbers_EContext)</code> -</li>
  <li><code>[RoundToExponentExact(PeterO.Numbers.EInteger, PeterO.Numbers.ERounding)](#RoundToExponentExact_PeterO_Numbers_EInteger_PeterO_Numbers_ERounding)</code> -</li>
  <li><code>[RoundToIntegerExact(PeterO.Numbers.EContext)](#RoundToIntegerExact_PeterO_Numbers_EContext)</code> -</li>
  <li><code>[RoundToIntegerNoRoundedFlag(PeterO.Numbers.EContext)](#RoundToIntegerNoRoundedFlag_PeterO_Numbers_EContext)</code> -</li>
  <li><code>[RoundToIntegralExact(PeterO.Numbers.EContext)](#RoundToIntegralExact_PeterO_Numbers_EContext)</code> - <b>Deprecated:</b> Renamed to RoundToIntegerExact.</li>
  <li><code>[RoundToIntegralNoRoundedFlag(PeterO.Numbers.EContext)](#RoundToIntegralNoRoundedFlag_PeterO_Numbers_EContext)</code> - <b>Deprecated:</b> Renamed to RoundToIntegerNoRoundedFlag.</li>
  <li><code>[RoundToPrecision(PeterO.Numbers.EContext)](#RoundToPrecision_PeterO_Numbers_EContext)</code> -</li>
  <li><code>[ScaleByPowerOfTwo(int)](#ScaleByPowerOfTwo_int)</code> -</li>
  <li><code>[ScaleByPowerOfTwo(int, PeterO.Numbers.EContext)](#ScaleByPowerOfTwo_int_PeterO_Numbers_EContext)</code> -</li>
  <li><code>[ScaleByPowerOfTwo(PeterO.Numbers.EInteger)](#ScaleByPowerOfTwo_PeterO_Numbers_EInteger)</code> -</li>
  <li><code>[ScaleByPowerOfTwo(PeterO.Numbers.EInteger, PeterO.Numbers.EContext)](#ScaleByPowerOfTwo_PeterO_Numbers_EInteger_PeterO_Numbers_EContext)</code> -</li>
  <li><code>[Sign](#Sign)</code> - Gets this value’s sign: -1 if negative; 1 if positive; 0 if zero.</li>
  <li><code>[public static readonly PeterO.Numbers.EFloat SignalingNaN;](#SignalingNaN)</code> - A not-a-number value that signals an invalid operation flag when it’s passed as an argument to any arithmetic operation in arbitrary-precision binary floating-point number.</li>
  <li><code>[Sqrt(PeterO.Numbers.EContext)](#Sqrt_PeterO_Numbers_EContext)</code> -</li>
  <li><code>[SquareRoot(PeterO.Numbers.EContext)](#SquareRoot_PeterO_Numbers_EContext)</code> - <b>Deprecated:</b> Renamed to Sqrt.</li>
  <li><code>[Subtract(int)](#Subtract_int)</code> -</li>
  <li><code>[Subtract(long)](#Subtract_long)</code> -</li>
  <li><code>[Subtract(PeterO.Numbers.EFloat)](#Subtract_PeterO_Numbers_EFloat)</code> -</li>
  <li><code>[Subtract(PeterO.Numbers.EFloat, PeterO.Numbers.EContext)](#Subtract_PeterO_Numbers_EFloat_PeterO_Numbers_EContext)</code> -</li>
  <li><code>[public static readonly PeterO.Numbers.EFloat Ten;](#Ten)</code> - Represents the number 10.</li>
  <li><code>[ToByteChecked()](#ToByteChecked)</code> - Converts this number’s value to a byte (from 0 to 255) if it can fit in a byte (from 0 to 255) after converting it to an integer by discarding its fractional part.</li>
  <li><code>[ToByteIfExact()](#ToByteIfExact)</code> - Converts this number’s value to a byte (from 0 to 255) if it can fit in a byte (from 0 to 255) without rounding to a different numerical value.</li>
  <li><code>[ToByteUnchecked()](#ToByteUnchecked)</code> - Converts this number’s value to an integer by discarding its fractional part, and returns the least-significant bits of its two’s-complement form as a byte (from 0 to 255).</li>
  <li><code>[ToDouble()](#ToDouble)</code> - Converts this value to a 64-bit floating-point number encoded in the IEEE 754 binary64 format.</li>
  <li><code>[ToDoubleBits()](#ToDoubleBits)</code> - Converts this value to its closest equivalent as a 64-bit floating-point number, expressed as an integer in the IEEE 754 binary64 format.</li>
  <li><code>[ToEDecimal()](#ToEDecimal)</code> - Converts this value to an arbitrary-precision decimal number.</li>
  <li><code>[ToEInteger()](#ToEInteger)</code> - Converts this value to an arbitrary-precision integer.</li>
  <li><code>[ToEIntegerExact()](#ToEIntegerExact)</code> - <b>Deprecated:</b> Renamed to ToEIntegerIfExact.</li>
  <li><code>[ToEIntegerIfExact()](#ToEIntegerIfExact)</code> - Converts this value to an arbitrary-precision integer, checking whether the value contains a fractional part.</li>
  <li><code>[ToEngineeringString()](#ToEngineeringString)</code> - Converts this value to an arbitrary-precision decimal number, then returns the value of that decimal’s ToEngineeringString method.</li>
  <li><code>[ToExtendedDecimal()](#ToExtendedDecimal)</code> - <b>Deprecated:</b> Renamed to ToEDecimal.</li>
  <li><code>[ToHalfBits()](#ToHalfBits)</code> - Converts this value to its closest equivalent as a binary floating-point number, expressed as an integer in the IEEE 754 binary16 format (also known as a “half-precision” floating-point number).</li>
  <li><code>[ToInt16Checked()](#ToInt16Checked)</code> - Converts this number’s value to a 16-bit signed integer if it can fit in a 16-bit signed integer after converting it to an integer by discarding its fractional part.</li>
  <li><code>[ToInt16IfExact()](#ToInt16IfExact)</code> - Converts this number’s value to a 16-bit signed integer if it can fit in a 16-bit signed integer without rounding to a different numerical value.</li>
  <li><code>[ToInt16Unchecked()](#ToInt16Unchecked)</code> - Converts this number’s value to an integer by discarding its fractional part, and returns the least-significant bits of its two’s-complement form as a 16-bit signed integer.</li>
  <li><code>[ToInt32Checked()](#ToInt32Checked)</code> - Converts this number’s value to a 32-bit signed integer if it can fit in a 32-bit signed integer after converting it to an integer by discarding its fractional part.</li>
  <li><code>[ToInt32IfExact()](#ToInt32IfExact)</code> - Converts this number’s value to a 32-bit signed integer if it can fit in a 32-bit signed integer without rounding to a different numerical value.</li>
  <li><code>[ToInt32Unchecked()](#ToInt32Unchecked)</code> - Converts this number’s value to an integer by discarding its fractional part, and returns the least-significant bits of its two’s-complement form as a 32-bit signed integer.</li>
  <li><code>[ToInt64Checked()](#ToInt64Checked)</code> - Converts this number’s value to a 64-bit signed integer if it can fit in a 64-bit signed integer after converting it to an integer by discarding its fractional part.</li>
  <li><code>[ToInt64IfExact()](#ToInt64IfExact)</code> - Converts this number’s value to a 64-bit signed integer if it can fit in a 64-bit signed integer without rounding to a different numerical value.</li>
  <li><code>[ToInt64Unchecked()](#ToInt64Unchecked)</code> - Converts this number’s value to an integer by discarding its fractional part, and returns the least-significant bits of its two’s-complement form as a 64-bit signed integer.</li>
  <li><code>[ToPlainString()](#ToPlainString)</code> - Converts this value to a string, but without exponential notation.</li>
  <li><code>[ToSByteChecked()](#ToSByteChecked)</code> - Converts this number’s value to an 8-bit signed integer if it can fit in an 8-bit signed integer after converting it to an integer by discarding its fractional part.</li>
  <li><code>[ToSByteIfExact()](#ToSByteIfExact)</code> - Converts this number’s value to an 8-bit signed integer if it can fit in an 8-bit signed integer without rounding to a different numerical value.</li>
  <li><code>[ToSByteUnchecked()](#ToSByteUnchecked)</code> - Converts this number’s value to an integer by discarding its fractional part, and returns the least-significant bits of its two’s-complement form as an 8-bit signed integer.</li>
  <li><code>[ToShortestString(PeterO.Numbers.EContext)](#ToShortestString_PeterO_Numbers_EContext)</code> -</li>
  <li><code>[ToSingle()](#ToSingle)</code> - Converts this value to its closest equivalent as a 32-bit floating-point number.</li>
  <li><code>[ToSingleBits()](#ToSingleBits)</code> - Converts this value to its closest equivalent as 32-bit floating-point number, expressed as an integer in the IEEE 754 binary32 format.</li>
  <li><code>[ToSizedEInteger(int)](#ToSizedEInteger_int)</code> -</li>
  <li><code>[ToSizedEIntegerIfExact(int)](#ToSizedEIntegerIfExact_int)</code> -</li>
  <li><code>[ToString()](#ToString)</code> - Converts this number’s value to a text string.</li>
  <li><code>[ToUInt16Checked()](#ToUInt16Checked)</code> - Converts this number’s value to a 16-bit unsigned integer if it can fit in a 16-bit unsigned integer after converting it to an integer by discarding its fractional part.</li>
  <li><code>[ToUInt16IfExact()](#ToUInt16IfExact)</code> - Converts this number’s value to a 16-bit unsigned integer if it can fit in a 16-bit unsigned integer without rounding to a different numerical value.</li>
  <li><code>[ToUInt16Unchecked()](#ToUInt16Unchecked)</code> - Converts this number’s value to an integer by discarding its fractional part, and returns the least-significant bits of its two’s-complement form as a 16-bit unsigned integer.</li>
  <li><code>[ToUInt32Checked()](#ToUInt32Checked)</code> - Converts this number’s value to a 32-bit signed integer if it can fit in a 32-bit signed integer after converting it to an integer by discarding its fractional part.</li>
  <li><code>[ToUInt32IfExact()](#ToUInt32IfExact)</code> - Converts this number’s value to a 32-bit signed integer if it can fit in a 32-bit signed integer without rounding to a different numerical value.</li>
  <li><code>[ToUInt32Unchecked()](#ToUInt32Unchecked)</code> - Converts this number’s value to an integer by discarding its fractional part, and returns the least-significant bits of its two’s-complement form as a 32-bit signed integer.</li>
  <li><code>[ToUInt64Checked()](#ToUInt64Checked)</code> - Converts this number’s value to a 64-bit unsigned integer if it can fit in a 64-bit unsigned integer after converting it to an integer by discarding its fractional part.</li>
  <li><code>[ToUInt64IfExact()](#ToUInt64IfExact)</code> - Converts this number’s value to a 64-bit unsigned integer if it can fit in a 64-bit unsigned integer without rounding to a different numerical value.</li>
  <li><code>[ToUInt64Unchecked()](#ToUInt64Unchecked)</code> - Converts this number’s value to an integer by discarding its fractional part, and returns the least-significant bits of its two’s-complement form as a 64-bit unsigned integer.</li>
  <li><code>[Ulp()](#Ulp)</code> - Returns the unit in the last place.</li>
  <li><code>[UnsignedMantissa](#UnsignedMantissa)</code> - Gets the absolute value of this object’s unscaled value, or significand.</li>
  <li><code>[public static readonly PeterO.Numbers.EFloat Zero;](#Zero)</code> - Represents the number 0.</li>
</ul>

<p><a id="NaN"></a>
### NaN</p>

<pre>public static readonly PeterO.Numbers.EFloat NaN;
</pre>

<p>A not-a-number value.</p>

<p><a id="NegativeInfinity"></a>
### NegativeInfinity</p>

<pre>public static readonly PeterO.Numbers.EFloat NegativeInfinity;
</pre>

<p>Negative infinity, less than any other number.</p>

<p><a id="NegativeZero"></a>
### NegativeZero</p>

<pre>public static readonly PeterO.Numbers.EFloat NegativeZero;
</pre>

<p>Represents the number negative zero.</p>

<p><a id="One"></a>
### One</p>

<pre>public static readonly PeterO.Numbers.EFloat One;
</pre>

<p>Represents the number 1.</p>

<p><a id="PositiveInfinity"></a>
### PositiveInfinity</p>

<pre>public static readonly PeterO.Numbers.EFloat PositiveInfinity;
</pre>

<p>Positive infinity, greater than any other number.</p>

<p><a id="SignalingNaN"></a>
### SignalingNaN</p>

<pre>public static readonly PeterO.Numbers.EFloat SignalingNaN;
</pre>

<p>A not-a-number value that signals an invalid operation flag when it’s passed as an argument to any arithmetic operation in arbitrary-precision binary floating-point number.</p>

<p><a id="Ten"></a>
### Ten</p>

<pre>public static readonly PeterO.Numbers.EFloat Ten;
</pre>

<p>Represents the number 10.</p>

<p><a id="Zero"></a>
### Zero</p>

<pre>public static readonly PeterO.Numbers.EFloat Zero;
</pre>

<p>Represents the number 0.</p>

<p><a id="Exponent"></a>
### Exponent</p>

<pre>public PeterO.Numbers.EInteger Exponent { get; }
</pre>

<p>Gets this object’s exponent. This object’s value will be an integer if the exponent is positive or zero.</p>

<p><b>Returns:</b></p>

<p>This object’s exponent. This object’s value will be an integer if the exponent is positive or zero.</p>

<p><a id="IsFinite"></a>
### IsFinite</p>

<pre>public bool IsFinite { get; }
</pre>

<p>Gets a value indicating whether this object is finite (not infinity or not-a-number, NaN).</p>

<p><b>Returns:</b></p>

<p><code>true</code>  if this object is finite (not infinity or not-a-number, NaN); otherwise,  <code>false</code> .</p>

<p><a id="IsNegative"></a>
### IsNegative</p>

<pre>public bool IsNegative { get; }
</pre>

<p>Gets a value indicating whether this object is negative, including negative zero.</p>

<p><b>Returns:</b></p>

<p><code>true</code>  if this object is negative, including negative zero; otherwise,  <code>false</code> .</p>

<p><a id="IsZero"></a>
### IsZero</p>

<pre>public bool IsZero { get; }
</pre>

<p>Gets a value indicating whether this object’s value equals 0.</p>

<p><b>Returns:</b></p>

<p><code>true</code>  if this object’s value equals 0; otherwise,  <code>false</code> .  <code>true</code>  if this object’s value equals 0; otherwise,  <code>false</code> .</p>

<p><a id="Mantissa"></a>
### Mantissa</p>

<pre>public PeterO.Numbers.EInteger Mantissa { get; }
</pre>

<p>Gets this object’s unscaled value, or significand, and makes it negative if this object is negative. If this value is not-a-number (NaN), that value’s absolute value is the NaN’s “payload” (diagnostic information).</p>

<p><b>Returns:</b></p>

<p>This object’s unscaled value. Will be negative if this object’s value is negative (including a negative NaN).</p>

<p><a id="Sign"></a>
### Sign</p>

<pre>public int Sign { get; }
</pre>

<p>Gets this value’s sign: -1 if negative; 1 if positive; 0 if zero.</p>

<p><b>Returns:</b></p>

<p>This value’s sign: -1 if negative; 1 if positive; 0 if zero.</p>

<p><a id="UnsignedMantissa"></a>
### UnsignedMantissa</p>

<pre>public PeterO.Numbers.EInteger UnsignedMantissa { get; }
</pre>

<p>Gets the absolute value of this object’s unscaled value, or significand. If this value is not-a-number (NaN), that value is the NaN’s “payload” (diagnostic information).</p>

<p><b>Returns:</b></p>

<p>The absolute value of this object’s unscaled value.</p>

<p><a id="Abs"></a>
### Abs</p>

<pre>public PeterO.Numbers.EFloat Abs();
</pre>

<p>Finds the absolute value of this object (if it’s negative, it becomes positive).</p>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision binary floating-point number. Returns signaling NaN if this value is signaling NaN. (In this sense, this method is similar to the “copy-abs” operation in the General Decimal Arithmetic Specification, except this method does not necessarily return a copy of this object.).</p>

<p><a id="Copy"></a>
### Copy</p>

<pre>public PeterO.Numbers.EFloat Copy();
</pre>

<p>Creates a copy of this arbitrary-precision binary number.</p>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision binary floating-point number.</p>

<p><a id="Decrement"></a>
### Decrement</p>

<pre>public PeterO.Numbers.EFloat Decrement();
</pre>

<p>Returns one subtracted from this arbitrary-precision binary floating-point number.</p>

<p><b>Return Value:</b></p>

<p>The given arbitrary-precision binary floating-point number minus one.</p>

<p><a id="GetHashCode"></a>
### GetHashCode</p>

<pre>public override int GetHashCode();
</pre>

<p>Calculates this object’s hash code. No application or process IDs are used in the hash code calculation.</p>

<p><b>Return Value:</b></p>

<p>A 32-bit signed integer.</p>

<p><a id="Increment"></a>
### Increment</p>

<pre>public PeterO.Numbers.EFloat Increment();
</pre>

<p>Returns one added to this arbitrary-precision binary floating-point number.</p>

<p><b>Return Value:</b></p>

<p>The given arbitrary-precision binary floating-point number plus one.</p>

<p><a id="IsInfinity"></a>
### IsInfinity</p>

<pre>public bool IsInfinity();
</pre>

<p>Gets a value indicating whether this object is positive or negative infinity.</p>

<p><b>Return Value:</b></p>

<p><code>true</code>  if this object is positive or negative infinity; otherwise,  <code>false</code> .</p>

<p><a id="IsInteger"></a>
### IsInteger</p>

<pre>public bool IsInteger();
</pre>

<p>Returns whether this object’s value is an integer.</p>

<p><b>Return Value:</b></p>

<p><code>true</code>  if this object’s value is an integer; otherwise,  <code>false</code> .</p>

<p><a id="IsNaN"></a>
### IsNaN</p>

<pre>public bool IsNaN();
</pre>

<p>Gets a value indicating whether this object is not a number (NaN).</p>

<p><b>Return Value:</b></p>

<p><code>true</code>  if this object is not a number (NaN); otherwise,  <code>false</code> .</p>

<p><a id="IsNegativeInfinity"></a>
### IsNegativeInfinity</p>

<pre>public bool IsNegativeInfinity();
</pre>

<p>Returns whether this object is negative infinity.</p>

<p><b>Return Value:</b></p>

<p><code>true</code>  if this object is negative infinity; otherwise,  <code>false</code> .</p>

<p><a id="IsPositiveInfinity"></a>
### IsPositiveInfinity</p>

<pre>public bool IsPositiveInfinity();
</pre>

<p>Returns whether this object is positive infinity.</p>

<p><b>Return Value:</b></p>

<p><code>true</code>  if this object is positive infinity; otherwise,  <code>false</code> .</p>

<p><a id="IsQuietNaN"></a>
### IsQuietNaN</p>

<pre>public bool IsQuietNaN();
</pre>

<p>Gets a value indicating whether this object is a quiet not-a-number value.</p>

<p><b>Return Value:</b></p>

<p><code>true</code>  if this object is a quiet not-a-number value; otherwise,  <code>false</code> .</p>

<p><a id="IsSignalingNaN"></a>
### IsSignalingNaN</p>

<pre>public bool IsSignalingNaN();
</pre>

<p>Gets a value indicating whether this object is a signaling not-a-number value.</p>

<p><b>Return Value:</b></p>

<p><code>true</code>  if this object is a signaling not-a-number value; otherwise,  <code>false</code> .</p>

<p><a id="Negate"></a>
### Negate</p>

<pre>public PeterO.Numbers.EFloat Negate();
</pre>

<p>Gets an object with the same value as this one, but with the sign reversed.</p>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision binary floating-point number. If this value is positive zero, returns negative zero. Returns signaling NaN if this value is signaling NaN. (In this sense, this method is similar to the “copy-negate” operation in the General Decimal Arithmetic Specification, except this method does not necessarily return a copy of this object.).</p>

<p><a id="Precision"></a>
### Precision</p>

<pre>public PeterO.Numbers.EInteger Precision();
</pre>

<p>Finds the number of digits in this number’s significand. Returns 1 if this value is 0, and 0 if this value is infinity or not-a-number (NaN).</p>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision integer.</p>

<p><a id="ToByteChecked"></a>
### ToByteChecked</p>

<pre>public byte ToByteChecked();
</pre>

<p>Converts this number’s value to a byte (from 0 to 255) if it can fit in a byte (from 0 to 255) after converting it to an integer by discarding its fractional part.</p>

<p><b>Return Value:</b></p>

<p>This number’s value, truncated to a byte (from 0 to 255).</p>

<p><b>Exceptions:</b></p>

<ul>
  <li>System.OverflowException:
This value is infinity or not-a-number, or the number, once converted to an integer by discarding its fractional part, is less than 0 or greater than 255.</li>
</ul>

<p><a id="ToByteIfExact"></a>
### ToByteIfExact</p>

<pre>public byte ToByteIfExact();
</pre>

<p>Converts this number’s value to a byte (from 0 to 255) if it can fit in a byte (from 0 to 255) without rounding to a different numerical value.</p>

<p><b>Return Value:</b></p>

<p>This number’s value as a byte (from 0 to 255).</p>

<p><b>Exceptions:</b></p>

<ul>
  <li>System.ArithmeticException:
This value is infinity or not-a-number, is not an exact integer, or is less than 0 or greater than 255.</li>
</ul>

<p><a id="ToByteUnchecked"></a>
### ToByteUnchecked</p>

<pre>public byte ToByteUnchecked();
</pre>

<p>Converts this number’s value to an integer by discarding its fractional part, and returns the least-significant bits of its two’s-complement form as a byte (from 0 to 255).</p>

<p><b>Return Value:</b></p>

<p>This number, converted to a byte (from 0 to 255). Returns 0 if this value is infinity or not-a-number.</p>

<p><a id="ToDouble"></a>
### ToDouble</p>

<pre>public double ToDouble();
</pre>

<p>Converts this value to a 64-bit floating-point number encoded in the IEEE 754 binary64 format.</p>

<p><b>Return Value:</b></p>

<p>This number, converted to a 64-bit floating-point number encoded in the IEEE 754 binary64 format. The return value can be positive infinity or negative infinity if this value exceeds the range of a 64-bit floating point number.</p>

<p><a id="ToDoubleBits"></a>
### ToDoubleBits</p>

<pre>public long ToDoubleBits();
</pre>

<p>Converts this value to its closest equivalent as a 64-bit floating-point number, expressed as an integer in the IEEE 754 binary64 format. The half-even rounding mode is used. If this value is a NaN, sets the high bit of the 64-bit floating point number’s significand area for a quiet NaN, and clears it for a signaling NaN. Then the other bits of the significand area are set to the lowest bits of this object’s unsigned significand, and the next-highest bit of the significand area is set if those bits are all zeros and this is a signaling NaN.</p>

<p><b>Return Value:</b></p>

<p>The closest 64-bit binary floating-point number to this value, expressed as an integer in the IEEE 754 binary64 format. The return value can be positive infinity or negative infinity if this value exceeds the range of a 64-bit floating point number.</p>

<p><a id="ToEDecimal"></a>
### ToEDecimal</p>

<pre>public PeterO.Numbers.EDecimal ToEDecimal();
</pre>

<p>Converts this value to an arbitrary-precision decimal number.</p>

<p><b>Return Value:</b></p>

<p>This number, converted to an arbitrary-precision decimal number.</p>

<p><a id="ToEInteger"></a>
### ToEInteger</p>

<pre>public PeterO.Numbers.EInteger ToEInteger();
</pre>

<p>Converts this value to an arbitrary-precision integer. Any fractional part of this value will be discarded when converting to an arbitrary-precision integer. Note that depending on the value, especially the exponent, generating the arbitrary-precision integer may require a huge amount of memory. Use the ToSizedEInteger method to convert a number to an EInteger only if the integer fits in a bounded bit range; that method will throw an exception on overflow.</p>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision integer.</p>

<p><b>Exceptions:</b></p>

<ul>
  <li>System.OverflowException:
This object’s value is infinity or not-a-number (NaN).</li>
</ul>

<p><a id="ToEIntegerExact"></a>
### ToEIntegerExact</p>

<pre>public PeterO.Numbers.EInteger ToEIntegerExact();
</pre>

<p><b>Deprecated.</b> Renamed to ToEIntegerIfExact.</p>

<p>Converts this value to an arbitrary-precision integer, checking whether the value contains a fractional part. Note that depending on the value, especially the exponent, generating the arbitrary-precision integer may require a huge amount of memory. Use the ToSizedEIntegerIfExact method to convert a number to an EInteger only if the integer fits in a bounded bit range; that method will throw an exception on overflow.</p>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision integer.</p>

<p><b>Exceptions:</b></p>

<ul>
  <li>
    <p>System.OverflowException:
This object’s value is infinity or not-a-number (NaN).</p>
  </li>
  <li>
    <p>System.ArithmeticException:
This object’s value is not an exact integer.</p>
  </li>
</ul>

<p><a id="ToEIntegerIfExact"></a>
### ToEIntegerIfExact</p>

<pre>public PeterO.Numbers.EInteger ToEIntegerIfExact();
</pre>

<p>Converts this value to an arbitrary-precision integer, checking whether the value contains a fractional part. Note that depending on the value, especially the exponent, generating the arbitrary-precision integer may require a huge amount of memory. Use the ToSizedEIntegerIfExact method to convert a number to an EInteger only if the integer fits in a bounded bit range; that method will throw an exception on overflow.</p>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision integer.</p>

<p><b>Exceptions:</b></p>

<ul>
  <li>
    <p>System.OverflowException:
This object’s value is infinity or not-a-number (NaN).</p>
  </li>
  <li>
    <p>System.ArithmeticException:
This object’s value is not an exact integer.</p>
  </li>
</ul>

<p><a id="ToEngineeringString"></a>
### ToEngineeringString</p>

<pre>public string ToEngineeringString();
</pre>

<p>Converts this value to an arbitrary-precision decimal number, then returns the value of that decimal’s ToEngineeringString method.</p>

<p><b>Return Value:</b></p>

<p>A text string.</p>

<p><a id="ToExtendedDecimal"></a>
### ToExtendedDecimal</p>

<pre>public PeterO.Numbers.EDecimal ToExtendedDecimal();
</pre>

<p><b>Deprecated.</b> Renamed to ToEDecimal.</p>

<p>Converts this value to an arbitrary-precision decimal number.</p>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision decimal number.</p>

<p><a id="ToHalfBits"></a>
### ToHalfBits</p>

<pre>public short ToHalfBits();
</pre>

<p>Converts this value to its closest equivalent as a binary floating-point number, expressed as an integer in the IEEE 754 binary16 format (also known as a “half-precision” floating-point number). The half-even rounding mode is used. If this value is a NaN, sets the high bit of the binary16 number’s significand area for a quiet NaN, and clears it for a signaling NaN. Then the other bits of the significand area are set to the lowest bits of this object’s unsigned significand, and the next-highest bit of the significand area is set if those bits are all zeros and this is a signaling NaN.</p>

<p><b>Return Value:</b></p>

<p>The closest binary floating-point number to this value, expressed as an integer in the IEEE 754 binary16 format. The return value can be positive infinity or negative infinity if this value exceeds the range of a floating-point number in the binary16 format.</p>

<p><a id="ToInt16Checked"></a>
### ToInt16Checked</p>

<pre>public short ToInt16Checked();
</pre>

<p>Converts this number’s value to a 16-bit signed integer if it can fit in a 16-bit signed integer after converting it to an integer by discarding its fractional part.</p>

<p><b>Return Value:</b></p>

<p>This number’s value, truncated to a 16-bit signed integer.</p>

<p><b>Exceptions:</b></p>

<ul>
  <li>System.OverflowException:
This value is infinity or not-a-number, or the number, once converted to an integer by discarding its fractional part, is less than -32768 or greater than 32767.</li>
</ul>

<p><a id="ToInt16IfExact"></a>
### ToInt16IfExact</p>

<pre>public short ToInt16IfExact();
</pre>

<p>Converts this number’s value to a 16-bit signed integer if it can fit in a 16-bit signed integer without rounding to a different numerical value.</p>

<p><b>Return Value:</b></p>

<p>This number’s value as a 16-bit signed integer.</p>

<p><b>Exceptions:</b></p>

<ul>
  <li>System.ArithmeticException:
This value is infinity or not-a-number, is not an exact integer, or is less than -32768 or greater than 32767.</li>
</ul>

<p><a id="ToInt16Unchecked"></a>
### ToInt16Unchecked</p>

<pre>public short ToInt16Unchecked();
</pre>

<p>Converts this number’s value to an integer by discarding its fractional part, and returns the least-significant bits of its two’s-complement form as a 16-bit signed integer.</p>

<p><b>Return Value:</b></p>

<p>This number, converted to a 16-bit signed integer. Returns 0 if this value is infinity or not-a-number.</p>

<p><a id="ToInt32Checked"></a>
### ToInt32Checked</p>

<pre>public int ToInt32Checked();
</pre>

<p>Converts this number’s value to a 32-bit signed integer if it can fit in a 32-bit signed integer after converting it to an integer by discarding its fractional part.</p>

<p><b>Return Value:</b></p>

<p>This number’s value, truncated to a 32-bit signed integer.</p>

<p><b>Exceptions:</b></p>

<ul>
  <li>System.OverflowException:
This value is infinity or not-a-number, or the number, once converted to an integer by discarding its fractional part, is less than -2147483648 or greater than 2147483647.</li>
</ul>

<p><a id="ToInt32IfExact"></a>
### ToInt32IfExact</p>

<pre>public int ToInt32IfExact();
</pre>

<p>Converts this number’s value to a 32-bit signed integer if it can fit in a 32-bit signed integer without rounding to a different numerical value.</p>

<p><b>Return Value:</b></p>

<p>This number’s value as a 32-bit signed integer.</p>

<p><b>Exceptions:</b></p>

<ul>
  <li>System.ArithmeticException:
This value is infinity or not-a-number, is not an exact integer, or is less than -2147483648 or greater than 2147483647.</li>
</ul>

<p><a id="ToInt32Unchecked"></a>
### ToInt32Unchecked</p>

<pre>public int ToInt32Unchecked();
</pre>

<p>Converts this number’s value to an integer by discarding its fractional part, and returns the least-significant bits of its two’s-complement form as a 32-bit signed integer.</p>

<p><b>Return Value:</b></p>

<p>This number, converted to a 32-bit signed integer. Returns 0 if this value is infinity or not-a-number.</p>

<p><a id="ToInt64Checked"></a>
### ToInt64Checked</p>

<pre>public long ToInt64Checked();
</pre>

<p>Converts this number’s value to a 64-bit signed integer if it can fit in a 64-bit signed integer after converting it to an integer by discarding its fractional part.</p>

<p><b>Return Value:</b></p>

<p>This number’s value, truncated to a 64-bit signed integer.</p>

<p><b>Exceptions:</b></p>

<ul>
  <li>System.OverflowException:
This value is infinity or not-a-number, or the number, once converted to an integer by discarding its fractional part, is less than -9223372036854775808 or greater than 9223372036854775807.</li>
</ul>

<p><a id="ToInt64IfExact"></a>
### ToInt64IfExact</p>

<pre>public long ToInt64IfExact();
</pre>

<p>Converts this number’s value to a 64-bit signed integer if it can fit in a 64-bit signed integer without rounding to a different numerical value.</p>

<p><b>Return Value:</b></p>

<p>This number’s value as a 64-bit signed integer.</p>

<p><b>Exceptions:</b></p>

<ul>
  <li>System.ArithmeticException:
This value is infinity or not-a-number, is not an exact integer, or is less than -9223372036854775808 or greater than 9223372036854775807.</li>
</ul>

<p><a id="ToInt64Unchecked"></a>
### ToInt64Unchecked</p>

<pre>public long ToInt64Unchecked();
</pre>

<p>Converts this number’s value to an integer by discarding its fractional part, and returns the least-significant bits of its two’s-complement form as a 64-bit signed integer.</p>

<p><b>Return Value:</b></p>

<p>This number, converted to a 64-bit signed integer. Returns 0 if this value is infinity or not-a-number.</p>

<p><a id="ToPlainString"></a>
### ToPlainString</p>

<pre>public string ToPlainString();
</pre>

<p>Converts this value to a string, but without exponential notation.</p>

<p><b>Return Value:</b></p>

<p>A text string.</p>

<p><a id="ToSByteChecked"></a>
### ToSByteChecked</p>

<pre>public sbyte ToSByteChecked();
</pre>

<p><b>This API is not CLS-compliant.</b></p>

<p>Converts this number’s value to an 8-bit signed integer if it can fit in an 8-bit signed integer after converting it to an integer by discarding its fractional part.</p>

<p><b>Return Value:</b></p>

<p>This number’s value, truncated to an 8-bit signed integer.</p>

<p><b>Exceptions:</b></p>

<ul>
  <li>System.OverflowException:
This value is infinity or not-a-number, or the number, once converted to an integer by discarding its fractional part, is less than -128 or greater than 127.</li>
</ul>

<p><a id="ToSByteIfExact"></a>
### ToSByteIfExact</p>

<pre>public sbyte ToSByteIfExact();
</pre>

<p><b>This API is not CLS-compliant.</b></p>

<p>Converts this number’s value to an 8-bit signed integer if it can fit in an 8-bit signed integer without rounding to a different numerical value.</p>

<p><b>Return Value:</b></p>

<p>This number’s value as an 8-bit signed integer.</p>

<p><b>Exceptions:</b></p>

<ul>
  <li>System.ArithmeticException:
This value is infinity or not-a-number, is not an exact integer, or is less than -128 or greater than 127.</li>
</ul>

<p><a id="ToSByteUnchecked"></a>
### ToSByteUnchecked</p>

<pre>public sbyte ToSByteUnchecked();
</pre>

<p><b>This API is not CLS-compliant.</b></p>

<p>Converts this number’s value to an integer by discarding its fractional part, and returns the least-significant bits of its two’s-complement form as an 8-bit signed integer.</p>

<p><b>Return Value:</b></p>

<p>This number, converted to an 8-bit signed integer. Returns 0 if this value is infinity or not-a-number.</p>

<p><a id="ToSingle"></a>
### ToSingle</p>

<pre>public float ToSingle();
</pre>

<p>Converts this value to its closest equivalent as a 32-bit floating-point number. The half-even rounding mode is used. If this value is a NaN, sets the high bit of the 32-bit floating point number’s significand area for a quiet NaN, and clears it for a signaling NaN. Then the other bits of the significand area are set to the lowest bits of this object’s unsigned significand, and the next-highest bit of the significand area is set if those bits are all zeros and this is a signaling NaN. Unfortunately, in the.NET implementation, the return value of this method may be a quiet NaN even if a signaling NaN would otherwise be generated.</p>

<p><b>Return Value:</b></p>

<p>The closest 32-bit binary floating-point number to this value. The return value can be positive infinity or negative infinity if this value exceeds the range of a 32-bit floating point number.</p>

<p><a id="ToSingleBits"></a>
### ToSingleBits</p>

<pre>public int ToSingleBits();
</pre>

<p>Converts this value to its closest equivalent as 32-bit floating-point number, expressed as an integer in the IEEE 754 binary32 format. The half-even rounding mode is used. If this value is a NaN, sets the high bit of the 32-bit floating point number’s significand area for a quiet NaN, and clears it for a signaling NaN. Then the other bits of the significand area are set to the lowest bits of this object’s unsigned significand, and the next-highest bit of the significand area is set if those bits are all zeros and this is a signaling NaN.</p>

<p><b>Return Value:</b></p>

<p>The closest 32-bit binary floating-point number to this value, expressed as an integer in the IEEE 754 binary32 format. The return value can be positive infinity or negative infinity if this value exceeds the range of a 32-bit floating point number.</p>

<p><a id="ToString"></a>
### ToString</p>

<pre>public override string ToString();
</pre>

<p>Converts this number’s value to a text string.</p>

<p><b>Return Value:</b></p>

<p>A string representation of this object. The value is converted to a decimal number (using the EDecimal.FromEFloat method) and the decimal form of this number’s value is returned. The text string will be in exponential notation (expressed as a number 1 or greater, but less than 10, times a power of 10) if the converted decimal number’s exponent (EDecimal’s Exponent property) is greater than 0 or if the number’s first nonzero decimal digit is more than five digits after the decimal point.</p>

<p><a id="ToUInt16Checked"></a>
### ToUInt16Checked</p>

<pre>public ushort ToUInt16Checked();
</pre>

<p><b>This API is not CLS-compliant.</b></p>

<p>Converts this number’s value to a 16-bit unsigned integer if it can fit in a 16-bit unsigned integer after converting it to an integer by discarding its fractional part.</p>

<p><b>Return Value:</b></p>

<p>This number’s value, truncated to a 16-bit unsigned integer.</p>

<p><b>Exceptions:</b></p>

<ul>
  <li>System.OverflowException:
This value is infinity or not-a-number, or the number, once converted to an integer by discarding its fractional part, is less than 0 or greater than 65535.</li>
</ul>

<p><a id="ToUInt16IfExact"></a>
### ToUInt16IfExact</p>

<pre>public ushort ToUInt16IfExact();
</pre>

<p><b>This API is not CLS-compliant.</b></p>

<p>Converts this number’s value to a 16-bit unsigned integer if it can fit in a 16-bit unsigned integer without rounding to a different numerical value.</p>

<p><b>Return Value:</b></p>

<p>This number’s value as a 16-bit unsigned integer.</p>

<p><b>Exceptions:</b></p>

<ul>
  <li>System.ArithmeticException:
This value is infinity or not-a-number, is not an exact integer, or is less than 0 or greater than 65535.</li>
</ul>

<p><a id="ToUInt16Unchecked"></a>
### ToUInt16Unchecked</p>

<pre>public ushort ToUInt16Unchecked();
</pre>

<p><b>This API is not CLS-compliant.</b></p>

<p>Converts this number’s value to an integer by discarding its fractional part, and returns the least-significant bits of its two’s-complement form as a 16-bit unsigned integer.</p>

<p><b>Return Value:</b></p>

<p>This number, converted to a 16-bit unsigned integer. Returns 0 if this value is infinity or not-a-number.</p>

<p><a id="ToUInt32Checked"></a>
### ToUInt32Checked</p>

<pre>public uint ToUInt32Checked();
</pre>

<p><b>This API is not CLS-compliant.</b></p>

<p>Converts this number’s value to a 32-bit signed integer if it can fit in a 32-bit signed integer after converting it to an integer by discarding its fractional part.</p>

<p><b>Return Value:</b></p>

<p>This number’s value, truncated to a 32-bit signed integer.</p>

<p><b>Exceptions:</b></p>

<ul>
  <li>System.OverflowException:
This value is infinity or not-a-number, or the number, once converted to an integer by discarding its fractional part, is less than 0 or greater than 4294967295.</li>
</ul>

<p><a id="ToUInt32IfExact"></a>
### ToUInt32IfExact</p>

<pre>public uint ToUInt32IfExact();
</pre>

<p><b>This API is not CLS-compliant.</b></p>

<p>Converts this number’s value to a 32-bit signed integer if it can fit in a 32-bit signed integer without rounding to a different numerical value.</p>

<p><b>Return Value:</b></p>

<p>This number’s value as a 32-bit signed integer.</p>

<p><b>Exceptions:</b></p>

<ul>
  <li>System.ArithmeticException:
This value is infinity or not-a-number, is not an exact integer, or is less than 0 or greater than 4294967295.</li>
</ul>

<p><a id="ToUInt32Unchecked"></a>
### ToUInt32Unchecked</p>

<pre>public uint ToUInt32Unchecked();
</pre>

<p><b>This API is not CLS-compliant.</b></p>

<p>Converts this number’s value to an integer by discarding its fractional part, and returns the least-significant bits of its two’s-complement form as a 32-bit signed integer.</p>

<p><b>Return Value:</b></p>

<p>This number, converted to a 32-bit signed integer. Returns 0 if this value is infinity or not-a-number.</p>

<p><a id="ToUInt64Checked"></a>
### ToUInt64Checked</p>

<pre>public ulong ToUInt64Checked();
</pre>

<p><b>This API is not CLS-compliant.</b></p>

<p>Converts this number’s value to a 64-bit unsigned integer if it can fit in a 64-bit unsigned integer after converting it to an integer by discarding its fractional part.</p>

<p><b>Return Value:</b></p>

<p>This number’s value, truncated to a 64-bit unsigned integer.</p>

<p><b>Exceptions:</b></p>

<ul>
  <li>System.OverflowException:
This value is infinity or not-a-number, or the number, once converted to an integer by discarding its fractional part, is less than 0 or greater than 18446744073709551615.</li>
</ul>

<p><a id="ToUInt64IfExact"></a>
### ToUInt64IfExact</p>

<pre>public ulong ToUInt64IfExact();
</pre>

<p><b>This API is not CLS-compliant.</b></p>

<p>Converts this number’s value to a 64-bit unsigned integer if it can fit in a 64-bit unsigned integer without rounding to a different numerical value.</p>

<p><b>Return Value:</b></p>

<p>This number’s value as a 64-bit unsigned integer.</p>

<p><b>Exceptions:</b></p>

<ul>
  <li>System.ArithmeticException:
This value is infinity or not-a-number, is not an exact integer, or is less than 0 or greater than 18446744073709551615.</li>
</ul>

<p><a id="ToUInt64Unchecked"></a>
### ToUInt64Unchecked</p>

<pre>public ulong ToUInt64Unchecked();
</pre>

<p><b>This API is not CLS-compliant.</b></p>

<p>Converts this number’s value to an integer by discarding its fractional part, and returns the least-significant bits of its two’s-complement form as a 64-bit unsigned integer.</p>

<p><b>Return Value:</b></p>

<p>This number, converted to a 64-bit unsigned integer. Returns 0 if this value is infinity or not-a-number.</p>

<p><a id="Ulp"></a>
### Ulp</p>

<pre>public PeterO.Numbers.EFloat Ulp();
</pre>

<p>Returns the unit in the last place. The significand will be 1 and the exponent will be this number’s exponent. Returns 1 with an exponent of 0 if this number is infinity or not-a-number (NaN).</p>

<p><b>Return Value:</b></p>

<p>An arbitrary-precision binary floating-point number.</p>

<p><a href="/Numbers/">Back to Numbers start page.</a></p>
</div><nav id="navigation"><ul>
<li><a href="/">Back to start site.</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io">This site's repository (source code)</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io/issues">Post an issue or comment</a></ul>

<div class="noprint">
<p>
<a href="//twitter.com/intent/tweet">Share via Twitter</a>, <a href="//www.facebook.com/sharer/sharer.php" id="sharer">Share via Facebook</a>
</p>
</div>
</nav></body></html>
