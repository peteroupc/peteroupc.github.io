<!DOCTYPE html><html xmlns:dc="http://purl.org/dc/terms/" itemscope itemtype="http://schema.org/Article"><head><meta http-equiv=Content-Type content="text/html; charset=utf-8"><title>More Algorithms for Arbitrary-Precision Sampling</title><meta name="citation_title" content="More Algorithms for Arbitrary-Precision Sampling"><meta name="og:title" content="More Algorithms for Arbitrary-Precision Sampling"><meta name="og:type" content="article"><meta name="og:site_name" content="peteroupc.github.io"><meta name="twitter:title" content="More Algorithms for Arbitrary-Precision Sampling"><meta name="author" content="Peter Occil"/><meta name="viewport" content="width=device-width"><link rel=stylesheet type="text/css" href="/style.css"></head><body>  <div class="header">
<nav><p><a href="#navigation">Menu</a> - <a href="#top">Top</a> - <a href="/">Home</a></nav></div>
<div class="mainarea" id="top">
<h1>More Algorithms for Arbitrary-Precision Sampling</h1>

<p><a href="mailto:poccil14@gmail.com"><strong>Peter Occil</strong></a></p>

<p>This page contains additional algorithms for arbitrary-precision sampling of continuous distributions, Bernoulli factory algorithms (biased-coin to biased-coin algorithms), and algorithms to simulate irrational probabilities.  These samplers are designed to not rely on floating-point arithmetic.  They may depend on algorithms given in the following pages:</p>

<ul>
<li><a href="https://peteroupc.github.io/exporand.html"><strong>Partially-Sampled Random Numbers for Accurate Sampling of Continuous Distributions</strong></a></li>
<li><a href="https://peteroupc.github.io/bernoulli.html"><strong>Bernoulli Factory Algorithms</strong></a></li>
</ul>

<p><a id=Contents></a></p>

<h2>Contents</h2>

<ul>
<li><a href="#Contents"><strong>Contents</strong></a></li>
<li><a href="#Bernoulli_Factories_and_Irrational_Probability_Simulation"><strong>Bernoulli Factories and Irrational Probability Simulation</strong></a>

<ul>
<li><a href="#Certain_Numbers_Based_on_the_Golden_Ratio"><strong>Certain Numbers Based on the Golden Ratio</strong></a></li>
<li><a href="#Ratio_of_Lower_Gamma_Functions_gamma__m___n__gamma__m__1"><strong>Ratio of Lower Gamma Functions (&gamma;(<em>m</em>, <em>n</em>)/&gamma;(<em>m</em>, 1)).</strong></a></li>
<li><a href="#Derivative_slope_of_arctan___lambda"><strong>Derivative (slope) of arctan(<em>&lambda;</em>)</strong></a></li>
<li><a href="#tanh___lambda"><strong>tanh(<em>&lambda;</em>)</strong></a></li>
<li><a href="#Certain_Piecewise_Linear_Functions"><strong>Certain Piecewise Linear Functions</strong></a></li>
</ul></li>
<li><a href="#General_Arbitrary_Precision_Samplers"><strong>General Arbitrary-Precision Samplers</strong></a>

<ul>
<li><a href="#Uniform_Distribution_Inside_N_Dimensional_Shapes"><strong>Uniform Distribution Inside N-Dimensional Shapes</strong></a></li>
<li><a href="#Building_an_Arbitrary_Precision_Sampler"><strong>Building an Arbitrary-Precision Sampler</strong></a></li>
<li><a href="#Mixtures"><strong>Mixtures</strong></a></li>
</ul></li>
<li><a href="#Specific_Arbitrary_Precision_Samplers"><strong>Specific Arbitrary-Precision Samplers</strong></a>

<ul>
<li><a href="#Rayleigh_Distribution"><strong>Rayleigh Distribution</strong></a></li>
<li><a href="#Sum_of_Exponential_Random_Numbers"><strong>Sum of Exponential Random Numbers</strong></a></li>
<li><a href="#Hyperbolic_Secant_Distribution"><strong>Hyperbolic Secant Distribution</strong></a></li>
<li><a href="#Reciprocal_of_Power_of_Uniform"><strong>Reciprocal of Power of Uniform</strong></a></li>
<li><a href="#Distribution_of__U__1_minus__U"><strong>Distribution of <em>U</em>/(1&minus;<em>U</em>)</strong></a></li>
<li><a href="#Arc_Cosine_Distribution"><strong>Arc-Cosine Distribution</strong></a></li>
<li><a href="#Logistic_Distribution"><strong>Logistic Distribution</strong></a></li>
<li><a href="#Cauchy_Distribution"><strong>Cauchy Distribution</strong></a></li>
<li><a href="#Exponential_Distribution_with_Rate_ln__x"><strong>Exponential Distribution with Rate ln(<em>x</em>)</strong></a></li>
<li><a href="#Lindley_Distribution_and_Lindley_Like_Mixtures"><strong>Lindley Distribution and Lindley-Like Mixtures</strong></a></li>
</ul></li>
<li><a href="#Requests_and_Open_Questions"><strong>Requests and Open Questions</strong></a></li>
<li><a href="#Notes"><strong>Notes</strong></a></li>
<li><a href="#Appendix"><strong>Appendix</strong></a>

<ul>
<li><a href="#Ratio_of_Uniforms"><strong>Ratio of Uniforms</strong></a></li>
<li><a href="#Implementation_Notes_for_Box_Shape_Intersection"><strong>Implementation Notes for Box/Shape Intersection</strong></a></li>
<li><a href="#SymPy_Code_for_Piecewise_Linear_Factory_Functions"><strong>SymPy Code for Piecewise Linear Factory Functions</strong></a></li>
</ul></li>
<li><a href="#License"><strong>License</strong></a></li>
</ul>

<p><a id=Bernoulli_Factories_and_Irrational_Probability_Simulation></a></p>

<h2>Bernoulli Factories and Irrational Probability Simulation</h2>

<p>&nbsp;</p>

<p>In the methods below, <em>&lambda;</em> is the unknown probability of heads of the coin involved in the Bernoulli Factory problem.</p>

<p><a id=Certain_Numbers_Based_on_the_Golden_Ratio></a></p>

<h3>Certain Numbers Based on the Golden Ratio</h3>

<p>The following algorithm given by Fishman and Miller (2013)<sup><a href="#Note1"><strong>(1)</strong></a></sup> finds the continued fraction expansion of certain numbers described as&mdash;</p>

<ul>
<li><em>G</em>(<em>m</em>, <em>&#x2113;</em>) = (<em>m</em> + sqrt(<em>m</em><sup>2</sup> + 4 * <em>&#x2113;</em>))/2<br>&nbsp;&nbsp;&nbsp;&nbsp;or (<em>m</em> &minus; sqrt(<em>m</em><sup>2</sup> + 4 * <em>&#x2113;</em>))/2,</li>
</ul>

<p>whichever results in a real number greater than 1, where <em>m</em> is a positive integer and <em>&#x2113;</em> is either 1 or &minus;1.  In this case, <em>G</em>(1, 1) is the golden ratio.</p>

<p>First, define the following operations:</p>

<ul>
<li><strong>Get the previous and next Fibonacci-based number given <em>k</em>, <em>m</em>, and <em>&#x2113;</em></strong>:

<ol>
<li>If <em>k</em> is 0 or less, return an error.</li>
<li>Set <em>g0</em> to 0, <em>g1</em> to 1, <em>x</em> to 0, and <em>y</em> to 0.</li>
<li>Do the following <em>k</em> times: Set <em>y</em> to <em>m</em> * <em>g1</em> + <em>&#x2113;</em> * <em>g0</em>, then set <em>x</em> to <em>g0</em>, then set <em>g0</em> to <em>g1</em>, then set <em>g1</em> to <em>y</em>.</li>
<li>Return <em>x</em> and <em>y</em>, in that order.</li>
</ol></li>
<li><strong>Get the partial denominator given <em>pos</em>, <em>k</em>, <em>m</em>, and <em>&#x2113;</em></strong> (this partial denominator is part of the continued fraction expansion found by Fishman and Miller):

<ol>
<li><strong>Get the previous and next Fibonacci-based number given <em>k</em>, <em>m</em>, and <em>&#x2113;</em></strong>, call them <em>p</em> and <em>n</em>, respectively.</li>
<li>If <em>&#x2113;</em> is 1 and <em>k</em> is odd, return <em>p</em> + <em>n</em>.</li>
<li>If <em>&#x2113;</em> is &minus;1 and <em>pos</em> is 0, return <em>n</em> &minus; <em>p</em> &minus; 1.</li>
<li>If <em>&#x2113;</em> is 1 and <em>pos</em> is 0, return (<em>n</em> + <em>p</em>) &minus; 1.</li>
<li>If <em>&#x2113;</em> is &minus;1 and <em>pos</em> is even, return <em>n</em> &minus; <em>p</em> &minus; 2. (The paper had an error here; the correction given here was verified by Miller via personal communication.)</li>
<li>If <em>&#x2113;</em> is 1 and <em>pos</em> is even, return (<em>n</em> + <em>p</em>) &minus; 2.</li>
<li>Return 1.</li>
</ol></li>
</ul>

<p>An application of the continued fraction algorithm is the following algorithm that generates 1 with probability <em>G</em>(<em>m</em>, <em>&#x2113;</em>)<sup>&minus;<em>k</em></sup> and 0 otherwise, where <em>k</em> is an integer that is 1 or greater (see &quot;Continued Fractions&quot; in my page on Bernoulli factory algorithms). The algorithm starts with <em>pos</em> = 0, then the following steps are taken:</p>

<ol>
<li><strong>Get the partial denominator given <em>pos</em>, <em>k</em>, <em>m</em>, and <em>&#x2113;</em></strong>, call it <em>kp</em>.</li>
<li>With probability <em>kp</em>/(1 + <em>kp</em>), return a number that is 1 with probability 1/<em>kp</em> and 0 otherwise.</li>
<li>Run this algorithm recursively, but with <em>pos</em> = <em>pos</em> + 1.  If the algorithm returns 1, return 0.  Otherwise, go to step 2.</li>
</ol>

<p><a id=Ratio_of_Lower_Gamma_Functions_gamma__m___n__gamma__m__1></a></p>

<h3>Ratio of Lower Gamma Functions (&gamma;(<em>m</em>, <em>n</em>)/&gamma;(<em>m</em>, 1)).</h3>

<ol>
<li>Set <em>ret</em> to the result of <strong>kthsmallest</strong> with the two parameters <em>m</em> and <em>m</em>.</li>
<li>Set <em>k</em> to 1, then set <em>u</em> to point to the same value as <em>ret</em>.</li>
<li>Generate a uniform(0, 1) random number <em>v</em>.</li>
<li>If <em>v</em> is less than <em>u</em>: Set <em>u</em> to <em>v</em>, then add 1 to <em>k</em>, then go to step 3.</li>
<li>If <em>k</em> is odd, return a number that is 1 if <em>ret</em> is less than <em>n</em> and 0 otherwise. (If <em>ret</em> is implemented as a uniform partially-sampled random number (PSRN), this comparison should be done via <strong>URandLessThanReal</strong>.)  If <em>k</em> is even, go to step 1.</li>
</ol>

<p><a id=Derivative_slope_of_arctan___lambda></a></p>

<h3>Derivative (slope) of arctan(<em>&lambda;</em>)</h3>

<p>This algorithm involves the series expansion of this function (1 &minus; <em>&lambda;</em><sup>2</sup> + <em>&lambda;</em><sup>4</sup> &minus; ...) and involves the general martingale algorithm.</p>

<ol>
<li>Set <em>u</em> to 1, set <em>w</em> to 1, set <em>&#x2113;</em> to 0, and set <em>n</em> to 1.</li>
<li>Generate a uniform(0, 1) random number <em>ret</em>.</li>
<li>(Loop.) If <em>w</em> is not 0, flip the input coin and multiply <em>w</em> by the result of the flip.  Do this step again.</li>
<li>If <em>n</em> is even, set <em>u</em> to <em>&#x2113;</em> + <em>w</em>.  Otherwise, set <em>&#x2113;</em> to <em>u</em> &minus; <em>w</em>.</li>
<li>If <em>ret</em> is less than (or equal to) <em>&#x2113;</em>, return 1.  If <em>ret</em> is less than <em>u</em>, go to the next step.  If neither is the case, return 0.  (If <em>ret</em> is a uniform PSRN, these comparisons should be done via the <strong>URandLessThanReal algorithm</strong>, which is described in my <a href="https://peteroupc.github.io/exporand.html"><strong>article on PSRNs</strong></a>.)</li>
<li>Add 1 to <em>n</em> and go to step 3.</li>
</ol>

<p><a id=tanh___lambda></a></p>

<h3>tanh(<em>&lambda;</em>)</h3>

<p>There are two algorithms.</p>

<p>The first uses Lambert&#39;s continued fraction for tanh(.), as well as Bernoulli Factory algorithm 3 for continued fractions.  The algorithm begins with <em>pos</em> equal to 1.  Then the following steps are taken.</p>

<ol>
<li>If <em>pos</em> is 1: With probability 1/2, flip the input coin and return the result.</li>
<li>If <em>pos</em> is greater than 1, then do the following with probability <em>pos</em>/(1+<em>pos</em>):

<ul>
<li>Flip the input coin twice.  If any of these flips returns 0, return 0.  Otherwise, return a number that is 1 with probability 1/<em>pos</em> and 0 otherwise.</li>
</ul></li>
<li>Run this algorithm recursively, but with <em>pos</em> = <em>pos</em> + 2.  If the result is 1, return 0.  Otherwise, go to step 1.</li>
</ol>

<p>The second algorithm involves the series expansion of tanh(.) and involves the general martingale algorithm.</p>

<p>First, define the following operation:</p>

<ul>
<li><strong>Get the <em>m</em><sup>th</sup> Bernoulli number</strong>:

<ol>
<li>If <em>m</em> is 0, 1, 2, 3, or 4, return 1, &minus;1/2, 1/6, 0, or &minus;1/30, respectively.  Otherwise, if <em>m</em> is odd, return 0.</li>
<li>Set <em>i</em> to 2 and <em>v</em> to 1 &minus; (<em>m</em>+1)/2.</li>
<li>While <em>i</em> is less than <em>m</em>:

<ol>
<li><strong>Get the <em>i</em><sup>th</sup> Bernoulli number</strong>, call it <em>b</em>.  Add <em>b</em>*choose(<em>m</em>+1, <em>i</em>) to <em>v</em>.<sup><a href="#Note2"><strong>(2)</strong></a></sup></li>
<li>Add 2 to <em>i</em>.</li>
</ol></li>
<li>Return &minus;<em>v</em>/(<em>m</em>+1).</li>
</ol></li>
</ul>

<p>The algorithm is then as follows:</p>

<ol>
<li>Flip the input coin.  If it returns 0, return 0.</li>
<li>Set <em>u</em> to 1, set <em>w</em> to 1, set <em>&#x2113;</em> to 0, and set <em>n</em> to 1.</li>
<li>Generate a uniform(0, 1) random number <em>ret</em>.</li>
<li>(Loop.) If <em>w</em> is not 0, flip the input coin. If the flip returns 0, set <em>w</em> to 0. Do this step again.</li>
<li>Let <em>m</em> be 2*(<em>n</em>+1).  <strong>Get the <em>m</em><sup>th</sup> Bernoulli number</strong>, call it <em>b</em>. Let <em>t</em> be abs(<em>b</em>)*2<sup><em>m</em></sup>*(2<sup><em>m</em></sup>&minus;1)/(<em>m</em>!).</li>
<li>If <em>n</em> is even, set <em>u</em> to <em>&#x2113;</em> + <em>w</em> * <em>t</em>.  Otherwise, set <em>&#x2113;</em> to <em>u</em> &minus; <em>w</em> * <em>t</em>.</li>
<li>If <em>ret</em> is less than (or equal to) <em>&#x2113;</em>, return 1.  If <em>ret</em> is less than <em>u</em>, go to the next step.  If neither is the case, return 0.  (If <em>ret</em> is a uniform PSRN, these comparisons should be done via the <strong>URandLessThanReal algorithm</strong>, which is described in my <a href="https://peteroupc.github.io/exporand.html"><strong>article on PSRNs</strong></a>.)</li>
<li>Add 1 to <em>n</em> and go to step 4.</li>
</ol>

<p><a id=Certain_Piecewise_Linear_Functions></a></p>

<h3>Certain Piecewise Linear Functions</h3>

<p>Let <em>f</em>(<em>&lambda;</em>) be a function of the form min(<em>&lambda;</em>*<em>mult</em>, 1&minus;<em>&epsilon;</em>). (This is a piecewise linear function with two pieces: a rising linear part and a constant part.) This section describes how to calculate the Bernstein coefficients for polynomials that converge from above and below to <em>f</em>, based on Thomas and Blanchet (2012)<sup><a href="#Note3"><strong>(3)</strong></a></sup>.  These polynomials can then be used to generate heads with probability <em>f</em>(<em>&lambda;</em>) via the algorithms given in &quot;<a href="https://peteroupc.github.io/bernoulli.html#General_Factory_Functions"><strong>General Factory Functions</strong></a>&quot;.</p>

<p>The code in the <a href="#Appendix"><strong>appendix</strong></a> uses the computer algebra library SymPy to calculate a list of parameters for a sequence of polynomials converging from above.  The method to do so is called <code>calc_linear_func(eps, mult, count)</code>, where <code>eps</code> is <em>&epsilon;</em>, <code>mult</code> = <em>mult</em>, and <code>count</code> is the number of polynomials to generate.  Each item returned by <code>calc_linear_func</code> is a list of two items: the degree of the polynomial, and a <em>Y parameter</em>.  The procedure to calculate the required polynomials is then logically as follows (as written, it runs very slowly, though):</p>

<ol>
<li>Set <em>i</em> to 1.</li>
<li>Run <code>calc_linear_func(eps, mult, i)</code> and get the degree and <em>Y parameter</em> for the last listed item, call them <em>n</em> and <em>y</em>, respectively.</li>
<li>Set <em>x</em> to &minus;((<em>y</em>&minus;(1&minus;<em>&epsilon;</em>))/<em>&epsilon;</em>)<sup>5</sup>/<em>mult</em> + <em>y</em>/<em>mult</em>.  (This exact formula doesn&#39;t appear in the Thomas and Blanchet paper; rather it comes from the <a href="https://github.com/acthomasca/rberfac/blob/main/rberfac-public-2.R"><strong>supplemental source code</strong></a> uploaded by A. C. Thomas at my request.</li>
<li>For the <em>i</em><sup>th</sup> upper polynomial, the <em>k</em><sup>th</sup> Bernstein coefficient (starting at 0) is min((<em>k</em>/<em>n</em>)*<em>y</em>/<em>x</em>,<em>y</em>).</li>
<li>For the <em>i</em><sup>th</sup> lower polynomial, the <em>k</em><sup>th</sup> Bernstein coefficient (starting at 0) is min((<em>k</em>/<em>n</em>)*<em>mult</em>, 1&minus;<em>&epsilon;</em>).  (This matches <em>f</em> because <em>f</em> is <em>concave</em> in the interval [0, 1], which roughly means that its rate of growth there never goes up.)</li>
<li>Add 1 to <em>i</em> and go to step 2.</li>
</ol>

<p>It would be interesting to find general formulas to find the appropriate polynomials (degrees and <em>Y parameters</em>) given only the values for <em>mult</em> and <em>&epsilon;</em>, rather than find them &quot;the hard way&quot; via <code>calc_linear_func</code>.  For this procedure, the degrees and <em>Y parameters</em> can be upper bounds, as long as the sequence of degrees is monotonically increasing and the sequence of Y parameters is nonincreasing.</p>

<p><a id=General_Arbitrary_Precision_Samplers></a></p>

<h2>General Arbitrary-Precision Samplers</h2>

<p>&nbsp;</p>

<p><a id=Uniform_Distribution_Inside_N_Dimensional_Shapes></a></p>

<h3>Uniform Distribution Inside N-Dimensional Shapes</h3>

<p>The following is a general way to describe an arbitrary-precision sampler for generating a point uniformly at random inside a geometric shape located entirely in the hypercube [0, <em>d1</em>]&times;[0, <em>d2</em>]&times;...&times;[0,<em>dN</em>] in <em>N</em>-dimensional space, where <em>d1</em>, ..., <em>dN</em> are integers greater than 0. The algorithm will generally work if the shape is reasonably defined; the technical requirements are that the shape must have a zero-volume boundary and a nonzero finite volume, and must assign zero probability to any zero-volume subset of it (such as a set of individual points).</p>

<p>The sampler&#39;s description has the following skeleton.</p>

<ol>
<li>Generate <em>N</em> empty uniform partially-sampled random numbers (PSRNs), with a positive sign, an integer part of 0, and an empty fractional part.  Call the PSRNs <em>p1</em>, <em>p2</em>, ..., <em>pN</em>.</li>
<li>Set <em>S</em> to <em>base</em>, where <em>base</em> is the base of digits to be stored by the PSRNs (such as 2 for binary or 10 for decimal).  Then set <em>N</em> coordinates to 0, call the coordinates <em>c1</em>, <em>c2</em>, ..., <em>cN</em>.  Then set <em>d</em> to 1.  Then, for each coordinate (<em>c1</em>, ..., <em>cN</em>), set that coordinate to an integer in [0, <em>dX</em>), chosen uniformly at random, where <em>dX</em> is the corresponding dimension&#39;s size.</li>
<li>For each coordinate (<em>c1</em>, ..., <em>cN</em>), multiply that coordinate by <em>base</em> and add a digit chosen uniformly at random to that coordinate.</li>
<li>This step uses a function known as <strong>InShape</strong>, which takes the coordinates of a box and returns one of three values: <em>YES</em> if the box is entirely inside the shape; <em>NO</em> if the box is entirely outside the shape; and <em>MAYBE</em> if the box is partly inside and partly outside the shape, or if the function is unsure.  <strong>InShape</strong>, as well as the divisions of the coordinates by <em>S</em>, should be implemented using rational arithmetic.  Instead of dividing those coordinates this way, an implementation can pass <em>S</em> as a separate parameter to <strong>InShape</strong>.  See the <a href="#Implementation_Notes_for_Box_Shape_Intersection"><strong>appendix</strong></a> for further implementation notes.  In this step, run <strong>InShape</strong> using the current box, whose coordinates in this case are ((<em>c1</em>/<em>S</em>, <em>c2</em>/<em>S</em>, ..., <em>cN</em>/<em>S</em>), ((<em>c1</em>+1)/<em>S</em>, (<em>c2</em>+1)/<em>S</em>, ..., (<em>cN</em>+1)/<em>S</em>)).</li>
<li>If the result of <strong>InShape</strong> is <em>YES</em>, then the current box was accepted.  If the box is accepted this way, then at this point, <em>c1</em>, <em>c2</em>, etc., will each store the <em>d</em> digits of a coordinate in the shape, expressed as a number in the interval [0, 1], or more precisely, a range of numbers.  (For example, if <em>base</em> is 10, <em>d</em> is 3, and <em>c1</em> is 342, then the first coordinate is 0.342, or more precisely, a number in the interval [0.342, 0.343].)  In this case, do the following:

<ol>
<li>For each coordinate (<em>c1</em>, ..., <em>cN</em>), transfer that coordinate&#39;s least significant digits to the corresponding PSRN&#39;s fractional part.  The variable <em>d</em> tells how many digits to transfer to each PSRN this way. Then, for each coordinate (<em>c1</em>, ..., <em>cN</em>), set the corresponding PSRN&#39;s integer part to floor(<em>cX</em>/<em>base</em><sup><em>d</em></sup>), where <em>cX</em> is that coordinate.  (For example, if <em>base</em> is 10, <em>d</em> is 3, and <em>c1</em> is 7342, set <em>p1</em>&#39;s fractional part to [3, 4, 2] and <em>p1</em>&#39;s integer part to 7.)</li>
<li>For each PSRN (<em>p1</em>, ..., <em>pN</em>), optionally fill that PSRN with uniform random digits as necessary to give its fractional part the desired number of digits (similarly to <strong>FillGeometricBag</strong>).</li>
<li>For each PSRN, optionally do the following: With probability 1/2, set that PSRN&#39;s sign to negative. (This will result in a symmetric shape in the corresponding dimension.  This step can be done for some PSRNs and not others.)</li>
<li>Return the PSRNs <em>p1</em>, ..., <em>pN</em>, in that order.</li>
</ol></li>
<li>If the result of <strong>InShape</strong> is <em>NO</em>, then the current box lies outside the shape and is rejected.  In this case, go to step 2.</li>
<li>If the result of <strong>InShape</strong> is <em>MAYBE</em>, it is not known whether the current box lies fully inside the shape, so multiply <em>S</em> by <em>base</em>, then add 1 to <em>d</em>, then go to step 3.</li>
</ol>

<blockquote>
<p><strong>Notes:</strong></p>

<ul>
<li>See (Li and El Gamal 2016)<sup><a href="#Note4"><strong>(4)</strong></a></sup> and (Oberhoff 2018)<sup><a href="#Note5"><strong>(5)</strong></a></sup> for related work on encoding random points uniformly distributed in a shape.</li>
<li>Rejection sampling on a shape is subject to the &quot;curse of dimensionality&quot;, since typical shapes of high dimension will tend to cover much less volume than their bounding boxes, so that it would take a lot of time on average to accept a high-dimensional box.  Moreover, the more area the shape takes up in the bounding box, the higher the acceptance rate.</li>
<li>Devroye (1986, chapter 8, section 3)<sup><a href="#Note6"><strong>(6)</strong></a></sup> describes grid-based methods to optimize random point generation.  In this case, the space is divided into a grid of boxes each with size 1/<em>base</em><sup><em>k</em></sup> in all dimensions; the result of <strong>InShape</strong> is calculated for each such box and that box labeled with the result; all boxes labeled <em>NO</em> are discarded; and the algorithm is modified by adding the following after step 2: &quot;2a. Choose a precalculated box uniformly at random, then set <em>c1</em>, ..., <em>cN</em> to that box&#39;s coordinates, then set <em>d</em> to <em>k</em> and set <em>S</em> to <em>base</em><sup><em>k</em></sup>. If a box labeled <em>YES</em> was chosen, follow the substeps in step 5. If a box labeled <em>MAYBE</em> was chosen, multiply <em>S</em> by <em>base</em> and add 1 to <em>d</em>.&quot; (For example, if <em>base</em> is 10, <em>k</em> is 1, <em>N</em> is 2, and <em>d1</em> = <em>d2</em> = 1, the space could be divided into a 10&times;10 grid, made up of 100 boxes each of size (1/10)&times;(1/10).  Then, <strong>InShape</strong> is precalculated for the box with coordinates ((0, 0), (1, 1)), the box ((0, 1), (1, 2)), and so on [the boxes&#39; coordinates are stored as just given, but <strong>InShape</strong> instead uses those coordinates divided by <em>base</em><sup><em>k</em></sup>, or 10<sup>1</sup> in this case], each such box is labeled with the result, and boxes labeled <em>NO</em> are discarded.  Finally the algorithm above is modified as just given.)</li>
<li>Besides a grid, another useful data structure is a <em>mapped regular paving</em> (Harlow et al. 2012)<sup><a href="#Note7"><strong>(7)</strong></a></sup>, which can be described as a binary tree with nodes each consisting of zero or two child nodes and a marking value.  Start with a box that entirely covers the desired shape.  Calculate <strong>InShape</strong> for the box.  If it returns <em>YES</em> or <em>NO</em> then mark the box with <em>YES</em> or <em>NO</em>, respectively; otherwise it returns <em>MAYBE</em>, so divide the box along its first widest coordinate into two sub-boxes, set the parent box&#39;s children to those sub-boxes, then repeat this process for each sub-box (or if the nesting level is too deep, instead mark each sub-box with <em>MAYBE</em>).  Then, to generate a random point (with a base-2 fractional part), start from the root, then: (1) If the box is marked <em>YES</em>, return a uniform random point between the given coordinates using the <strong>RandUniformInRange</strong> algorithm; or (2) if the box is marked <em>NO</em>, start over from the root; or (3) if the box is marked <em>MAYBE</em>, get the two child boxes bisected from the box, choose one of them with equal probability (e.g., choose the left child if an unbiased random bit is 0, or the right child otherwise), mark the chosen child with the result of <strong>InShape</strong> for that child, and repeat this process with that child; or (4) the box has two child boxes, so choose one of them with equal probability and repeat this process with that child.</li>
</ul>

<p><strong>Examples:</strong></p>

<ul>
<li>The following example generates a point inside a quarter diamond (centered at (0, ..., 0), &quot;radius&quot; <em>k</em> where <em>k</em> is an integer greater than 0): Let <em>d1</em>, ..., <em>dN</em> be <em>k</em>. Let <strong>InShape</strong> return <em>YES</em> if ((<em>c1</em>+1) + ... + (<em>cN</em>+1)) &lt; <em>S</em>*<em>k</em>; <em>NO</em> if (<em>c1</em> + ... + <em>cN</em>) &gt; <em>S</em>*<em>k</em>; and <em>MAYBE</em> otherwise.  For a full diamond, step 5.3 in the algorithm is done for all <em>N</em> dimensions.</li>
<li>The following example generates a point inside a quarter hypersphere (centered at (0, ..., 0), radius <em>k</em> where <em>k</em> is an integer greater than 0): Let <em>d1</em>, ..., <em>dN</em> be <em>k</em>. Let <strong>InShape</strong> return <em>YES</em> if ((<em>c1</em>+1)<sup>2</sup> + ... + (<em>cN</em>+1)<sup>2</sup>) &lt; (<em>S</em>*<em>k</em>)<sup>2</sup>; <em>NO</em> if (<em>c1</em><sup>2</sup> + ... + <em>cN</em><sup>2</sup>) &gt; (<em>S</em>*<em>k</em>)<sup>2</sup>; and <em>MAYBE</em> otherwise.  For a full hypersphere with radius 1, step 5.3 in the algorithm is done for all <em>N</em> dimensions.  In the case of a 2-dimensional circle, this algorithm thus adapts the well-known rejection technique of generating X and Y coordinates until X<sup>2</sup>+Y<sup>2</sup> &lt; 1 (e.g., (Devroye 1986, p. 230 et seq.)<sup><a href="#Note6"><strong>(6)</strong></a></sup>).</li>
<li>The following example generates a point inside a quarter <em>astroid</em> (centered at (0, ..., 0), radius <em>k</em> where <em>k</em> is an integer greater than 0): Let <em>d1</em>, ..., <em>dN</em> be <em>k</em>. Let <strong>InShape</strong> return <em>YES</em> if ((<em>sk</em>&minus;<em>c1</em>&minus;1)<sup>2</sup> + ... + (<em>sk</em>&minus;<em>cN</em>&minus;1)<sup>2</sup>) &gt; <em>sk</em><sup>2</sup>; <em>NO</em> if ((<em>sk</em>&minus;<em>c1</em>)<sup>2</sup> + ... + (<em>sk</em>&minus;<em>cN</em>)<sup>2</sup>) &lt; <em>sk</em><sup>2</sup>; and <em>MAYBE</em> otherwise, where <em>sk</em> = <em>S</em>*<em>k</em>.  For a full astroid, step 5.3 in the algorithm is done for all <em>N</em> dimensions.</li>
</ul>
</blockquote>

<p><a id=Building_an_Arbitrary_Precision_Sampler></a></p>

<h3>Building an Arbitrary-Precision Sampler</h3>

<p>In many cases, if a continuous distribution&mdash;</p>

<ul>
<li>has a probability density function (PDF), or a function proportional to the PDF, with a known symbolic form,</li>
<li>has a cumulative distribution function (CDF) with a known symbolic form,</li>
<li>takes on only values 0 or greater, and</li>
<li>has a PDF that has an infinite tail to the right, is bounded from above (that is, <em>PDF(0)</em> is other than infinity), and decreases monotonically,</li>
</ul>

<p>it may be possible to describe an arbitrary-precision sampler for that distribution.  Such a description has the following skeleton.</p>

<ol>
<li>With probability <em>A</em>, set <em>intval</em> to 0, then set <em>size</em> to 1, then go to step 4.

<ul>
<li><em>A</em> is calculated as (<em>CDF</em>(1) &minus; <em>CDF</em>(0)) / (1&minus;<em>CDF</em>(0)), where <em>CDF</em> is the distribution&#39;s CDF.  This should be found analytically using a computer algebra system such as SymPy.</li>
<li>The symbolic form of <em>A</em> will help determine which Bernoulli factory algorithm, if any, will simulate the probability; if a Bernoulli factory exists, it should be used.</li>
</ul></li>
<li>Set <em>intval</em> to 1 and set <em>size</em> to 1.</li>
<li>With probability <em>B</em>(<em>size</em>, <em>intval</em>), go to step 4.  Otherwise, add <em>size</em> to <em>intval</em>, then multiply <em>size</em> by 2, then repeat this step.

<ul>
<li>This step chooses an interval beyond 1, and grows this interval by geometric steps, so that an appropriate interval is chosen with the correct probability.</li>
<li>The probability <em>B</em>(<em>size</em>, <em>intval</em>) is the probability that the interval is chosen given that the previous intervals weren&#39;t chosen, and is calculated as (<em>CDF</em>(<em>size</em> + <em>intval</em>) &minus; <em>CDF</em>(<em>intval</em>)) / (1&minus;<em>CDF</em>(<em>intval</em>)).  This should be found analytically using a computer algebra system such as SymPy.</li>
<li>The symbolic form of <em>B</em> will help determine which Bernoulli factory algorithm, if any, will simulate the probability; if a Bernoulli factory exists, it should be used.</li>
</ul></li>
<li>Generate an integer in the interval [<em>intval</em>, <em>intval</em> + <em>size</em>) uniformly at random, call it <em>i</em>.</li>
<li>Create a positive-sign zero-integer-part uniform PSRN, <em>ret</em>.</li>
<li>Create an input coin that calls <strong>SampleGeometricBag</strong> on the PSRN <em>ret</em>.  Run a Bernoulli factory algorithm that simulates the probability <em>C</em>(<em>i</em>, <em>&lambda;</em>), using the input coin (here, <em>&lambda;</em> is the probability built up in <em>ret</em> via <strong>SampleGeometricBag</strong>, and lies in the interval [0, 1]).  If the call returns 0, go to step 4.

<ul>
<li>The probability <em>C</em>(<em>i</em>, <em>&lambda;</em>) is calculated as <em>PDF</em>(<em>i</em> + <em>&lambda;</em>) / <em>M</em>, where <em>PDF</em> is the distribution&#39;s PDF or a function proportional to the PDF, and should be found analytically using a computer algebra system such as SymPy.</li>
<li>In this formula, <em>M</em> is any convenient number in the interval [<em>PDF</em>(<em>intval</em>),  max(1, <em>PDF</em>(<em>intval</em>))], and should be as low as feasible. <em>M</em> serves to ensure that <em>C</em> is as close as feasible to 1 (to improve acceptance rates), but no higher than 1.  The choice of <em>M</em> can vary for each interval (each value of <em>intval</em>, which can only be 0, 1, or a power of 2).  Any such choice for <em>M</em> preserves the algorithm&#39;s correctness because the PDF has to be monotonically decreasing and a new interval isn&#39;t chosen when <em>&lambda;</em> is rejected.</li>
<li>The symbolic form of <em>C</em> will help determine which Bernoulli factory algorithm, if any, will simulate the probability; if a Bernoulli factory exists, it should be used.</li>
</ul></li>
<li>The PSRN <em>ret</em> was accepted, so set <em>ret</em>&#39;s integer part to <em>i</em>, then optionally fill <em>ret</em> with uniform random digits as necessary to give its fractional part the desired number of digits (similarly to <strong>FillGeometricBag</strong>), then return <em>ret</em>.</li>
</ol>

<p>Examples of algorithms that use this skeleton are the algorithm for the <a href="https://peteroupc.github.io/uniformsum.html"><strong>ratio of two uniform random numbers</strong></a>, as well as the algorithms for the Rayleigh distribution and for the reciprocal of power of uniform, both given later.</p>

<p>Perhaps the most difficult part of describing an arbitrary-precision sampler with this skeleton is finding the appropriate Bernoulli factory for the probabilities <em>A</em>, <em>B</em>, and <em>C</em>, especially when these probabilities have a non-trivial symbolic form.</p>

<blockquote>
<p><strong>Note:</strong> The algorithm skeleton uses ideas similar to the inversion-rejection method described in (Devroye 1986, ch. 7, sec. 4.6)<sup><a href="#Note6"><strong>(6)</strong></a></sup>; an exception is that instead of generating a uniform random number and comparing it to calculations of a CDF, this algorithm uses conditional probabilities of choosing a given piece, probabilities labeled <em>A</em> and <em>B</em>.  This approach was taken so that the CDF of the distribution in question is never directly calculated in the course of the algorithm, which furthers the goal of sampling with arbitrary precision and without using floating-point arithmetic.</p>
</blockquote>

<p><a id=Mixtures></a></p>

<h3>Mixtures</h3>

<p>A <em>mixture</em> involves sampling one of several distributions, where each distribution has a separate probability of being sampled.  In general, an arbitrary-precision sampler is possible if all of the following conditions are met:</p>

<ul>
<li>There is a finite number of distributions to choose from.</li>
<li>The probability of sampling each distribution is a rational number, or it can be expressed as a function for which a <a href="https://peteroupc.github.io/bernoulli.html"><strong>Bernoulli factory algorithm</strong></a> exists.</li>
<li>For each distribution, an arbitrary-precision sampler exists.</li>
</ul>

<blockquote>
<p><strong>Example:</strong> One example of a mixture is two beta distributions, with separate parameters.  One beta distribution is chosen with probability exp(&minus;3) (a probability for which a Bernoulli factory algorithm exists) and the other is chosen with the opposite probability.  For the two beta distributions, an arbitrary-precision sampling algorithm exists (see my article on <a href="https://peteroupc.github.io/exporand.html"><strong>partially-sampled random numbers (PSRNs)</strong></a> for details).</p>
</blockquote>

<p><a id=Specific_Arbitrary_Precision_Samplers></a></p>

<h2>Specific Arbitrary-Precision Samplers</h2>

<p>&nbsp;</p>

<p><a id=Rayleigh_Distribution></a></p>

<h3>Rayleigh Distribution</h3>

<p>The following is an arbitrary-precision sampler for the Rayleigh distribution with parameter <em>s</em>, which is a rational number greater than 0.</p>

<ol>
<li>Set <em>k</em> to 0, and set <em>y</em> to 2 * <em>s</em> * <em>s</em>.</li>
<li>With probability exp(&minus;(<em>k</em> * 2 + 1)/<em>y</em>), go to step 3.  Otherwise, add 1 to <em>k</em> and repeat this step.  (The probability check should be done with the <strong>exp(&minus;<em>x</em>/<em>y</em>) algorithm</strong> in &quot;<a href="https://peteroupc.github.io/bernoulli.html"><strong>Bernoulli Factory Algorithms</strong></a>&quot;, with <em>x</em>/<em>y</em> = (<em>k</em> * 2 + 1)/<em>y</em>.)</li>
<li>(Now we sample the piece located at [<em>k</em>, <em>k</em> + 1).)  Create a positive-sign zero-integer-part uniform PSRN, and create an input coin that returns the result of <strong>SampleGeometricBag</strong> on that uniform PSRN.</li>
<li>Set <em>ky</em> to <em>k</em> * <em>k</em> / <em>y</em>.</li>
<li>(At this point, we simulate exp(&minus;<em>U</em><sup>2</sup>/<em>y</em>), exp(&minus;<em>k</em><sup>2</sup>/<em>y</em>) , exp(&minus;<em>U</em>*<em>k</em>*2/<em>y</em>), as well as a scaled-down version of <em>U</em> + <em>k</em>, where <em>U</em> is the number built up by the uniform PSRN.) Call the <strong>exp(&minus;<em>x</em>/<em>y</em>) algorithm</strong> with <em>x</em>/<em>y</em> = <em>ky</em>, then call the <strong>exp(&minus;(<em>&lambda;</em><sup><em>k</em></sup> * <em>x</em>)) algorithm</strong> using the input coin from step 2, <em>x</em> = 1/<em>y</em>, and <em>k</em> = 2, then call the <strong>exp(&minus;(<em>&lambda;</em><sup><em>k</em></sup> * (<em>x</em>+<em>m</em>)))</strong> algorithm using the same input coin, <em>x</em>+<em>m</em> = floor(<em>k</em> * 2 / <em>y</em>), and <em>k</em> = 1, then call the <strong>sub-algorithm</strong> given later with the uniform PSRN and <em>k</em> = <em>k</em>.  If all of these calls return 1, the uniform PSRN was accepted.  Otherwise, remove all digits from the uniform PSRN&#39;s fractional part and go to step 4.</li>
<li>If the uniform PSRN, call it <em>ret</em>, was accepted by step 5, set <em>ret</em>&#39;s integer part to <em>k</em>, then optionally fill <em>ret</em> with uniform random digits as necessary to give its fractional part the desired number of digits (similarly to <strong>FillGeometricBag</strong>), and return <em>ret</em>.</li>
</ol>

<p>The sub-algorithm below simulates a probability equal to (<em>U</em>+<em>k</em>)/<em>base</em><sup><em>z</em></sup>, where <em>U</em> is the number built by the uniform PSRN, <em>base</em> is the base (radix) of digits stored by that PSRN, <em>k</em> is an integer 0 or greater, and <em>z</em> is the number of significant digits in <em>k</em> (for this purpose, <em>z</em> is 0 if <em>k</em> is 0).</p>

<p>For base 2:</p>

<ol>
<li> Set <em>N</em> to 0.</li>
<li> With probability 1/2, go to the next step.  Otherwise, add 1 to <em>N</em> and repeat this step.</li>
<li> If <em>N</em> is less than <em>z</em>, return rem(<em>k</em> / 2<sup><em>z</em> &minus; 1 &minus; <em>N</em></sup>, 2).  (Alternatively, shift <em>k</em> to the right, by <em>z</em> &minus; 1 &minus; <em>N</em> bits, then return <em>k</em> <em>AND</em> 1, where &quot;<em>AND</em>&quot; is a bitwise AND-operation.)</li>
<li> Subtract <em>z</em> from <em>N</em>.  Then, if the item at position <em>N</em> in the uniform PSRN&#39;s fractional part (positions start at 0) is not set to a digit (e.g., 0 or 1 for base 2), set the item at that position to a digit chosen uniformly at random (e.g., either 0 or 1 for base 2), increasing the capacity of the uniform PSRN&#39;s fractional part as necessary.</li>
<li> Return the item at position <em>N</em>.</li>
</ol>

<p>For bases other than 2, such as 10 for decimal, this can be implemented as follows (based on <strong>URandLess</strong>):</p>

<ol>
<li>Set <em>i</em> to 0.</li>
<li>If <em>i</em> is less than <em>z</em>:

<ol>
<li>Set <em>da</em> to rem(<em>k</em> / 2<sup><em>z</em> &minus; 1 &minus; <em>i</em></sup>, <em>base</em>), and set <em>db</em> to a digit chosen uniformly at random (that is, an integer in the interval [0, <em>base</em>)).</li>
<li>Return 1 if <em>da</em> is less than <em>db</em>, or 0 if <em>da</em> is greater than <em>db</em>.</li>
</ol></li>
<li>If <em>i</em> is <em>z</em> or greater:

<ol>
<li>If the digit at position (<em>i</em> &minus; <em>z</em>) in the uniform PSRN&#39;s fractional part is not set, set the item at that position to a digit chosen uniformly at random (positions start at 0 where 0 is the most significant digit after the point, 1 is the next, etc.).</li>
<li>Set <em>da</em> to the item at that position, and set <em>db</em> to a digit chosen uniformly at random (that is, an integer in the interval [0, <em>base</em>)).</li>
<li>Return 1 if <em>da</em> is less than <em>db</em>, or 0 if <em>da</em> is greater than <em>db</em>.</li>
</ol></li>
<li>Add 1 to <em>i</em> and go to step 3.</li>
</ol>

<p><a id=Sum_of_Exponential_Random_Numbers></a></p>

<h3>Sum of Exponential Random Numbers</h3>

<p>An arbitrary-precision sampler for the sum of <em>n</em> exponential random numbers (also known as the Erlang(<em>n</em>) or gamma(<em>n</em>) distribution) is doable via partially-sampled uniform random numbers, though it is obviously inefficient for large values of <em>n</em>.</p>

<ol>
<li>Generate <em>n</em> exponential random numbers with a rate of 1 via the <strong>ExpRand</strong> or <strong>ExpRand2</strong> algorithm described in my article on <a href="https://peteroupc.github.io/exporand.html"><strong>partially-sampled random numbers (PSRNs)</strong></a>.  These numbers will be uniform PSRNs; this algorithm won&#39;t work for exponential PSRNs (e-rands), described in the same article, because the sum of two e-rands may follow a subtly wrong distribution.  By contrast, generating exponential random numbers via rejection from the uniform distribution will allow unsampled digits to be sampled uniformly at random without deviating from the exponential distribution.</li>
<li>Generate the sum of the random numbers generated in step 1 by applying the <a href="https://peteroupc.github.io/exporand.html#Addition_and_Subtraction"><strong>UniformAdd</strong></a> algorithm given in another document.</li>
</ol>

<p><a id=Hyperbolic_Secant_Distribution></a></p>

<h3>Hyperbolic Secant Distribution</h3>

<p>The following algorithm adapts the rejection algorithm from p. 472 in (Devroye 1986)<sup><a href="#Note6"><strong>(6)</strong></a></sup> for arbitrary-precision sampling.</p>

<ol>
<li>Generate a uniform PSRN, call it <em>ret</em>, and turn it into an exponential random number with a rate of 1, using an algorithm that employs rejection from the uniform distribution.</li>
<li>Set <em>ip</em> to 1 plus <em>ret</em>&#39;s integer part.</li>
<li>(The rest of the algorithm accepts <em>ret</em> with probability 1/(1+<em>ret</em>).) With probability <em>ip</em>/(1+<em>ip</em>), generate a number that is 1 with probability 1/<em>ip</em> and 0 otherwise.  If that number is 1, <em>ret</em> was accepted, in which case optionally fill it with uniform random digits as necessary to give its fractional part the desired number of digits (similarly to <strong>FillGeometricBag</strong>), then set <em>ret</em>&#39;s sign to positive or negative with equal probability, then return <em>ret</em>.</li>
<li>Call <strong>SampleGeometricBag</strong> on <em>ret</em>&#39;s fractional part (ignore <em>ret</em>&#39;s integer part and sign).  If the call returns 1, go to step 1.  Otherwise, go to step 3.</li>
</ol>

<p><a id=Reciprocal_of_Power_of_Uniform></a></p>

<h3>Reciprocal of Power of Uniform</h3>

<p>The following algorithm generates a PSRN of the form 1/<em>U</em><sup>1/<em>x</em></sup>, where <em>U</em> is a uniform random number in [0, 1] and <em>x</em> is an integer greater than 0.</p>

<ol>
<li>Set <em>intval</em> to 1 and set <em>size</em> to 1.</li>
<li>With probability (4<sup><em>x</em></sup>&minus;2<sup><em>x</em></sup>)/4<sup><em>x</em></sup>, go to step 3.  Otherwise, add <em>size</em> to <em>intval</em>, then multiply <em>size</em> by 2, then repeat this step.</li>
<li>Generate an integer in the interval [<em>intval</em>, <em>intval</em> + <em>size</em>) uniformly at random, call it <em>i</em>.</li>
<li>Create a positive-sign zero-integer-part uniform PSRN, <em>ret</em>.</li>
<li>Create an input coin that calls <strong>SampleGeometricBag</strong> on the PSRN <em>ret</em>.  Call the <strong>algorithm for <em>d</em><sup><em>k</em></sup> / (<em>c</em> + <em>&lambda;</em>)<sup><em>k</em></sup></strong> in &quot;<a href="https://peteroupc.github.io/bernoulli.html"><strong>Bernoulli Factory Algorithms</strong></a>&quot;, using the input coin, where <em>d</em> = <em>intval</em>, <em>c</em> = <em>i</em>, and <em>k</em> = <em>x</em> + 1 (here, <em>&lambda;</em> is the probability built up in <em>ret</em> via <strong>SampleGeometricBag</strong>, and lies in the interval [0, 1]).  If the call returns 0, go to step 3.</li>
<li>The PSRN <em>ret</em> was accepted, so set <em>ret</em>&#39;s integer part to <em>i</em>, then optionally fill <em>ret</em> with uniform random digits as necessary to give its fractional part the desired number of digits (similarly to <strong>FillGeometricBag</strong>), then return <em>ret</em>.</li>
</ol>

<p>This algorithm uses the skeleton described earlier in &quot;Building an Arbitrary-Precision Sampler&quot;.  Here, the probabilities <em>A</em>, <em>B</em>,  and <em>C</em> are as follows:</p>

<ul>
<li><em>A</em> = 0, since the random number can&#39;t lie in the interval [0, 1).</li>
<li><em>B</em> = (4<sup><em>x</em></sup>&minus;2<sup><em>x</em></sup>)/4<sup><em>x</em></sup>.</li>
<li><em>C</em> = (<em>x</em>/(<em>i</em> + <em>&lambda;</em>)<sup><em>x</em>+1</sup>) / <em>M</em>.  Ideally, <em>M</em> is either <em>x</em> if <em>intval</em> is 1, or <em>x</em>/<em>intval</em><sup><em>x</em>+1</sup> otherwise.  Thus, the ideal form for <em>C</em> is <em>intval</em><sup><em>x</em>+1</sup>/(<em>i</em>+<em>&lambda;</em>)<sup><em>x</em>+1</sup>.</li>
</ul>

<p><a id=Distribution_of__U__1_minus__U></a></p>

<h3>Distribution of <em>U</em>/(1&minus;<em>U</em>)</h3>

<p>The following algorithm generates a PSRN of the form <em>U</em>/(1&minus;<em>U</em>), where <em>U</em> is a uniform random number in [0, 1].</p>

<ol>
<li>With probability 1/2, set <em>intval</em> to 0, then set <em>size</em> to 1, then go to step 4.</li>
<li>Set <em>intval</em> to 1 and set <em>size</em> to 1.</li>
<li>With probability <em>size</em>/(<em>size</em> + <em>intval</em> + 1), go to step 4.  Otherwise, add <em>size</em> to <em>intval</em>, then multiply <em>size</em> by 2, then repeat this step.</li>
<li>Generate an integer in the interval [<em>intval</em>, <em>intval</em> + <em>size</em>) uniformly at random, call it <em>i</em>.</li>
<li>Create a positive-sign zero-integer-part uniform PSRN, <em>ret</em>.</li>
<li>Create an input coin that calls <strong>SampleGeometricBag</strong> on the PSRN <em>ret</em>.  Call the <strong>algorithm for <em>d</em><sup><em>k</em></sup> / (<em>c</em> + <em>&lambda;</em>)<sup><em>k</em></sup></strong> in &quot;<a href="https://peteroupc.github.io/bernoulli.html"><strong>Bernoulli Factory Algorithms</strong></a>&quot;, using the input coin, where <em>d</em> = <em>intval</em> + 1, <em>c</em> = <em>i</em> + 1, and <em>k</em> = 2 (here, <em>&lambda;</em> is the probability built up in <em>ret</em> via <strong>SampleGeometricBag</strong>, and lies in the interval [0, 1]).  If the call returns 0, go to step 4.</li>
<li>The PSRN <em>ret</em> was accepted, so set <em>ret</em>&#39;s integer part to <em>i</em>, then optionally fill <em>ret</em> with uniform random digits as necessary to give its fractional part the desired number of digits (similarly to <strong>FillGeometricBag</strong>), then return <em>ret</em>.</li>
</ol>

<p>This algorithm uses the skeleton described earlier in &quot;Building an Arbitrary-Precision Sampler&quot;.  Here, the probabilities <em>A</em>, <em>B</em>,  and <em>C</em> are as follows:</p>

<ul>
<li><em>A</em> = 1/2.</li>
<li><em>B</em> = <em>size</em>/(<em>size</em> + <em>intval</em> + 1).</li>
<li><em>C</em> = (1/(<em>i</em>+<em>&lambda;</em>+1)<sup>2</sup>) / <em>M</em>.  Ideally, <em>M</em> is 1/(<em>intval</em>+1)<sup>2</sup>.  Thus, the ideal form for <em>C</em> is (<em>intval</em>+1)<sup>2</sup>/(<em>i</em>+<em>&lambda;</em>+1)<sup>2</sup>.</li>
</ul>

<p><a id=Arc_Cosine_Distribution></a></p>

<h3>Arc-Cosine Distribution</h3>

<p>Here we reimplement an example from Devroye&#39;s book <em>Non-Uniform Random Variate Generation</em> (Devroye 1986, pp. 128&ndash;129)<sup><a href="#Note6"><strong>(6)</strong></a></sup></sup>.  The following arbitrary-precision sampler generates a random number from a distribution with the following cumulative distribution function (CDF): <code>1 - cos(pi*x/2).</code>  The random number will be in the interval [0, 1].  Note that the result is the same as applying acos(<em>U</em>)*2/&pi;, where <em>U</em> is a uniform [0, 1] random number, as pointed out by Devroye.  The algorithm follows.</p>

<ol>
<li>Call the <strong>kthsmallest</strong> algorithm with <code>n = 2</code> and <code>k = 2</code>, but without filling it with digits at the last step.  Let <em>ret</em> be the result.</li>
<li>Set <em>m</em> to 1.</li>
<li>Call the <strong>kthsmallest</strong> algorithm with <code>n = 2</code> and <code>k = 2</code>, but without filling it with digits at the last step.  Let <em>u</em> be the result.</li>
<li>With probability 4/(4*<em>m</em>*<em>m</em> + 2*<em>m</em>), call the <strong>URandLess</strong> algorithm with parameters <em>u</em> and <em>ret</em> in that order, and if that call returns 1, call the <strong>algorithm for &pi; / 4</strong>, described in &quot;<a href="https://peteroupc.github.io/bernoulli.html"><strong>Bernoulli Factory Algorithms</strong></a>&quot;, twice, and if both of these calls return 1, add 1 to <em>m</em> and go to step 3.  (Here, we incorporate an erratum in the algorithm on page 129 of the book.)</li>
<li>If <em>m</em> is odd, optionally fill <em>ret</em> with uniform random digits as necessary to give its fractional part the desired number of digits  (similarly to <strong>FillGeometricBag</strong>), and return <em>ret</em>.</li>
<li>If <em>m</em> is even, go to step 1.</li>
</ol>

<p>And here is Python code that implements this algorithm.  Note that it uses floating-point arithmetic only at the end, to convert the result to a convenient form, and that it relies on methods from <em>randomgen.py</em> and <em>bernoulli.py</em>.</p>

<pre>def example_4_2_1(rg, bern, precision=53):
    while True:
       ret=rg.kthsmallest_psrn(2,2)
       k=1
       while True:
          u=rg.kthsmallest_psrn(2,2)
          kden=4*k*k+2*k # erratum incorporated
          if randomgen.urandless(rg,u, ret) and \
             rg.zero_or_one(4, kden)==1 and \
             bern.zero_or_one_pi_div_4()==1 and \
             bern.zero_or_one_pi_div_4()==1:
             k+=1
          elif (k&amp;1)==1:
             return randomgen.urandfill(rg,ret,precision)/(1&lt;&lt;precision)
          else: break
</pre>

<p><a id=Logistic_Distribution></a></p>

<h3>Logistic Distribution</h3>

<p>The following new algorithm generates a partially-sampled random number that follows the logistic distribution.</p>

<ol>
<li>Set <em>k</em> to 0.</li>
<li>(Choose a 1-unit-wide piece of the logistic density.) Run the <strong>algorithm for (1+exp(<em>k</em>))/(1+exp(<em>k</em>+1))</strong> described in &quot;<a href="https://peteroupc.github.io/bernoulli.html"><strong>Bernoulli Factory Algorithms</strong></a>&quot;).  If the call returns 0, add 1 to <em>k</em> and repeat this step.  Otherwise, go to step 3.</li>
<li>(The rest of the algorithm samples from the chosen piece.) Generate a uniform(0, 1) random number, call it <em>f</em>.</li>
<li>(Steps 4 through 7 succeed with probability exp(&minus;(<em>f</em>+<em>k</em>))/(1+exp(&minus;(<em>f</em>+<em>k</em>)))<sup>2</sup>.) With probability 1/2, go to step 3.</li>
<li>Run the <strong>algorithm for exp(&minus;<em>k</em>/1)</strong> (described in &quot;Bernoulli Factory Algorithms&quot;), then <strong>sample from the number <em>f</em></strong> (e.g., call <strong>SampleGeometricBag</strong> on <em>f</em> if <em>f</em> is implemented as a uniform PSRN).  If any of these calls returns 0, go to step 4.</li>
<li>With probability 1/2, accept <em>f</em>.  If <em>f</em> is accepted this way, set <em>f</em>&#39;s integer part to <em>k</em>, then optionally fill <em>f</em> with uniform random digits as necessary to give its fractional part the desired number of digits (similarly to <strong>FillGeometricBag</strong>), then set <em>f</em>&#39;s sign to positive or negative with equal probability, then return <em>f</em>.</li>
<li>Run the <strong>algorithm for exp(&minus;<em>k</em>/1)</strong> and <strong>sample from the number <em>f</em></strong> (e.g., call <strong>SampleGeometricBag</strong> on <em>f</em> if <em>f</em> is implemented as a uniform PSRN).  If both calls return 1, go to step 3.  Otherwise, go to step 6.</li>
</ol>

<p><a id=Cauchy_Distribution></a></p>

<h3>Cauchy Distribution</h3>

<p>Uses the skeleton for the uniform distribution inside N-dimensional shapes.</p>

<ol>
<li>Generate two empty PSRNs, with a positive sign, an integer part of 0, and an empty fractional part.  Call the PSRNs <em>p1</em> and <em>p2</em>.</li>
<li>Set <em>S</em> to <em>base</em>, where <em>base</em> is the base of digits to be stored by the PSRNs (such as 2 for binary or 10 for decimal).  Then set <em>c1</em> and <em>c2</em> each to 0.  Then set <em>d</em> to 1.</li>
<li>Multiply <em>c1</em> and <em>c2</em> each by <em>base</em> and add a digit chosen uniformly at random to that coordinate.</li>
<li>If ((<em>c1</em>+1)<sup>2</sup> + (<em>c2</em>+1)<sup>2</sup>) &lt; <em>S</em><sup>2</sup>, then do the following:

<ol>
<li>Transfer <em>c1</em>&#39;s least significant digits to <em>p1</em>&#39;s fractional part, and transfer <em>c2</em>&#39;s least significant digits to <em>p2</em>&#39;s fractional part.  The variable <em>d</em> tells how many digits to transfer to each PSRN this way. (For example, if <em>base</em> is 10, <em>d</em> is 3, and <em>c1</em> is 342, set <em>p1</em>&#39;s fractional part to [3, 4, 2].)</li>
<li>Run the <strong>UniformDivision</strong> algorithm (described in the article on PSRNs) on <em>p1</em> and <em>p2</em>, in that order, then set the resulting PSRN&#39;s sign to positive or negative with equal probability, then return that PSRN.</li>
</ol></li>
<li>If (<em>c1</em><sup>2</sup> + <em>c2</em><sup>2</sup>) &gt; <em>S</em><sup>2</sup>, then go to step 2.</li>
<li>Multiply <em>S</em> by <em>base</em>, then add 1 to <em>d</em>, then go to step 3.</li>
</ol>

<p><a id=Exponential_Distribution_with_Rate_ln__x></a></p>

<h3>Exponential Distribution with Rate ln(<em>x</em>)</h3>

<p>The following new algorithm generates a partially-sampled random number that follows the exponential distribution with rate ln(<em>x</em>).  This is useful for generating a base-<em>x</em> logarithm of a uniform(0,1) random number.  Here, <em>x</em> is a rational number that&#39;s greater than 1.  In the algorithm, let <em>b</em> be floor(ln(<em>x</em>)/ln(2)).</p>

<ol>
<li>(Samples the integer part of the random number.) Generate a random number that expresses the number of failed trials before the first success, where each trial succeeds with probability 1&minus;1/<em>x</em>.  Set <em>k</em> to that random number.  (This is also known as a &quot;geometric random number&quot;, but this terminology is avoided because it has conflicting meanings in academic works.  If <em>x</em> is a power of 2, this step can be implemented by generating blocks of <em>b</em> unbiased random bits until a <strong>non-zero</strong> block of bits is generated this way, then setting <em>k</em> to the number of <strong>all-zero</strong> blocks of bits generated this way.)</li>
<li>(The rest of the algorithm samples the fractional part.) Generate a uniform (0, 1) random number, call it <em>f</em>.</li>
<li>Create a <em>&mu;</em> input coin that does the following: &quot;<strong>Sample from the number <em>f</em></strong> (e.g., call <strong>SampleGeometricBag</strong> on <em>f</em> if <em>f</em> is implemented as a uniform PSRN), then run the <strong>algorithm for ln(2)</strong> (described in &quot;Bernoulli Factory Algorithms&quot;).  If both calls return 1, return 1.  Otherwise, return 0.&quot; (This simulates the probability <em>&lambda;</em> = <em>f</em>*ln(2).)    If <em>x</em> is not a power of 2, also create a <em>&nu;</em> input coin that does the following: &quot;<strong>Sample from the number <em>f</em></strong>, then run the <strong>algorithm for ln(1 + <em>y</em>/<em>z</em>)</strong> (described in &quot;Bernoulli Factory Algorithms&quot;) with <em>y</em>/<em>z</em> = (<em>x</em>&minus;2<sup><em>b</em></sup>)/2<sup><em>b</em></sup>.  If both calls return 1, return 1.  Otherwise, return 0.&quot;</li>
<li>Run the <strong>algorithm for exp(&minus;<em>&lambda;</em>)</strong> (described in &quot;Bernoulli Factory Algorithms&quot;) <em>b</em> times, using the <em>&mu;</em> input coin.  If <em>x</em> is not a power of 2, run the same algorithm once, using the <em>&nu;</em> input coin.  If all these calls return 1, accept <em>f</em>.  If <em>f</em> is accepted this way, set <em>f</em>&#39;s integer part to <em>k</em>, then optionally fill <em>f</em> with uniform random digits as necessary to give its fractional part the desired number of digits (similarly to <strong>FillGeometricBag</strong>), then return <em>f</em>.</li>
<li>If <em>f</em> was not accepted by the previous step, go to step 2.</li>
</ol>

<blockquote>
<p><strong>Note</strong>: A <em>bounded exponential</em> random number with rate ln(<em>x</em>) and bounded by <em>m</em> has a similar algorithm to this one.  Step 1 is changed to read as follows: &quot;Set <em>k</em> to a bounded-geometric(1&minus;1/<em>x</em>, <em>m</em>) random number (Bringmann and Friedrich 2013)<sup><a href="#Note8"><strong>(8)</strong></a></sup>, or more simply, the lesser of <em>m</em> or the number of failed trials before the first success, where each trial succeeds with probability 1&minus;1/<em>x</em>. (If <em>x</em> is a power of 2, this can be implemented by generating blocks of <em>b</em> unbiased random bits until a <strong>non-zero</strong> block of bits or <em>m</em> blocks of bits are generated this way, whichever comes first, then setting <em>k</em> to the number of <strong>all-zero</strong> blocks of bits generated this way.) If <em>k</em> is <em>m</em>, return <em>m</em> (note that this <em>m</em> is a constant, not a uniform PSRN; if the algorithm would otherwise return a uniform PSRN, it can return something else in order to distinguish this constant from a uniform PSRN).&quot;  Additionally, instead of generating a uniform(0,1) random number in step 2, a uniform(0,<em>&mu;</em>) random number can be generated instead, such as a uniform PSRN generated via <strong>RandUniformFromReal</strong>, to implement an exponential distribution bounded by <em>m</em>+<em>&mu;</em> (where <em>&mu;</em> is a real number in the interval (0, 1)).</p>
</blockquote>

<p>The following generator for the <strong>rate ln(2)</strong> is a special case of the previous algorithm and is useful for generating a base-2 logarithm of a uniform(0,1) random number. Unlike the similar algorithm of Ahrens and Dieter (1972)<sup><a href="#Note9"><strong>(9)</strong></a></sup>, this one doesn&#39;t require a table of probability values.</p>

<ol>
<li>(Samples the integer part of the random number.  This will be geometrically distributed with parameter 1/2.) Generate unbiased random bits until a zero is generated this way.  Set <em>k</em> to the number of ones generated this way.</li>
<li>(The rest of the algorithm samples the fractional part.) Generate a uniform (0, 1) random number, call it <em>f</em>.</li>
<li>Create an input coin that does the following: &quot;<strong>Sample from the number <em>f</em></strong> (e.g., call <strong>SampleGeometricBag</strong> on <em>f</em> if <em>f</em> is implemented as a uniform PSRN), then run the <strong>algorithm for ln(2)</strong> (described in &quot;Bernoulli Factory Algorithms&quot;).  If both calls return 1, return 1.  Otherwise, return 0.&quot; (This simulates the probability <em>&lambda;</em> = <em>f</em>*ln(2).)</li>
<li>Run the <strong>algorithm for exp(&minus;<em>&lambda;</em>)</strong> (described in &quot;Bernoulli Factory Algorithms&quot;), using the input coin from the previous step.  If the call returns 1, accept <em>f</em>.  If <em>f</em> is accepted this way, set <em>f</em>&#39;s integer part to <em>k</em>, then optionally fill <em>f</em> with uniform random digits as necessary to give its fractional part the desired number of digits (similarly to <strong>FillGeometricBag</strong>), then return <em>f</em>.</li>
<li>If <em>f</em> was not accepted by the previous step, go to step 2.</li>
</ol>

<p><a id=Lindley_Distribution_and_Lindley_Like_Mixtures></a></p>

<h3>Lindley Distribution and Lindley-Like Mixtures</h3>

<p>A random number that follows the Lindley distribution (Lindley 1958)<sup><a href="#Note10"><strong>(10)</strong></a></sup> with parameter <em>&theta;</em> (a rational number greater than 0) can be generated as follows:</p>

<ol>
<li>With probability <em>w</em> = <em>&theta;</em>/(1+<em>&theta;</em>), generate an exponential random number with a rate of <em>&theta;</em> via <strong>ExpRand</strong> or <strong>ExpRand2</strong> (described in my article on PSRNs) and return that number.</li>
<li>Otherwise, generate two exponential random numbers with a rate of <em>&theta;</em> via <strong>ExpRand</strong> or <strong>ExpRand2</strong>, then generate their sum by applying the <strong>UniformAdd</strong> algorithm, then return that sum.</li>
</ol>

<p>For the Garima distribution (Shanker 2016)<sup><a href="#Note11"><strong>(11)</strong></a></sup>, <em>w</em> = (1+<em>&theta;</em>)/(2+<em>&theta;</em>).</p>

<p>For the i-Garima distribution (Singh and Das 2020)<sup><a href="#Note12"><strong>(12)</strong></a></sup>, <em>w</em> = (2+<em>&theta;</em>)/(3+<em>&theta;</em>).</p>

<p>For the mixture-of-weighted-exponential-and-weighted-gamma distribution in (Iqbal and Iqbal 2020)<sup><a href="#Note13"><strong>(13)</strong></a></sup>, two exponential random numbers (rather than one) are generated in step 1, and three (rather than two) are generated in step 2.</p>

<p><a id=Requests_and_Open_Questions></a></p>

<h2>Requests and Open Questions</h2>

<p>We would like to see new implementations of the following:</p>

<ul>
<li>Algorithms that implement <strong>InShape</strong> for specific closed curves, specific closed surfaces, and specific signed distance functions.  Recall that <strong>InShape</strong> determines whether a box lies inside, outside, or partly inside or outside a given curve or surface.</li>
<li>Descriptions of new arbitrary-precision algorithms that use the skeleton given in the section &quot;Building an Arbitrary-Precision Sampler&quot;.</li>
</ul>

<p>The appendix contains implementation notes for <strong>InShape</strong>, which determines whether a box is outside or partially or fully inside a shape.  However, practical implementations of <strong>InShape</strong> will generally only be able to evaluate a shape pointwise.  What are necessary and/or sufficient conditions that allow an implementation to correctly classify a box just by evaluating the shape pointwise?</p>

<p><a id=Notes></a></p>

<h2>Notes</h2>

<ul>
<li><small><sup id=Note1>(1)</sup> Fishman, D., Miller, S.J., &quot;Closed Form Continued Fraction Expansions of Special Quadratic Irrationals&quot;, ISRN Combinatorics Vol. 2013, Article ID 414623 (2013).</small></li>
<li><small><sup id=Note2>(2)</sup> choose(<em>n</em>, <em>k</em>) = <em>n</em>!/(<em>k</em>! * (<em>n</em> &minus; <em>k</em>)!) is a binomial coefficient.  It can be calculated, for example, by calculating <em>i</em>/(<em>n</em>&minus;<em>i</em>+1) for each integer <em>i</em> in the interval [<em>n</em>&minus;<em>k</em>+1, <em>n</em>], then multiplying the results (Yannis Manolopoulos. 2002. &quot;<a href="https://doi.org/10.1145/820127.820168"><strong>Binomial coefficient computation: recursion or iteration?</strong></a>&quot;, SIGCSE Bull. 34, 4 (December 2002), 6567).  Note that for all <em>m</em>&gt;0, choose(<em>m</em>, 0) = choose(<em>m</em>, <em>m</em>) = 1 and choose(<em>m</em>, 1) = choose(<em>m</em>, <em>m</em>&minus;1) = <em>m</em>.</small></li>
<li><small><sup id=Note3>(3)</sup> Thomas, A.C., Blanchet, J., &quot;<a href="https://arxiv.org/abs/1106.2508v3"><strong>A Practical Implementation of the Bernoulli Factory</strong></a>&quot;, arXiv:1106.2508v3  [stat.AP], 2012.</small></li>
<li><small><sup id=Note4>(4)</sup> C.T. Li, A. El Gamal, &quot;<a href="https://arxiv.org/abs/1603.05238v1"><strong>A Universal Coding Scheme for Remote Generation of Continuous Random Variables</strong></a>&quot;, arXiv:1603.05238v1  [cs.IT], 2016</small></li>
<li><small><sup id=Note5>(5)</sup> Oberhoff, Sebastian, &quot;<a href="https://dc.uwm.edu/etd/1888"><strong>Exact Sampling and Prefix Distributions</strong></a>&quot;, <em>Theses and Dissertations</em>, University of Wisconsin Milwaukee, 2018.</small></li>
<li><small><sup id=Note6>(6)</sup> Devroye, L., <a href="http://luc.devroye.org/rnbookindex.html"><strong><em>Non-Uniform Random Variate Generation</em></strong></a>, 1986.</small></li>
<li><small><sup id=Note7>(7)</sup> Harlow, J., Sainudiin, R., Tucker, W., &quot;Mapped Regular Pavings&quot;, <em>Reliable Computing</em> 16 (2012).</small></li>
<li><small><sup id=Note8>(8)</sup> Bringmann, K. and Friedrich, T., 2013, July. &quot;Exact and efficient generation of geometric random variates and random graphs&quot;, in <em>International Colloquium on Automata, Languages, and Programming</em> (pp. 267-278).</small></li>
<li><small><sup id=Note9>(9)</sup> Ahrens, J.H., and Dieter, U., &quot;Computer methods from sampling from the exponential and normal distributions&quot;, <em>Communications of the ACM</em> 15, 1972.</small></li>
<li><small><sup id=Note10>(10)</sup> Lindley, D.V., &quot;Fiducial distributions and Bayes&#39; theorem&quot;, <em>Journal of the Royal Statistical Society Series B</em>, 1958.</small></li>
<li><small><sup id=Note11>(11)</sup> Shanker, R., &quot;Garima distribution and its application to model behavioral science data&quot;, <em>Biom Biostat Int J.</em> 4(7), 2016.</small></li>
<li><small><sup id=Note12>(12)</sup> Singh, B.P., Das, U.D., &quot;<a href="https://arxiv.org/abs/2010.15078"><strong>On an Induced Distribution and its Statistical Properties</strong></a>&quot;, arXiv:2010.15078 [stat.ME], 2020.</small></li>
<li><small><sup id=Note13>(13)</sup> Iqbal, T. and Iqbal, M.Z., 2020. On the Mixture Of Weighted Exponential and Weighted Gamma Distribution. International Journal of Analysis and Applications, 18(3), pp.396-408.</small></li>
<li><small><sup id=Note14>(14)</sup> Kinderman, A.J., Monahan, J.F., &quot;Computer generation of random variables using the ratio of uniform deviates&quot;, <em>ACM Transactions on Mathematical Software</em> 3(3), pp. 257-260, 1977.</small></li>
<li><small><sup id=Note15>(15)</sup> Daumas, M., Lester, D., Muoz, C., &quot;<a href="https://arxiv.org/abs/0708.3721"><strong>Verified Real Number Calculations: A Library for Interval Arithmetic</strong></a>&quot;, arXiv:0708.3721 [cs.MS], 2007.</small></li>
<li><small><sup id=Note16>(16)</sup> Karney, C.F.F., &quot;<a href="https://arxiv.org/abs/1303.6257v2"><strong>Sampling exactly from the normal distribution</strong></a>&quot;, arXiv:1303.6257v2  [physics.comp-ph], 2014.</small></li>
<li><small><sup id=Note17>(17)</sup> I thank D. Eisenstat from the <em>Stack Overflow</em> community for leading me to this insight.</small></li>
</ul>

<p><a id=Appendix></a></p>

<h2>Appendix</h2>

<p>&nbsp;</p>

<p><a id=Ratio_of_Uniforms></a></p>

<h3>Ratio of Uniforms</h3>

<p>The Cauchy sampler given earlier demonstrates the <em>ratio-of-uniforms</em> technique for sampling a distribution (Kinderman and Monahan 1977)<sup><a href="#Note14"><strong>(14)</strong></a></sup>.  It involves transforming the distribution&#39;s density function (PDF) into a compact shape.  The ratio-of-uniforms method appears here in the appendix, particularly since it can involve calculating upper and lower bounds of transcendental functions which, while it&#39;s possible to achieve in rational arithmetic (Daumas et al., 2007)<sup><a href="#Note15"><strong>(15)</strong></a></sup>, is less elegant than, say, the normal distribution sampler by Karney (2014)<sup><a href="#Note16"><strong>(16)</strong></a></sup>, which doesn&#39;t require calculating logarithms or other transcendental functions.</p>

<p>This algorithm works for any univariate (one-variable) distribution as long as&mdash;</p>

<ul>
<li>for all <em>x</em>, <em>PDF</em>(<em>x</em>) &lt; &infin; and <em>PDF</em>(<em>x</em>)*<em>x</em><sup>2</sup> &lt; &infin;, where <em>PDF</em> is the distribution&#39;s PDF or a function proportional to the PDF,</li>
<li><em>PDF</em> is continuous almost everywhere, and</li>
<li>either&mdash;

<ul>
<li>the distribution&#39;s ratio-of-uniforms shape (the transformed PDF) is covered entirely by the rectangle [0, ceil(<em>d1</em>)]&times;[0, ceil(<em>d2</em>)], where <em>d1</em> is not less than the highest value of <em>x</em>*sqrt(<em>PDF</em>(<em>x</em>)) anywhere, and <em>d2</em> is not less than the highest value of sqrt(<em>PDF</em>(<em>x</em>)) anywhere, or</li>
<li>half of that shape is covered this way and the shape is symmetric about the <em>v</em>-axis.</li>
</ul></li>
</ul>

<p>The algorithm follows.</p>

<ol>
<li>Generate two empty PSRNs, with a positive sign, an integer part of 0, and an empty fractional part.  Call the PSRNs <em>p1</em> and <em>p2</em>.</li>
<li>Set <em>S</em> to <em>base</em>, where <em>base</em> is the base of digits to be stored by the PSRNs (such as 2 for binary or 10 for decimal).  Then set <em>c1</em> to an integer in the interval [0, <em>d1</em>), chosen uniformly at random, then set <em>c2</em> to an integer in [0, <em>d2</em>), chosen uniformly at random, then set <em>d</em> to 1.</li>
<li>Multiply <em>c1</em> and <em>c2</em> each by <em>base</em> and add a digit chosen uniformly at random to that coordinate.</li>
<li>Run an <strong>InShape</strong> function that determines whether the transformed PDF is covered by the current box. In principle, this is the case when <em>z</em> &lt;= 0 everywhere in the box, where <em>u</em> lies in [<em>c1</em>/<em>S</em>, (<em>c1</em>+1)/<em>S</em>], <em>v</em> lies in [<em>c2</em>/<em>S</em>, (<em>c2</em>+1)/<em>S</em>], and <em>z</em> is <em>v</em><sup>2</sup>&minus;<em>PDF</em>(<em>u</em>/<em>v</em>).  <strong>InShape</strong> returns <em>YES</em> if the box is fully inside the transformed PDF, <em>NO</em> if the box is fully outside it, and <em>MAYBE</em> in any other case, or if evaluating <em>z</em> fails for a given box (e.g., because ln(0) would be calculated or <em>v</em> is 0).  See the next section for implementation notes.</li>
<li>If <strong>InShape</strong> as described in step 4 returns <em>YES</em>, then do the following:

<ol>
<li>Transfer <em>c1</em>&#39;s least significant digits to <em>p1</em>&#39;s fractional part, and transfer <em>c2</em>&#39;s least significant digits to <em>p2</em>&#39;s fractional part.  The variable <em>d</em> tells how many digits to transfer to each PSRN this way.  Then set <em>p1</em>&#39;s integer part to floor(<em>c1</em>/<em>base</em><sup><em>d</em></sup>) and <em>p2</em>&#39;s integer part to floor(<em>c2</em>/<em>base</em><sup><em>d</em></sup>). (For example, if <em>base</em> is 10, <em>d</em> is 3, and <em>c1</em> is 7342, set <em>p1</em>&#39;s fractional part to [3, 4, 2] and <em>p1</em>&#39;s integer part to 7.)</li>
<li>Run the <strong>UniformDivision</strong> algorithm (described in the article on PSRNs) on <em>p1</em> and <em>p2</em>, in that order.</li>
<li>If the transformed PDF is symmetric about the <em>v</em>-axis, set the resulting PSRN&#39;s sign to positive or negative with equal probability.  Otherwise, set the PSRN&#39;s sign to positive.</li>
<li>Return the PSRN.</li>
</ol></li>
<li>If <strong>InShape</strong> as described in step 4 returns <em>NO</em>, then go to step 2.</li>
<li>Multiply <em>S</em> by <em>base</em>, then add 1 to <em>d</em>, then go to step 3.</li>
</ol>

<blockquote>
<p><strong>Examples:</strong></p>

<ol>
<li>For the normal distribution, <em>PDF</em> is proportional to exp(&minus;<em>x</em><sup>2</sup>/2), so that <em>z</em> after a logarithmic transformation (see next section) becomes 4*ln(<em>v</em>) + (<em>u</em>/<em>v</em>)<sup>2</sup>, and since the distribution&#39;s ratio-of-uniforms shape is symmetric about the <em>v</em>-axis, the return value&#39;s sign is positive or negative with equal probability.</li>
<li>For the standard lognormal distribution (<a href="https://mathworld.wolfram.com/GibratsDistribution.html"><strong>Gibrat&#39;s distribution</strong></a>), <em>PDF</em>(<em>x</em>) is proportional to exp(&minus;(ln(<em>x</em>))<sup>2</sup>/2)/<em>x</em>, so that <em>z</em> after a logarithmic transformation becomes 2*ln(<em>v</em>)&minus;(&minus;ln(<em>u</em>/<em>v</em>)<sup>2</sup>/2 &minus; ln(<em>u</em>/<em>v</em>)), and the returned PSRN has a positive sign.</li>
<li>For the gamma distribution with shape parameter <em>a</em> &gt; 1, <em>PDF</em>(<em>x</em>) is proportional to <em>x</em><sup><em>a</em>&minus;1</sup>*exp(&minus;<em>x</em>), so that <em>z</em> after a logarithmic transformation becomes 2*ln(<em>v</em>)&minus;(<em>a</em>&minus;1)*ln(<em>u</em>/<em>v</em>)&minus;(<em>u</em>/<em>v</em>), or 0 if <em>u</em> or <em>v</em> is 0, and the returned PSRN has a positive sign.</li>
</ol>
</blockquote>

<p><a id=Implementation_Notes_for_Box_Shape_Intersection></a></p>

<h3>Implementation Notes for Box/Shape Intersection</h3>

<p>The &quot;<a href="#Uniform_Distribution_Inside_N_Dimensional_Shapes"><strong>Uniform Distribution Inside N-Dimensional Shapes</strong></a>&quot; algorithm uses a function called <strong>InShape</strong> to determine whether an axis-aligned box is either outside a shape, fully inside the shape, or partially inside the shape.  The following are notes that will aid in developing a robust implementation of <strong>InShape</strong> for a particular shape, especially because the boxes being tested can be arbitrarily small.</p>

<ol>
<li><strong>InShape</strong>, as well as the divisions of the coordinates by <em>S</em>, should be implemented using rational arithmetic.  Instead of dividing those coordinates this way, an implementation can pass <em>S</em> as a separate parameter to <strong>InShape</strong>.</li>
<li><p>If the shape is convex, and the point (0, 0, ..., 0) is on or inside that shape, <strong>InShape</strong> can return&mdash;</p>

<ul>
<li><em>YES</em> if all the box&#39;s corners are in the shape;</li>
<li><em>NO</em> if none of the box&#39;s corners are in the shape and if the shape&#39;s boundary does not intersect with the box&#39;s boundary; and</li>
<li><em>MAYBE</em> in any other case, or if the function is unsure.</li>
</ul>

<p>In the case of two-dimensional shapes, the shape&#39;s corners are (<em>c1</em>/<em>S</em>, <em>c2</em>/<em>S</em>), ((<em>c1</em>+1)/<em>S</em>, <em>c2</em>/<em>S</em>), (<em>c1</em>,(<em>c2</em>+1)/<em>S</em>), and ((<em>c1</em>+1)/<em>S</em>, (<em>c2</em>+1)/<em>S</em>).  However, checking for box/shape intersections this way is non-trivial to implement robustly, especially if interval arithmetic is not used.</p></li>
<li><p>If the shape is given as an inequality of the form <em>f</em>(<em>t1</em>, ..., <em>tN</em>) &lt;= 0, <strong>InShape</strong> should use rational interval arithmetic (such as the one given in (Daumas et al., 2007)<sup><a href="#Note15"><strong>(15)</strong></a></sup>), where the two bounds of each interval are rational numbers with arbitrary-precision numerators and denominators.  Then, <strong>InShape</strong> should build one interval for each dimension of the box and evaluate <em>f</em> using those intervals<sup><a href="#Note17"><strong>(17)</strong></a></sup> with an accuracy that increases as <em>S</em> increases.  Then, <strong>InShape</strong> can return&mdash;</p>

<ul>
<li><em>YES</em> if the interval result of <em>f</em> has an upper bound less than or equal to 0;</li>
<li><em>NO</em> if the interval result of <em>f</em> has a lower bound greater than 0; and</li>
<li><em>MAYBE</em> in any other case.</li>
</ul>

<p>For example, if <em>f</em> is (<em>t1</em><sup>2</sup>+<em>t2</em><sup>2</sup>&minus;1), which describes a quarter disk, <strong>InShape</strong> should build two intervals, namely <em>t1</em> = [<em>c1</em>/<em>S</em>, (<em>c1</em>+1)/<em>S</em>] and <em>t2</em> = [<em>c2</em>/<em>S</em>, (<em>c2</em>+1)/<em>S</em>], and evaluate <em>f</em>(<em>t1</em>, <em>t2</em>) using interval arithmetic.</p>

<p>One thing to point out, though: If <em>f</em> calls the exp(<em>x</em>) function where <em>x</em> can potentially have a high absolute value, say 10000 or higher, the exp function can run a very long time in order to calculate proper bounds for the result, since the number of digits in exp(<em>x</em>) grows linearly with <em>x</em>.  In this case, it may help to transform the inequality to its logarithmic version.  For example, by applying ln(.) to each side of the inequality <em>y</em><sup>2</sup> &lt;= exp(&minus;(<em>x</em>/<em>y</em>)<sup>2</sup>/2), the inequality becomes 2*ln(<em>y</em>) &lt;= &minus;(<em>x</em>/<em>y</em>)<sup>2</sup>/2 and thus becomes 2*ln(<em>y</em>) + (<em>x</em>/<em>y</em>)<sup>2</sup>/2 &lt;= 0 and thus becomes 4*ln(<em>y</em>) + (<em>x</em>/<em>y</em>)<sup>2</sup> &lt;= 0.</p></li>
<li><p>If the shape is such that every axis-aligned line segment that begins in one face of the hypercube and ends in another face crosses the shape at most once, ignoring the segment&#39;s endpoints (an example is an axis-aligned quarter of a circular disk where the disk&#39;s center is (0, 0)), then <strong>InShape</strong> can return&mdash;</p>

<ul>
<li><em>YES</em> if all the box&#39;s corners are in the shape;</li>
<li><em>NO</em> if none of the box&#39;s corners are in the shape; and</li>
<li><em>MAYBE</em> in any other case, or if the function is unsure.</li>
</ul>

<p>If <strong>InShape</strong> uses rational interval arithmetic, it can build an interval per dimension <em>per corner</em>, evaluate the shape for each corner individually and with an accuracy that increases as <em>S</em> increases, and treat a corner as inside or outside the shape only if the result of the evaluation clearly indicates that.  Using the example of a quarter disk, <strong>InShape</strong> can build eight intervals, namely an <em>x</em>- and <em>y</em>-interval for each of the four corners; evaluate (<em>x</em><sup>2</sup>+<em>y</em><sup>2</sup>&minus;1) for each corner; and return <em>YES</em> only if all four results have upper bounds less than or equal to 0, <em>NO</em> only if all four results have lower bounds greater than 0, and <em>MAYBE</em> in any other case.</p></li>
<li>If <strong>InShape</strong> expresses a shape in the form of a <a href="https://en.wikipedia.org/wiki/Signed_distance_function"><strong><em>signed distance function</em></strong></a>, namely a function that describes the closest distance from any point in space to the shape&#39;s boundary, it can return&mdash;

<ul>
<li><em>YES</em> if the signed distance (or an upper bound of such distance) at each of the box&#39;s corners, after dividing their coordinates by <em>S</em>, is less than or equal to &minus;<em>&sigma;</em> (where <em>&sigma;</em> is an upper bound for sqrt(<em>N</em>)/(<em>S</em>*2), such as 1/<em>S</em>);</li>
<li><em>NO</em> if the signed distance (or a lower bound of such distance) at each of the box&#39;s corners is greater than <em>&sigma;</em>; and</li>
<li><em>MAYBE</em> in any other case, or if the function is unsure.</li>
</ul></li>
<li><strong>InShape</strong> implementations can also involve a shape&#39;s <em>implicit curve</em> or <em>algebraic curve</em> equation (for closed curves), its <em>implicit surface</em> equation (for closed surfaces), or its <em>signed distance field</em> (a quantized version of a signed distance function).</li>
<li>An <strong>InShape</strong> function can implement a set operation (such as a union, intersection, or difference) of several simpler shapes, each with its own <strong>InShape</strong> function.  The final result depends on the shape operation (such as union or intersection) as well as the result returned by each component for a given box.  The following are examples of set operations:

<ul>
<li>For unions, the final result is <em>YES</em> if any component returns <em>YES</em>; <em>NO</em> if all components return <em>NO</em>; and <em>MAYBE</em> otherwise.</li>
<li>For intersections, the final result is <em>YES</em> if all components return <em>YES</em>; <em>NO</em> if any component returns <em>NO</em>; and <em>MAYBE</em> otherwise.</li>
<li>For differences between two shapes, the final result is <em>YES</em> if the first shape returns <em>YES</em> and the second returns <em>NO</em>; <em>NO</em> if the first shape returns <em>NO</em> or if both shapes return <em>YES</em>; and <em>MAYBE</em> otherwise.</li>
<li>For the exclusive OR of two shapes, the final result is <em>YES</em> if one shape returns <em>YES</em> and the other returns <em>NO</em>; <em>NO</em> if both shapes return <em>NO</em> or both return <em>YES</em>; and <em>MAYBE</em> otherwise.</li>
</ul></li>
</ol>

<p><a id=SymPy_Code_for_Piecewise_Linear_Factory_Functions></a></p>

<h3>SymPy Code for Piecewise Linear Factory Functions</h3>

<pre>def bernstein_n(func, x, n, pt=None):
  # Bernstein operator.
  # Create a polynomial that approximates func, which in turn uses
  # the symbol x.  The polynomial&#39;s degree is n and is evaluated
  # at the point pt (or at x if not given).
  if pt==None: pt=x
  ret=0
  v=[binomial(n,j) for j in range(n//2+1)]
  for i in range(0, n+1):
    oldret=ret
    bin=v[i] if i&lt;len(v) else v[n-i]
    ret+=func.subs(x,S(i)/n)*bin*pt**i*(1-pt)**(n-i)
    if pt!=x and ret==oldret and ret&gt;0: break
  return ret

def inflec(y,eps=S(2)/10,mult=2):
  # Calculate the inflection point (x) given y, eps, and mult.
  # The formula is not found in the paper by Thomas and
  # Blanchet 2012, but in
  # the supplemental source code uploaded by
  # A.C. Thomas.
  po=5 # Degree of y-to-x polynomial curve
  eps=S(eps)
  mult=S(mult)
  x=-((y-(1-eps))/eps)**po/mult + y/mult
  return x

def xfunc(y,sym,eps=S(2)/10,mult=2):
  # Calculate Bernstein &quot;control polygon&quot; given y,
  # eps, and mult.
  return Min(sym*y/inflec(y,eps,mult),y)

def calc_linear_func(eps=S(5)/10, mult=1, count=10):
   # Calculates the degrees and Y parameters
   # of a sequence of polynomials that converge
   # from above to min(x*mult, 1-eps).
   # eps must be in the interval (0, 1).
   # Default is 10 polynomials.
   polys=[]
   eps=S(eps)
   mult=S(mult)
   count=S(count)
   bs=20
   ypt=1-(eps/4)
   x=symbols(&#39;x&#39;)
   tfunc=Min(x*mult,1-eps)
   tfn=tfunc.subs(x,(1-eps)/mult).n()
   xpt=xfunc(ypt,x,eps=eps,mult=mult)
   bits=5
   #oldbx=None
   i=0
   lastbxn = 1
   diffs=[]
   while i&lt;count:
     bx=bernstein_n(xpt,x,bits,(1-eps)/mult)
     bxn=bx.n()
     if bxn &gt; tfn and bxn &lt; lastbxn:
       # Dominates target function
       #if oldbx!=None:
       #   diffs.append(bx)
       #   diffs.append(oldbx-bx)
       #oldbx=bx
       oldxpt=xpt
       lastbxn = bxn
       polys.append([bits,ypt])
       print(&quot;    [%d,%s],&quot; % (bits,ypt))
       # Find y2 such that y2 &lt; ypt and
       # bernstein_n(oldxpt,x,bits,inflec(y2, ...)) &gt;= y2,
       # so that next Bernstein expansion will go
       # underneath the previous one
       while True:
         ypt-=(ypt-(1-eps))/4
         xpt=inflec(ypt,eps=eps,mult=mult).n()
         bxs=bernstein_n(oldxpt,x,bits,xpt).n()
         if bxs&gt;=ypt.n():
            break
       xpt=xfunc(ypt,x,eps=eps,mult=mult)
       bits+=20
       i+=1
     else:
       bits=int(bits*200/100)
   return polys

calc_linear_func(count=8)
</pre>

<p><a id=License></a></p>

<h2>License</h2>

<p>Any copyright to this page is released to the Public Domain.  In case this is not possible, this page is also licensed under <a href="https://creativecommons.org/publicdomain/zero/1.0/"><strong>Creative Commons Zero</strong></a>.</p>
</div><nav id="navigation"><ul>
<li><a href="/">Back to start site.</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io">This site's repository (source code)</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io/issues">Post an issue or comment</a></ul>
<p>
If you like this software, you should consider donating to me, Peter O., at the link below:</p>
<p class="printonly"><b>peteroupc.github.io</b></p>
<div class="noprint">
<a href="https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=56E5T4FH7KD2S">
<img src="https://www.paypalobjects.com/en_US/i/btn/btn_donateCC_LG.gif"
name="submit" border="2" alt="PayPal - The safer, easier way to pay online!"></a>
<p>
<a href="//twitter.com/share">Share via Twitter</a>, <a href="//www.facebook.com/sharer/sharer.php" id="sharer">Share via Facebook</a>
</p>
</div>
</nav><script>
if("share" in navigator){
 document.getElementById("sharer").href="javascript:void(null)";
 document.getElementById("sharer").innerHTML="Share This Page";
 navigator.share({title:document.title,url:document.location.href}).then(
   function(){});
} else {
 document.getElementById("sharer").href="//www.facebook.com/sharer/sharer.php?u="+
    encodeURIComponent(document.location.href)
}
</script>
</body></html>
