<!DOCTYPE html><html xmlns:dc="http://purl.org/dc/terms/" itemscope itemtype="http://schema.org/Article"><head><meta http-equiv=Content-Type content="text/html; charset=utf-8"><title>More Algorithms for Arbitrary-Precision Sampling</title><meta name="citation_title" content="More Algorithms for Arbitrary-Precision Sampling"><meta name="citation_pdf_url" content="https://peteroupc.github.io/morealg.pdf"><meta name="citation_url" content="https://peteroupc.github.io/morealg.html"><meta name="citation_date" content="2023/03/10"><meta name="citation_online_date" content="2023/03/10"><meta name="og:title" content="More Algorithms for Arbitrary-Precision Sampling"><meta name="og:description" content="This page contains additional algorithms for arbitrary-precision sampling of distributions, Bernoulli factory algorithms (biased-coin to biased-coin algorithms), and algorithms to produce heads with an irrational probability.  They supplement my pages on Bernoulli factory algorithms and partially-sampled random numbers."><meta name="description" content="This page contains additional algorithms for arbitrary-precision sampling of distributions, Bernoulli factory algorithms (biased-coin to biased-coin algorithms), and algorithms to produce heads with an irrational probability.  They supplement my pages on Bernoulli factory algorithms and partially-sampled random numbers."><meta name="twitter:description" content="This page contains additional algorithms for arbitrary-precision sampling of distributions, Bernoulli factory algorithms (biased-coin to biased-coin algorithms), and algorithms to produce heads with an irrational probability.  They supplement my pages on Bernoulli factory algo..."><meta name="og:type" content="article"><meta name="og:url" content="https://peteroupc.github.io/morealg.html"><meta name="og:site_name" content="peteroupc.github.io"><meta name="twitter:title" content="More Algorithms for Arbitrary-Precision Sampling"><meta name="author" content="Peter Occil"/><meta name="citation_author" content="Peter Occil"/><meta name="viewport" content="width=device-width"><link rel=stylesheet type="text/css" href="/style.css">
            <script type="text/x-mathjax-config"> MathJax.Hub.Config({"HTML-CSS": { availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, preferredFont: "TeX" },
                    tex2jax: { displayMath: [ ["$$","$$"], ["\\[", "\\]"] ], inlineMath: [ ["$", "$"], ["\\\\(","\\\\)"] ], processEscapes: true } });
            </script><script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"></script></head><body>  <div class="header">
<nav><p><a href="#navigation">Menu</a> - <a href="#top">Top</a> - <a href="/">Home</a></nav></div>
<div class="mainarea" id="top">
<h1>More Algorithms for Arbitrary-Precision Sampling</h1>

<p><a href="mailto:poccil14@gmail.com"><strong>Peter Occil</strong></a></p>

<p><strong>Abstract:</strong> This page contains additional algorithms for arbitrary-precision sampling of distributions, Bernoulli factory algorithms (biased-coin to biased-coin algorithms), and algorithms to produce heads with an irrational probability.  They supplement my pages on Bernoulli factory algorithms and partially-sampled random numbers.</p>

<p><strong>2020 Mathematics Subject Classification:</strong> 68W20, 60-08, 60-04.</p>

<p><a id=Introduction></a></p>

<h2>Introduction</h2>

<p>This page contains additional algorithms for arbitrary-precision sampling of distributions, Bernoulli factory algorithms (biased-coin to biased-coin algorithms), and algorithms to produce heads with an irrational probability.  These samplers are designed to not rely on floating-point arithmetic.</p>

<p>The samplers on this page may depend on algorithms given in the following pages:</p>

<ul>
<li><a href="https://peteroupc.github.io/exporand.html"><strong>Partially-Sampled Random Numbers for Accurate Sampling of Continuous Distributions</strong></a></li>
<li><a href="https://peteroupc.github.io/bernoulli.html"><strong>Bernoulli Factory Algorithms</strong></a></li>
</ul>

<p>Additional Bernoulli factory algorithms and irrational probability samplers are included here rather than in &quot;<a href="https://peteroupc.github.io/bernoulli.html"><strong>Bernoulli Factory Algorithms</strong></a>&quot; because that article is quite long as it is.</p>

<p><a id=About_This_Document></a></p>

<h3>About This Document</h3>

<p><strong>This is an open-source document; for an updated version, see the</strong> <a href="https://github.com/peteroupc/peteroupc.github.io/raw/master/morealg.md"><strong>source code</strong></a> <strong>or its</strong> <a href="https://github.com/peteroupc/peteroupc.github.io/blob/master/morealg.md"><strong>rendering on GitHub</strong></a><strong>.  You can send comments on this document on the</strong> <a href="https://github.com/peteroupc/peteroupc.github.io/issues"><strong>GitHub issues page</strong></a><strong>.</strong></p>

<p>My audience for this article is <strong>computer programmers with mathematics knowledge, but little or no familiarity with calculus</strong>.</p>

<p>I encourage readers to implement any of the algorithms given in this page, and report their implementation experiences.  In particular, <a href="https://github.com/peteroupc/peteroupc.github.io/issues/18"><strong>I seek comments on the following aspects</strong></a>:</p>

<ul>
<li>Are the algorithms in this article easy to implement? Is each algorithm written so that someone could write code for that algorithm after reading the article?</li>
<li>Does this article have errors that should be corrected?</li>
<li>Are there ways to make this article more useful to the target audience?</li>
</ul>

<p>Comments on other aspects of this document are welcome.</p>

<p><a id=Contents></a></p>

<h2>Contents</h2>

<ul>
<li><a href="#Introduction"><strong>Introduction</strong></a>

<ul>
<li><a href="#About_This_Document"><strong>About This Document</strong></a></li>
</ul></li>
<li><a href="#Contents"><strong>Contents</strong></a></li>
<li><a href="#Bernoulli_Factories"><strong>Bernoulli Factories</strong></a>

<ul>
<li><a href="#Certain_Piecewise_Linear_Functions"><strong>Certain Piecewise Linear Functions</strong></a></li>
<li><a href="#Pushdown_Automata_for_Square_Root_Like_Functions"><strong>Pushdown Automata for Square-Root-Like Functions</strong></a></li>
</ul></li>
<li><a href="#Irrational_Probabilities"><strong>Irrational Probabilities</strong></a>

<ul>
<li><a href="#Ratio_of_Lower_Gamma_Functions_gamma__m___x__gamma__m__1"><strong>Ratio of Lower Gamma Functions (&gamma;(<em>m</em>, <em>x</em>)/&gamma;(<em>m</em>, 1)).</strong></a></li>
<li><a href="#4_3___pi"><strong>4/(3*<em>&pi;</em>)</strong></a></li>
<li><a href="#1_exp__k__1_exp__k__1"><strong>(1 + exp(<em>k</em>)) / (1 + exp(<em>k</em> + 1))</strong></a></li>
</ul></li>
<li><a href="#Sampling_Distributions_Using_Incomplete_Information"><strong>Sampling Distributions Using Incomplete Information</strong></a></li>
<li><a href="#Sum_of_Uniform_Random_Variates"><strong>Sum of Uniform Random Variates</strong></a>

<ul>
<li><a href="#About_the_Uniform_Sum_Distribution"><strong>About the Uniform Sum Distribution</strong></a></li>
<li><a href="#Finding_Parameters"><strong>Finding Parameters</strong></a></li>
<li><a href="#Sum_of_Two_Uniform_Random_Variates"><strong>Sum of Two Uniform Random Variates</strong></a></li>
<li><a href="#Sum_of_Three_Uniform_Random_Variates"><strong>Sum of Three Uniform Random Variates</strong></a></li>
</ul></li>
<li><a href="#Acknowledgments"><strong>Acknowledgments</strong></a></li>
<li><a href="#Notes"><strong>Notes</strong></a></li>
<li><a href="#Appendix"><strong>Appendix</strong></a>

<ul>
<li><a href="#Probability_Transformations"><strong>Probability Transformations</strong></a></li>
<li><a href="#Proof_of_the_General_Martingale_Algorithm"><strong>Proof of the General Martingale Algorithm</strong></a></li>
<li><a href="#Algorithm_for_sin___lambda_____pi___2"><strong>Algorithm for sin(<em>&lambda;</em>*<em>&pi;</em>/2)</strong></a></li>
<li><a href="#Pushdown_Automata_and_Algebraic_Functions"><strong>Pushdown Automata and Algebraic Functions</strong></a></li>
<li><a href="#Sampling_Distributions_Using_Incomplete_Information_Omitted_Algorithms"><strong>Sampling Distributions Using Incomplete Information: Omitted Algorithms</strong></a></li>
</ul></li>
<li><a href="#License"><strong>License</strong></a></li>
</ul>

<p><a id=Bernoulli_Factories></a></p>

<h2>Bernoulli Factories</h2>

<p>&nbsp;</p>

<p>As a reminder, the <em>Bernoulli factory problem</em> is: We&#39;re given a coin that shows heads with an unknown probability, <em>&lambda;</em>, and the goal is to use that coin (and possibly also a fair coin) to build a &quot;new&quot; coin that shows heads with a probability that depends on <em>&lambda;</em>, call it <em>f</em>(<em>&lambda;</em>).  <em>f</em> is a Bernoulli factory function (or factory function) if this problem can be solved for that function.</p>

<p>This section contains additional algorithms to solve the Bernoulli factory problem for certain kinds of functions.  Such algorithms could be placed in &quot;<a href="https://peteroupc.github.io/bernoulli.html"><strong>Bernoulli Factory Algorithms</strong></a>&quot;, but, since that article is quite long as it is, they are included here instead.</p>

<p>In the methods below, <em>&lambda;</em> is the unknown probability of heads of the coin involved in the Bernoulli factory problem.</p>

<p><a id=Certain_Piecewise_Linear_Functions></a></p>

<h3>Certain Piecewise Linear Functions</h3>

<p>Let <em>f</em>(<em>&lambda;</em>) be a function of the form min(<em>&lambda;</em>*<em>mult</em>, 1&minus;<em>&epsilon;</em>). This is a <em>piecewise linear function</em>, a function made up of two linear pieces (in this case, the pieces are a rising linear part and a constant part).</p>

<p>This section describes how to calculate the Bernstein coefficients for polynomials that converge from above and below to <em>f</em>, based on Thomas and Blanchet (2012)[^1].  These polynomials can then be used to show heads with probability <em>f</em>(<em>&lambda;</em>) using the algorithms given in &quot;<a href="https://peteroupc.github.io/bernoulli.html#General_Factory_Functions"><strong>General Factory Functions</strong></a>&quot;.</p>

<p>In this section, <strong>fbelow(<em>n</em>, <em>k</em>)</strong> and <strong>fabove(<em>n</em>, <em>k</em>)</strong> are the <em>k</em><sup>th</sup> coefficients (with <em>k</em> starting at 0) of the lower and upper polynomials, respectively, in Bernstein form of degree <em>n</em>.</p>

<p>The code at the end of this section uses the computer algebra library SymPy to calculate a list of parameters for a sequence of polynomials converging from above.  The method to do so is called <code>calc_linear_func(eps, mult, count)</code>, where <code>eps</code> is <em>&epsilon;</em>, <code>mult</code> = <em>mult</em>, and <code>count</code> is the number of polynomials to generate.  Each item returned by <code>calc_linear_func</code> is a list of two items: the degree of the polynomial, and a <em>Y parameter</em>.  The procedure to calculate the required polynomials is then logically as follows (as written, it runs very slowly, though):</p>

<ol>
<li>Set <em>i</em> to 1.</li>
<li>Run <code>calc_linear_func(eps, mult, i)</code> and get the degree and <em>Y parameter</em> for the last listed item, call them <em>n</em> and <em>y</em>, respectively.</li>
<li>Set <em>x</em> to &minus;((<em>y</em>&minus;(1&minus;<em>&epsilon;</em>))/<em>&epsilon;</em>)<sup>5</sup>/<em>mult</em> + <em>y</em>/<em>mult</em>.  (This exact formula doesn&#39;t appear in the Thomas and Blanchet paper; rather it comes from the <a href="https://github.com/acthomasca/rberfac/blob/main/rberfac-public-2.R"><strong>supplemental source code</strong></a> uploaded by A. C. Thomas at my request.)</li>
<li>For degree <em>n</em>, <strong>fbelow(<em>n</em>, <em>k</em>)</strong> is min((<em>k</em>/<em>n</em>)*<em>mult</em>, 1&minus;<em>&epsilon;</em>), and <strong>fabove(<em>n</em>, <em>k</em>)</strong> is min((<em>k</em>/<em>n</em>)*<em>y</em>/<em>x</em>,<em>y</em>).  (<strong>fbelow</strong> matches <em>f</em> because <em>f</em> is <em>concave</em> on the interval [0, 1], which roughly means that its rate of growth there never goes up.)</li>
<li>Add 1 to <em>i</em> and go to step 2.</li>
</ol>

<p>It would be interesting to find general formulas to find the appropriate polynomials (degrees and <em>Y parameters</em>) given only the values for <em>mult</em> and <em>&epsilon;</em>, rather than find them &quot;the hard way&quot; via <code>calc_linear_func</code>.  For this procedure, the degrees and <em>Y parameters</em> can be upper bounds, as long as the sequence of degrees is strictly increasing and the sequence of Y parameters is nowhere increasing.</p>

<blockquote>
<p><strong>Note:</strong> In Nacu and Peres (2005)[^2], the following polynomial sequences were suggested to simulate $\min(2\lambda, 1-2\varepsilon)$, provided $\varepsilon \lt 1/8$, where <em>n</em> is a power of 2.  However, with these sequences, an extraordinary number of input coin flips is required to simulate this function each time.</p>

<ul>
<li><strong>fbelow(<em>n</em>, <em>k</em>)</strong> = $\min(2(k/n), 1-2\varepsilon)$.</li>
<li><strong>fabove(<em>n</em>, <em>k</em>)</strong> = $\min(2(k/n), 1-2\varepsilon)+$<br> $
\frac{2\times\max(0, k/n+3\varepsilon - 1/2)}{\varepsilon(2-\sqrt{2})} \sqrt{2/n}+$<br> $\frac{72\times\max(0,k/n-1/9)}{1-\exp(-2\times\varepsilon^2)} \exp(-2n\times\varepsilon^2)$.</li>
</ul>
</blockquote>

<p>SymPy code for piecewise linear functions:</p>

<pre>def bernstein_n(func, x, n, pt=None):
  # Bernstein operator.
  # Create a polynomial that approximates func, which in turn uses
  # the symbol x.  The polynomial&#39;s degree is n and is evaluated
  # at the point pt (or at x if not given).
  if pt==None: pt=x
  ret=0
  v=[binomial(n,j) for j in range(n//2+1)]
  for i in range(0, n+1):
    oldret=ret
    bino=v[i] if i&lt;len(v) else v[n-i]
    ret+=func.subs(x,S(i)/n)*bino*pt**i*(1-pt)**(n-i)
    if pt!=x and ret==oldret and ret&gt;0: break
  return ret

def inflec(y,eps=S(2)/10,mult=2):
  # Calculate the inflection point (x) given y, eps, and mult.
  # The formula is not found in the paper by Thomas and
  # Blanchet 2012, but in
  # the supplemental source code uploaded by
  # A.C. Thomas.
  po=5 # Degree of y-to-x polynomial curve
  eps=S(eps)
  mult=S(mult)
  x=-((y-(1-eps))/eps)**po/mult + y/mult
  return x

def xfunc(y,sym,eps=S(2)/10,mult=2):
  # Calculate Bernstein &quot;control polygon&quot; given y,
  # eps, and mult.
  return Min(sym*y/inflec(y,eps,mult),y)

def calc_linear_func(eps=S(5)/10, mult=1, count=10):
   # Calculates the degrees and Y parameters
   # of a sequence of polynomials that converge
   # from above to min(x*mult, 1-eps).
   # eps must be greater than 0 and less than 1.
   # Default is 10 polynomials.
   polys=[]
   eps=S(eps)
   mult=S(mult)
   count=S(count)
   bs=20
   ypt=1-(eps/4)
   x=symbols(&#39;x&#39;)
   tfunc=Min(x*mult,1-eps)
   tfn=tfunc.subs(x,(1-eps)/mult).n()
   xpt=xfunc(ypt,x,eps=eps,mult=mult)
   bits=5
   i=0
   lastbxn = 1
   diffs=[]
   while i&lt;count:
     bx=bernstein_n(xpt,x,bits,(1-eps)/mult)
     bxn=bx.n()
     if bxn &gt; tfn and bxn &lt; lastbxn:
       # Dominates target function
       #if oldbx!=None:
       #   diffs.append(bx)
       #   diffs.append(oldbx-bx)
       #oldbx=bx
       oldxpt=xpt
       lastbxn = bxn
       polys.append([bits,ypt])
       print(&quot;    [%d,%s],&quot; % (bits,ypt))
       # Find y2 such that y2 &lt; ypt and
       # bernstein_n(oldxpt,x,bits,inflec(y2, ...)) &gt;= y2,
       # so that next Bernstein expansion will go
       # underneath the previous one
       while True:
         ypt-=(ypt-(1-eps))/4
         xpt=inflec(ypt,eps=eps,mult=mult).n()
         bxs=bernstein_n(oldxpt,x,bits,xpt).n()
         if bxs&gt;=ypt.n():
            break
       xpt=xfunc(ypt,x,eps=eps,mult=mult)
       bits+=20
       i+=1
     else:
       bits=int(bits*200/100)
   return polys

calc_linear_func(count=8)
</pre>

<p><a id=Pushdown_Automata_for_Square_Root_Like_Functions></a></p>

<h3>Pushdown Automata for Square-Root-Like Functions</h3>

<p>In this section, ${n \choose m}$ = choose($n$, $m$) is a binomial coefficient.</p>

<p>The following algorithm extends the square-root construction of Flajolet et al. (2010)[^3], takes an input coin with probability of heads <em>&lambda;</em> (where 0 &le; <em>&lambda;</em> &lt; 1), and returns 1 with probability&mdash;</p>

<p>$$f(\lambda)=\frac{1-\lambda}{\sqrt{1+4\lambda\mathtt{Coin}(\lambda)(\mathtt{Coin}(\lambda)-1)}} = (1-\lambda)\sum_{n\ge 0} \lambda^n (\mathtt{Coin}(\lambda))^n (1-\mathtt{Coin}(\lambda))^n {2n \choose n}$$  $$= (1-\lambda)\sum_{n\ge 0} (\lambda \mathtt{Coin}(\lambda) (1-\mathtt{Coin}(\lambda)))^n {2n \choose n}$$ $$= \sum_{n\ge 0} (1-\lambda) \lambda^n h_n(\lambda) = \sum_{n\ge 0} g(n, \lambda) h_n(\lambda),$$</p>

<p>and 0 otherwise, where:</p>

<ul>
<li><code>Coin</code>(<em>&lambda;</em>) is a Bernoulli factory function. If <code>Coin</code> is a rational function (a ratio of two polynomials) whose coefficients are rational numbers, then <em>f</em> is an <em>algebraic function</em> (a function that can be a solution of a nonzero polynomial equation) and can be simulated by a <em>pushdown automaton</em>, or a state machine with a stack (see the algorithm below and the note that follows it). But this algorithm will still work even if <code>Coin</code> is not a rational function.  In the original square-root construction,  <code>Coin</code>(<em>&lambda;</em>) = 1/2.</li>
<li>$g(n, \lambda) = (1-\lambda) \lambda^n$; this is the probability of running the <code>Coin</code> Bernoulli factory $2 \times n$ times.</li>
<li>$h_n(\lambda) = (\mathtt{Coin}(\lambda))^n (1-\mathtt{Coin}(\lambda))^n {2n \choose n}$; this is the probability of getting as many ones as zeros from the <code>Coin</code> Bernoulli factory.</li>
</ul>

<p>Equivalently&mdash; $$f(\lambda)=(1-\lambda) OGF(\lambda \mathtt{Coin}(\lambda) (1-\mathtt{Coin}(\lambda))),$$ where $OGF(x) = \sum_{n\ge 0} x^n {2n \choose n}$ is the algorithm&#39;s ordinary generating function (also known as counting generating function).</p>

<p>The algorithm follows.</p>

<ol>
<li>Set <em>d</em> to 0.</li>
<li>Do the following process repeatedly until this run of the algorithm returns a value:

<ol>
<li>Flip the input coin.  If it returns 1, go to the next substep.  Otherwise, return either 1 if <em>d</em> is 0, or 0 otherwise.</li>
<li>Run a Bernoulli factory algorithm for <code>Coin</code>(<em>&lambda;</em>).  If the run returns 1, add 1 to <em>d</em>.  Otherwise, subtract 1 from <em>d</em>.</li>
<li>Repeat the previous substep.</li>
</ol></li>
</ol>

<blockquote>
<p><strong>Note:</strong> A <em>pushdown automaton</em> is a state machine that keeps a stack of symbols.  In this document, the input for this automaton is a stream of flips of a coin that shows heads with probability <em>&lambda;</em>, and the output is 0 or 1 depending on which state the automaton ends up in when it empties the stack (Mossel and Peres 2005)[^4].  That paper shows that a pushdown automaton, as defined here, can simulate only <em>algebraic functions</em>, that is, functions that can be a solution of a nonzero polynomial equation.  The <a href="#Pushdown_Automata_and_Algebraic_Functions"><strong>appendix</strong></a> defines these machines in more detail and has proofs on which algebraic functions are possible with pushdown automata.</p>

<p>As a pushdown automaton, this algorithm (except the &quot;Repeat the previous substep&quot; part) can be expressed as follows. Let the stack have the single symbol EMPTY, and start at the state POS-S1.  Based on the current state, the last coin flip (HEADS or TAILS), and the symbol on the top of the stack, set the new state and replace the top stack symbol with zero, one, or two symbols.  These <em>transition rules</em> can be written as follows:</p>

<ul>
<li>(POS-S1, HEADS, <em>topsymbol</em>) &rarr; (POS-S2, {<em>topsymbol</em>}) (set state to POS-S2, keep <em>topsymbol</em> on the stack).</li>
<li>(NEG-S1, HEADS, <em>topsymbol</em>) &rarr; (NEG-S2, {<em>topsymbol</em>}).</li>
<li>(POS-S1, TAILS, EMPTY) &rarr; (ONE, {}) (set state to ONE, pop the top symbol from the stack).</li>
<li>(NEG-S1, TAILS, EMPTY) &rarr; (ONE, {}).</li>
<li>(POS-S1, TAILS, X) &rarr; (ZERO, {}).</li>
<li>(NEG-S1, TAILS, X) &rarr; (ZERO, {}).</li>
<li>(ZERO, <em>flip</em>, <em>topsymbol</em>) &rarr; (ZERO, {}).</li>
<li>(POS-S2, <em>flip</em>, <em>topsymbol</em>) &rarr; Add enough transition rules to the automaton to simulate <em>g</em>(<em>&lambda;</em>) by a finite-state machine (only possible if <em>g</em> is rational with rational coefficients (Mossel and Peres 2005)[^4]).  Transition to POS-S2-ZERO if the machine outputs 0, or POS-S2-ONE if the machine outputs 1.</li>
<li>(NEG-S2, <em>flip</em>, <em>topsymbol</em>) &rarr; Same as before, but the transitioning states are NEG-S2-ZERO and NEG-S2-ONE, respectively.</li>
<li>(POS-S2-ONE, <em>flip</em>, <em>topsymbol</em>) &rarr; (POS-S1, {<em>topsymbol</em>, X}) (replace top stack symbol with <em>topsymbol</em>, then push X to the stack).</li>
<li>(POS-S2-ZERO, <em>flip</em>, EMPTY) &rarr; (NEG-S1, {EMPTY, X}).</li>
<li>(POS-S2-ZERO, <em>flip</em>, X) &rarr; (POS-S1, {}).</li>
<li>(NEG-S2-ZERO, <em>flip</em>, <em>topsymbol</em>) &rarr; (NEG-S1, {<em>topsymbol</em>, X}).</li>
<li>(NEG-S2-ONE, <em>flip</em>, EMPTY) &rarr; (POS-S1, {EMPTY, X}).</li>
<li>(NEG-S2-ONE, <em>flip</em>, X) &rarr; (NEG-S1, {}).</li>
</ul>

<p>The machine stops when it removes EMPTY from the stack, and the result is either ZERO (0) or ONE (1).</p>
</blockquote>

<p>For the following algorithm, which extends the end of Note 1 of the Flajolet paper, the probability is&mdash; $$f(\lambda)=(1-\lambda) \sum_{n\ge 0} \lambda^{Hn} \mathtt{Coin}(\lambda)^n (1-\mathtt{Coin}(\lambda))^{Hn-n} {Hn \choose n},$$ where <em>H</em> &ge; 2 is an integer; and <code>Coin</code> has the same meaning as earlier.</p>

<ol>
<li>Set <em>d</em> to 0.</li>
<li>Do the following process repeatedly until this run of the algorithm returns a value:

<ol>
<li>Flip the input coin.  If it returns 1, go to the next substep.  Otherwise, return either 1 if <em>d</em> is 0, or 0 otherwise.</li>
<li>Run a Bernoulli factory algorithm for <code>Coin</code>(<em>&lambda;</em>).  If the run returns 1, add (<em>H</em>&minus;1) to <em>d</em>.  Otherwise, subtract 1 from <em>d</em>.</li>
</ol></li>
</ol>

<p>The following algorithm simulates the probability&mdash; $$
f(\lambda) = (1-\lambda) \sum_{n\ge 0} \lambda^n \left( \sum_{m\ge 0} W(n,m) \mathtt{Coin}(\lambda)^m (1-\mathtt{Coin}(\lambda))^{n-m} {n \choose m}\right)$$ $$= (1-\lambda) \sum_{n\ge 0} \lambda^n \left( \sum_{m\ge 0} V(n,m) \mathtt{Coin}(\lambda)^m (1-\mathtt{Coin}(\lambda))^{n-m}\right),$$ where <code>Coin</code> has the same meaning as earlier; <em>W</em>(<em>n</em>, <em>m</em>) is 1 if <em>m</em>*<em>H</em> equals (<em>n</em>&minus;<em>m</em>)*<em>T</em>, or 0 otherwise; and <em>H</em>&ge;1 and <em>T</em>&ge;1 are integers. (In the first formula, the sum in parentheses is a polynomial in Bernstein form, in the variable <code>Coin</code>(<em>&lambda;</em>) and with only zeros and ones as coefficients.  Because of the <em>&lambda;</em><sup><em>n</em></sup>, the polynomial gets smaller as <em>n</em> gets larger.  <em>V</em>(<em>n</em>, <em>m</em>) is the number of <em>n</em>-letter words that have <em>m</em> heads <em>and</em> describe a walk that ends at the beginning.)</p>

<ol>
<li>Set <em>d</em> to 0.</li>
<li>Do the following process repeatedly until this run of the algorithm returns a value:

<ol>
<li>Flip the input coin.  If it returns 1, go to the next substep.  Otherwise, return either 1 if <em>d</em> is 0, or 0 otherwise.</li>
<li>Run a Bernoulli factory algorithm for <code>Coin</code>(<em>&lambda;</em>).  If the run returns 1 (&quot;heads&quot;), add <em>H</em> to <em>d</em>.  Otherwise (&quot;tails&quot;), subtract <em>T</em> from <em>d</em>.</li>
</ol></li>
</ol>

<p><a id=Irrational_Probabilities></a></p>

<h2>Irrational Probabilities</h2>

<p><a id=Ratio_of_Lower_Gamma_Functions_gamma__m___x__gamma__m__1></a></p>

<h3>Ratio of Lower Gamma Functions (&gamma;(<em>m</em>, <em>x</em>)/&gamma;(<em>m</em>, 1)).</h3>

<ol>
<li>Set <em>ret</em> to the result of <strong>kthsmallest</strong> with the two parameters <em>m</em> and <em>m</em>.  (Thus, <em>ret</em> is distributed as <em>u</em><sup>1/<em>m</em></sup> where <em>u</em> is a uniform random variate greater than 0 and less than 1; although <strong>kthsmallest</strong> accepts only integers, this formula works for every <em>m</em> greater than 0.)</li>
<li>Set <em>k</em> to 1, then set <em>u</em> to point to the same value as <em>ret</em>.</li>
<li>Generate a uniform(0, 1) random variate <em>v</em>.</li>
<li>If <em>v</em> is less than <em>u</em>: Set <em>u</em> to <em>v</em>, then add 1 to <em>k</em>, then go to step 3.</li>
<li>If <em>k</em> is odd[^5], return a number that is 1 if <em>ret</em> is less than <em>x</em> and 0 otherwise. (If <em>ret</em> is implemented as a uniform partially-sampled random number (PSRN), this comparison should be done via <strong>URandLessThanReal</strong>.)  If <em>k</em> is even[^6], go to step 1.</li>
</ol>

<p>Derivation:  See Formula 1 in the section &quot;<a href="https://peteroupc.github.io/bernoulli.html#Probabilities_Arising_from_Certain_Permutations"><strong>Probabilities Arising from Certain Permutations</strong></a>&quot;, where:</p>

<ul>
<li><code>ECDF(x)</code>  is the probability that a uniform random variate greater than 0 and less than 1 is <em>x</em> or less, namely <em>x</em> if <em>x</em> is in [0, 1], 0 if <em>x</em> is less than 0, and 1 otherwise.</li>
<li><code>DPDF(x)</code> is the probability density function for the maximum of <em>m</em> uniform random variates in [0, 1], namely <em>m</em>*<em>x</em><sup><em>m</em>&minus;1</sup> if <em>x</em> is in [0, 1], and 0 otherwise.</li>
</ul>

<p><a id=4_3___pi></a></p>

<h3>4/(3*<em>&pi;</em>)</h3>

<p>Given that the point (<em>x</em>, <em>y</em>) has positive coordinates and lies inside a disk of radius 1 centered at (0, 0), the mean value of <em>x</em> is 4/(3*<em>&pi;</em>). This leads to the following algorithm to sample that probability:</p>

<ol>
<li>Generate two PSRNs in the form of a uniformly chosen point inside a 2-dimensional quarter hypersphere (that is, a quarter of a &quot;filled circle&quot;; see &quot;<a href="https://peteroupc.github.io/morealg.html#Uniform_Distribution_Inside_N_Dimensional_Shapes"><strong>Uniform Distribution Inside N-Dimensional Shapes</strong></a>&quot; in the article &quot;More Algorithms for Arbitrary-Precision Sampling&quot;, as well as the examples there).</li>
<li>Let <em>x</em> be one of those PSRNs.  Run <strong>SampleGeometricBag</strong> on that PSRN and return the result (which will be either 0 or 1).</li>
</ol>

<blockquote>
<p><strong>Note:</strong> The mean value 4/(3*<em>&pi;</em>) can be derived as follows.  The relative probability that <em>x</em> is &quot;close&quot; to <em>z</em>, where $0\le <em>z</em> \le 1$, is <em>p</em>(<em>z</em>) = sqrt(1 &minus; <em>z</em>*<em>z</em>).  Now find the integral (&quot;area under the graph&quot;) of <em>z</em>*<em>p</em>(<em>z</em>)/<em>c</em> (where <em>c</em>=<em>&pi;</em>/4 is the integral of <em>p</em>(<em>z</em>) on the interval [0, 1]).  The result is the mean value 4/(3*<em>&pi;</em>).  The following Python code prints this mean value using the SymPy computer algebra library: <code>p=sqrt(1-z*z); c=integrate(p,(z,0,1)); print(integrate(z*p/c,(z,0,1)));</code>.</p>
</blockquote>

<p><a id=1_exp__k__1_exp__k__1></a></p>

<h3>(1 + exp(<em>k</em>)) / (1 + exp(<em>k</em> + 1))</h3>

<p>This algorithm simulates this probability by computing lower and upper bounds of exp(1), which improve as more and more digits are calculated.  These bounds are calculated through an algorithm by Citterio and Pavani (2016)[^7].  Note the use of the methodology in Łatuszyński et al. (2009/2011, algorithm 2)[^8] in this algorithm.  In this algorithm, <em>k</em> must be an integer 0 or greater.</p>

<ol>
<li>If <em>k</em> is 0, run the <strong>algorithm for 2 / (1 + exp(2))</strong> and return the result.  If <em>k</em> is 1, run the <strong>algorithm for (1 + exp(1)) / (1 + exp(2))</strong> and return the result.</li>
<li>Generate a uniform(0, 1) random variate, call it <em>ret</em>.</li>
<li>If <em>k</em> is 3 or greater, return 0 if <em>ret</em> is greater than 38/100, or 1 if <em>ret</em> is less than 36/100.  (This is an early return step.  If <em>ret</em> is implemented as a uniform PSRN, these comparisons should be done via the <strong>URandLessThanReal algorithm</strong>, which is described in my <a href="https://peteroupc.github.io/exporand.html"><strong>article on PSRNs</strong></a>.)</li>
<li>Set <em>d</em> to 2.</li>
<li>Calculate a lower and upper bound of exp(1) (<em>LB</em> and <em>UB</em>, respectively) in the form of rational numbers whose numerator has at most <em>d</em> digits, using the Citterio and Pavani algorithm.  For details, see later.</li>
<li>Set <em>rl</em> to (1+<em>LB</em><sup><em>k</em></sup>) / (1+<em>UB</em><sup><em>k</em> + 1</sup>), and set <em>ru</em> to (1+<em>UB</em><sup><em>k</em></sup>) / (1+<em>LB</em><sup><em>k</em> + 1</sup>); both these numbers should be calculated using rational arithmetic.</li>
<li>If <em>ret</em> is greater than <em>ru</em>, return 0.  If <em>ret</em> is less than <em>rl</em>, return 1.  (If <em>ret</em> is implemented as a uniform PSRN, these comparisons should be done via <strong>URandLessThanReal</strong>.)</li>
<li>Add 1 to <em>d</em> and go to step 5.</li>
</ol>

<p>The following implements the parts of Citterio and Pavani&#39;s algorithm needed to calculate lower and upper bounds for exp(1) in the form of rational numbers.</p>

<p>Define the following operations:</p>

<ul>
<li><strong>Setup:</strong> Set <em>p</em> to the list <code>[0, 1]</code>, set <em>q</em> to the list <code>[1, 0]</code>, set <em>a</em> to the list <code>[0, 0, 2]</code> (two zeros, followed by the integer part for exp(1)), set <em>v</em> to 0, and set <em>av</em> to 0.</li>
<li><strong>Ensure <em>n</em>:</strong> While <em>v</em> is less than or equal to <em>n</em>:

<ol>
<li>(Ensure partial denominator <em>v</em>, starting from 0, is available.) If <em>v</em> + 2 is greater than or equal to the size of <em>a</em>, append 1, <em>av</em>, and 1, in that order, to the list <em>a</em>, then add 2 to <em>av</em>.</li>
<li>(Calculate convergent <em>v</em>, starting from 0.) Append <em>a</em>[<em>n</em>+2] * <em>p</em>[<em>n</em>+1]+<em>p</em>[<em>n</em>] to the list <em>p</em>, and append <em>a</em>[<em>n</em>+2] * <em>q</em>[<em>n</em>+1]+<em>q</em>[<em>n</em>] to the list <em>q</em>. (Positions in lists start at 0.  For example, <em>p</em>[0] means the first item in <em>p</em>; <em>p</em>[1] means the second; and so on.)</li>
<li>Add 1 to <em>v</em>.</li>
</ol></li>
<li><strong>Get the numerator for convergent <em>n</em>:</strong> Ensure <em>n</em>, then return <em>p</em>[<em>n</em>+2].</li>
<li><strong>Get convergent <em>n</em>:</strong> Ensure <em>n</em>, then return <em>p</em>[<em>n</em>+2]/<em>q</em>[<em>n</em>+2].</li>
<li><strong>Get semiconvergent <em>n</em> given <em>d</em>:</strong>

<ol>
<li>Ensure <em>n</em>, then set <em>m</em> to floor(((10<sup><em>d</em></sup>)&minus;1&minus;<em>p</em>[<em>n</em>+1])/<em>p</em>[<em>n</em>+2]).</li>
<li>Return (<em>p</em>[<em>n</em>+2] * <em>m</em> +<em>p</em>[<em>n</em>+1]) / (<em>q</em>[<em>n</em>+2] * <em>m</em> +<em>q</em>[<em>n</em>+1]).</li>
</ol></li>
</ul>

<p>Then the algorithm to calculate lower and upper bounds for exp(1), given <em>d</em>, is as follows:</p>

<ol>
<li>Set <em>i</em> to 0, then run the <strong>setup</strong>.</li>
<li><strong>Get the numerator for convergent <em>i</em></strong>, call it <em>c</em>. If <em>c</em> is less than 10<sup><em>d</em></sup>, add 1 to <em>i</em> and repeat this step.  Otherwise, go to the next step.</li>
<li><strong>Get convergent <em>i</em> &minus; 1</strong> and <strong>get semiconvergent <em>i</em> &minus; 1 given <em>d</em></strong>, call them <em>conv</em> and <em>semi</em>, respectively.</li>
<li>If (<em>i</em> &minus; 1) is odd[^5], return <em>semi</em> as the lower bound and <em>conv</em> as the upper bound.  Otherwise, return <em>conv</em> as the lower bound and <em>semi</em> as the upper bound.</li>
</ol>

<p><a id=Sampling_Distributions_Using_Incomplete_Information></a></p>

<h2>Sampling Distributions Using Incomplete Information</h2>

<p>The Bernoulli factory is a special case of the problem of <strong>sampling a probability distribution with unknown parameters</strong>.  This problem can be described as sampling from a new distribution using an <em>oracle</em> (black box) that produces numbers of an incompletely known distribution. In the Bernoulli factory problem, this oracle is a <em>coin that shows heads or tails where the probability of heads is unknown</em>.  The rest of this section deals with oracles that go beyond coins.</p>

<p><strong>Algorithm 1.</strong> Suppose there is an oracle that produces independent random variates on a closed interval [<em>a</em>, <em>b</em>], and these numbers have an unknown mean of <em>&mu;</em>. The goal is now to produce nonnegative random variates whose expected value (&quot;long-run average&quot;) is <em>f</em>(<em>&mu;</em>).  Unless <em>f</em> is constant, this is possible if and only if&mdash;</p>

<ul>
<li><em>f</em> is continuous on the closed interval, and</li>
<li><em>f</em>(<em>&mu;</em>) is greater than or equal to <em>&epsilon;</em>*min((<em>&mu;</em> &minus; <em>a</em>)<sup><em>n</em></sup>, (<em>b</em> &minus; <em>&mu;</em>)<sup><em>n</em></sup>) for some integer <em>n</em> and some <em>&epsilon;</em> greater than 0 (loosely speaking, <em>f</em> is nonnegative and neither touches 0 in the interior of the interval nor moves away from 0 more slowly than a polynomial)</li>
</ul>

<p>(Jacob and Thiery 2015)[^9]. (Here, <em>a</em> and <em>b</em> are both rational numbers and may be less than 0.)</p>

<p>In the algorithm below, let <em>K</em> be a rational number greater than the maximum value of <em>f</em> on the closed interval [<em>a</em>, <em>b</em>], and let <em>g</em>(<em>&lambda;</em>) = <em>f</em>(<em>a</em> + (<em>b</em>&minus;<em>a</em>)*<em>&lambda;</em>)/<em>K</em>.</p>

<ol>
<li>Create a <em>&lambda;</em> input coin that does the following: &quot;Take a number from the oracle, call it <em>x</em>.  With probability (<em>x</em>&minus;<em>a</em>)/(<em>b</em>&minus;<em>a</em>) (see note below), return 1.  Otherwise, return 0.&quot;</li>
<li>Run a Bernoulli factory algorithm for <em>g</em>(<em>&lambda;</em>), using the <em>&lambda;</em> input coin.  Then return <em>K</em> times the result.</li>
</ol>

<blockquote>
<p><strong>Note:</strong> The check &quot;With probability (<em>x</em>&minus;<em>a</em>)/(<em>b</em>&minus;<em>a</em>)&quot; is exact if the oracle produces only rational numbers.  If the oracle can produce irrational numbers (such as numbers that follow a beta distribution or another non-discrete distribution), then the code for the oracle should use uniform <a href="https://peteroupc.github.io/exporand.html"><strong>partially-sampled random numbers (PSRNs)</strong></a>.  In that case, the check can be implemented as follows.  Let <em>x</em> be a uniform PSRN representing a number generated by the oracle.  Set <em>y</em> to <strong>RandUniformFromReal</strong>(<em>b</em>&minus;<em>a</em>), then the check succeeds if <strong>URandLess</strong>(<em>y</em>, <strong>UniformAddRational</strong>(<em>x</em>, &minus;<em>a</em>)) returns 1, and fails otherwise.</p>

<p><strong>Example:</strong> Suppose an oracle produces random variates in the interval [3, 13] with unknown mean <em>&mu;</em>, and the goal is to use the oracle to produce nonnegative random variates with mean <em>f</em>(<em>&mu;</em>) = &minus;319/100 + <em>&mu;</em>*103/50 &minus; <em>&mu;</em><sup>2</sup>*11/100, which is a polynomial with Bernstein coefficients [2, 9, 5] in the given interval.  Then since 8 is greater than the maximum of <em>f</em> in that interval, <em>g</em>(<em>&lambda;</em>) is a degree-2 polynomial in the interval [0, 1] that has Bernstein coefficients [2/8, 9/8, 5/8].  <em>g</em> can&#39;t be simulated as is, though, but increasing <em>g</em>&#39;s degree to 3 leads to the Bernstein coefficients [1/4, 5/6, 23/24, 5/8], which are all less than 1 so that the following algorithm can be used (see &quot;<a href="https://peteroupc.github.io/bernoulli.html#Certain_Polynomials"><strong>Certain Polynomials</strong></a>&quot;):</p>

<ol>
<li>Set <em>heads</em> to 0.</li>
<li>Generate three random variates from the oracle (which must produce random variates in the interval [3, 13]).  For each number <em>x</em>: With probability (<em>x</em>&minus;3)/(10&minus;3), add 1 to <em>heads</em>.</li>
<li>Depending on <em>heads</em>, return 8 (that is, 1 times the upper bound) with the given probability, or 0 otherwise: <em>heads</em>=0 &rarr; probability 1/4; 1 &rarr; 5/6; 2 &rarr; 23/24; 3 &rarr; 5/8.</li>
</ol>
</blockquote>

<p><strong>Algorithm 2.</strong> This algorithm takes an oracle and produces nonnegative random variates whose expected value (&quot;long-run average&quot;) is the mean of <em>f</em>(<em>X</em>), where <em>X</em> is a number produced by the oracle.  The algorithm appears in the appendix, however, because it requires applying an arbitrary function (here, <em>f</em>) to a potentially irrational number.</p>

<p><strong>Algorithm 3.</strong> For this algorithm, see the appendix.</p>

<p><strong>Algorithm 4.</strong> Say there is an oracle in the form of a fair die.  The number of faces of the die, <em>n</em>, is at least 2 but otherwise unknown. Each face shows a different integer 0 or greater and less than <em>n</em>.  The question arises: Which probability distributions based on the number of faces can be sampled with this oracle?  This question was studied in the French-language dissertation of R. Duvignau (2015, section 5.2)[^10], and the following are four of these distributions.</p>

<p><strong><em>Bernoulli 1/n.</em></strong> It&#39;s trivial to generate a Bernoulli variate that is 1 with probability 1/<em>n</em> and 0 otherwise: just take a number from the oracle and return either 1 if that number is 0, or 0 otherwise.  Alternatively, take two numbers from the oracle and return either 1 if both are the same, or 0 otherwise (Duvignau 2015, p. 153)[^10].</p>

<p><strong><em>Random variate with mean n.</em></strong> Likewise, it&#39;s trivial to generate variates with a mean of <em>n</em>: Do &quot;Bernoulli 1/n&quot; trials as described above until a trial returns 0, then return the number of trials done this way.  (This is related to the ambiguously defined &quot;geometric&quot; random variates.)</p>

<p><strong><em>Binomial with parameters n and 1/n.</em></strong> Using the oracle, the following algorithm generates a binomial variate of this kind (Duvignau 2015, Algorithm 20)[^10]:</p>

<ol>
<li>Take items from the oracle until the same item is taken twice.</li>
<li>Create a list consisting of the items taken in step 1, except for the last item taken, then shuffle that list.</li>
<li>In the shuffled list, count the number of items that didn&#39;t change position after being shuffled, then return that number.</li>
</ol>

<p><strong><em>Binomial with parameters n and k/n.</em></strong> Duvignau 2015 also includes an algorithm (Algorithm 25) to generate a binomial variate of this kind using the oracle (where <em>k</em> is a known integer such that 0 &lt; <em>k</em> and <em>k</em> &le; <em>n</em>):</p>

<ol>
<li>Take items from the oracle until <em>k</em> different items were taken this way.  Let <em>U</em> be a list of these <em>k</em> items, in the order in which they were first taken.</li>
<li>Create an empty list <em>L</em>.</li>
<li>For each integer <em>i</em> in [0, <em>k</em>):

<ol>
<li>Create an empty list <em>M</em>.</li>
<li>Take an item from the oracle.  If the item is in <em>U</em> at a position <strong>less than <em>i</em></strong> (positions start at 0), repeat this substep.  Otherwise, if the item is not in <em>M</em>, add it to <em>M</em> and repeat this substep.  Otherwise, go to the next substep.</li>
<li>Shuffle the list <em>M</em>, then add to <em>L</em> each item that didn&#39;t change position after being shuffled (if not already present in <em>L</em>).</li>
</ol></li>
<li>For each integer <em>i</em> in [0, <em>k</em>):

<ol>
<li>Let <em>P</em> be the item at position <em>i</em> in <em>U</em>.</li>
<li>Take an item from the oracle.  If the item is in <em>U</em> at position <strong><em>i</em> or less</strong> (positions start at 0), repeat this substep.</li>
<li>If the last item taken in the previous substep is in <em>U</em> at a position <strong>greater than <em>i</em></strong>, add <em>P</em> to <em>L</em> (if not already present).</li>
</ol></li>
<li>Return the number of items in <em>L</em>.</li>
</ol>

<blockquote>
<p><strong>Note:</strong> Duvignau proved a result (Theorem 5.2) that answers the question: Which probability distributions based on the unknown <em>n</em> can be sampled with the oracle?[^11] The result applies to a family of (discrete) distributions with the same unknown parameter <em>n</em>, starting with either 1 or a greater integer.  Let Supp(<em>m</em>) be the set of values taken on by the distribution with parameter equal to <em>m</em>.  Then that family can be sampled using the oracle if and only if:</p>

<ul>
<li>There is a computable function <em>f</em>(<em>k</em>) that outputs a positive number.</li>
<li>For each <em>n</em>, Supp(<em>n</em>) is included in Supp(<em>n</em>+1).</li>
<li>For every <em>k</em> and for every <em>n</em> &ge; 2 starting with the first <em>n</em> for which <em>k</em> is in Supp(<em>n</em>), the probability of seeing <em>k</em> given parameter <em>n</em> is at least (1/<em>n</em>)<sup><em>f</em>(<em>k</em>)</sup> (roughly speaking, the probability doesn&#39;t decay at a faster than polynomial rate as <em>n</em> increases).</li>
</ul>
</blockquote>

<p><a id=Sum_of_Uniform_Random_Variates></a></p>

<h2>Sum of Uniform Random Variates</h2>

<p>This page presents new algorithms to sample the sum of uniform(0, 1) random variates and the ratio of two uniform(0, 1) random variates, with the help of <a href="https://peteroupc.github.io/exporand.html"><strong>partially-sampled random numbers</strong></a> (PSRNs), with arbitrary precision and without relying on floating-point arithmetic.  See the page on PSRNs for more information on some of the algorithms made use of here, including <strong>SampleGeometricBag</strong> and <strong>FillGeometricBag</strong>.</p>

<p>The algorithms on this page work no matter what base the digits of the partially-sampled number are stored in (such as base 2 for decimal or base 10 for binary), unless noted otherwise.</p>

<p><a id=About_the_Uniform_Sum_Distribution></a></p>

<h3>About the Uniform Sum Distribution</h3>

<p>The sum of <em>n</em> uniform(0, 1) random variates has the following probability density function (PDF) (see <a href="https://mathworld.wolfram.com/UniformSumDistribution.html"><strong>MathWorld</strong></a>):</p>

<p>$$f(x)=\left(\sum_{k=0}^n (-1)^k {n\choose k} (x-k)^{n-1} \text{sign}(x-k)\right)/(2(n-1)!),$$</p>

<p>where ${n\choose k}$ is a <em>binomial coefficient</em>, or the number of ways to choose <em>k</em> out of <em>n</em> labeled items, and sign(<em>x</em>) is 1 if <em>x</em> is greater than 0, or 0 if <em>x</em> is 0, or &minus;1 is less than 0.[^12][^13][^14]</p>

<p>This is a polynomial of degree <em>n</em> &minus; 1.  For <em>n</em> uniform numbers, the distribution can take on values that are 0 or greater and <em>n</em> or less.</p>

<p>The samplers given below for the uniform sum logically work as follows:</p>

<ol>
<li>The distribution is divided into pieces that are each 1 unit long (thus, for example, if <em>n</em> is 4, there will be four pieces).</li>
<li>An integer in [0, <em>n</em>) is chosen uniformly at random, call it <em>i</em>, then the piece identified by <em>i</em> is chosen.  There are <a href="https://peteroupc.github.io/randomfunc.html#RNDINT_Random_Integers_in_0_N"><strong>many algorithms to choose an integer</strong></a> this way, but an algorithm that is &quot;optimal&quot; in terms of the number of bits it uses, as well as unbiased, should be chosen.</li>
<li><p>The PDF at [<em>i</em>, <em>i</em> + 1] is simulated.  This is done by shifting the PDF so the desired piece of the PDF is at [0, 1] rather than its usual place.  More specifically, the PDF is now as follows: $$f(x)=\left(\sum_{k=0}^n (-1)^k {n\choose k} ((x+i)-k)^{n-1} \text{sign}((x+i)-k)\right)/(2(n-1)!),$$ where <em>x</em> is a real number in [0, 1].  Since <em>f</em>&prime; is a polynomial, it can be rewritten in Bernstein form, so that it has <em>Bernstein coefficients</em>, which are equivalent to control points describing the shape of the curve drawn out by <em>f</em>&prime;. (The Bernstein coefficients are the backbone of the well-known Bézier curve.) A polynomial can be written in Bernstein form as&mdash; $$\sum_{k=0}^m {m\choose k} x^k (1-x)^{m-k} a[k],$$ where <em>a</em>[<em>k</em>] are the control points and <em>m</em> is the polynomial&#39;s degree (here, <em>n</em> &minus; 1). In this case, there will be <em>n</em> control points, which together trace out a 1-dimensional Bézier curve.  For example, given control points 0.2, 0.3, and 0.6, the curve is at 0.2 when <em>x</em> = 0, and 0.6 when <em>x</em> = 1.  (Note that the curve is not at 0.3 when <em>x</em> = 1/2; in general, Bézier curves do not cross their control points other than the first and the last.)</p>

<p>Moreover, this polynomial can be simulated because its Bernstein coefficients all lie in [0, 1] (Goyal and Sigman 2012)[^15].</p></li>
<li>The sampler creates a &quot;coin&quot; made up of a uniform partially-sampled random number (PSRN) whose contents are built up on demand using an algorithm called <strong>SampleGeometricBag</strong>.  It flips this &quot;coin&quot; <em>n</em> &minus; 1 times and counts the number of times the coin returned 1 this way, call it <em>j</em>. (The &quot;coin&quot; will return 1 with probability equal to the to-be-determined uniform random variate.)</li>
<li>Based on <em>j</em>, the sampler accepts the PSRN with probability equal to the control point <em>a</em>[<em>j</em>]. (See (Goyal and Sigman 2012)[^15].)</li>
<li>If the PSRN is accepted, the sampler optionally fills it up with uniform random digits, then sets the PSRN&#39;s integer part to <em>i</em>, then the sampler returns the finished PSRN.  If the PSRN is not accepted, the sampler starts over from step 2.</li>
</ol>

<p><a id=Finding_Parameters></a></p>

<h3>Finding Parameters</h3>

<p>Using the uniform sum sampler for an arbitrary <em>n</em> requires finding the Bernstein control points for each of the <em>n</em> pieces of the uniform sum PDF.  This can be found, for example, with the Python code below, which uses the SymPy computer algebra library.  In the code:</p>

<ul>
<li><code>unifsum(x,n,v)</code> calculates the PDF of the sum of <code>n</code> uniform random variates when the variable <code>x</code> is shifted by <code>v</code> units.</li>
<li><code>find_control_points</code> returns the control points for each piece of the PDF for the sum of <code>n</code> uniform random variates, starting with piece 0.</li>
<li><code>find_areas</code> returns the relative areas for each piece of that PDF.  This can be useful to implement a variant of the sampler above, as detailed later in this section.</li>
</ul>

<pre>def unifsum(x,n,v):
    # Builds up the PDF at x (with offset v)
    # of the sum of n uniform random variates
    ret=0
    x=x+v # v is an offset
    for k in range(n+1):
           s=(-1)**k*binomial(n,k)*(x-k)**(n-1)
           # Equivalent to k&gt;x+v since x is limited
           # to [0, 1]
           if k&gt;v: ret-=s
           else: ret+=s
    return ret/(2*factorial(n-1))

def find_areas(n):
   x=symbols(&#39;x&#39;, real=True)
   areas=[integrate(unifsum(x,n,i),(x,0,1)) for i in range(n)]
   g=prod([v.q for v in areas])
   areas=[int(v*g) for v in areas]
   g=gcd(areas)
   areas=[v/int(g) for v in areas]
   return areas

def find_control_points(n, scale_pieces=False):
 x=symbols(&#39;x&#39;, real=True)
 controls=[]
 for i in range(n):
  # Find the &quot;usual&quot; coefficients of the uniform
  # sum polynomial at offset i.
  poly=Poly(unifsum(x, n, i))
  coeffs=[poly.coeff_monomial(x**i) for i in range(n)]
  # Build coefficient vector
  coeffs=Matrix(coeffs)
  # Build power-to-Bernstein basis matrix
  mat=[[0 for _ in range(n)] for _ in range(n)]
  for j in range(n):
    for k in range(n):
       if k==0 or j==n-1:
         mat[j][k]=1
       elif k&lt;=j:
         mat[j][k]=binomial(j, j-k) / binomial(n-1, k)
       else:
         mat[j][k]=0
  mat=Matrix(mat)
  # Get the Bernstein control points
  mv = mat*coeffs
  mvc = [Rational(mv[i]) for i in range(n)]
  maxcoeff = max(mvc)
  # If requested, scale up control points to raise acceptance rate
  if scale_pieces:
     mvc = [v/maxcoeff for v in mvc]
  mv = [[v.p, v.q] for v in mvc]
  controls.append(mv)
 return controls
</pre>

<p>The basis matrix is found, for example, as Equation 42 of (Ray and Nataraj 2012)[^16].</p>

<p>For example, if <em>n</em> = 4 (so a sum of four uniform random variates is desired), the following control points are used for each piece of the PDF:</p>

<table><thead>
<tr>
<th>Piece</th>
<th>Control Points</th>
</tr>
</thead><tbody>
<tr>
<td>0</td>
<td>0, 0, 0, 1/6</td>
</tr>
<tr>
<td>1</td>
<td>1/6, 1/3, 2/3, 2/3</td>
</tr>
<tr>
<td>2</td>
<td>2/3, 2/3, 1/3, 1/6</td>
</tr>
<tr>
<td>3</td>
<td>1/6, 0, 0, 0</td>
</tr>
</tbody></table>

<p>For more efficient results, all these control points could be scaled so that the highest control point is equal to 1.  This doesn&#39;t affect the algorithm&#39;s correctness because scaling a Bézier curve&#39;s control points scales the curve accordingly, as is well known. In the example above, after multiplying by 3/2 (the reciprocal of the highest control point, which is 2/3), the table would now look like this:</p>

<table><thead>
<tr>
<th>Piece</th>
<th>Control Points</th>
</tr>
</thead><tbody>
<tr>
<td>0</td>
<td>0, 0, 0, 1/4</td>
</tr>
<tr>
<td>1</td>
<td>1/4, 1/2, 1, 1</td>
</tr>
<tr>
<td>2</td>
<td>1, 1, 1/2, 1/4</td>
</tr>
<tr>
<td>3</td>
<td>1/4, 0, 0, 0</td>
</tr>
</tbody></table>

<p>Notice the following:</p>

<ul>
<li>All these control points are rational numbers, and the sampler may have to determine whether an event is true with probability equal to a control point.  For rational numbers like these, it is possible to determine this exactly (using only random bits), using the <strong>ZeroOrOne</strong> method given in my <a href="https://peteroupc.github.io/randomfunc.html#Boolean_True_False_Conditions"><strong>article on randomization and sampling methods</strong></a>.</li>
<li>The first and last piece of the PDF have a predictable set of control points.  Namely the control points are as follows:

<ul>
<li>Piece 0: 0, 0, ..., 0, 1/((<em>n</em> &minus; 1)!), where (<em>n</em> &minus; 1)! = 1*2*3*...*(<em>n</em>&minus;1).</li>
<li>Piece <em>n</em> &minus; 1: 1/((<em>n</em> &minus; 1)!), 0, 0, ..., 0.</li>
</ul></li>
</ul>

<p>If the areas of the PDF&#39;s pieces are known in advance (and SymPy makes them easy to find as the <code>find_areas</code> method shows), then the sampler could be modified as follows, since each piece is now chosen with probability proportional to the chance that a random variate there will be sampled:</p>

<ul>
<li>Step 2 is changed to read: &quot;An integer in [0, <em>n</em>) is chosen with probability proportional to the corresponding piece&#39;s area, call the integer <em>i</em>, then the piece identified by <em>i</em> is chosen.  There are many <a href="https://peteroupc.github.io/randomfunc.html#Weighted_Choice_With_Replacement"><strong>algorithms to choose an integer</strong></a> this way.&quot;</li>
<li>The last sentence in step 6 is changed to read: &quot;If the PSRN is not accepted, the sampler starts over from step 3.&quot;  With this, the same piece is sampled again.</li>
<li><p>The following are additional modifications that should be done to the sampler.  However, not applying them does not affect the sampler&#39;s correctness.</p>

<ul>
<li>The control points should be scaled so that the highest control point of <em>each</em> piece is equal to 1.  See the table below for an example.</li>
<li>If piece 0 is being sampled and the PSRN&#39;s digits are binary (base 2), the &quot;coin&quot; described in step 4 uses a modified version of <strong>SampleGeometricBag</strong> in which a 1 (rather than any other digit) is sampled from the PSRN when it reads from or writes to that PSRN.  Moreover, the PSRN is always accepted regardless of the result of the &quot;coin&quot; flip.</li>
<li>If piece <em>n</em> &minus; 1 is being sampled and the PSRN&#39;s digits are binary (base 2), the &quot;coin&quot; uses a modified version of <strong>SampleGeometricBag</strong> in which a 0 (rather than any other digit) is sampled, and the PSRN is always accepted.</li>
</ul></li>
</ul>

<table><thead>
<tr>
<th>Piece</th>
<th>Control Points</th>
</tr>
</thead><tbody>
<tr>
<td>0</td>
<td>0, 0, 0, 1</td>
</tr>
<tr>
<td>1</td>
<td>1/4, 1/2, 1, 1</td>
</tr>
<tr>
<td>2</td>
<td>1, 1, 1/2, 1/4</td>
</tr>
<tr>
<td>3</td>
<td>1, 0, 0, 0</td>
</tr>
</tbody></table>

<p><a id=Sum_of_Two_Uniform_Random_Variates></a></p>

<h3>Sum of Two Uniform Random Variates</h3>

<p>The following algorithm samples the sum of two uniform random variates.</p>

<ol>
<li>Create a positive-sign zero-integer-part uniform PSRN (partially-sampled random number), call it <em>ret</em>.</li>
<li>Generate an unbiased random bit (that is, either 0 or 1, chosen with equal probability).</li>
<li>Remove all digits from <em>ret</em>.  (This algorithm works for digits of any base, including base 10 for decimal, or base 2 for binary.)</li>
<li>Call the <strong>SampleGeometricBag</strong> algorithm on <em>ret</em>, then generate an unbiased random bit.</li>
<li>If the bit generated in step 2 is 1 and the result of <strong>SampleGeometricBag</strong> is 1, optionally fill <em>ret</em> with uniform random digits as necessary to give its fractional part the desired number of digits (similarly to <strong>FillGeometricBag</strong>), then return <em>ret</em>.</li>
<li>If the bit generated in step 2 is 0 and the result of <strong>SampleGeometricBag</strong> is 0, optionally fill <em>ret</em> as in step 5, then set <em>ret</em>&#39;s integer part to 1, then return <em>ret</em>.</li>
<li>Go to step 3.</li>
</ol>

<p>For base 2, the following algorithm also works, using certain &quot;tricks&quot; described in the next section.</p>

<ol>
<li>Generate an unbiased random bit (that is, either 0 or 1, chosen with equal probability), call it <em>d</em>.</li>
<li>Generate unbiased random bits until 0 is generated this way.  Set <em>g</em> to the number of one-bits generated by this step.</li>
<li>Create a positive-sign zero-integer-part uniform PSRN (partially-sampled random number), call it <em>ret</em>.  Then, set the digit at position <em>g</em> of the PSRN&#39;s fractional part to <em>d</em> (positions start at 0 in the PSRN).</li>
<li>Optionally, fill <em>ret</em> with uniform random digits as necessary to give its fractional part the desired number of digits (similarly to <strong>FillGeometricBag</strong>).  Then set <em>ret</em>&#39;s integer part to (1 &minus; <em>d</em>), then return <em>ret</em></li>
</ol>

<p>And here is Python code that implements this algorithm. It uses floating-point arithmetic only at the end, to convert the result to a convenient form, and that it relies on methods from <em>randomgen.py</em> and <em>bernoulli.py</em>.</p>

<pre>def sum_of_uniform(bern, precision=53):
    &quot;&quot;&quot; Exact simulation of the sum of two uniform
          random variates. &quot;&quot;&quot;
    bag=[]
    rb=bern.randbit()
    while True:
       bag.clear()
       if rb==1:
          # 0 to 1
          if bern.geometric_bag(bag)==1:
             return bern.fill_geometric_bag(bag, precision)
       else:
          # 1 to 2
          if bern.geometric_bag(bag)==0:
             return 1.0 + bern.fill_geometric_bag(bag, precision)

def sum_of_uniform_base2(bern, precision=53):
    &quot;&quot;&quot; Exact simulation of the sum of two uniform
          random variates (base 2). &quot;&quot;&quot;
    if bern.randbit()==1:
      g=0
      while bern.randbit()==0:
          g+=1
      bag=[None for i in range(g+1)]
      bag[g]=1
      return bern.fill_geometric_bag(bag)
    else:
      g=0
      while bern.randbit()==0:
          g+=1
      bag=[None for i in range(g+1)]
      bag[g]=0
      return bern.fill_geometric_bag(bag) + 1.0
</pre>

<p><a id=Sum_of_Three_Uniform_Random_Variates></a></p>

<h3>Sum of Three Uniform Random Variates</h3>

<p>The following algorithm samples the sum of three uniform random variates.</p>

<ol>
<li>Create a positive-sign zero-integer-part uniform PSRN, call it <em>ret</em>.</li>
<li>Choose an integer in [0, 6), uniformly at random. (With this, the left piece is chosen at a 1/6 chance, the right piece at 1/6, and the middle piece at 2/3, corresponding to the relative areas occupied by the three pieces.)</li>
<li>Remove all digits from <em>ret</em>.</li>
<li><p>If 0 was chosen by step 2, we will sample from the left piece of the function for the sum of three uniform random variates.  This piece runs along the interval [0, 1) and is a polynomial with Bernstein coefficients of (0, 1, 1/2) (and is thus a Bézier curve with those control points).  Due to the particular form of the control points, the piece can be sampled in one of the following ways:</p>

<ul>
<li>Call the <strong>SampleGeometricBag</strong> algorithm twice on <em>ret</em>.  If both of these calls return 1, then accept <em>ret</em> with probability 1/2.  This is the most &quot;naïve&quot; approach.</li>
<li>Call the <strong>SampleGeometricBag</strong> algorithm twice on <em>ret</em>.  If both of these calls return 1, then accept <em>ret</em>.  This version of the step is still correct since it merely scales the polynomial so its upper bound is closer to 1, which is the top of the left piece, thus improving the acceptance rate of this step.</li>
<li>Base-2 only: Call a modified version of <strong>SampleGeometricBag</strong> twice on <em>ret</em>; in this modified algorithm, a 1 (rather than any other digit) is sampled from <em>ret</em> when that algorithm reads or writes a digit in <em>ret</em>.  Then <em>ret</em> is accepted.  This version will always accept <em>ret</em> on the first try, without rejection, and is still correct because <em>ret</em> would be accepted by this step only if <strong>SampleGeometricBag</strong> succeeds both times, which will happen only if that algorithm reads or writes out a 1 each time (because otherwise the control point is 0, meaning that <em>ret</em> is accepted with probability 0).</li>
</ul>

<p>If <em>ret</em> was accepted, optionally fill <em>ret</em> with uniform random digits as necessary to give its fractional part the desired number of digits (similarly to <strong>FillGeometricBag</strong>), then return <em>ret</em>.</p></li>
<li>If 2, 3, 4, or 5 was chosen by step 2, we will sample from the middle piece of the PDF, which runs along the interval [1, 2) and is a polynomial with Bernstein coefficients (control points) of (1/2, 1, 1/2).  Call the <strong>SampleGeometricBag</strong> algorithm twice on <em>ret</em>.  If neither or both of these calls return 1, then accept <em>ret</em>.  Otherwise, if one of these calls returns 1 and the other 0, then accept <em>ret</em> with probability 1/2.  If <em>ret</em> was accepted, optionally fill <em>ret</em> as given in step 4, then set <em>ret</em>&#39;s integer part to 1, then return <em>ret</em>.</li>
<li><p>If 1 was chosen by step 2, we will sample from the right piece of the PDF, which runs along the interval [2, 3) and is a polynomial with Bernstein coefficients (control points) of (1/2, 0, 0).  Due to the particular form of the control points, the piece can be sampled in one of the following ways:</p>

<ul>
<li>Call the <strong>SampleGeometricBag</strong> algorithm twice on <em>ret</em>.  If both of these calls return 0, then accept <em>ret</em> with probability 1/2.  This is the most &quot;naïve&quot; approach.</li>
<li>Call the <strong>SampleGeometricBag</strong> algorithm twice on <em>ret</em>.  If both of these calls return 0, then accept <em>ret</em>.  This version is correct for a similar reason as in step 4.</li>
<li>Base-2 only: Call a modified version of <strong>SampleGeometricBag</strong> twice on <em>ret</em>; in this modified algorithm, a 0 (rather than any other digit) is sampled from <em>ret</em> when that algorithm reads or writes a digit in <em>ret</em>.  Then <em>ret</em> is accepted.  This version is correct for a similar reason as in step 4.</li>
</ul>

<p>If <em>ret</em> was accepted, optionally fill <em>ret</em> as given in step 4, then set <em>ret</em>&#39;s integer part to 2, then return <em>ret</em>.</p></li>
<li>Go to step 3.</li>
</ol>

<p>And here is Python code that implements this algorithm.</p>

<pre>def sum_of_uniform3(bern):
    &quot;&quot;&quot; Exact simulation of the sum of three uniform
          random variates. &quot;&quot;&quot;
    r=6
    while r&gt;=6:
       r=bern.randbit() + bern.randbit() * 2 + bern.randbit() * 4
    while True:
       # Choose a piece of the PDF uniformly (but
       # not by area).
       bag=[]
       if r==0:
          # Left piece
          if bern.geometric_bag(bag) == 1 and \
             bern.geometric_bag(bag) == 1:
              # Accepted
             return bern.fill_geometric_bag(bag)
       elif r&lt;=4:
          # Middle piece
          ones=bern.geometric_bag(bag) + bern.geometric_bag(bag)
          if (ones == 0 or ones == 2) and bern.randbit() == 0:
              # Accepted
             return 1.0 + bern.fill_geometric_bag(bag)
          if ones == 1:
              # Accepted
             return 1.0 + bern.fill_geometric_bag(bag)
       else:
          # Right piece
          if bern.randbit() == 0 and \
             bern.geometric_bag(bag) == 0 and \
             bern.geometric_bag(bag) == 0:
              # Accepted
             return 2.0 + bern.fill_geometric_bag(bag)
</pre>

<p><a id=Acknowledgments></a></p>

<h2>Acknowledgments</h2>

<p>Michael Shoemate gave comments on this article.</p>

<p><a id=Notes></a></p>

<h2>Notes</h2>

<p>[^1]: Thomas, A.C., Blanchet, J., &quot;<a href="https://arxiv.org/abs/1106.2508v3"><strong>A Practical Implementation of the Bernoulli Factory</strong></a>&quot;, arXiv:1106.2508v3  [stat.AP], 2012.</p>

<p>[^2]: Nacu, Şerban, and Yuval Peres. &quot;<a href="https://projecteuclid.org/euclid.aoap/1106922322"><strong>Fast simulation of new coins from old</strong></a>&quot;, The Annals of Applied Probability 15, no. 1A (2005): 93-115.</p>

<p>[^3]: Flajolet, P., Pelletier, M., Soria, M., &quot;<a href="https://arxiv.org/abs/0906.5560"><strong>On Buffon machines and numbers</strong></a>&quot;, arXiv:0906.5560  [math.PR], 2010</p>

<p>[^4]: Mossel, Elchanan, and Yuval Peres. New coins from old: computing with unknown bias. Combinatorica, 25(6), pp.707-724, 2005.</p>

<p>[^5]: &quot;<em>x</em> is odd&quot; means that <em>x</em> is an integer and not divisible by 2.  This is true if <em>x</em> &minus; 2*floor(<em>x</em>/2) equals 1, or if <em>x</em> is an integer and the least significant bit of abs(<em>x</em>) is 1.</p>

<p>[^6]: &quot;<em>x</em> is even&quot; means that <em>x</em> is an integer and divisible by 2.  This is true if <em>x</em> &minus; 2*floor(<em>x</em>/2) equals 0, or if <em>x</em> is an integer and the least significant bit of abs(<em>x</em>) is 0.</p>

<p>[^7]: Citterio, M., Pavani, R., &quot;A Fast Computation of the Best k-Digit Rational Approximation to a Real Number&quot;, Mediterranean Journal of Mathematics 13 (2016).</p>

<p>[^8]: Łatuszyński, K., Kosmidis, I., Papaspiliopoulos, O., Roberts, G.O., &quot;<a href="https://arxiv.org/abs/0907.4018v2"><strong>Simulating events of unknown probabilities via reverse time martingales</strong></a>&quot;, arXiv:0907.4018v2 [stat.CO], 2009/2011.</p>

<p>[^9]: Jacob, P.E., Thiery, A.H., &quot;On nonnegative unbiased estimators&quot;, Ann. Statist., Volume 43, Number 2 (2015), 769-784.</p>

<p>[^10]: Duvignau, R., 2015. Maintenance et simulation de graphes aléatoires dynamiques (Doctoral dissertation, Université de Bordeaux).</p>

<p>[^11]: There are many distributions that can be sampled using the oracle, by first generating unbiased random bits via randomness extraction methods, but then these distributions won&#39;t use the unknown number of faces in general.  Duvignau proved Theorem 5.2 for an oracle that outputs <em>arbitrary</em> but still distinct items, as opposed to integers, but this case can be reduced to the integer case (see section 4.1.3).</p>

<p>[^12]: <em>Summation notation</em>, involving the Greek capital sigma (&Sigma;), is a way to write the sum of one or more terms of similar form. For example, $\sum_{k=0}^n g(k)$ means $g(0)+g(1)+...+g(n)$, and $\sum_{k\ge 0} g(k)$ means $g(0)+g(1)+...$.</p>

<p>[^13]: choose(<em>n</em>, <em>k</em>) = (1*2*3*...*<em>n</em>)/((1*...*<em>k</em>)*(1*...*(<em>n</em>&minus;<em>k</em>))) =  <em>n</em>!/(<em>k</em>! * (<em>n</em> &minus; <em>k</em>)!) is a <em>binomial coefficient</em>, or the number of ways to choose <em>k</em> out of <em>n</em> labeled items.  It can be calculated, for example, by calculating <em>i</em>/(<em>n</em>&minus;<em>i</em>+1) for each integer <em>i</em> in the interval [<em>n</em>&minus;<em>k</em>+1, <em>n</em>], then multiplying the results (Yannis Manolopoulos. 2002. &quot;<a href="https://doi.org/10.1145/820127.820168"><strong>Binomial coefficient computation: recursion or iteration?</strong></a>&quot;, SIGCSE Bull. 34, 4 (December 2002), 65–67).  For every <em>m</em>&gt;0, choose(<em>m</em>, 0) = choose(<em>m</em>, <em>m</em>) = 1 and choose(<em>m</em>, 1) = choose(<em>m</em>, <em>m</em>&minus;1) = <em>m</em>; also, in this document, choose(<em>n</em>, <em>k</em>) is 0 when <em>k</em> is less than 0 or greater than <em>n</em>.</p>

<p>[^14]: <em>n</em>! = 1*2*3*...*<em>n</em> is also known as <em>n</em> factorial; in this document, (0!) = 1.</p>

<p>[^15]: Goyal, V. and Sigman, K., 2012. On simulating a class of Bernstein polynomials. ACM Transactions on Modeling and Computer Simulation (TOMACS), 22(2), pp.1-5.</p>

<p>[^16]: S. Ray, P.S.V. Nataraj, &quot;A Matrix Method for Efficient Computation of Bernstein Coefficients&quot;, <em>Reliable Computing</em> 17(1), 2012.</p>

<p>[^17]: Brassard, G., Devroye, L., Gravel, C., &quot;Remote Sampling with Applications to General Entanglement Simulation&quot;, <em>Entropy</em> 2019(21)(92), <a href="https://doi.org/10.3390/e21010092"><strong>https://doi.org/10.3390/e21010092</strong></a></p>

<p>[^18]: Devroye, L., <a href="http://luc.devroye.org/rnbookindex.html"><strong><em>Non-Uniform Random Variate Generation</em></strong></a>, 1986.</p>

<p>[^19]: Devroye, L., Gravel, C., &quot;<a href="https://arxiv.org/abs/1502.02539v6"><strong>Random variate generation using only finitely many unbiased, independently and identically distributed random bits</strong></a>&quot;, arXiv:1502.02539v6 [cs.IT], 2020.</p>

<p>[^20]: Keane,  M.  S.,  and  O&#39;Brien,  G.  L., &quot;A Bernoulli factory&quot;, <em>ACM Transactions on Modeling and Computer Simulation</em> 4(2), 1994.</p>

<p>[^21]: Łatuszyński, K., Kosmidis, I.,  Papaspiliopoulos, O., Roberts, G.O., &quot;<a href="https://arxiv.org/abs/0907.4018v2"><strong>Simulating events of unknown probabilities via reverse time martingales</strong></a>&quot;, arXiv:0907.4018v2 [stat.CO], 2009/2011.</p>

<p>[^22]: Lee, A., Doucet, A. and Łatuszyński, K., 2014. &quot;<a href="https://arxiv.org/abs/1407.5770v1"><strong>Perfect simulation using atomic regeneration with application to Sequential Monte Carlo</strong></a>&quot;, arXiv:1407.5770v1  [stat.CO].</p>

<p><a id=Appendix></a></p>

<h2>Appendix</h2>

<p>&nbsp;</p>

<p><a id=Probability_Transformations></a></p>

<h3>Probability Transformations</h3>

<p>The following algorithm takes a uniform partially-sampled random number (PSRN) as a &quot;coin&quot; and flips that &quot;coin&quot; using <strong>SampleGeometricBag</strong>.  Given that &quot;coin&quot; and a function <em>f</em> as described below, the algorithm returns 1 with probability <em>f</em>(<em>U</em>), where <em>U</em> is the number built up by the uniform PSRN (see also Brassard et al., (2019)[^17], (Devroye 1986, p. 769)[^18], (Devroye and Gravel 2020)[^19].  In the algorithm:</p>

<ul>
<li> The uniform PSRN&#39;s sign must be positive and its integer part must be 0.</li>
<li><p>For correctness, <em>f</em>(<em>U</em>) must meet the following conditions:</p>

<ul>
<li>If the algorithm will be run multiple times with the same PSRN, <em>f</em>(<em>U</em>) must be the constant 0 or 1, or be continuous and polynomially bounded on the open interval (0, 1) (polynomially bounded means that both <em>f</em>(<em>U</em>) and 1&minus;<em>f</em>(<em>U</em>) are greater than or equal to min(<em>U</em><sup><em>n</em></sup>, (1&minus;<em>U</em>)<sup><em>n</em></sup>) for some integer <em>n</em> (Keane and O&#39;Brien 1994)[^20]).</li>
<li>Otherwise, <em>f</em>(<em>U</em>) must map the interval [0, 1] to [0, 1] and be continuous everywhere or &quot;almost everywhere&quot;.</li>
</ul>

<p>The first set of conditions is the same as those for the Bernoulli factory problem (see &quot;<a href="https://peteroupc.github.io/bernoulli.html#About_Bernoulli_Factories"><strong>About Bernoulli Factories</strong></a>) and ensure this algorithm is unbiased (see also Łatuszyński et al. (2009/2011)[^21]).</p></li>
</ul>

<p>The algorithm follows.</p>

<ol>
<li>Set <em>v</em> to 0 and <em>k</em> to 1.</li>
<li>(<em>v</em> acts as a uniform random variate greater than 0 and less than 1 to compare with <em>f</em>(<em>U</em>).) Set <em>v</em> to <em>b</em> * <em>v</em> + <em>d</em>, where <em>b</em> is the base (or radix) of the uniform PSRN&#39;s digits, and <em>d</em> is a digit chosen uniformly at random.</li>
<li>Calculate an approximation of <em>f</em>(<em>U</em>) as follows:

<ol>
<li>Set <em>n</em> to the number of items (sampled and unsampled digits) in the uniform PSRN&#39;s fractional part.</li>
<li>Of the first <em>n</em> digits (sampled and unsampled) in the PSRN&#39;s fractional part, sample each of the unsampled digits uniformly at random.  Then let <em>uk</em> be the PSRN&#39;s digit expansion up to the first <em>n</em> digits after the point.</li>
<li>Calculate the lowest and highest values of <em>f</em> in the interval [<em>uk</em>, <em>uk</em> + <em>b</em><sup>&minus;<em>n</em></sup>], call them <em>fmin</em> and <em>fmax</em>. If abs(<em>fmin</em> &minus; <em>fmax</em>) &le; 2 * <em>b</em><sup>&minus;<em>k</em></sup>, calculate (<em>fmax</em> + <em>fmin</em>) / 2 as the approximation.  Otherwise, add 1 to <em>n</em> and go to the previous substep.</li>
</ol></li>
<li>Let <em>pk</em> be the approximation&#39;s digit expansion up to the <em>k</em> digits after the point.  For example, if <em>f</em>(<em>U</em>) is <em>&pi;</em>/5, <em>b</em> is 10, and <em>k</em> is 3, <em>pk</em> is 628.</li>
<li>If <em>pk</em> + 1 &le; <em>v</em>, return 0. If <em>pk</em> &minus; 2 &ge; <em>v</em>, return 1.  If neither is the case, add 1 to <em>k</em> and go to step 2.</li>
</ol>

<blockquote>
<p><strong>Notes:</strong></p>

<ol>
<li>This algorithm is related to the Bernoulli factory problem, where the input probability is unknown.  However, the algorithm doesn&#39;t exactly solve that problem because it has access to the input probability&#39;s value to some extent.</li>
<li>This section appears in the appendix because this article is focused on algorithms that don&#39;t rely on calculations of irrational numbers.</li>
</ol>
</blockquote>

<p><a id=Proof_of_the_General_Martingale_Algorithm></a></p>

<h3>Proof of the General Martingale Algorithm</h3>

<p>This proof of the <strong>general martingale algorithm</strong> is similar to the proof for certain alternating series with only nonzero coefficients, given in Łatuszyński et al. (2019/2011)[^21], section 3.1.  Suppose we repeatedly flip a coin that shows heads with probability $g(\lambda)$ and we get the following results: $X_1, X_2, ...$, where each result is either 1 if the coin shows heads or 0 otherwise.  Then define two sequences <em>U</em> and <em>L</em> as follows:</p>

<ul>
<li>$U_0=d_0$ and $L_0=0$.</li>
<li>For each $n&gt;0$, $U_n$ is $L_{n-1} + |a_n|\times X_1\times...\times X_n$ if $a_n &gt; 0$, otherwise $U_{n-1} - |a_n|\times X_1\times...\times X_n$ if no nonzero coefficients follow $a_n$ and $a_n &lt; 0$, otherwise $U_{n-1}$.</li>
<li>For each $n&gt;0$, $L_n$ is $U_{n-1} - |a_n|\times X_1\times...\times X_n$ if $a_n &lt; 0$, otherwise $L_{n-1} + |a_n|\times X_1\times...\times X_n$ if no nonzero coefficients follow $a_n$ and $a_n &gt; 0$, otherwise $L_{n-1}$.</li>
</ul>

<p>Then it&#39;s clear that with probability 1, for every $n\ge 1$&mdash;</p>

<ul>
<li>$L_n \le U_n$,</li>
<li>$U_n$ is 0 or greater and $L_n$ is 1 or less, and</li>
<li>$L_{n-1} \le L_n$ and $U_{n-1} \ge U_n$.</li>
</ul>

<p>Moreover, if there are infinitely many nonzero coefficients, the <em>U</em> and <em>L</em> sequences have expected values (&quot;long-run averages&quot;) converging to $f(\lambda)$ with probability 1; otherwise $f(\lambda)$ is a polynomial in $g(\lambda)$, and $U_n$ and $L_n$ have expected values that approach $f(\lambda)$ as $n$ gets large.  These conditions are required for the paper&#39;s Algorithm 3 (and thus the <strong>general martingale algorithm</strong>) to be valid.</p>

<p><a id=Algorithm_for_sin___lambda_____pi___2></a></p>

<h3>Algorithm for sin(<em>&lambda;</em>*<em>&pi;</em>/2)</h3>

<p>The following algorithm returns 1 with probability sin(<em>&lambda;</em>*<em>&pi;</em>/2) and 0 otherwise, given a coin that shows heads with probability <em>&lambda;</em>.  However, this algorithm appears in the appendix since it requires manipulating irrational numbers, particularly numbers involving <em>&pi;</em>.</p>

<ol>
<li>Choose at random an integer <em>n</em> (0 or greater) with probability (<em>&pi;</em>/2)<sup>4*<em>n</em>+2</sup>/((4*<em>n</em>+2)!) &minus; (<em>&pi;</em>/2)<sup>4*<em>n</em>+4</sup>/((4*<em>n</em>+4)!).</li>
<li>Let <em>v</em> = 16*(<em>n</em>+1)*(4*<em>n</em>+3).</li>
<li>Flip the input coin 4*<em>n</em>+4 times.  Let <em>tails</em> be the number of flips that returned 0 this way. (This would be the number of heads if the probability <em>&lambda;</em> were 1 &minus; <em>&lambda;</em>.)</li>
<li>If <em>tails</em> = 4*<em>n</em>+4, return 0.</li>
<li>If <em>tails</em> = 4*<em>n</em>+3, return a number that is 0 with probability 8*(4*<em>n</em>+3)/(<em>v</em>&minus;<em>&pi;</em><sup>2</sup>) and 1 otherwise.</li>
<li>If <em>tails</em> = 4*<em>n</em>+2, return a number that is 0 with probability 8/(<em>v</em>&minus;<em>&pi;</em><sup>2</sup>) and 1 otherwise.</li>
<li>Return 1.</li>
</ol>

<p>Derivation:  Write&mdash; $$f(\lambda) = \sin(\lambda \pi/2) = 1-g(1-\lambda),$$ where&mdash; $$g(\mu) = 1-\sin((1-\mu) \pi/2)$$ $$= \sum_{n\ge 0} \frac{(\mu\pi/2)^{4n+2}}{(4n+2)!} - \frac{(\mu\pi/2)^{4n+4}}{(4n+4)!}$$ $$= \sum_{n\ge 0} w_n(\mu) = \sum_{n\ge 0} w_n(1) \frac{w_n(\mu)}{w_n(1)}.$$</p>

<p>This is a <a href="https://peteroupc.github.io/bernoulli.html#Convex_Combinations"><strong>convex combination</strong></a> of $w_n(1)$ and $\frac{w_n(\mu)}{w_n(1)}$ &mdash; to simulate $g(\mu)$, first an integer <em>n</em> is chosen with probability $w_n(1)$ and then a coin that shows heads with probability $\frac{w_n(\mu)}{w_n(1)}$ is flipped.  Finally, to simulate $f(\lambda)$, the input coin is &quot;inverted&quot; ($\mu = 1-\lambda$), $g(\mu)$ is simulated using the &quot;inverted&quot; coin, and 1 minus the simulation result is returned.</p>

<p>As given above, each term $w_n(\mu)$ is a polynomial in $\mu$, and is strictly increasing and equals 1 or less everywhere on the interval $[0, 1]$, and $w_n(1)$ is a constant so that $\frac{w_n(\mu)}{w_n(1)}$ remains a polynomial.  Each polynomial $\frac{w_n(\mu)}{w_n(1)}$ can be transformed into a polynomial in Bernstein form with the following coefficients: $$(0, 0, ..., 0, 8/(v-\pi^2), 8(4n+3)/(v-\pi^2), 1),$$ where the polynomial is of degree $4n+4$ and so has $4n+5$ coefficients, and $v = \frac{((4n+4)!)\times 2^{4n+4}}{((4n+2)!)\times 2^{4n+2}} = 16 (n+1) (4n+3)$.  These are the coefficients used in steps 4 through 7 of the algorithm above.</p>

<blockquote>
<p><strong>Note:</strong> sin(<em>&lambda;</em>*<em>&pi;</em>/2) = cos((1&minus;<em>&lambda;</em>)*<em>&pi;</em>/2).</p>
</blockquote>

<p><a id=Pushdown_Automata_and_Algebraic_Functions></a></p>

<h3>Pushdown Automata and Algebraic Functions</h3>

<p>Moved to <a href="https://peteroupc.github.io/bernsupp.html"><strong>Supplemental Notes on Bernoulli Factories</strong></a>.</p>

<p><a id=Sampling_Distributions_Using_Incomplete_Information_Omitted_Algorithms></a></p>

<h3>Sampling Distributions Using Incomplete Information: Omitted Algorithms</h3>

<p><strong>Algorithm 2.</strong> Suppose there is an <em>oracle</em> that produces independent random real numbers whose expected value (&quot;long-run average&quot;) is a known or unknown mean. The goal is now to produce nonnegative random variates whose expected value is the mean of <em>f</em>(<em>X</em>), where <em>X</em> is a number produced by the oracle.  This is possible whenever&mdash;</p>

<ul>
<li><em>f</em> has a finite lower bound and a finite upper bound on its domain, and</li>
<li>the mean of <em>f</em>(<em>X</em>) is not less than <em>&delta;</em>, where <em>&delta;</em> is a known rational number greater than 0.</li>
</ul>

<p>The algorithm to achieve this goal follows (see Lee et al. 2014)[^22]:</p>

<ol>
<li>Let <em>m</em> be a rational number equal to or greater than the maximum value of abs(<em>f</em>(<em>&mu;</em>)) anywhere.  Create a <em>&nu;</em> input coin that does the following: &quot;Take a number from the oracle, call it <em>x</em>.  With probability abs(<em>f</em>(<em>x</em>))/<em>m</em>, return a number that is 1 if <em>f</em>(<em>x</em>) &lt; 0 and 0 otherwise.  Otherwise, repeat this process.&quot;</li>
<li>Use one of the <a href="https://peteroupc.github.io/bernoulli.html#lambda____x___y__linear_Bernoulli_factories"><strong>linear Bernoulli factories</strong></a> to simulate 2*<em>&nu;</em> (2 times the <em>&nu;</em> coin&#39;s probability of heads), using the <em>&nu;</em> input coin, with <em>&#x03F5;</em> = <em>&delta;</em>/<em>m</em>.  If the factory returns 1, return 0.  Otherwise, take a number from the oracle, call it <em>&xi;</em>, and return abs(<em>f</em>(<em>&xi;</em>)).</li>
</ol>

<blockquote>
<p><strong>Example:</strong> An example from Lee et al. (2014)[^22].  Say the oracle produces uniform random variates in [0, 3*<em>&pi;</em>], and let <em>f</em>(<em>&nu;</em>) = sin(<em>&nu;</em>).  Then the mean of <em>f</em>(<em>X</em>) is 2/(3*<em>&pi;</em>), which is greater than 0 and found in SymPy by <code>sympy.stats.E(sin(sympy.stats.Uniform(&#39;U&#39;,0,3*pi)))</code>, so the algorithm can produce nonnegative random variates whose expected value (&quot;long-run average&quot;) is that mean.</p>

<p><strong>Notes:</strong></p>

<ol>
<li>Averaging to the mean of <em>f</em>(<em>X</em>) (that is, <strong>E</strong>[<em>f</em>(<em>X</em>)] where <strong>E</strong>[.] means expected or average value) is not the same as averaging to <em>f</em>(<em>&mu;</em>) where <em>&mu;</em> is the mean of the oracle&#39;s numbers (that is, <em>f</em>(<strong>E</strong>[<em>X</em>])).  For example, if <em>X</em> is 0 or 1 with equal probability, and <em>f</em>(<em>&nu;</em>) = exp(&minus;<em>&nu;</em>), then <strong>E</strong>[<em>f</em>(<em>X</em>)] = exp(0) + (exp(&minus;1) &minus; exp(0))*(1/2), and <em>f</em>(<strong>E</strong>[<em>X</em>]) = <em>f</em>(1/2) = exp(&minus;1/2).</li>
<li><p>(Lee et al. 2014, Corollary 4)[^22]: If <em>f</em>(<em>&mu;</em>) is known to return only values in the interval [<em>a</em>, <em>c</em>], the mean of <em>f</em>(<em>X</em>) is not less than <em>&delta;</em>, <em>&delta;</em> &gt; <em>b</em>, and <em>&delta;</em> and <em>b</em> are known numbers, then Algorithm 2 can be modified as follows:</p>

<ul>
<li>Use <em>f</em>(<em>&nu;</em>) = <em>f</em>(<em>&nu;</em>) &minus; <em>b</em>, and use <em>&delta;</em> = <em>&delta;</em> &minus; <em>b</em>.</li>
<li><em>m</em> is taken as max(<em>b</em>&minus;<em>a</em>, <em>c</em>&minus;<em>b</em>).</li>
<li>When Algorithm 2 finishes, add <em>b</em> to its return value.</li>
</ul></li>
<li>The check &quot;With probability abs(<em>f</em>(<em>x</em>))/<em>m</em>&quot; is exact if the oracle produces only rational numbers <em>and</em> if <em>f</em>(<em>x</em>) outputs only rational numbers.  If the oracle or <em>f</em> can produce irrational numbers (such as numbers that follow a beta distribution or another non-discrete distribution), then this check should be implemented using uniform <a href="https://peteroupc.github.io/exporand.html"><strong>partially-sampled random numbers (PSRNs)</strong></a>.</li>
</ol>
</blockquote>

<p><strong>Algorithm 3.</strong> Suppose there is an <em>oracle</em> that produces independent random real numbers that are all greater than or equal to <em>a</em> (which is a known rational number), whose mean (<em>&mu;</em>) is unknown.  The goal is to use the oracle to produce nonnegative random variates with mean <em>f</em>(<em>&mu;</em>).  This is possible only if <em>f</em> is 0 or greater everywhere in the interval [<em>a</em>, <em>&infin;</em>) and is nowhere decreasing in that interval (Jacob and Thiery 2015)[^9].  This can be done using the algorithm below.  In the algorithm:</p>

<ul>
<li><em>f</em>(<em>&mu;</em>) must be a function that can be written as&mdash;<br><em>c</em>[0]*<em>z</em><sup>0</sup> + <em>c</em>[1]*<em>z</em><sup>1</sup> + ...,<br>which is an infinite series where <em>z</em> = <em>&mu;</em>&minus;<em>a</em> and all <em>c</em>[<em>i</em>] are 0 or greater.</li>
<li><em>&psi;</em> is a rational number close to 1, such as 95/100.  (The exact choice is arbitrary and can be less or greater for efficiency purposes, but must be greater than 0 and less than 1.)</li>
</ul>

<p>The algorithm follows.</p>

<ol>
<li>Set <em>ret</em> to 0, <em>prod</em> to 1, <em>k</em> to 0, and <em>w</em> to 1. (<em>w</em> is the probability of generating <em>k</em> or more random variates in a single run of the algorithm.)</li>
<li>If <em>k</em> is greater than 0: Take a number from the oracle, call it <em>x</em>, and multiply <em>prod</em> by <em>x</em>&minus;<em>a</em>.</li>
<li>Add <em>c</em>[<em>k</em>]*<em>prod</em>/<em>w</em> to <em>ret</em>.</li>
<li>Multiply <em>w</em> by <em>&psi;</em> and add 1 to <em>k</em>.</li>
<li>With probability <em>&psi;</em>, go to step 2.  Otherwise, return <em>ret</em>.</li>
</ol>

<p>Now, assume the oracle&#39;s numbers are all less than or equal to <em>b</em> (rather than greater than or equal to <em>a</em>), where <em>b</em> is a known rational number.  Then <em>f</em> must be 0 or greater everywhere in (&minus;<em>&infin;</em>, <em>b</em>] and be nowhere increasing there (Jacob and Thiery 2015)[^9], and the algorithm above can be used with the following modifications: (1) In the note on the infinite series, <em>z</em> = <em>b</em> &minus;<em>&mu;</em>; (2) in step 2, multiply <em>prod</em> by <em>b</em> &minus; <em>x</em> rather than <em>x</em> &minus; <em>a</em>.</p>

<blockquote>
<p><strong>Note:</strong> This algorithm is exact if the oracle produces only rational numbers <em>and</em> if all <em>c</em>[<em>i</em>] are rational numbers.  If the oracle can produce irrational numbers, then they should be implemented using uniform PSRNs.  See also note 3 on Algorithm 2.</p>
</blockquote>

<p><a id=License></a></p>

<h2>License</h2>

<p>Any copyright to this page is released to the Public Domain.  In case this is not possible, this page is also licensed under <a href="https://creativecommons.org/publicdomain/zero/1.0/"><strong>Creative Commons Zero</strong></a>.</p>
</div><nav id="navigation"><ul>
<li><a href="/">Back to start site.</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io">This site's repository (source code)</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io/issues">Post an issue or comment</a></ul>

<div class="noprint">
<p>
<a href="//twitter.com/intent/tweet">Share via Twitter</a>, <a href="//www.facebook.com/sharer/sharer.php" id="sharer">Share via Facebook</a>
</p>
</div>
</nav><script>
 document.getElementById("sharer").href="//www.facebook.com/sharer/sharer.php?u="+
    encodeURIComponent(document.location.href)
</script>
</body></html>
