<!DOCTYPE html><html xmlns:dc="http://purl.org/dc/terms/" itemscope itemtype="http://schema.org/Article"><head><meta http-equiv=Content-Type content="text/html; charset=utf-8"><title>Miscellaneous Observations on Randomization</title><meta name="citation_title" content="Miscellaneous Observations on Randomization"><meta name="citation_pdf_url" content="https://peteroupc.github.io/randmisc.pdf"><meta name="citation_url" content="https://peteroupc.github.io/randmisc.html"><meta name="citation_date" content="2023/06/13"><meta name="citation_online_date" content="2023/06/13"><meta name="og:title" content="Miscellaneous Observations on Randomization"><meta name="og:type" content="article"><meta name="og:url" content="https://peteroupc.github.io/randmisc.html"><meta name="og:site_name" content="peteroupc.github.io"><meta name="twitter:title" content="Miscellaneous Observations on Randomization"><meta name="author" content="Peter Occil"/><meta name="citation_author" content="Peter Occil"/><meta name="viewport" content="width=device-width"><link rel=stylesheet type="text/css" href="/style.css">
            <script type="text/x-mathjax-config"> MathJax.Hub.Config({"HTML-CSS": { availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, preferredFont: "TeX" },
                    tex2jax: { displayMath: [ ["$$","$$"], ["\\[", "\\]"] ], inlineMath: [ ["$", "$"], ["\\\\(","\\\\)"] ], processEscapes: true } });
            </script><script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"></script></head><body>  <div class="header">
<nav><p><a href="#navigation">Menu</a> - <a href="#top">Top</a> - <a href="/">Home</a></nav></div>
<div class="mainarea" id="top">
<h1>Miscellaneous Observations on Randomization</h1>

<p><a href="mailto:poccil14@gmail.com"><strong>Peter Occil</strong></a></p>

<p>This page should be read in conjunction with the following articles:</p>

<ul>
<li><a href="https://peteroupc.github.io/randomfunc.html"><strong>Randomization and Sampling Methods</strong></a>.</li>
<li><a href="https://peteroupc.github.io/randomnotes.html"><strong>More Random Sampling Methods</strong></a>.</li>
</ul>

<p><a id=Contents></a></p>

<h2>Contents</h2>

<ul>
<li><a href="#Contents"><strong>Contents</strong></a></li>
<li><a href="#About_This_Document"><strong>About This Document</strong></a></li>
<li><a href="#Samplers_for_Certain_Discrete_Distributions"><strong>Samplers for Certain Discrete Distributions</strong></a>

<ul>
<li><a href="#On_a_Binomial_Sampler"><strong>On a Binomial Sampler</strong></a></li>
<li><a href="#On_Geometric_Samplers"><strong>On Geometric Samplers</strong></a>

<ul>
<li><a href="#Bounded_Geometric_Distribution"><strong>Bounded Geometric Distribution</strong></a></li>
<li><a href="#Symmetric_Geometric_Distribution"><strong>Symmetric Geometric Distribution</strong></a></li>
</ul></li>
<li><a href="#Weighted_Choice_for_Special_Distributions"><strong>Weighted Choice for Special Distributions</strong></a>

<ul>
<li><a href="#Weighted_Choice_with_Weights_Written_as_an_Integer_and_Fraction"><strong>Weighted Choice with Weights Written as an Integer and Fraction</strong></a></li>
<li><a href="#Distributions_with_nowhere_increasing_or_nowhere_decreasing_weights"><strong>Distributions with nowhere increasing or nowhere decreasing weights</strong></a></li>
<li><a href="#Unimodal_distributions_of_weights"><strong>Unimodal distributions of weights</strong></a></li>
<li><a href="#Weighted_Choice_with_Log_Probabilities"><strong>Weighted Choice with Log Probabilities</strong></a></li>
</ul></li>
<li><a href="#Bernoulli_Distribution_for_Cumulative_Distribution_Functions"><strong>Bernoulli Distribution for Cumulative Distribution Functions</strong></a></li>
<li><a href="#Bit_Vectors_with_Random_Bit_Flips"><strong>Bit Vectors with Random Bit Flips</strong></a></li>
<li><a href="#Log_Uniform_Distribution"><strong>Log-Uniform Distribution</strong></a></li>
</ul></li>
<li><a href="#Sampling_Unbounded_Monotone_Density_Functions"><strong>Sampling Unbounded Monotone Density Functions</strong></a></li>
<li><a href="#Certain_Families_of_Distributions"><strong>Certain Families of Distributions</strong></a></li>
<li><a href="#Certain_Distributions"><strong>Certain Distributions</strong></a></li>
<li><a href="#Random_Variate_Generation_via_Quantiles"><strong>Random Variate Generation via Quantiles</strong></a></li>
<li><a href="#Batching_Random_Samples_via_Randomness_Extraction"><strong>Batching Random Samples via Randomness Extraction</strong></a></li>
<li><a href="#Sampling_Distributions_Using_Incomplete_Information"><strong>Sampling Distributions Using Incomplete Information</strong></a>

<ul>
<li><a href="#Additional_Algorithms"><strong>Additional Algorithms</strong></a></li>
</ul></li>
<li><a href="#Acknowledgments"><strong>Acknowledgments</strong></a></li>
<li><a href="#Notes"><strong>Notes</strong></a></li>
<li><a href="#License"><strong>License</strong></a></li>
</ul>

<p><a id=About_This_Document></a></p>

<h2>About This Document</h2>

<p><strong>This is an open-source document; for an updated version, see the</strong> <a href="https://github.com/peteroupc/peteroupc.github.io/raw/master/randmisc.md"><strong>source code</strong></a> <strong>or its</strong> <a href="https://github.com/peteroupc/peteroupc.github.io/blob/master/randmisc.md"><strong>rendering on GitHub</strong></a><strong>.  You can send comments on this document on the</strong> <a href="https://github.com/peteroupc/peteroupc.github.io/issues"><strong>GitHub issues page</strong></a><strong>.</strong></p>

<p>My audience for this article is <strong>computer programmers with mathematics knowledge, but little or no familiarity with calculus</strong>.</p>

<p>I encourage readers to implement any of the algorithms given in this page, and report their implementation experiences.  In particular, <a href="https://github.com/peteroupc/peteroupc.github.io/issues/18"><strong>I seek comments on the following aspects</strong></a>:</p>

<ul>
<li>Are the algorithms in this article easy to implement? Is each algorithm written so that someone could write code for that algorithm after reading the article?</li>
<li>Does this article have errors that should be corrected?</li>
<li>Are there ways to make this article more useful to the target audience?</li>
</ul>

<p>Comments on other aspects of this document are welcome.</p>

<p><a id=Samplers_for_Certain_Discrete_Distributions></a></p>

<h2>Samplers for Certain Discrete Distributions</h2>

<p>The following are exact samplers for certain <em>discrete distributions</em>, or probability distributions that take on values each mappable to a different integer.</p>

<p><a id=On_a_Binomial_Sampler></a></p>

<h3>On a Binomial Sampler</h3>

<p>The binomial(<em>n</em>, <em>p</em>) distribution models the number of successful trials (&quot;coin flips&quot;) out of <em>n</em> of them, where the trials are independent and have success probability <em>p</em>.</p>

<p>Take the following sampler of a binomial(<em>n</em>, 1/2) distribution, where <em>n</em> is even, which is equivalent to the one that appeared in Bringmann et al. (2014)[^1], and adapted to be more programmer-friendly.</p>

<ol>
<li>If <em>n</em> is less than 4, generate <em>n</em> unbiased random bits (each bit is zero or one with equal probability) and return their sum.  Otherwise, if <em>n</em> is odd[^2], set <em>ret</em> to the result of this algorithm with <em>n</em> = <em>n</em> &minus; 1, then add an unbiased random bit&#39;s value to <em>ret</em>, then return <em>ret</em>.</li>
<li>Set <em>m</em> to floor(sqrt(<em>n</em>)) + 1.</li>
<li>(First, sample from an envelope of the binomial curve.) Generate unbiased random bits until a zero is generated this way.  Set <em>k</em> to the number of ones generated this way.</li>
<li>Set <em>s</em> to an integer in [0, <em>m</em>) chosen uniformly at random, then set <em>i</em> to <em>k</em>*<em>m</em> + <em>s</em>.</li>
<li>Generate an unbiased random bit.  If that bit is 0, set <em>ret</em> to (<em>n</em>/2)+<em>i</em>.  Otherwise, set <em>ret</em> to (<em>n</em>/2)&minus;<em>i</em>&minus;1.</li>
<li>(Second, accept or reject <em>ret</em>.) If <em>ret</em> &lt; 0 or <em>ret</em> &gt; <em>n</em>, go to step 3.</li>
<li>With probability choose(<em>n</em>, <em>ret</em>)*<em>m</em>*2<sup><em>k</em>&minus;<em>n</em>&minus;2</sup>, return <em>ret</em>.  Otherwise, go to step 3. (Here, choose(<em>n</em>, <em>k</em>) is a <em>binomial coefficient</em>, or the number of ways to choose <em>k</em> out of <em>n</em> labeled items.[^3])</li>
</ol>

<p>This algorithm has an acceptance rate of 1/16 regardless of the value of <em>n</em>.  However, step 7 will generally require a growing amount of storage and time to exactly calculate the given probability as <em>n</em> gets larger, notably due to the inherent factorial in the binomial coefficient.  The Bringmann paper suggests approximating this factorial via Spouge&#39;s approximation; however, it seems hard to do so without using floating-point arithmetic, which the paper ultimately resorts to. Alternatively, the logarithm of that probability can be calculated, then 0 minus an exponential random variate can be generated and compared with that logarithm to determine whether the step succeeds.</p>

<p>More specifically, step 7 can be changed as follows:</p>

<ul>
<li>(7.) Let <em>p</em> be loggamma(<em>n</em>+1)&minus;loggamma(<em>ret</em>+1)&minus;loggamma((<em>n</em>&minus;<em>ret</em>)+1)+ln(<em>m</em>)+ln(2)*(<em>k</em>&minus;<em>n</em>&minus;2) (where loggamma(<em>x</em>) is the logarithm of the gamma function).</li>
<li>(7a.) Generate an exponential random variate with rate 1 (which is the negative natural logarithm of a uniform(0,1) random variate).  Set <em>h</em> to 0 minus that number.</li>
<li>(7b.) If <em>h</em> is greater than <em>p</em>, go to step 3.  Otherwise, return <em>ret</em>. (This step can be replaced by calculating lower and upper bounds that converge to <em>p</em>.  In that case, go to step 3 if <em>h</em> is greater than the upper bound, or return <em>ret</em> if <em>h</em> is less than the lower bound, or compute better bounds and repeat this step otherwise.  See also chapter 4 of (Devroye 1986)[^4].)</li>
</ul>

<p>My implementation of loggamma and the natural logarithm (<a href="https://peteroupc.github.io/betadist.py"><strong>betadist.py</strong></a>) relies on so-called &quot;constructive reals&quot; as well as a fast converging version of Stirling&#39;s formula for the factorial&#39;s natural logarithm (Schumacher 2016)[^5].</p>

<p>Also, according to the Bringmann paper, <em>m</em> can be set such that <em>m</em> is in the interval [sqrt(<em>n</em>), sqrt(<em>n</em>)+3], so I implement step 1 by starting with <em>u</em> = 2<sup>floor((1+<em>&beta;</em>(<em>n</em>))/2)</sup>, then calculating <em>v</em> = floor((<em>u</em>+floor(<em>n</em>/<em>u</em>))/2), <em>w</em> = <em>u</em>, <em>u</em> = <em>v</em>  until <em>v</em> &ge; <em>w</em>, then setting <em>m</em> to <em>w</em> + 1.  Here, <em>&beta;</em>(<em>n</em>) = ceil(ln(<em>n</em>+1)/ln(2)), or alternatively the minimum number of bits needed to store <em>n</em> (with <em>&beta;</em>(0) = 0).</p>

<blockquote>
<p><strong>Notes:</strong></p>

<ul>
<li>A binomial(<em>n</em>, 1/2) random variate, where <em>n</em> is odd[^2], can be generated by adding an unbiased random bit&#39;s value (either zero or one with equal probability) to a binomial(<em>n</em>&minus;1, 1/2) random variate.</li>
<li>As pointed out by Farach-Colton and Tsai (2015)[^6], a binomial(<em>n</em>, <em>p</em>) random variate, where <em>p</em> is in the interval (0, 1), can be generated using binomial(<em>n</em>, 1/2) numbers using a procedure equivalent to the following:

<ol>
<li>Set <em>k</em> to 0 and <em>ret</em> to 0.</li>
<li>If the binary digit at position <em>k</em> after the point in <em>p</em>&#39;s binary expansion (that is, 0.bbbb... where each b is a zero or one) is 1, add a binomial(<em>n</em>, 1/2) random variate to <em>ret</em> and subtract the same variate from <em>n</em>; otherwise, set <em>n</em> to a binomial(<em>n</em>, 1/2) random variate.</li>
<li>If <em>n</em> is greater than 0, add 1 to <em>k</em> and go to step 2; otherwise, return <em>ret</em>. (Positions start at 0 where 0 is the most significant digit after the point, 1 is the next, etc.)</li>
</ol></li>
</ul>
</blockquote>

<p><a id=On_Geometric_Samplers></a></p>

<h3>On Geometric Samplers</h3>

<p>As used in Bringmann and Friedrich (2013)[^7], a geometric(<em>p</em>) random variate expresses the number of failing trial before the first success, where each trial (&quot;coin flip&quot;) is independent and has success probability <em>p</em>, satisfying 0 &lt; <em>p</em> &le; 1.</p>

<blockquote>
<p><strong>Note</strong>: The terms &quot;geometric distribution&quot; and &quot;geometric random variate&quot; have conflicting meanings in academic works.</p>
</blockquote>

<p>The following algorithm is equivalent to the geometric(<em>px</em>/<em>py</em>) sampler that appeared in that paper, but adapted to be more programmer-friendly.  The algorithm uses the rational number <em>px</em>/<em>py</em>, not an arbitrary real number <em>p</em>; some of the notes in this section indicate how to adapt the algorithm to an arbitrary <em>p</em>.</p>

<ol>
<li>Set <em>pn</em> to <em>px</em>, <em>k</em> to 0, and <em>d</em> to 0.</li>
<li>While <em>pn</em>*2 &le; <em>py</em>, add 1 to <em>k</em> and multiply <em>pn</em> by 2.  (Equivalent to finding the largest <em>k</em> &ge; 0 such that <em>p</em>*2<sup><em>k</em></sup> &le; 1.  For the case when <em>p</em> need not be rational, enough of its binary expansion can be calculated to carry out this step accurately, but in this case any <em>k</em> such that <em>p</em> is greater than 1/(2<sup><em>k</em>+2</sup>) and less than or equal to 1/(2<sup><em>k</em></sup>) will suffice, as the Bringmann paper points out.)</li>
<li>With probability (1&minus;<em>px</em>/<em>py</em>)<sup>2<sup><em>k</em></sup></sup>, add 1 to <em>d</em> and repeat this step. (To simulate this probability, the first sub-algorithm below can be used.)</li>
<li>Generate a uniform random integer in [0, 2<sup><em>k</em></sup>), call it <em>m</em>, then with probability (1&minus;<em>px</em>/<em>py</em>)<sup><em>m</em></sup>, return <em>d</em>*2<sup><em>k</em></sup>+<em>m</em>. Otherwise, repeat this step. (The Bringmann paper, though, suggests to simulate this probability by sampling only as many bits of <em>m</em> as needed to do so, rather than just generating <em>m</em> in one go, then using the first sub-algorithm on <em>m</em>.  However, the implementation, given as the second sub-algorithm below, is much more complicated and is not crucial for correctness.)</li>
</ol>

<p>The first sub-algorithm returns 1 with probability (1&minus;<em>px</em>/<em>py</em>)<sup><em>n</em></sup>, assuming that <em>n</em>*<em>px</em>/<em>py</em> &le; 1.  It implements the approach from the Bringmann paper by rewriting the probability using the binomial theorem. (More generally, to return 1 with probability (1&minus;<em>p</em>)<sup><em>n</em></sup>, it&#39;s enough to flip a coin that shows heads with probability <em>p</em>, <em>n</em> times or until it shows heads, whichever comes first, and then return either 1 if all the flips showed tails, or 0 otherwise.  See also &quot;<a href="https://peteroupc.github.io/bernoulli.html"><strong>Bernoulli Factory Algorithms</strong></a>&quot;.)</p>

<ol>
<li>Set <em>pnum</em>, <em>pden</em>, and <em>j</em>  to 1, then set <em>r</em> to 0, then set <em>qnum</em> to <em>px</em>, and <em>qden</em> to <em>py</em>, then set <em>i</em> to 2.</li>
<li>If <em>j</em> is greater than <em>n</em>, go to step 5.</li>
<li>If <em>j</em> is even[^8], set <em>pnum</em> to <em>pnum</em>*<em>qden</em> + <em>pden</em>*<em>qnum</em>*choose(<em>n</em>,<em>j</em>). Otherwise, set <em>pnum</em> to <em>pnum</em>*<em>qden</em> &minus; <em>pden</em>*<em>qnum</em>*choose(<em>n</em>,<em>j</em>).</li>
<li>Multiply <em>pden</em> by <em>qden</em>, then multiply <em>qnum</em> by <em>px</em>, then multiply <em>qden</em> by <em>py</em>, then add 1 to <em>j</em>.</li>
<li>If <em>j</em> is less than or equal to 2 and less than or equal to <em>n</em>, go to step 2.</li>
<li>Multiply <em>r</em> by 2, then add an unbiased random bit&#39;s value (either 0 or 1 with equal probability) to <em>r</em>.</li>
<li>If <em>r</em> &le; floor((<em>pnum</em>*<em>i</em>)/<em>pden</em>) &minus; 2, return 1. If <em>r</em> &ge; floor((<em>pnum</em>*<em>i</em>)/<em>pden</em>) + 1, return 0.  If neither is the case, multiply <em>i</em> by 2 and go to step 2.</li>
</ol>

<p>The second sub-algorithm returns an integer <em>m</em> in [0, 2<sup><em>k</em></sup>) with probability (1&minus;<em>px</em>/<em>py</em>)<sup><em>m</em></sup>, or &minus;1 with the opposite probability.  It assumes that 2<sup><em>k</em></sup>*<em>px</em>/<em>py</em> &le; 1.</p>

<ol>
<li>Set <em>r</em> and <em>m</em> to 0.</li>
<li>Set <em>b</em> to 0, then while <em>b</em> is less than <em>k</em>:

<ol>
<li>(Sum <em>b</em>+2 summands of the binomial equivalent of the desired probability.  First, append an additional bit to <em>m</em>, from most to least significant.) Generate an unbiased random bit (either 0 or 1 with equal probability).  If that bit is 1, add 2<sup><em>k</em>&minus;<em>b</em></sup> to <em>m</em>.</li>
<li>(Now build up the binomial probability.) Set <em>pnum</em>, <em>pden</em>, and <em>j</em>  to 1, then set <em>qnum</em> to <em>px</em>, and <em>qden</em> to <em>py</em>.</li>
<li>If <em>j</em> is greater than <em>m</em> or greater than <em>b</em> + 2, go to the sixth substep.</li>
<li>If <em>j</em> is even[^8], set <em>pnum</em> to <em>pnum</em>*<em>qden</em> + <em>pden</em>*<em>qnum</em>*choose(<em>m</em>,<em>j</em>). Otherwise, set <em>pnum</em> to <em>pnum</em>*<em>qden</em> &minus; <em>pden</em>*<em>qnum</em>*choose(<em>m</em>,<em>j</em>).</li>
<li>Multiply <em>pden</em> by <em>qden</em>, then multiply <em>qnum</em> by <em>px</em>, then multiply <em>qden</em> by <em>py</em>, then add 1 to <em>j</em>, then go to the third substep.</li>
<li>(Now check the probability.) Multiply <em>r</em> by 2, then add an unbiased random bit&#39;s value (either 0 or 1 with equal probability) to <em>r</em>.</li>
<li>If <em>r</em> &le; floor((<em>pnum</em>*2<sup><em>b</em></sup>)/<em>pden</em>) &minus; 2, add a uniform random integer in [0, 2<sup><em>k</em>*<em>b</em></sup>) to <em>m</em> and return <em>m</em> (and, if requested, the number <em>k</em>&minus;<em>b</em>&minus;1). If <em>r</em> &ge; floor((<em>pnum</em>*2<sup><em>b</em></sup>)/<em>pden</em>) + 1, return &minus;1 (and, if requested, an arbitrary value).  If neither is the case, add 1 to <em>b</em>.</li>
</ol></li>
<li>Add an unbiased random bit to <em>m</em>. (At this point, <em>m</em> is fully sampled.)</li>
<li>Run the first sub-algorithm with <em>n</em> = <em>m</em>, except in step 1 of that sub-algorithm, set <em>r</em> to the value of <em>r</em> built up by this algorithm, rather than 0, and set <em>i</em> to 2<sup><em>k</em></sup>, rather than 2.  If that sub-algorithm returns 1, return <em>m</em> (and, if requested, the number &minus;1).  Otherwise, return &minus;1 (and, if requested, an arbitrary value).</li>
</ol>

<p><a id=Bounded_Geometric_Distribution></a></p>

<h4>Bounded Geometric Distribution</h4>

<p>As used in the Bringmann paper, a bounded geometric(<em>p</em>, <em>n</em>) random variate is a geometric(<em>p</em>) random variate or <em>n</em> (an integer greater than 0), whichever is less.  The following algorithm is equivalent to the algorithm given in that paper, but adapted to be more programmer-friendly.</p>

<ol>
<li>Set <em>pn</em> to <em>px</em>, <em>k</em> to 0, <em>d</em> to 0, and <em>m2</em> to the smallest power of 2 that is greater than <em>n</em> (or equivalently, 2<sup><em>bits</em></sup> where <em>bits</em> is the minimum number of bits needed to store <em>n</em>).</li>
<li>While <em>pn</em>*2 &le; <em>py</em>, add 1 to <em>k</em> and multiply <em>pn</em> by 2.</li>
<li>With probability (1&minus;<em>px</em>/<em>py</em>)<sup>2<sup><em>k</em></sup></sup>, add 1 to <em>d</em> and then either return <em>n</em> if <em>d</em>*2<sup><em>k</em></sup> is greater than or equal to <em>m2</em>, or repeat this step if less. (To simulate this probability, the first sub-algorithm above can be used.)</li>
<li>Generate a uniform random integer in [0, 2<sup><em>k</em></sup>), call it <em>m</em>, then with probability (1&minus;<em>px</em>/<em>py</em>)<sup><em>m</em></sup>, return min(<em>n</em>, <em>d</em>*2<sup><em>k</em></sup>+<em>m</em>). In the Bringmann paper, this step is implemented in a manner equivalent to the following (this alternative implementation, though, is not crucial for correctness):

<ol>
<li>Run the second sub-algorithm above, except return two values, rather than one, in the situations given in the sub-algorithm.  Call these two values <em>m</em> and <em>mbit</em>.</li>
<li>If <em>m</em> &lt; 0, go to the first substep.</li>
<li>If <em>mbit</em> &ge; 0, add 2<sup><em>mbit</em></sup> times an unbiased random bit to <em>m</em> and subtract 1 from <em>mbit</em>.  If that bit is 1 or <em>mbit</em> &lt; 0, go to the next substep; otherwise, repeat this substep.</li>
<li>Return <em>n</em> if <em>d</em>*2<sup><em>k</em></sup> is greater than or equal to <em>m2</em>.</li>
<li>Add a uniform random integer in [0, 2<sup><em>mbit</em>+1</sup>) to <em>m</em>, then return min(<em>n</em>, <em>d</em>*2<sup><em>k</em></sup>+<em>m</em>).</li>
</ol></li>
</ol>

<p><a id=Symmetric_Geometric_Distribution></a></p>

<h4>Symmetric Geometric Distribution</h4>

<p>Samples from the symmetric geometric distribution from (Ghosh et al. 2012)[^9], with parameter <em>&lambda;</em> (a real number satisfying 0 &lt; <em>&lambda;</em> &le; 1), in the form of an input coin with unknown probability of heads of <em>&lambda;</em>.</p>

<ol>
<li>Flip the input coin until it returns 1.  Set <em>n</em> to the number of times the coin returned 0 this way.</li>
<li>Run a <strong>Bernoulli factory algorithm for 1/(2&minus;<em>&lambda;</em>)</strong>, using the input coin.  If the run returns 1, return <em>n</em>.  Otherwise, return &minus;1 &minus; <em>n</em>.</li>
</ol>

<p>This is similar to an algorithm mentioned in an appendix in Li (2021)[^10], in which the input coin&mdash;</p>

<ul>
<li>has <em>&lambda;</em> = 1&minus;exp(&minus;<em>&epsilon;</em>), where <em>&epsilon;</em> &gt; 0, and</li>
<li>can be built as follows using another input coin: &quot;Run the <strong>ExpMinus</strong> algorithm with parameter <em>&epsilon;</em>, then return 1 minus the result.&quot;</li>
</ul>

<p>The algorithm of Li generates a variate from the <em>discrete Laplace distribution</em> with parameter <em>&epsilon;</em>, and Canonne et al. (2020)[^11] likewise gave an exact algorithm for that distribution where <em>&epsilon;</em> = <em>s</em>/<em>t</em> is a rational number, where <em>s</em> &gt; 0 and <em>t</em> &gt; 0 are integers, namely an algorithm equivalent to the following:</p>

<ol>
<li>Generate a uniform random integer <em>u</em> that satisfies 0 &le; <em>u</em> &lt; <em>t</em>.</li>
<li>Run the <strong>ExpMinus</strong> algorithm with parameter <em>u</em>/<em>t</em>.   If it returns 0, go to step 1.</li>
<li>Run the <strong>ExpMinus</strong> algorithm with parameter 1, until a run returns 0, then set <em>n</em> to the number of times the algorithm returned 1 this way.</li>
<li>Set <em>y</em> to floor((<em>u</em>+<em>n</em>*<em>t</em>)/<em>s</em>).</li>
<li>Generate an unbiased random bit (either zero or one with equal probability).  If the bit is 0, return <em>y</em>.  Otherwise, if <em>y</em> is 0, go to step 1.  Otherwise, return &minus;<em>y</em>.</li>
</ol>

<p><a id=Weighted_Choice_for_Special_Distributions></a></p>

<h3>Weighted Choice for Special Distributions</h3>

<p>The following are algorithms to sample items whose &quot;weights&quot; (which are related to the probability of sampling each item) are given in a special way.  They supplement the section &quot;<a href="https://peteroupc.github.io/randomfunc.html#Weighted_Choice"><strong>Weighted Choice</strong></a>&quot; in my article &quot;Randomization and Sampling Methods&quot;.</p>

<p><a id=Weighted_Choice_with_Weights_Written_as_an_Integer_and_Fraction></a></p>

<h4>Weighted Choice with Weights Written as an Integer and Fraction</h4>

<p>Suppose there is a list called <em>weights</em>.  This is a list of <em>n</em> weights, with labels starting at 0 and ending at <em>n</em>&minus;1.</p>

<p>Each weight&mdash;</p>

<ol>
<li>can store an integer part <em>m</em> and have <em>&nu;</em> represent a &quot;coin&quot; that implements an algorithm that returns 1 (or outputs heads) with probability exactly equal to the fractional part <em>&nu;</em> (<em>m</em> &ge; 0, and 0 &le; <em>&nu;</em> &le; 1), or</li>
<li>can store a <a href="https://peteroupc.github.io/exporand.html"><strong>partially-sampled random number</strong></a> (PSRN), with the integer part equal to <em>m</em> and the fractional part equal to <em>&nu;</em> (<em>m</em> &ge; 0, and 0 &le; <em>&nu;</em> &le; 1), or</li>
<li>can store a rational number <em>x</em>/<em>y</em>, where <em>x</em>&ge;0 and <em>y</em>&gt;0 are integers, such that <em>m</em> = floor(<em>x</em>/<em>y</em>) and <em>&nu;</em> = <em>x</em>/<em>y</em>&minus;<em>m</em>.</li>
</ol>

<p>Given this list of weights, the following algorithm chooses an integer in [0, <em>n</em>) with probability proportional to its weight.</p>

<ol>
<li>Create an empty list, then for each weight starting with weight 0, append the weight&#39;s integer part (<em>m</em>) plus 1 to that list.  For example, if the weights are PSRNs written as [2.22...,0.001...,1.3...], in that order, the list will be [3, 1, 2], corresponding to integers 0, 1, and 2, in that order.  Call the list just created the <em>rounded weights list</em>.</li>
<li>Choose an integer <em>i</em> with probability proportional to the weights in the rounded weights list.  This can be done, for example, by taking the result of <strong>WeightedChoice</strong>(<em>list</em>), where <em>list</em> is the rounded weights list and <strong>WeightedChoice</strong> is given in &quot;<a href="https://peteroupc.github.io/randomfunc.html#Weighted_Choice_With_Replacement"><strong>Randomization and Sampling Methods</strong></a>&quot;.  Let <em>w</em> be the original weight for integer <em>i</em>, and let <em>rw</em> be the rounded weight for integer <em>i</em> in the rounded weights list.</li>
<li><p>Generate <em>j</em>, a uniform random integer that is 0 or greater and less than <em>rw</em>. If <em>j</em> is less than <em>rw</em>&minus;1, return <em>i</em>.  Otherwise:</p>

<ul>
<li>If <em>w</em> is written as in case 1, above, flip the &quot;coin&quot; represented by <em>&nu;</em> (the weight&#39;s fractional part).  If it returns 1, return <em>i</em>.  Otherwise, go to step 2.</li>
<li>If <em>w</em> is written as in case 2, run <strong>SampleGeometricBag</strong> on the PSRN.  If the result is 1, return <em>i</em>.  Otherwise, go to step 2.</li>
<li>If <em>w</em> is written as in case 3, let <em>r</em> = rem(<em>x</em>, <em>y</em>) = <em>x</em>&minus;floor(<em>x</em>/<em>y</em>)*<em>y</em>, then with probability <em>r</em>/<em>y</em>, return <em>i</em>. (For example, generate <em>z</em>, a uniform random integer satisfying 0&le;<em>z</em>&lt;<em>y</em>, then if <em>z</em>&lt;<em>r</em>, return <em>i</em>.) Otherwise, go to step 2.</li>
</ul></li>
</ol>

<p><a id=Distributions_with_nowhere_increasing_or_nowhere_decreasing_weights></a></p>

<h4>Distributions with nowhere increasing or nowhere decreasing weights</h4>

<p>An algorithm for sampling an integer in the interval [<em>a</em>, <em>b</em>) with probability proportional to weights listed in <em>nowhere increasing</em> order (example: [10, 3, 2, 1, 1] when <em>a</em> = 0 and <em>b</em> = 5) can be implemented as follows (Chewi et al. 2022)[^12].  It has a logarithmic time complexity in terms of setup and sampling.</p>

<ul>
<li>Setup:  Let <em>w</em>[<em>i</em>] be the weight for integer <em>i</em> (with <em>i</em> starting at <em>a</em>).

<ol>
<li>(Envelope weights.) Build a list <em>q</em> as follows: The first item is <em>w</em>[<em>a</em>], then set <em>j</em> to 1, then while <em>j</em> &lt; <em>b</em>&minus;<em>a</em>, append <em>w</em>[<em>a</em> + <em>j</em>] and multiply <em>j</em> by 2.  The list <em>q</em>&#39;s items should be rational numbers that equal the true values, if possible, or overestimate them if not.</li>
<li>(Envelope chunk weights.) Build a list <em>r</em> as follows: The first item is <em>q</em>[0], then set <em>j</em> to 1 and <em>m</em> to 1, then while <em>j</em> &lt; <em>b</em>&minus;<em>a</em>, append <em>q</em>[<em>m</em>]*min((<em>b</em>&minus;<em>a</em>) &minus; <em>j</em>, <em>j</em>) and multiply <em>j</em> by 2 and add 1 to <em>m</em>.</li>
<li>(Start and end points of each chunk.) Build a list <em>D</em> as follows: The first item is the list [<em>a</em>, <em>a</em>+1], then set <em>j</em> to 1, then while <em>j</em> &lt; <em>n</em>, append the list [<em>j</em>, <em>j</em> + min((<em>b</em>&minus;<em>a</em>) &minus; <em>j</em>, <em>j</em>)] and multiply <em>j</em> by 2.</li>
</ol></li>
<li>Sampling:

<ol>
<li>Choose an integer in [0, <em>s</em>) with probability proportional to the weights in <em>r</em>, where <em>s</em> is the number of items in <em>r</em>.  Call the chosen integer <em>k</em>.</li>
<li>Set <em>x</em> to an integer chosen uniformly at random such that <em>x</em> is greater than or equal to <em>D</em>[<em>k</em>][0] and is less than <em>D</em>[<em>k</em>][1].</li>
<li>With probability <em>w</em>[<em>x</em>] / <em>q</em>[<em>k</em>], return <em>x</em>.  Otherwise, go to step 1.</li>
</ol></li>
</ul>

<p>For <em>nowhere decreasing</em> rather than nowhere increasing weights, the algorithm is as follows instead:</p>

<ul>
<li>Setup:  Let <em>w</em>[<em>i</em>] be the weight for integer <em>i</em> (with <em>i</em> starting at <em>a</em>).

<ol>
<li>(Envelope weights.) Build a list <em>q</em> as follows: The first item is <em>w</em>[<em>b</em>&minus;1], then set <em>j</em> to 1, then while <em>j</em> &lt; (<em>b</em>&minus;<em>a</em>), append <em>w</em>[<em>b</em>&minus;1&minus;<em>j</em>] and multiply <em>j</em> by 2.  The list <em>q</em>&#39;s items should be rational numbers that equal the true values, if possible, or overestimate them if not.</li>
<li>(Envelope chunk weights.) Build a list <em>r</em> as given in step 2 of the previous algorithm&#39;s setup.</li>
<li>(Start and end points of each chunk.) Build a list <em>D</em> as follows: The first item is the list [<em>b</em>&minus;1, <em>b</em>], then set <em>j</em> to 1, then while <em>j</em> &lt; (<em>b</em>&minus;<em>a</em>), append the list [(<em>b</em>&minus;<em>j</em>) &minus; min((<em>b</em>&minus;<em>a</em>) &minus; <em>j</em>, <em>j</em>), <em>b</em>&minus;<em>j</em>] and multiply <em>j</em> by 2.</li>
</ol></li>
<li>The sampling is the same as for the previous algorithm.</li>
</ul>

<blockquote>
<p><strong>Notes:</strong></p>

<ol>
<li>The weights can be base-<em>&beta;</em> logarithms, especially since logarithms preserve order, but in this case the algorithm requires changes.  In the setup step 2, replace &quot;<em>q</em>[<em>m</em>]*min((<em>b</em>&minus;<em>a</em>)&quot; with &quot;<em>q</em>[<em>m</em>]+ln(min((<em>b</em>&minus;<em>a</em>))/ln(<em>&beta;</em>)&quot; (which is generally inexact unless <em>&beta;</em> is 2); in sampling step 1, use an algorithm that takes base-<em>&beta;</em> logarithms as weights; and replace sampling step 3 with &quot;Generate an exponential random variate with rate ln(<em>&beta;</em>) (that is, the variate is <em>E</em>/ln(<em>&beta;</em>) where <em>E</em> is an exponential random variate with rate 1).  If that variate is greater than <em>q</em>[<em>k</em>] minus <em>w</em>[<em>x</em>], return <em>x</em>.  Otherwise, go to step 1.&quot;<br>Applying these modifications to this section&#39;s algorithms can introduce numerical errors unless care is taken (see note 2).  The same is true for running the unmodified algorithms with weights that are not rational numbers.</li>
<li>If an algorithm will operate on potentially irrational numbers, then to avoid numerical errors, it should store and operate on real numbers in the form of constructive reals or recursive reals (see, e.g., Boehm 1987[^13], 2020[^14]), or in the form of partially-sampled random numbers (PSRNs) together with algorithms with <a href="https://peteroupc.github.io/exporand.html#Properties"><strong>desirable properties for PSRN samplers</strong></a>.</li>
</ol>
</blockquote>

<p><a id=Unimodal_distributions_of_weights></a></p>

<h4>Unimodal distributions of weights</h4>

<p>The following is an algorithm for sampling an integer in the interval [<em>a</em>, <em>b</em>) with probability proportional to a <em>unimodal distribution</em> of weights (that is, nowhere decreasing on the left and nowhere increasing on the right) (Chewi et al. 2022)[^12].  It assumes the mode (the point with the highest weight) is known.  An example is [1, 3, 9, 4, 4] when <em>a</em> = 0 and <em>b</em> = 5, and the <em>mode</em> is 2, which corresponds to the weight 9.  It has a logarithmic time complexity in terms of setup and sampling.</p>

<ul>
<li>Setup:

<ol>
<li>Find the point with the highest weight, such as via binary search.  Call this point <em>mode</em>.</li>
<li>Run the setup for <em>nowhere decreasing</em> weights on the interval [<em>a</em>, <em>mode</em>), then run the setup for <em>nowhere increasing</em> weights on the interval [<em>mode</em>, <em>b</em>).  Both setups are described in the previous section.  Then, concatenate the two <em>q</em> lists into one, the two <em>r</em> lists into one, and the two <em>D</em> lists into one.</li>
</ol></li>
<li>The sampling is the same as for the algorithms in the previous section.</li>
</ul>

<p><a id=Weighted_Choice_with_Log_Probabilities></a></p>

<h4>Weighted Choice with Log Probabilities</h4>

<p>Huijben et al. (2022)[^15] reviews the Gumbel max trick and Gumbel softmax distributions.</p>

<blockquote>
<p><strong>Note</strong>: Because these algorithms involve adding one real number to another and calculating <code>exp</code> of a real number, they can introduce numerical errors unless care is taken (see note 2 in &quot;Distributions with nowhere increasing or nowhere decreasing weights&quot;, above).</p>
</blockquote>

<p><strong>Weighted choice with the Gumbel max trick.</strong> Let <em>C</em>&gt;0 be an unknown number.  Then, given&mdash;</p>

<ul>
<li>a vector of the form [<em>p</em><sub>0</sub>, <em>p</em><sub>1</sub>, ..., <em>p</em><sub><em>n</em></sub>], where <em>p</em><sub><em>i</em></sub> is a so-called &quot;unnormalized log probability&quot; of the form ln(<em>x</em>)+<em>C</em> (where <em>C</em> is a constant and <em>x</em> is the probability of getting <em>i</em>),</li>
</ul>

<p>an integer in the closed interval [0, <em>n</em>] can be sampled as follows:</p>

<ol>
<li>(&quot;Gumbel&quot;.) For each <em>p</em><sub><em>i</em></sub>, generate a &quot;Gumbel variate&quot; <em>G</em>, then set <em>q</em><sub><em>i</em></sub> to <em>p</em><sub><em>i</em></sub>+<em>G</em>.  (A so-called &quot;Gumbel variate&quot; is distributed as &minus;ln(&minus;ln(<em>U</em>)), where <em>U</em> is a uniform random variate greater than 0 and less than 1.[^16])</li>
<li>(&quot;Max&quot;.) Return the integer <em>i</em> corresponding to the highest <em>q</em><sub><em>i</em></sub> value.</li>
</ol>

<blockquote>
<p><strong>Note:</strong> &quot;Gumbel top <em>k</em> sampling&quot; samples <em>k</em> items according to their &quot;unnormalized log probabilities&quot; (see Fig. 7 of Huijben et al. (2022)[^15]); this sampling works by doing step 1, then choosing the <em>k</em> integers corresponding to the <em>k</em> highest <em>q</em><sub><em>i</em></sub> values.  With this sampling, though, the probability of getting <em>i</em> (if the plain Gumbel max trick were used) is not necessarily the probability that <em>i</em> is included in the <em>k</em>-item sample (Tillé 2023)[^17].</p>
</blockquote>

<p><strong>Weighted choice with the Gumbel softmax trick.</strong> Given a vector described above as well as a &quot;temperature&quot; parameter <em>&lambda;</em> &gt; 0, a &quot;continuous relaxation&quot; or &quot;concrete distribution&quot; (which transforms the vector to a new one) can be sampled as follows:</p>

<ol>
<li>(&quot;Gumbel&quot;.) For each <em>p</em><sub><em>i</em></sub>, generate a &quot;Gumbel variate&quot; <em>G</em>, then set <em>q</em><sub><em>i</em></sub> to <em>p</em><sub><em>i</em></sub>+<em>G</em>.</li>
<li>(&quot;Softmax&quot;.) For each <em>q</em><sub><em>i</em></sub>, set it to exp(<em>q</em><sub><em>i</em></sub>/<em>&lambda;</em>).</li>
<li>Set <em>d</em> to the sum of all values of <em>q</em><sub><em>i</em></sub>.</li>
<li>For each <em>q</em><sub><em>i</em></sub>, divide it by <em>d</em>.</li>
</ol>

<p>The algorithm&#39;s result is a vector <em>q</em>, which can be used only once to sample <em>i</em> with probability proportional to <em>q</em><sub><em>i</em></sub> (which is not a &quot;log probability&quot;). (In this case, steps 3 and 4 above can be omitted if that sampling method can work with weights that need not sum to 1.)</p>

<p><a id=Bernoulli_Distribution_for_Cumulative_Distribution_Functions></a></p>

<h3>Bernoulli Distribution for Cumulative Distribution Functions</h3>

<p>Suppose a real number <em>z</em> is given (which might be a partially-sampled random number [PSRN] or a rational number).  If a probability distribution&mdash;</p>

<ul>
<li>has a probability density function (PDF) (as with the normal or exponential distribution), and</li>
<li>has an arbitrary-precision sampler that returns a PSRN <em>X</em>,</li>
</ul>

<p>then it&#39;s possible to generate 1 with the same probability as the sampler returns an <em>X</em> that is less than or equal to <em>z</em>, as follows:</p>

<ol>
<li>Run the arbitrary-precision sampler to generate <em>X</em>, a uniform PSRN.</li>
<li>Run <strong>RandLess</strong> (if <em>z</em> is a PSRN) or <strong>RandLessThanReal</strong> (if <em>z</em> is a real number) with parameters <em>X</em> and <em>z</em>, in that order, and return the result.</li>
</ol>

<p>Specifically, the probability of returning 1 is the <em>cumulative distribution function</em> (CDF) for the distribution of <em>X</em>.</p>

<blockquote>
<p><strong>Notes:</strong></p>

<ol>
<li>Although step 2 of the algorithm checks whether <em>X</em> is merely less than <em>z</em>, this is still correct; because the distribution of <em>X</em> has a PDF, <em>X</em> is less than <em>z</em> with the same probability as <em>X</em> is less than or equal to <em>z</em>.</li>
<li>All probability distributions have a CDF, not just those with a PDF, but also discrete ones such as Poisson or binomial.</li>
</ol>
</blockquote>

<p><a id=Bit_Vectors_with_Random_Bit_Flips></a></p>

<h3>Bit Vectors with Random Bit Flips</h3>

<p>Chakraborty and Vardeman (2021)[^18] describes distributions of bit vectors with a random number of bit flips. Given three parameters &mdash; <em>&mu;</em> is a <em>p</em>-item vector (list) with only zeros and ones in any combination; <em>p</em> is the size of <em>&mu;</em>; and <em>&alpha;</em> is a spread parameter greater than 0 and less than 1 &mdash; do the following to generate such a vector:</p>

<ol>
<li>Generate a random integer <em>c</em> in the interval [0, <em>p</em>] in some way.  (<em>c</em> need not be uniformly distributed.  This is the number of bit flips.)</li>
<li>Create a <em>p</em>-item list <em>&nu;</em>, where the first <em>c</em> items are ones and the rest are zeros.  <a href="https://peteroupc.github.io/randomfunc.html#Shuffling"><strong>Shuffle</strong></a> the list.</li>
<li>Create a copy of <em>&mu;</em>, call it <em>M</em>.  Then for each <em>i</em> where <em>&nu;</em>[<em>i</em>] = 1, set <em>M</em>[<em>i</em>] to 1 &minus; <em>M</em>[<em>i</em>].  Then return <em>M</em>.</li>
</ol>

<p>The paper describes two ways to establish the weights for <em>c</em> in step 1 (there are others as well):</p>

<ul>
<li>Generate <em>c</em> with probability proportional to the following weights: [<em>&alpha;</em><sup>0</sup>, <em>&alpha;</em><sup>1</sup>, ..., <em>&alpha;</em><sup><em>p</em></sup>].  (Since each weight is 1 or less, this can be implemented as follows, for example.  Generate a uniform random integer in [0, <em>p</em>], call it <em>d</em>, then flip a coin that shows heads with probability <em>&alpha;</em>, <em>d</em> times, then either return <em>d</em> if <em>d</em> is 0 or all the flips are heads, or repeat this process otherwise.)</li>
<li>Generate <em>c</em> with probability proportional to the following weights: [<em>&alpha;</em><sup>0</sup>*choose(<em>p</em>,0), <em>&alpha;</em><sup>1</sup>*choose(<em>p</em>,1), ..., <em>&alpha;</em><sup><em>p</em></sup>*choose(<em>p</em>,<em>p</em>)].  (Since the sum of weights is no more than $2^p$, each weight can be divided by $2^p$ to get weights that are 1 or less, so that this can be implemented as follows, for example.  Generate a uniform random integer in [0, <em>p</em>], call it <em>d</em>, then flip a coin that shows heads with probability <em>&alpha;</em>, <em>d</em> times, and a coin that shows heads with probability choose(<em>p</em>, <em>d</em>)/2<sup><em>p</em></sup> once, then either return <em>d</em> if all the flips are heads, or repeat this process otherwise.  Note that the probability choose(<em>p</em>, <em>d</em>)/2<sup><em>p</em></sup> is simple to simulate for being a rational number.)</li>
</ul>

<p><a id=Log_Uniform_Distribution></a></p>

<h3>Log-Uniform Distribution</h3>

<p>Samples from the so-called &quot;log uniform distribution&quot; as used by the Abseil programming library.  This algorithm takes a maximum <em>mx</em> and a logarithmic base <em>b</em>, and chooses an integer in [0, <em>mx</em>] such that two values are chosen with the same probability if their base-<em>b</em> logarithms are equal in their integer parts (which roughly means that lower numbers occur with an exponentially greater probability).  Although this algorithm works, in principle, for every <em>b</em> &gt; 0, Abseil supports only integer bases <em>b</em>.</p>

<ol>
<li>Let <em>L</em> be ceil(ln(<em>mx</em>+1)/ln(<em>b</em>)). Choose a uniform random integer in the closed interval [0, <em>L</em>], call it <em>u</em>.</li>
<li>If <em>u</em> is 0, return 0.</li>
<li>Set <em>st</em> to min(<em>mx</em>, ceil(<em>b</em><sup><em>u</em>&minus;1</sup>)).</li>
<li>Set <em>en</em> to min(<em>mx</em>, ceil(<em>b</em><sup><em>u</em></sup>) &minus; 1).</li>
<li>Choose a uniform random integer in the closed interval [<em>st</em>, <em>en</em>], and return it.</li>
</ol>

<p><a id=Sampling_Unbounded_Monotone_Density_Functions></a></p>

<h2>Sampling Unbounded Monotone Density Functions</h2>

<p>This section shows a preprocessing algorithm to generate a random variate in the closed interval [0, 1] from a distribution whose probability density function (PDF)&mdash;</p>

<ul>
<li>is continuous in the interval [0, 1],</li>
<li>is strictly decreasing in [0, 1], and</li>
<li>has an unbounded peak at 0.</li>
</ul>

<p>The trick here is to sample the peak in such a way that the result is either forced to be 0 or forced to belong to the bounded part of the PDF.  This algorithm does not require the area under the curve of the PDF in [0, 1] to be 1; in other words, this algorithm works even if the PDF is known up to a normalizing constant.  The algorithm is as follows.</p>

<ol>
<li>Set <em>i</em> to 1.</li>
<li>Calculate the cumulative probability of the interval [0, 2<sup>&minus;<em>i</em></sup>] and that of [0, 2<sup>&minus;(<em>i</em> &minus; 1)</sup>], call them <em>p</em> and <em>t</em>, respectively.</li>
<li>With probability <em>p</em>/<em>t</em>, add 1 to <em>i</em> and go to step 2. (Alternatively, if <em>i</em> is equal to or higher than the desired number of fractional bits in the result, return 0 instead of adding 1 and going to step 2.)</li>
<li>At this point, the PDF at [2<sup>&minus;<em>i</em></sup>, 2<sup>&minus;(<em>i</em> &minus; 1)</sup>) is less than or equal to a finite number, so sample a random variate in this interval using any appropriate algorithm, including rejection sampling.  Because the PDF is strictly decreasing, the peak of the PDF at this interval is located at 2<sup>&minus;<em>i</em></sup>, so that rejection sampling becomes trivial.</li>
</ol>

<p>It is relatively straightforward to adapt this algorithm for strictly increasing PDFs with the unbounded peak at 1, or to PDFs with a different domain than [0, 1].</p>

<p>This algorithm is similar to the &quot;inversion&ndash;rejection&quot; algorithm mentioned in section 4.4 of chapter 7 of Devroye&#39;s <em>Non-Uniform Random Variate Generation</em> (1986)[^4].  I was unaware of that algorithm at the time I started writing the text that became this section (Jul. 25, 2020).  The difference here is that it assumes the whole distribution has support [0, 1] (&quot;support&quot; is defined later), while the algorithm presented in this article doesn&#39;t make that assumption (for example, the interval [0, 1] can cover only part of the distribution&#39;s support).</p>

<p>By the way, this algorithm arose while trying to devise an algorithm that can generate an integer power of a uniform random variate, with arbitrary precision, without actually calculating that power (a naïve calculation that is merely an approximation and usually introduces bias); for more information, see the article on <a href="https://peteroupc.github.io/exporand.html"><strong>partially-sampled random numbers</strong></a>.  Even so, the algorithm I have come up with in this note may be of independent interest.</p>

<p>In the case of powers of a uniform random variate between 0 and 1, call the variate <em>X</em>, namely <em>X</em><sup><em>n</em></sup>, the ratio <em>p</em>/<em>t</em> in this algorithm has a very simple form, namely (1/2)<sup>1/<em>n</em></sup>.  Note that this formula is the same regardless of <em>i</em>. (To return 1 with probability (1/2)<sup>1/<em>n</em></sup>, the algorithm for <strong>(<em>a</em>/<em>b</em>)<sup><em>z</em></sup></strong> in &quot;<a href="https://peteroupc.github.io/bernoulli.html"><strong>Bernoulli Factory Algorithms</strong></a>&quot; can be used with <em>a</em>=1, <em>b</em>=2, and <em>z</em>=1/<em>n</em>.)  This is found by taking the PDF <em>f</em>(<em>x</em>) = <em>x</em><sup>1/<em>n</em></sup>/(<em>x</em> * <em>n</em>)</sup> and finding the appropriate <em>p</em>/<em>t</em> ratios by integrating <em>f</em> over the two intervals mentioned in step 2 of the algorithm.</p>

<p><a id=Certain_Families_of_Distributions></a></p>

<h2>Certain Families of Distributions</h2>

<p>This section is a note on certain families of univariate (one-variable) probability distributions, with emphasis on generating random variates from them.  Some of these families are described in Ahmad et al. (2019)[^19], Jones (2015)[^20].</p>

<p>The following mathematical definitions are used:</p>

<ul>
<li>A probability distribution&#39;s <em>quantile function</em> (also known as <em>inverse cumulative distribution function</em> or <em>inverse CDF</em>) is a nowhere decreasing function that maps uniform random variates greater than 0 and less than 1 to numbers that follow the distribution.</li>
<li>A probability distribution&#39;s <em>support</em> is the set of values the distribution can take on, plus that set&#39;s endpoints.  For example, the beta distribution&#39;s support is the closed interval [0, 1], and the normal distribution&#39;s support is the entire real line.</li>
<li>The <em>zero-truncated Poisson</em> distribution: To generate a random variate that follows this distribution (with parameter <em>&lambda;</em> &gt; 0), generate random variates from the <a href="https://peteroupc.github.io/randomfunc.html#Poisson_Distribution"><strong>Poisson distribution</strong></a> with parameter <em>&lambda;</em> until a variate other than 0 is generated this way, then take the last generated variate.</li>
</ul>

<p><strong>G families.</strong> In general, families of the form &quot;X-G&quot; (such as &quot;beta-G&quot; (Eugene et al., 2002)[^21]) use two distributions, X and G, where&mdash;</p>

<ul>
<li>X is a probability distribution whose support is the closed interval [0, 1], and</li>
<li>G is a probability distribution that should have an easy-to-compute quantile function.</li>
</ul>

<p>The following algorithm samples a random variate following a distribution from this kind of family:</p>

<ol>
<li>Generate a random variate that follows the distribution X. (Or generate a uniform <a href="https://peteroupc.github.io/exporand.html"><strong>partially-sampled random number (PSRN)</strong></a> that follows the distribution X.)  Call the number <em>x</em>.</li>
<li>Calculate the quantile for G of <em>x</em>, and return that quantile. (If <em>x</em> is a uniform PSRN, see &quot;Random Variate Generation via Quantiles&quot;, later.)</li>
</ol>

<p>Certain special cases of the &quot;X-G&quot; families, such as the following, use a specially designed distribution for X:</p>

<ul>
<li>The <em>exp-G</em> family (Barreto-Souza and Simas 2010/2013)[^22], where X is an exponential distribution, truncated to the interval [0, 1], with parameter <em>&lambda;</em> &ge; 0; step 1 is modified to read: &quot;Generate <em>U</em>, a uniform random variate between 0 and 1, then set <em>x</em> to &minus;ln((exp(&minus;<em>&lambda;</em>)&minus;1)*<em>U</em> + 1)/<em>&lambda;</em> if <em>&lambda;</em> != 0, and <em>U</em> otherwise.&quot; (The <em>alpha power</em> or <em>alpha power transformed</em> family (Mahdavi and Kundu 2017)[^23] uses the same distribution for X, but with <em>&lambda;</em>=&minus;ln(<em>&alpha;</em>) where <em>&alpha;</em> is in (0, 1]; see also Jones (2018)[^24].)</li>
<li>One family uses a shape parameter <em>a</em> &gt; 0; step 1 is modified to read: &quot;Generate <em>u</em>, a uniform random variate between 0 and 1, then set <em>x</em> to <em>u</em><sup>1/<em>a</em></sup>.&quot;  This family is mentioned in Lehmann (1953)[^25], Durrans (1992)[^26], and Mudholkar and Srivastava (1993)[^27], which called it <em>exponentiated</em>.</li>
<li>The <em>transmuted-G</em> family (Shaw and Buckley 2007)[^28]. The family uses a shape parameter <em>&eta;</em> satisfying &minus;1 &le; <em>&eta;</em> &le; 1; step 1 is modified to read: &quot;Generate a piecewise linear random variate between 0 and 1 with weight 1&minus;<em>&eta;</em> at 0 and weight 1+<em>&eta;</em> at 1, call the number <em>x</em>. (It can be generated as follows, see also (Devroye 1986, p. 71-72)[^4]: With probability min(1&minus;<em>&eta;</em>, 1+<em>&eta;</em>), generate <em>x</em>, a uniform random variate between 0 and 1. Otherwise, generate two uniform random variates between 0 and 1, set <em>x</em> to the higher of the two, then if <em>&eta;</em> is less than 0, set <em>x</em> to 1&minus;<em>x</em>.)&quot;. ((Granzotto et al. 2017)[^29] mentions the same distribution, but with a parameter <em>&lambda;</em> = <em>&eta;</em> + 1 satisfying 0 &le; <em>&lambda;</em> &le; 2.)</li>
<li>A <em>cubic rank transmuted</em> distribution (Granzotto et al. 2017)[^29] uses parameters <em>&lambda;</em><sub>0</sub> and <em>&lambda;</em><sub>1</sub> in the interval [0, 1]; step 1 is modified to read: &quot;Generate three uniform random variates between 0 and 1, then sort them in ascending order.  Then, choose 1, 2, or 3 with probability proportional to these weights: [<em>&lambda;</em><sub>0</sub>, <em>&lambda;</em><sub>1</sub>, 3&minus;<em>&lambda;</em><sub>0</sub>&minus;<em>&lambda;</em><sub>1</sub>].  Then set <em>x</em> to the first, second, or third variate if 1, 2, or 3 is chosen this way, respectively.&quot;</li>
<li>Biweight distribution (Al-Khazaleh and Alzoubi 2021)[^52]: Step 1 is modified to read: &quot;Generate a uniform random variate <em>x</em> in [0, 1], then with probability (1&minus;<em>x</em><sup>2</sup>)<sup>2</sup>, go to the next step.  Otherwise, repeat this process.&quot;; or &quot;Create a uniform PSRN <em>x</em> with positive sign and integer part 0, then run <strong>SampleGeometricBag</strong> on that PSRN four times.  If the first two results are not both 1 and if the last two results are not both 1, go to the next step; otherwise, repeat this process.&quot;</li>
</ul>

<p><strong>Transformed&ndash;transformer family.</strong> In fact, the &quot;X-G&quot; families are a special case of the so-called &quot;transformed&ndash;transformer&quot; family of distributions introduced by Alzaatreh et al. (2013)[^30] that uses two distributions, X and G, where X (the &quot;transformed&quot;) is an arbitrary distribution with a probability density function; G (the &quot;transformer&quot;) is a distribution with an easy-to-compute quantile function; and <em>W</em> is a nowhere decreasing function that, among other conditions, maps a number in the closed interval [0, 1] to a number with the same support as X.  The following algorithm samples a random variate from this kind of family:</p>

<ol>
<li>Generate a random variate that follows the distribution X. (Or generate a uniform PSRN that follows X.) Call the number <em>x</em>.</li>
<li>Calculate <em>w</em> = <em>W</em><sup>&minus;1</sup>(<em>x</em>) (where <em>W</em><sup>&minus;1</sup>(.) is the inverse of <em>W</em>), then calculate the quantile for G of <em>w</em> and return that quantile. (If <em>x</em> is a uniform PSRN, see &quot;Random Variate Generation via Quantiles&quot;, later.)</li>
</ol>

<p>The following are special cases of the &quot;transformed&ndash;transformer&quot; family:</p>

<ul>
<li>The &quot;T-R{<em>Y</em>}&quot; family (Aljarrah et al., 2014)[^31], in which <em>T</em> is an arbitrary distribution with a PDF (X in the algorithm above), <em>R</em> is a distribution with an easy-to-compute quantile function (G in the algorithm above), and <em>W</em> is the quantile function for the distribution <em>Y</em>, whose support must contain the support of <em>T</em> (so that <em>W</em><sup>&minus;1</sup>(<em>x</em>) is the cumulative distribution function for <em>Y</em>, or the probability that a <em>Y</em>-distributed number is <em>x</em> or less).</li>
<li>Several versions of <em>W</em> have been proposed for the case when distribution X&#39;s support is [0, &infin;), such as the Rayleigh and gamma distributions.  They include:

<ul>
<li><em>W</em>(<em>x</em>) = &minus;ln(1&minus;<em>x</em>) (<em>W</em><sup>&minus;1</sup>(<em>x</em>) = 1&minus;exp(&minus;<em>x</em>)).  Suggested in the original paper by Alzaatreh et al.</li>
<li><em>W</em>(<em>x</em>) = <em>x</em>/(1&minus;<em>x</em>) (<em>W</em><sup>&minus;1</sup>(<em>x</em>) = <em>x</em>/(1+<em>x</em>)).  Suggested in the original paper by Alzaatreh et al.  This choice forms the so-called &quot;odd X G&quot; family, and one example is the &quot;odd log-logistic G&quot; family (Gleaton and Lynch 2006)[^32].</li>
</ul></li>
</ul>

<blockquote>
<p><strong>Example:</strong> For the &quot;generalized odd gamma-G&quot; family (Hosseini et al. 2018)[^33], X is the gamma(<em>&alpha;</em>) distribution, <em>W</em><sup>&minus;1</sup>(<em>x</em>) = (<em>x</em>/(1+<em>x</em>))<sup>1/<em>&beta;</em></sup>, G is arbitrary, <em>&alpha;</em>&gt;0, and <em>&beta;</em>&gt;0.</p>
</blockquote>

<p>A family very similar to the &quot;transformed&ndash;transformer&quot; family uses a <em>decreasing</em> <em>W</em>.</p>

<ul>
<li>When distribution X&#39;s support is [0, &infin;), one such <em>W</em> that has been proposed is <em>W</em>(<em>x</em>) = &minus;ln(<em>x</em>) (<em>W</em><sup>&minus;1</sup>(<em>x</em>) = exp(&minus;<em>x</em>); examples include the &quot;Rayleigh-G&quot; family or &quot;Rayleigh&ndash;Rayleigh&quot; distribution (Al Noor and Assi 2020)[^34], as well as the &quot;generalized gamma-G&quot; family, where &quot;generalized gamma&quot; refers to the Stacy distribution (Boshi et al. 2020)[^35]).</li>
</ul>

<p><strong>Minimums, maximums, and sums.</strong> Some distributions are described as a minimum, maximum, or sum of <em>N</em> independent random variates distributed as <em>X</em>, where <em>N</em> &ge; 1 is an independent integer distributed as the discrete distribution <em>Y</em>.</p>

<ul>
<li>Tahir and Cordeiro (2016)[^36] calls a distribution of minimums a <em>compound distribution</em>, and a distribution of maximums a <em>complementary compound distribution</em>.</li>
<li>Pérez-Casany et al. (2016)[^37] calls a distribution of minimums or of maximums a <em>random-stopped extreme distribution</em>.</li>
<li>Let <em>S</em> be a sum of <em>N</em> variates as described above.  Then Amponsah et al. (2021)[^38] describe the distribution of (<em>S</em>, <em>N</em>), a two-variable random variate often called an <em>episode</em>.</li>
<li>A distribution of sums can be called a <em>stopped-sum distribution</em> (Johnson et al. 2005)[^39]. (In this case, <em>N</em> can be 0 so that <em>N</em> &ge; 0 is an integer distributed as <em>Y</em>.)</li>
</ul>

<p>A variate following a distribution of minimums or of maximums can be generated as follows (Duarte-López et al. 2021)[^40]:</p>

<ol>
<li>Generate a uniform random variate between 0 and 1. (Or generate a uniform PSRN with integer part 0, positive sign, and empty fractional part.)  Call the number <em>x</em>.</li>
<li>For minimums, calculate the quantile for <em>X</em> of 1&minus;<em>W</em><sup>&minus;1</sup>(<em>x</em>) (where <em>W</em><sup>&minus;1</sup>(.) is the inverse of <em>Y</em>&#39;s probability generating function), and return that quantile.[^41] (If <em>x</em> is a uniform PSRN, see &quot;Random Variate Generation via Quantiles&quot;, later.  <em>Y</em>&#39;s probability generating function is <em>W</em>(<em>z</em>) = <em>a</em>[0]*<em>z</em><sup>0</sup> + <em>a</em>[1]*<em>z</em><sup>1</sup> + ..., where 0 &lt; <em>z</em> &lt; 1 and <em>a</em>[<em>i</em>] is the probability that a <em>Y</em>-distributed variate equals <em>i</em>.  See example below.)</li>
<li>For maximums, calculate the quantile for <em>X</em> of <em>W</em><sup>&minus;1</sup>(<em>x</em>), and return that quantile.</li>
</ol>

<blockquote>
<p><strong>Examples:</strong></p>

<table><thead>
<tr>
<th>This distribution:</th>
<th>Is a distribution of:</th>
<th>Where <em>X</em> is:</th>
<th>And <em>Y</em> is:</th>
</tr>
</thead><tbody>
<tr>
<td>Geometric zero-truncated Poisson (Akdoğan et al., 2020)[^42].</td>
<td>Maximums.</td>
<td>1 plus the number of failures before the first success, with each success having the same probability.</td>
<td>Zero-truncated Poisson.</td>
</tr>
<tr>
<td>GMDP(<em>&alpha;</em>, <em>&beta;</em>, <em>&delta;</em>, <em>p</em>) (Amponsah et al. 2021)[^38] (<em>&alpha;</em>&gt;0, <em>&beta;</em>&gt;0, <em>&delta;</em>&gt;0, 0&lt;<em>p</em>&lt;1).</td>
<td>(<em>S</em>, <em>N</em>) episodes.</td>
<td>Gamma(<em>&alpha;</em>) variate divided by <em>&beta;</em>.</td>
<td>Discrete Pareto(<em>&delta;</em>, <em>p</em>) (see &quot;Certain Distributions&quot;).</td>
</tr>
<tr>
<td>Bivariate gamma geometric(<em>&alpha;</em>, <em>&beta;</em>, <em>p</em>) (Barreto-Souza 2012)[^43] (<em>&alpha;</em>&gt;0, <em>&beta;</em>&gt;0, 0&lt;<em>p</em>&lt;1).</td>
<td>(<em>S</em>, <em>N</em>) episodes.</td>
<td>Gamma(<em>&alpha;</em>) variate divided by <em>&beta;</em>.</td>
<td>1 plus the number of failures before the first success, with each success having probability <em>p</em>.</td>
</tr>
<tr>
<td>Exponential Poisson (Kuş 2007)[^44].</td>
<td>Minimums.</td>
<td>Exponential.</td>
<td>Zero-truncated Poisson.</td>
</tr>
<tr>
<td>Poisson exponential (Cancho et al. 2011)[^45].</td>
<td>Maximums.</td>
<td>Exponential.</td>
<td>Zero-truncated Poisson.</td>
</tr>
<tr>
<td>Right-truncated Weibull(<em>a</em>, <em>b</em>, <em>c</em>) (Jodrá 2020)[^46] (<em>a</em>, <em>b</em>, and <em>c</em> are greater than 0).</td>
<td>Minimums.</td>
<td>Power function(<em>b</em>, <em>c</em>).</td>
<td>Zero-truncated Poisson(<em>a</em>*<em>c</em><sup><em>b</em></sup>).</td>
</tr>
</tbody></table>

<p><strong>Example:</strong> If <em>Y</em> is zero-truncated Poisson with parameter <em>&lambda;</em>, its probability generating function is $W(z)=\frac{1-\exp(z\lambda)}{1-\exp(\lambda)}$, and solving for <em>x</em> leads to its inverse: $W^{-1}(x)=\ln(1-x+x\times\exp(\lambda))/\lambda$.</p>

<p><strong>Note:</strong> Bivariate exponential geometric (Barreto-Souza 2012)[^43] is a special case of bivariate gamma geometric with <em>&alpha;</em>=1.</p>
</blockquote>

<p><strong>Inverse distributions.</strong> An <em>inverse X distribution</em> (or <em>inverted X distribution</em>) is generally the distribution of 1 divided by a random variate distributed as <em>X</em>.  For example, an <em>inverse exponential</em> random variate (Keller and Kamath 1982)[^47] is 1 divided by an exponential random variate with rate 1 (and so is distributed as &minus;1/ln(<em>U</em>) where <em>U</em> is a uniform random variate between 0 and 1) and may be multiplied by a parameter <em>&theta;</em> &gt; 0.</p>

<p><strong>Weighted distributions.</strong> A <em>weighted X distribution</em> uses a distribution X and a weight function <em>w</em>(<em>x</em>) whose values lie in [0, 1] everywhere in X&#39;s support.  The following algorithm samples from a weighted distribution (see also (Devroye 1986, p. 47)[^4]):</p>

<ol>
<li>Generate a random variate that follows the distribution X. (Or generate a uniform PSRN that follows X.) Call the number <em>x</em>.</li>
<li>With probability <em>w</em>(<em>x</em>), return <em>x</em>.  Otherwise, go to step 1.</li>
</ol>

<p>Some weighted distributions allow any weight function <em>w</em>(<em>x</em>) whose values are nonnegative everywhere in X&#39;s support (Rao 1985)[^48].  (If <em>w</em>(<em>x</em>) = <em>x</em>, the distribution is often called a <em>length-biased</em> or <em>size-biased distribution</em>; if <em>w</em>(<em>x</em>) = <em>x</em><sup>2</sup>, <em>area-biased</em>.)  Their probability density functions (PDFs) are proportional to the original PDFs multiplied by <em>w</em>(<em>x</em>).</p>

<p><strong>Inflated distributions.</strong> To generate an <em>inflated X</em> (also called <em>c-inflated X</em> or <em>c-adjusted X</em>) random variate with parameters <em>c</em> and <em>&alpha;</em>, generate&mdash;</p>

<ul>
<li><em>c</em> with probability <em>&alpha;</em>, and</li>
<li>a random variate distributed as X otherwise.</li>
</ul>

<p>For example, a <em>zero-inflated beta</em> random variate is 0 with probability <em>&alpha;</em> and a beta random variate otherwise (the parameter <em>c</em> is 0) (Ospina and Ferrari 2010)[^49]  A zero-and-one inflated X distribution is 0 or 1 with probability <em>&alpha;</em> and distributed as X otherwise.  For example, to generate a <em>zero-and-one-inflated unit Lindley</em> random variate (with parameters <em>&alpha;</em>, <em>&theta;</em>, and <em>p</em>) (Chakraborty and Bhattacharjee 2021)[^50]:</p>

<ol>
<li>With probability <em>&alpha;</em>, return a number that is 0 with probability <em>p</em> and 1 otherwise.</li>
<li>Generate a unit Lindley(<em>&theta;</em>) random variate, that is, generate <em>x</em>/(1+<em>x</em>) where <em>x</em> is a <a href="https://peteroupc.github.io/exporand.html#Lindley_Distribution_and_Lindley_Like_Mixtures"><strong>Lindley(<em>&theta;</em>) random variate</strong></a>.</li>
</ol>

<blockquote>
<p><strong>Note:</strong> A zero-inflated X distribution where X takes on 0 with probability 0 is also called a <em>hurdle distribution</em> (Mullahy 1986)[^51].</p>
</blockquote>

<p><strong>Unit distributions.</strong> To generate a <em>unit X</em> random variate (where X is a distribution whose support is the positive real line), generate a random variate distributed as X, call it <em>x</em>, then return exp(&minus;<em>x</em>) or 1 &minus;exp(&minus;<em>x</em>) (also known as &quot;Type I&quot; or &quot;Type II&quot;, respectively).  For example, a unit gamma distribution is also known as the <em>Grassia distribution</em> (Grassia 1977)[^52].</p>

<p><strong>CDF&ndash;quantile family.</strong> Given two distributions X and Y (which can be the same), a location parameter <em>&mu;</em> &ge; 0, and a dispersion parameter <em>&sigma;</em>&gt;0, a variate from this family of distributions can be generated as follows (Smithson and Shou 2019)[^42]:</p>

<ol>
<li>Generate a random variate that follows the distribution X. (Or generate a uniform PSRN that follows X.) Call the number <em>x</em>.</li>
<li>If distribution X&#39;s support is the positive real line, calculate <em>x</em> as ln(<em>x</em>).</li>
<li>Calculate <em>z</em> as <em>&mu;</em>+<em>&sigma;</em>*<em>x</em>.</li>
<li>If distribution Y&#39;s support is the positive real line, calculate <em>z</em> as exp(<em>z</em>).</li>
<li>Return <em>H</em>(<em>z</em>).</li>
</ol>

<p>In this algorithm:</p>

<ul>
<li>X and Y are distributions that each have support on either the whole real line or the positive real line.  However, the book intends X to have an easy-to-compute quantile function.</li>
<li><em>H</em>(<em>z</em>) is Y&#39;s <em>cumulative distribution function</em>, or the probability that a Y-distributed random variate is <em>z</em> or less.  The book likewise intends <em>H</em> to be easy to compute.</li>
</ul>

<blockquote>
<p><strong>Note:</strong> An important property for use in statistical estimation is <em>identifiability</em>.  A family of distributions is <em>identifiable</em> if it has the property that if two parameter vectors (<em>&theta;</em><sub>1</sub> and <em>&theta;</em><sub>2</sub>) determine the same distribution, then <em>&theta;</em><sub>1</sub> must equal <em>&theta;</em><sub>2</sub>.</p>
</blockquote>

<p><a id=Certain_Distributions></a></p>

<h2>Certain Distributions</h2>

<p>In the table below, <em>U</em> is a uniform random variate between 0 and 1, and all random variates are independently generated.</p>

<table><thead>
<tr>
<th>This distribution:</th>
<th>Is distributed as:</th>
<th>And uses these parameters:</th>
</tr>
</thead><tbody>
<tr>
<td>Power function(<em>a</em>, <em>c</em>).</td>
<td><em>c</em>*<em>U</em><sup>1/<em>a</em></sup>.</td>
<td><em>a</em> &gt; 0, <em>c</em> &gt; 0.</td>
</tr>
<tr>
<td>Lehmann Weibull(<em>a1</em>, <em>a2</em>, <em>&beta;</em>) (Elgohari and Yousof 2020)[^53].</td>
<td>(ln(1/<em>U</em>)/<em>&beta;</em>)<sup>1/<em>a1</em></sup>/<em>a2</em> or (<em>E</em>/<em>&beta;</em>)<sup>1/<em>a1</em></sup>/<em>a2</em></td>
<td><em>a1</em>, <em>a2</em>, <em>&beta;</em> &gt; 0. <em>E</em> is an exponential random variate with rate 1.</td>
</tr>
<tr>
<td>Marshall&ndash;Olkin(<em>&alpha;</em>) (Marshall and Olkin 1997)[^54]</td>
<td>(1&minus;<em>U</em>)/(<em>U</em>*(<em>&alpha;</em>&minus;1) + 1).</td>
<td><em>&alpha;</em> in [0, 1].</td>
</tr>
<tr>
<td>Lomax(<em>&alpha;</em>).</td>
<td>(1&minus;<em>U</em>)<sup>&minus;1/<em>&alpha;</em></sup>&minus;1.</td>
<td><em>&alpha;</em> &gt; 0.</td>
</tr>
<tr>
<td>Power Lomax(<em>&alpha;</em>, <em>&beta;</em>) (Rady et al. 2016)[^55].</td>
<td><em>L</em><sup>1/<em>&beta;</em></sup></td>
<td><em>&beta;</em> &gt; 0; <em>L</em> is Lomax(<em>&alpha;</em>).</td>
</tr>
<tr>
<td>Topp&ndash;Leone(<em>&alpha;</em>).</td>
<td>1&minus;sqrt(1&minus;<em>U</em><sup>1/<em>&alpha;</em></sup>).</td>
<td><em>&alpha;</em> &gt; 0.</td>
</tr>
<tr>
<td>Bell&ndash;Touchard(<em>a</em>, <em>b</em>) (Castellares et al. 2020)[^56].</td>
<td>Sum of <em>N</em> zero-truncated Poisson(<em>a</em>) random variates, where <em>N</em> is Poisson with parameter <em>b</em>*exp(<em>a</em>)&minus;<em>b</em>.[^57]</td>
<td><em>a</em>&gt;0, <em>b</em>&gt;0.</td>
</tr>
<tr>
<td>Bell(<em>a</em>) (Castellares et al. 2020)[^56].</td>
<td>Bell&ndash;Touchard(<em>a</em>, 0).</td>
<td><em>a</em>&gt;0.</td>
</tr>
<tr>
<td>Discrete Pareto(<em>&delta;</em>, <em>p</em>) (Buddana and Kozubowski 2014)[^58]</td>
<td>1 plus the number of failures before the first success, with each success having probability 1&minus;exp(&minus;<em>Z</em>), where <em>Z</em> is a gamma(1/<em>&delta;</em>) variate times &minus;<em>&delta;</em>*ln(1&minus;<em>p</em>).</td>
<td><em>&delta;</em> &gt; 0, and 0&lt;<em>p</em>&lt;1.</td>
</tr>
<tr>
<td>Neyman type A(<em>&delta;</em>, <em>&tau;</em>) (Batsidis and Lemonte 2021)[^59]</td>
<td>Bell&ndash;Touchard(<em>&tau;</em>, <em>&delta;</em>*exp(&minus;<em>&tau;</em>)).</td>
<td><em>&delta;</em>&gt;0, <em>&tau;</em>&gt;0.</td>
</tr>
<tr>
<td>Gamma exponential (Kudryavtsev 2019)[^60].</td>
<td><em>&delta;</em>*Gamma(<em>t</em>)<sup>1/<em>&nu;</em></sup>/Gamma(<em>s</em>)<sup><em>r</em>/<em>&nu;</em></sup>, where Gamma(<em>x</em>) is a gamma(<em>x</em>) variate.</td>
<td>0 &le; <em>r</em> &lt; 1; <em>&nu;</em> &ne; 0; <em>s</em>&gt;0; <em>t</em>&gt;0; <em>&delta;</em>&gt;0.</td>
</tr>
<tr>
<td>Extended xgamma (Saha et al. 2019)[^61]</td>
<td>Gamma(<em>&alpha;</em> + <em>c</em>) variate divided by <em>&theta;</em>, where <em>c</em> is either 0 with probability <em>&theta;</em>/(<em>&theta;</em>+<em>&beta;</em>), or 2 otherwise.</td>
<td><em>&theta;</em>&gt;0, <em>&alpha;</em>&gt;0, <em>&beta;</em> &ge; 0.</td>
</tr>
<tr>
<td>Generalized Pareto(<em>a</em>, <em>b</em>) (McNeil et al. 2010)[^62]</td>
<td><em>a</em>*((1/(1&minus;<em>U</em>))<sup><em>b</em></sup>&minus;1)/<em>b</em>.</td>
<td><em>a</em>&gt;0; <em>b</em>&gt;0.</td>
</tr>
<tr>
<td>Skew symmetric or symmetry-modulated (Azzalini and Capitanio 2003)[^63], (Azzalini 2022)[^64].</td>
<td><em>Z</em> if <em>T</em> &le; <em>w</em>(<em>Z</em>), or &minus;<em>Z</em> otherwise.</td>
<td><em>Z</em> follows a symmetric distribution around 0; <em>T</em> follows a symmetric distribution (not necessarily around 0). <em>w</em>(<em>x</em>) satisfies &minus;<em>w</em>(<em>x</em>) = <em>w</em>(&minus;<em>x</em>).</td>
</tr>
<tr>
<td>Skew normal (Azzalini 1985)[^65].</td>
<td>Skew symmetric with <em>Z</em> and <em>T</em> both separate Normal(0, 1) variates, and <em>w</em>(<em>x</em>) = <em>x</em>*<em>&alpha;</em>.</td>
<td><em>&alpha;</em> is a real number.</td>
</tr>
<tr>
<td>Logarithmic skew normal (Gómez-Déniz et al. 2020)[^66]</td>
<td>exp(SNE(<em>&lambda;</em>,<em>&lambda;</em>)*<em>&sigma;</em>+<em>&mu;</em>).</td>
<td><em>&mu;</em> and <em>&lambda;</em> are real numbers; <em>&sigma;</em> &gt; 0. SNE is described later.</td>
</tr>
<tr>
<td>Tilted beta binomial (Hahn 2022)[^67]</td>
<td>Binomial(<em>n</em>, Tilted-beta(<em>&theta;</em>, <em>v</em>, <em>&alpha;</em>, <em>&beta;</em>)) variate.</td>
<td>0 &le; <em>&theta;</em> &le; 1;  0 &le; <em>v</em> &le; 1; <em>&alpha;</em>&gt;0, <em>&beta;</em>&gt;0; <em>n</em> &ge; 0 is an integer.</td>
</tr>
<tr>
<td>Two-piece distribution (Rubio and Steel 2020)[^68].</td>
<td><em>&mu;</em> &minus; abs(<em>Z</em>)*<em>sigma1</em> with probability <em>sigma1</em>/(<em>sigma1</em>+<em>sigma2</em>), or <em>&mu;</em> + abs(<em>Z</em>)*<em>sigma2</em> otherwise.</td>
<td><em>&mu;</em> is a real number; <em>sigma1</em>&gt;0; <em>sigma2</em>&gt;0; <em>Z</em> follows a symmetric distribution around 0.</td>
</tr>
<tr>
<td>Asymmetric generalized Gaussian (Tesei and Regazzoni 1996)[^69]</td>
<td>Two-piece distribution where <em>Z</em> is exponential-power(<em>&alpha;</em>).</td>
<td><em>&alpha;</em>&gt;0; <em>&mu;</em> is a real number; <em>sigma1</em>&gt;0; <em>sigma2</em>&gt;0.</td>
</tr>
</tbody></table>

<table><thead>
<tr>
<th>This distribution:</th>
<th>Can be sampled with the following algorithms:</th>
<th>And uses these parameters:</th>
</tr>
</thead><tbody>
<tr>
<td>Offset-symmetric Gaussian (Sadeghi and Korki 2021)[^70]</td>
<td>(1) Generate an unbiased random bit <em>b</em> (either 0 or 1 with equal probability); (2) generate <em>Y</em>, a Normal(0, <em>&sigma;</em>) random variate (standard deviation <em>&sigma;</em>), and if <em>Y</em> &lt; <em>m</em>, repeat this step; (3) return (<em>Y</em> &minus; <em>m</em>)*(<em>b</em>*2 &minus; 1).</td>
<td><em>m</em>&gt;0; <em>&sigma;</em>&gt;0.</td>
</tr>
<tr>
<td>Generalized skew normal (SNE(<em>&lambda;</em>,<em>&xi;</em>)) (Henze 1986)[^71]</td>
<td><strong>First algorithm:</strong> (1) Generate <em>Y</em> and <em>Z</em>, two Normal(0,1) variates; (2) if <em>Z</em>&lt;<em>Y</em>*<em>&lambda;</em>+<em>&xi;</em>, return <em>Y</em>; else go to 1. <strong>Second algorithm:</strong> (1) Let <em>il</em>=1/sqrt(1+<em>&lambda;</em><sup>2</sup>); (2) Generate <em>Y</em> and <em>Z</em>, two Normal(0,1) variates; (3) if <em>Y</em>&gt;&minus;<em>&xi;</em>*<em>il</em>, return <em>Y</em>*<em>&lambda;</em>*<em>il</em> + <em>Z</em>; else go to 2.</td>
<td><em>&lambda;</em> and <em>&xi;</em> are real numbers.</td>
</tr>
<tr>
<td>Generalized geometric (Francis-Staite and White 2022)[^72]</td>
<td>(1) Set <em>ret</em> to 1; (2) with probability <em>&rho;</em>(<em>ret</em>), add 1 to <em>ret</em> and repeat this step; otherwise, return <em>ret</em>.</td>
<td>0 &le; <em>&rho;</em>(<em>k</em>) &le; 1 for each <em>k</em>.</td>
</tr>
<tr>
<td>Generalized Sibuya (Kozubowski and Podgórski 2018)[^73]</td>
<td>(1) Set <em>ret</em> to 1; (2) with probability <em>&alpha;</em>/(<em>&nu;</em>+<em>ret</em>), return <em>ret</em>; otherwise, add 1 to <em>ret</em> and repeat this step.</td>
<td><em>&alpha;</em> &lt; <em>&nu;</em> + 1, and <em>&nu;</em> &ge; 0.[^74]</td>
</tr>
<tr>
<td>Himanshu (Agarwal and Pandey 2022)[^75]</td>
<td>(1) Set <em>ret</em> to 0; (2) flip coin that shows heads with probability <em>p</em>, <em>n</em> times; (3) if any flip shows 0 (tails), add 1 to <em>ret</em> and go to 2; otherwise, return <em>ret</em>.</td>
<td>0 &le; <em>p</em> &le; 1; <em>n</em> &ge; 1 is an integer.</td>
</tr>
<tr>
<td>Tilted beta (Hahn and López Martín 2005)[^76]</td>
<td>(1) With probability <em>&theta;</em>, return a beta(<em>&alpha;</em>, <em>&beta;</em>) variate; (2) Generate a uniform variate in (0, 1), call it <em>x</em>; (3) Flip coin that returns 1 with probability <em>x</em>, and another that returns 1 with probability <em>v</em>; (4) If both coins return 1 or both return 0, return <em>x</em>; otherwise go to step 2.</td>
<td>0 &le; <em>&theta;</em> &le; 1;  0 &le; <em>v</em> &le; 1; <em>&alpha;</em>&gt;0; <em>&beta;</em>&gt;0.</td>
</tr>
</tbody></table>

<p><a id=Random_Variate_Generation_via_Quantiles></a></p>

<h2>Random Variate Generation via Quantiles</h2>

<p>This note is about generating random variates from a non-discrete distribution via <em>inverse transform sampling</em>, using uniform <a href="https://peteroupc.github.io/exporand.html"><strong>partially-sampled random numbers (PSRNs)</strong></a>.</p>

<p>In this section:</p>

<ul>
<li>A distribution&#39;s <em>quantile function</em> (also known as <em>inverse cumulative distribution function</em> or <em>inverse CDF</em>) is a nowhere decreasing function that maps uniform random variates greater than 0 and less than 1 to numbers that follow the distribution.</li>
<li>A <em>uniform PSRN</em> is ultimately a number that lies in an interval; it contains a sign, an integer part, and a fractional part made up of digits sampled on demand.</li>
</ul>

<p>Take the following situation:</p>

<ul>
<li>Let <em>f</em>(.) be a function applied to <em>a</em> or <em>b</em> before calculating the quantile.</li>
<li>Let <em>Q</em>(<em>z</em>) be the quantile function for the desired distribution.</li>
<li>Let <em>x</em> be a random variate in the form of a uniform PSRN, so that this PSRN will lie in the interval [<em>a</em>, <em>b</em>].  If <em>f</em>(<em>t</em>) = <em>t</em> (the identity function), the PSRN <em>x</em> must have a positive sign and an integer part of 0, so that the interval [<em>a</em>, <em>b</em>] is either the interval [0, 1] or a closed interval in [0, 1], depending on the PSRN&#39;s fractional part.  For example, if the PSRN is 2.147..., then the interval is [2.147, 2.148].</li>
<li>Let <em>&beta;</em> be the digit base of digits in <em>x</em>&#39;s fractional part (such as 2 for binary).</li>
<li>Suppose <em>Q</em>(<em>z</em>) is continuous on the open interval (<em>a</em>, <em>b</em>).</li>
</ul>

<p>Then the following algorithm transforms that number to a random variate for the desired distribution, which comes within the desired error tolerance of <em>&epsilon;</em> with probability 1 (see (Devroye and Gravel 2020)[^77]):</p>

<ol>
<li>Generate additional digits of <em>x</em> uniformly at random&mdash;thus shortening the interval [<em>a</em>, <em>b</em>]&mdash;until a lower bound of <em>Q</em>(<em>f</em>(<em>a</em>)) and an upper bound of <em>Q</em>(<em>f</em>(<em>b</em>)) differ by no more than 2*<em>&epsilon;</em>.  Call the two bounds <em>low</em> and <em>high</em>, respectively.</li>
<li>Return <em>low</em>+(<em>high</em>&minus;<em>low</em>)/2.</li>
</ol>

<p>In some cases, it may be possible to calculate the needed digit size in advance.</p>

<p>As one example, if <em>f</em>(<em>t</em>) = <em>t</em> (the identity function) and the quantile function is <em>Lipschitz continuous</em> with Lipschitz constant <em>L</em> or less on the interval [<em>a</em>, <em>b</em>][^78], then the following algorithm generates a quantile with error tolerance <em>&epsilon;</em>:</p>

<ol>
<li>Let <em>d</em> be ceil((ln(max(1,<em>L</em>)) &minus; ln(<em>&epsilon;</em>)) / ln(<em>&beta;</em>)). For each digit among the first <em>d</em> digits in <em>x</em>&#39;s fractional part, if that digit is unsampled, set it to a digit chosen uniformly at random.</li>
<li>The PSRN <em>x</em> now lies in the interval [<em>a</em>, <em>b</em>].  Calculate lower and upper bounds of <em>Q</em>(<em>a</em>) and <em>Q</em>(<em>b</em>), respectively, that are within <em>&epsilon;</em>/2 of the true quantiles, call the bounds <em>low</em> and <em>high</em>, respectively.</li>
<li>Return <em>low</em>+(<em>high</em>&minus;<em>low</em>)/2.</li>
</ol>

<p>This algorithm chooses a random interval of size equal to <em>&beta;</em><sup><em>d</em></sup>, and because the quantile function is Lipschitz continuous, the values at the interval&#39;s bounds are guaranteed to vary by no more than 2*<em>&epsilon;</em> (actually <em>&epsilon;</em>, but the calculation in step 2 adds an additional error of at most <em>&epsilon;</em>), which is needed to meet the tolerance <em>&epsilon;</em> (see also Devroye and Gravel 2020[^77]).</p>

<p>A similar algorithm can exist even if the quantile function <em>Q</em> is not Lipschitz continuous on the interval [<em>a</em>, <em>b</em>].</p>

<p>Specifically, if&mdash;</p>

<ul>
<li><em>f</em>(<em>t</em>) = <em>t</em> (the identity function),</li>
<li><em>Q</em> on the interval [<em>a</em>, <em>b</em>] is continuous and has a minimum and maximum, and</li>
<li><em>Q</em> on [<em>a</em>, <em>b</em>] admits a continuous and strictly increasing function <em>&omega;</em>(<em>&delta;</em>) as a <em>modulus of continuity</em>,</li>
</ul>

<p>then <em>d</em> in step 1 above can be calculated as&mdash;<br/>&nbsp;&nbsp;max(0, ceil(&minus;ln(<em>&omega;</em><sup>&minus;1</sup>(<em>&epsilon;</em>))/ln(<em>&beta;</em>))),<br/>where <em>&omega;</em><sup>&minus;1</sup>(<em>&epsilon;</em>) is the inverse of the modulus of continuity.  (Loosely speaking, a modulus of continuity <em>&omega;</em>(<em>&delta;</em>) gives the quantile function&#39;s maximum-minus-minimum in a window of size <em>&delta;</em>, and the inverse modulus <em>&omega;</em><sup>&minus;1</sup>(<em>&epsilon;</em>) finds a window small enough that the quantile function differs by no more than <em>&epsilon;</em> in the window.[^79]).[^80]</p>

<p>For example&mdash;</p>

<ul>
<li>if <em>Q</em> is Lipschitz continuous[^78] with Lipschitz constant <em>L</em> or less on [<em>a</em>, <em>b</em>], then the function is no &quot;steeper&quot; than that of <em>&omega;</em>(<em>&delta;</em>) = <em>L</em>*<em>&delta;</em>, so <em>&omega;</em><sup>&minus;1</sup>(<em>&epsilon;</em>) = <em>&epsilon;</em>/<em>L</em>, and</li>
<li>if <em>Q</em> is Hölder continuous with Hölder constant <em>M</em> or less and Hölder exponent <em>&alpha;</em> on that interval [^81], then the function is no &quot;steeper&quot; than that of <em>&omega;</em>(<em>&delta;</em>) = <em>M</em>*<em>&delta;</em><sup><em>&alpha;</em></sup>, so <em>&omega;</em><sup>&minus;1</sup>(<em>&epsilon;</em>) = (<em>&epsilon;</em>/<em>M</em>)<sup>1/<em>&alpha;</em></sup>.</li>
</ul>

<p>The algorithms given earlier in this section have a disadvantage: the desired error tolerance has to be made known to the algorithm in advance. (Indeed, for this reason, the algorithms don&#39;t satisfy <a href="https://peteroupc.github.io/exporand.html#Properties"><strong>desirable properties for PSRN samplers</strong></a>.)  To generate a quantile to any error tolerance (even if the tolerance is not known in advance), a rejection sampling approach is needed.  For this to work:</p>

<ul>
<li>The target distribution must have a probability density function (PDF), as is the case with the normal and exponential distributions.</li>
<li>That PDF, or a function proportional to it, must be known, must be less than or equal to a finite number, and must be continuous &quot;almost everywhere&quot; (the set of discontinuous points is &quot;zero-volume&quot;, that is, has Lebesgue measure zero) (see also (Devroye and Gravel 2020)[^77]).</li>
</ul>

<p>Here is a sketch of how this rejection sampler might work:</p>

<ol>
<li>After using one of the algorithms given earlier in this section to sample digits of <em>x</em> as needed, let <em>a</em> and <em>b</em> be <em>x</em>&#39;s upper and lower bounds.  Calculate lower and upper bounds of the quantiles of <em>f</em>(<em>a</em>) and <em>f</em>(<em>b</em>) (the bounds are [<em>alow</em>, <em>ahigh</em>] and [<em>blow</em>, <em>bhigh</em>] respectively).</li>
<li>Given the target function&#39;s PDF or a function proportional to it, sample a uniform PSRN, <em>y</em>, in the interval [<em>alow</em>, <em>bhigh</em>] using an arbitrary-precision rejection sampler such as Oberhoff&#39;s method (described in an <a href="https://peteroupc.github.io/exporand.html#Oberhoff_s_Exact_Rejection_Sampling_Method"><strong>appendix to the PSRN article</strong></a>).</li>
<li>Accept <em>y</em> (and return it) if it clearly lies in [<em>ahigh</em>, <em>blow</em>].  Reject <em>y</em> (and go to the previous step) if it clearly lies outside [<em>alow</em>, <em>bhigh</em>].  If <em>y</em> clearly lies in [<em>alow</em>, <em>ahigh</em>] or in [<em>blow</em>, <em>bhigh</em>], generate more digits of <em>x</em>, uniformly at random, and go to the first step.</li>
<li>If <em>y</em> doesn&#39;t clearly fall in any of the cases in the previous step, generate more digits of <em>y</em>, uniformly at random, and go to the previous step.</li>
</ol>

<p><a id=Batching_Random_Samples_via_Randomness_Extraction></a></p>

<h2>Batching Random Samples via Randomness Extraction</h2>

<p>Devroye and Gravel (2020)[^77] suggest the following randomness extractor to reduce the number of random bits needed to produce a batch of samples by a sampling algorithm.  The extractor works based on the probability that the algorithm consumes <em>X</em> random bits given that it produces a specific output <em>Y</em> (or <em>P</em>(<em>X</em> | <em>Y</em>) for short):</p>

<ol>
<li>Start with the interval [0, 1].</li>
<li>For each pair (<em>X</em>, <em>Y</em>) in the batch, the interval shrinks from below by <em>P</em>(<em>X</em>&minus;1 | <em>Y</em>) and from above by <em>P</em>(<em>X</em> | <em>Y</em>). (For example, if [0.2, 0.8] (range 0.6) shrinks from below by 0.1 and from above by 0.8, the new interval is [0.2+0.1*0.6, 0.2+0.8*0.6] = [0.26, 0.68].  For correctness, though, the interval is not allowed to shrink to a single point, since otherwise step 3 would run forever.)</li>
<li>Extract the bits, starting from the binary point, that the final interval&#39;s lower and upper bound have in common (or 0 bits if the upper bound is 1). (For example, if the final interval is [0.101010..., 0.101110...] in binary, the bits 1, 0, 1 are extracted, since the common bits starting from the point are 101.)</li>
</ol>

<p>After a sampling method produces an output <em>Y</em>, both <em>X</em> (the number of random bits the sampler consumed) and <em>Y</em> (the output) are added to the batch and fed to the extractor, and new bits extracted this way are added to a queue for the sampling method to use to produce future outputs. (Notice that the number of bits extracted by the algorithm above grows as the batch grows, so only the new bits extracted this way are added to the queue this way.)</p>

<p>The issue of finding <em>P</em>(<em>X</em> | <em>Y</em>) is now discussed.  Generally, if the sampling method implements a random walk on a binary tree that is driven by unbiased random bits and has leaves labeled with one outcome each (Knuth and Yao 1976)[^82], <em>P</em>(<em>X</em> | <em>Y</em>) is found as follows (and Claude Gravel clarified to me that this is the intention of the extractor algorithm): Take a weighted count of all leaves labeled <em>Y</em> up to depth <em>X</em> (where the weight for depth <em>z</em> is 1/2<sup><em>z</em></sup>), then divide it by a weighted count of all leaves labeled <em>Y</em> at all depths (for instance, if the tree has two leaves labeled <em>Y</em> at <em>z</em>=2, three at <em>z</em>=3, and three at <em>z</em>=4, and <em>X</em> is 3, then <em>P</em>(<em>X</em> | <em>Y</em>) is (2/2<sup>2</sup>+3/2<sup>3</sup>) / (2/2<sup>2</sup>+3/2<sup>3</sup>+3/2<sup>4</sup>)).  In the special case where the tree has at most 1 leaf labeled <em>Y</em> at every depth, this is implemented by finding <em>P</em>(<em>Y</em>), or the probability to output <em>Y</em>, then chopping <em>P</em>(<em>Y</em>) up to the <em>X</em><sup>th</sup> binary digit after the point and dividing by the original <em>P</em>(<em>Y</em>) (for instance, if <em>X</em> is 4 and P(<em>Y</em>) is 0.101011..., then <em>P</em>(<em>X</em> | <em>Y</em>) is 0.1010 / 0.101011...).</p>

<p>Unfortunately, <em>P</em>(<em>X</em> | <em>Y</em>) is not easy to calculate when the number of values <em>Y</em> can take on is large or even unbounded.  In this case, I can suggest the following ad hoc algorithm, which uses a randomness extractor that takes <em>bits</em> as input, such as the von Neumann, Peres, or Zhou&ndash;Bruck extractor (see &quot;<a href="https://peteroupc.github.io/randextract.html"><strong>Notes on Randomness Extraction</strong></a>&quot;).  The algorithm counts the number of bits it consumes (<em>X</em>) to produce an output, then feeds <em>X</em> to the extractor as follows.</p>

<ol>
<li>Let <em>z</em> be abs(<em>X</em>&minus;<em>lastX</em>), where <em>lastX</em> is either the last value of <em>X</em> fed to this extractor for this batch or 0 if there is no such value.</li>
<li>If <em>z</em> is greater than 0, feed the bits of <em>z</em> from most significant to least significant to a queue of extractor inputs.</li>
<li>Now, when the sampler consumes a random bit, it checks the input queue.  As long as 64 bits or more are in the input queue, the sampler dequeues 64 bits from it, runs the extractor on those bits, and adds the extracted bits to an output queue. (The number 64 can instead be any even number greater than 2.)  Then, if the output queue is not empty, the sampler dequeues a bit from that queue and uses that bit; otherwise it generates an unbiased random bit as usual.</li>
</ol>

<p><a id=Sampling_Distributions_Using_Incomplete_Information></a></p>

<h2>Sampling Distributions Using Incomplete Information</h2>

<p>The Bernoulli factory problem (the problem of turning one biased coin into another biased coin; see &quot;<a href="https://peteroupc.github.io/bernoulli.html"><strong>Bernoulli Factory Algorithms</strong></a>&quot;) is a special case of the problem of <strong>sampling a probability distribution with unknown parameters</strong>.  This problem can be described as sampling from a new distribution using an <em>oracle</em> (black box) that produces numbers of an incompletely known distribution. In the Bernoulli factory problem, this oracle is a <em>coin that shows heads or tails where the probability of heads is unknown</em>.  The rest of this section deals with oracles that go beyond coins.</p>

<p><strong>Algorithm 1.</strong> Suppose there is an oracle that produces independent random variates on a closed interval [<em>a</em>, <em>b</em>], and these numbers have an unknown mean of <em>&mu;</em>. The goal is now to produce nonnegative random variates whose expected value (&quot;long-run average&quot;) is <em>f</em>(<em>&mu;</em>).  Unless <em>f</em> is constant, this is possible if and only if&mdash;</p>

<ul>
<li><em>f</em> is continuous on the closed interval, and</li>
<li><em>f</em>(<em>&mu;</em>) is greater than or equal to <em>&epsilon;</em>*min((<em>&mu;</em> &minus; <em>a</em>)<sup><em>n</em></sup>, (<em>b</em> &minus; <em>&mu;</em>)<sup><em>n</em></sup>) for some integer <em>n</em> and some <em>&epsilon;</em> greater than 0 (loosely speaking, <em>f</em> is nonnegative and neither touches 0 in the interior of the interval nor moves away from 0 more slowly than a polynomial)</li>
</ul>

<p>(Jacob and Thiery 2015)[^83]. (Here, <em>a</em> and <em>b</em> are both rational numbers and may be less than 0.)</p>

<p>In the algorithm below, let <em>K</em> be a rational number greater than the maximum value of <em>f</em> on the closed interval [<em>a</em>, <em>b</em>], and let <em>g</em>(<em>&lambda;</em>) = <em>f</em>(<em>a</em> + (<em>b</em>&minus;<em>a</em>)*<em>&lambda;</em>)/<em>K</em>.</p>

<ol>
<li>Create a <em>&lambda;</em> input coin that does the following: &quot;Take a number from the oracle, call it <em>x</em>.  With probability (<em>x</em>&minus;<em>a</em>)/(<em>b</em>&minus;<em>a</em>) (see note below), return 1.  Otherwise, return 0.&quot;</li>
<li>Run a Bernoulli factory algorithm for <em>g</em>(<em>&lambda;</em>), using the <em>&lambda;</em> input coin.  Then return <em>K</em> times the result.</li>
</ol>

<blockquote>
<p><strong>Note:</strong> The check &quot;With probability (<em>x</em>&minus;<em>a</em>)/(<em>b</em>&minus;<em>a</em>)&quot; is exact if the oracle produces only rational numbers.  Otherwise, calculating the probability can lead to numerical errors unless care is taken (see note 2 in &quot;Distributions with nowhere increasing or nowhere decreasing weights&quot;, above).  With uniform partially-sampled random numbers (PSRNs), the check can be implemented as follows.  Let <em>x</em> be a uniform PSRN representing a number generated by the oracle.  Set <em>y</em> to <strong>RandUniformFromReal</strong>(<em>b</em>&minus;<em>a</em>), then the check succeeds if <strong>RandLess</strong>(<em>y</em>, <strong>UniformAddRational</strong>(<em>x</em>, &minus;<em>a</em>)) returns 1, and fails otherwise.</p>

<p><strong>Example:</strong> Suppose an oracle produces random variates in the interval [3, 13] with unknown mean <em>&mu;</em>, and the goal is to use the oracle to produce nonnegative random variates with mean <em>f</em>(<em>&mu;</em>) = &minus;319/100 + <em>&mu;</em>*103/50 &minus; <em>&mu;</em><sup>2</sup>*11/100, which is a polynomial with Bernstein coefficients [2, 9, 5] in the given interval.  Then since 8 is greater than the maximum of <em>f</em> in that interval, <em>g</em>(<em>&lambda;</em>) is a degree-2 polynomial in the interval [0, 1] that has Bernstein coefficients [2/8, 9/8, 5/8].  <em>g</em> can&#39;t be simulated as is, though, but increasing <em>g</em>&#39;s degree to 3 leads to the Bernstein coefficients [1/4, 5/6, 23/24, 5/8], which are all less than 1 so that the following algorithm can be used (see &quot;<a href="https://peteroupc.github.io/bernoulli.html#Certain_Polynomials"><strong>Certain Polynomials</strong></a>&quot;):</p>

<ol>
<li>Set <em>heads</em> to 0.</li>
<li>Generate three random variates from the oracle (which must produce random variates in the interval [3, 13]).  For each number <em>x</em>: With probability (<em>x</em>&minus;3)/(10&minus;3), add 1 to <em>heads</em>.</li>
<li>Depending on <em>heads</em>, return 8 (that is, 1 times the upper bound) with the given probability, or 0 otherwise: <em>heads</em>=0 &rarr; probability 1/4; 1 &rarr; 5/6; 2 &rarr; 23/24; 3 &rarr; 5/8.</li>
</ol>
</blockquote>

<p><strong>Algorithm 2.</strong> Say there is an oracle in the form of a fair die.  The number of faces of the die, <em>n</em>, is at least 2 but otherwise unknown. Each face shows a different integer 0 or greater and less than <em>n</em>.  The question arises: Which probability distributions based on the number of faces can be sampled with this oracle?  This question was studied in the French-language dissertation of R. Duvignau (2015, section 5.2)[^84], and the following are four of these distributions.</p>

<p><strong><em>Bernoulli 1/n.</em></strong> It&#39;s trivial to generate a Bernoulli variate that is 1 with probability 1/<em>n</em> and 0 otherwise: just take a number from the oracle and return either 1 if that number is 0, or 0 otherwise.  Alternatively, take two numbers from the oracle and return either 1 if both are the same, or 0 otherwise (Duvignau 2015, p. 153)[^84].</p>

<p><strong><em>Random variate with mean n.</em></strong> Likewise, it&#39;s trivial to generate variates with a mean of <em>n</em>: Do &quot;Bernoulli 1/n&quot; trials as described above until a trial returns 0, then return the number of trials done this way.  (This is related to the ambiguously defined &quot;geometric&quot; random variates.)</p>

<p><strong><em>Binomial with parameters n and 1/n.</em></strong> Using the oracle, the following algorithm generates a binomial variate of this kind (Duvignau 2015, Algorithm 20)[^84]:</p>

<ol>
<li>Take items from the oracle until the same item is taken twice.</li>
<li>Create a list consisting of the items taken in step 1, except for the last item taken, then shuffle that list.</li>
<li>In the shuffled list, count the number of items that didn&#39;t change position after being shuffled, then return that number.</li>
</ol>

<p><strong><em>Binomial with parameters n and k/n.</em></strong> Duvignau 2015 also includes an algorithm (Algorithm 25) to generate a binomial variate of this kind using the oracle (where <em>k</em> is a known integer such that 0 &lt; <em>k</em> and <em>k</em> &le; <em>n</em>):</p>

<ol>
<li>Take items from the oracle until <em>k</em> different items were taken this way.  Let <em>U</em> be a list of these <em>k</em> items, in the order in which they were first taken.</li>
<li>Create an empty list <em>L</em>.</li>
<li>For each integer <em>i</em> satisfying 0 &le; <em>i</em> &lt; <em>k</em>:

<ol>
<li>Create an empty list <em>M</em>.</li>
<li>Take an item from the oracle.  If the item is in <em>U</em> at a position <strong>less than <em>i</em></strong> (positions start at 0), repeat this substep.  Otherwise, if the item is not in <em>M</em>, add it to <em>M</em> and repeat this substep.  Otherwise, go to the next substep.</li>
<li>Shuffle the list <em>M</em>, then add to <em>L</em> each item that didn&#39;t change position after being shuffled (if not already present in <em>L</em>).</li>
</ol></li>
<li>For each integer <em>i</em> satisfying 0 &le; <em>i</em> &lt; <em>k</em>:

<ol>
<li>Let <em>P</em> be the item at position <em>i</em> in <em>U</em>.</li>
<li>Take an item from the oracle.  If the item is in <em>U</em> at position <strong><em>i</em> or less</strong> (positions start at 0), repeat this substep.</li>
<li>If the last item taken in the previous substep is in <em>U</em> at a position <strong>greater than <em>i</em></strong>, add <em>P</em> to <em>L</em> (if not already present).</li>
</ol></li>
<li>Return the number of items in <em>L</em>.</li>
</ol>

<blockquote>
<p><strong>Note:</strong> Duvignau proved a result (Theorem 5.2) that answers the question: Which probability distributions based on the unknown <em>n</em> can be sampled with the oracle?[^85] The result applies to a family of (discrete) distributions with the same unknown parameter <em>n</em>, starting with either 1 or a greater integer.  Let Supp(<em>m</em>) be the set of values taken on by the distribution with parameter equal to <em>m</em>.  Then that family can be sampled using the oracle (with or without additional randomness) if and only if:</p>

<ul>
<li>There is a computable function <em>f</em>(<em>k</em>) that outputs a positive number.</li>
<li>For each <em>n</em>, Supp(<em>n</em>) is included in Supp(<em>n</em>+1).</li>
<li>For every <em>k</em> and for every <em>n</em> &ge; 2 starting with the first <em>n</em> for which <em>k</em> is in Supp(<em>n</em>), the probability of seeing <em>k</em> given parameter <em>n</em> is at least (1/<em>n</em>)<sup><em>f</em>(<em>k</em>)</sup>.</li>
</ul>

<p>Moreover, by Proposition 5.5 of Duvignau, a family meeting the conditions above can be sampled without additional randomness (besides the oracle) if and only if Supp(1) has no more than one element.</p>

<p><strong>Example:</strong> Let <em>n</em>&ge; 2 be an integer.<br>The family of Bernoulli distributions, taking on 1 with probability exp(&minus;<em>n</em>) and 0 otherwise, cannot be simulated this way, because that probability decays faster than the rate (1/<em>n</em>)<sup><em>f</em>(1)</sup> for any <em>f</em>.  This is consistent with the results for <em>Bernoulli factories</em> (Keane and O&#39;Brien 1994)[^86], where a coin that shows heads with unknown probability <em>&lambda;</em> = 1/<em>n</em> cannot be turned into a coin that shows heads with probability g(<em>&lambda;</em>) = exp(&minus;1/<em>&lambda;</em>) = exp(&minus;<em>n</em>) since <em>g</em> is not polynomially bounded (away from 0).<br>However, a Bernoulli family, taking on 1 with probability <em>h</em>(<em>n</em>) = (1+ln(<em>n</em>))/<em>n</em> and 0 with probability 1&minus;<em>h</em>(<em>n</em>), <em>can</em> be simulated, because min(<em>h</em>(<em>n</em>), 1&minus;<em>h</em>(<em>n</em>)) &ge; (1/<em>n</em>)<sup>3</sup>.</p>
</blockquote>

<p><a id=Additional_Algorithms></a></p>

<h3>Additional Algorithms</h3>

<p>The following algorithms are included here because they require applying an arbitrary function (such as <em>f</em>(<em>&lambda;</em>)) to a potentially irrational number.</p>

<p><strong>Algorithm 3.</strong> Suppose there is an <em>oracle</em> that produces independent random real numbers whose expected value (&quot;long-run average&quot;) is a known or unknown mean. The goal is now to produce nonnegative random variates whose expected value is the mean of <em>f</em>(<em>X</em>), where <em>X</em> is a number produced by the oracle.  This is possible whenever&mdash;</p>

<ul>
<li><em>f</em> has a finite lower bound and a finite upper bound on its domain, and</li>
<li>the mean of <em>f</em>(<em>X</em>) is not less than <em>&delta;</em>, where <em>&delta;</em> is a known rational number greater than 0.</li>
</ul>

<p>The algorithm to achieve this goal follows (see Lee et al. 2014[^87]):</p>

<ol>
<li>Let <em>m</em> be a rational number equal to or greater than the maximum value of abs(<em>f</em>(<em>&mu;</em>)) anywhere.  Create a <em>&nu;</em> input coin that does the following: &quot;Take a number from the oracle, call it <em>x</em>.  With probability abs(<em>f</em>(<em>x</em>))/<em>m</em>, return a number that is 1 if <em>f</em>(<em>x</em>) &lt; 0 and 0 otherwise.  Otherwise, repeat this process.&quot;</li>
<li>Use one of the <a href="https://peteroupc.github.io/bernoulli.html#lambda____x___y__linear_Bernoulli_factories"><strong>linear Bernoulli factories</strong></a> to simulate 2*<em>&nu;</em> (2 times the <em>&nu;</em> coin&#39;s probability of heads), using the <em>&nu;</em> input coin, with <em>&#x03F5;</em> = <em>&delta;</em>/<em>m</em>.  If the factory returns 1, return 0.  Otherwise, take a number from the oracle, call it <em>&xi;</em>, and return abs(<em>f</em>(<em>&xi;</em>)).</li>
</ol>

<blockquote>
<p><strong>Example:</strong> An example from Lee et al. (2014)[^87].  Say the oracle produces uniform random variates in [0, 3*<em>&pi;</em>], and let <em>f</em>(<em>&nu;</em>) = sin(<em>&nu;</em>).  Then the mean of <em>f</em>(<em>X</em>) is 2/(3*<em>&pi;</em>), which is greater than 0 and found in SymPy by <code>sympy.stats.E(sin(sympy.stats.Uniform(&#39;U&#39;,0,3*pi)))</code>, so the algorithm can produce nonnegative random variates whose expected value (&quot;long-run average&quot;) is that mean.</p>

<p><strong>Notes:</strong></p>

<ol>
<li>Averaging to the mean of <em>f</em>(<em>X</em>) (that is, <strong>E</strong>[<em>f</em>(<em>X</em>)] where <strong>E</strong>[.] means expected value or &quot;long-run average&quot;) is not the same as averaging to <em>f</em>(<em>&mu;</em>) where <em>&mu;</em> is the mean of the oracle&#39;s numbers (that is, <em>f</em>(<strong>E</strong>[<em>X</em>])).  For example, if <em>X</em> is 0 or 1 with equal probability, and <em>f</em>(<em>&nu;</em>) = exp(&minus;<em>&nu;</em>), then <strong>E</strong>[<em>f</em>(<em>X</em>)] = exp(0) + (exp(&minus;1) &minus; exp(0))*(1/2), and <em>f</em>(<strong>E</strong>[<em>X</em>]) = <em>f</em>(1/2) = exp(&minus;1/2).</li>
<li><p>(Lee et al. 2014, Corollary 4)[^87]: If <em>f</em>(<em>&mu;</em>) is known to return only values in the interval [<em>a</em>, <em>c</em>], the mean of <em>f</em>(<em>X</em>) is not less than <em>&delta;</em>, <em>&delta;</em> &gt; <em>b</em>, and <em>&delta;</em> and <em>b</em> are known numbers, then Algorithm 2 can be modified as follows:</p>

<ul>
<li>Use <em>f</em>(<em>&nu;</em>) = <em>f</em>(<em>&nu;</em>) &minus; <em>b</em>, and use <em>&delta;</em> = <em>&delta;</em> &minus; <em>b</em>.</li>
<li><em>m</em> is taken as max(<em>b</em>&minus;<em>a</em>, <em>c</em>&minus;<em>b</em>).</li>
<li>When Algorithm 2 finishes, add <em>b</em> to its return value.</li>
</ul></li>
<li>The check &quot;With probability abs(<em>f</em>(<em>x</em>))/<em>m</em>&quot; is exact if the oracle produces only rational numbers <em>and</em> if <em>f</em>(<em>x</em>) outputs only rational numbers.  If the oracle or <em>f</em> can produce irrational numbers (such as numbers that follow a beta distribution or another non-discrete distribution), then calculating the probability can lead to numerical errors unless care is taken (see note 2 in &quot;Distributions with nowhere increasing or nowhere decreasing weights&quot;, above).</li>
</ol>
</blockquote>

<p><strong>Algorithm 4.</strong> Suppose there is an <em>oracle</em> that produces independent random real numbers that are all greater than or equal to <em>a</em> (which is a known rational number), whose mean (<em>&mu;</em>) is unknown.  The goal is to use the oracle to produce nonnegative random variates with mean <em>f</em>(<em>&mu;</em>).  This is possible only if <em>f</em> is 0 or greater everywhere in the interval [<em>a</em>, <em>&infin;</em>) and is nowhere decreasing in that interval (Jacob and Thiery 2015)[^83].  This can be done using the algorithm below.  In the algorithm:</p>

<ul>
<li><em>f</em>(<em>&mu;</em>) must be a function that can be written as&mdash;<br><em>c</em>[0]*<em>z</em><sup>0</sup> + <em>c</em>[1]*<em>z</em><sup>1</sup> + ...,<br>which is an infinite series where <em>z</em> = <em>&mu;</em>&minus;<em>a</em> and all <em>c</em>[<em>i</em>] are 0 or greater.</li>
<li><em>&psi;</em> is a rational number close to 1, such as 95/100.  (The exact choice is arbitrary and can be less or greater for efficiency purposes, but must be greater than 0 and less than 1.)</li>
</ul>

<p>The algorithm follows.</p>

<ol>
<li>Set <em>ret</em> to 0, <em>prod</em> to 1, <em>k</em> to 0, and <em>w</em> to 1. (<em>w</em> is the probability of taking <em>k</em> or more numbers from the oracle in a single run of the algorithm.)</li>
<li>If <em>k</em> is greater than 0: Take a number from the oracle, call it <em>x</em>, and multiply <em>prod</em> by <em>x</em>&minus;<em>a</em>.</li>
<li>Add <em>c</em>[<em>k</em>]*<em>prod</em>/<em>w</em> to <em>ret</em>.</li>
<li>Multiply <em>w</em> by <em>&psi;</em> and add 1 to <em>k</em>.</li>
<li>With probability <em>&psi;</em>, go to step 2.  Otherwise, return <em>ret</em>.</li>
</ol>

<p>Now, assume the oracle&#39;s numbers are all less than or equal to <em>b</em> (rather than greater than or equal to <em>a</em>), where <em>b</em> is a known rational number.  Then <em>f</em> must be 0 or greater everywhere in (&minus;<em>&infin;</em>, <em>b</em>] and be nowhere increasing there (Jacob and Thiery 2015)[^83], and the algorithm above can be used with the following modifications: (1) In the note on the infinite series, <em>z</em> = <em>b</em> &minus;<em>&mu;</em>; (2) in step 2, multiply <em>prod</em> by <em>b</em> &minus; <em>x</em> rather than <em>x</em> &minus; <em>a</em>.</p>

<blockquote>
<p><strong>Note:</strong> This algorithm is exact if the oracle produces only rational numbers <em>and</em> if all <em>c</em>[<em>i</em>] are rational numbers.  Otherwise, the algorithm can introduce numerical errors unless care is taken (see note 2 in &quot;Distributions with nowhere increasing or nowhere decreasing weights&quot;, above).  See also note 3 on the previous algorithm.</p>
</blockquote>

<p><a id=Acknowledgments></a></p>

<h2>Acknowledgments</h2>

<p>Due to a suggestion by Michael Shoemate who suggested it was &quot;easy to get lost&quot; in this and related articles, some sections that related to geometric distributions were moved here.  He also noticed a minor error which was corrected.</p>

<p><a id=Notes></a></p>

<h2>Notes</h2>

<p>[^1]: K. Bringmann, F. Kuhn, et al., “Internal DLA: Efficient Simulation of a Physical Growth Model.” In: <em>Proc. 41st International Colloquium on Automata, Languages, and Programming (ICALP&#39;14)</em>, 2014.</p>

<p>[^2]: &quot;<em>x</em> is odd&quot; means that <em>x</em> is an integer and not divisible by 2.  This is true if <em>x</em> &minus; 2*floor(<em>x</em>/2) equals 1, or if <em>x</em> is an integer and the least significant bit of abs(<em>x</em>) is 1.</p>

<p>[^3]: choose(<em>n</em>, <em>k</em>) = (1*2*3*...*<em>n</em>)/((1*...*<em>k</em>)*(1*...*(<em>n</em>&minus;<em>k</em>))) =  <em>n</em>!/(<em>k</em>! * (<em>n</em> &minus; <em>k</em>)!) is a <em>binomial coefficient</em>, or the number of ways to choose <em>k</em> out of <em>n</em> labeled items.  It can be calculated, for example, by calculating <em>i</em>/(<em>n</em>&minus;<em>i</em>+1) for each integer <em>i</em> satisfying <em>n</em>&minus;<em>k</em>+1 &le; <em>i</em> &le; <em>n</em>, then multiplying the results (Yannis Manolopoulos. 2002. &quot;<a href="https://doi.org/10.1145/820127.820168"><strong>Binomial coefficient computation: recursion or iteration?</strong></a>&quot;, SIGCSE Bull. 34, 4 (December 2002), 65–67).  Note that for every <em>m</em>&gt;0, choose(<em>m</em>, 0) = choose(<em>m</em>, <em>m</em>) = 1 and choose(<em>m</em>, 1) = choose(<em>m</em>, <em>m</em>&minus;1) = <em>m</em>; also, in this document, choose(<em>n</em>, <em>k</em>) is 0 when <em>k</em> is less than 0 or greater than <em>n</em>.</p>

<p>[^4]: Devroye, L., <a href="http://luc.devroye.org/rnbookindex.html"><strong><em>Non-Uniform Random Variate Generation</em></strong></a>, 1986.</p>

<p>[^5]: R. Schumacher, &quot;<a href="https://arxiv.org/abs/1602.00336v1"><strong>Rapidly Convergent Summation Formulas involving Stirling Series</strong></a>&quot;, arXiv:1602.00336v1 [math.NT], 2016.</p>

<p>[^6]: Farach-Colton, M. and Tsai, M.T., 2015. Exact sublinear binomial sampling. <em>Algorithmica</em> 73(4), pp. 637-651.</p>

<p>[^7]: Bringmann, K., and Friedrich, T., 2013, July. Exact and efficient generation of geometric random variates and random graphs, in <em>International Colloquium on Automata, Languages, and Programming</em> (pp. 267-278).</p>

<p>[^8]: &quot;<em>x</em> is even&quot; means that <em>x</em> is an integer and divisible by 2.  This is true if <em>x</em> &minus; 2*floor(<em>x</em>/2) equals 0, or if <em>x</em> is an integer and the least significant bit of abs(<em>x</em>) is 0.</p>

<p>[^9]: Ghosh, A., Roughgarden, T., and Sundararajan, M., &quot;Universally Utility-Maximizing Privacy Mechanisms&quot;, <em>SIAM Journal on Computing</em> 41(6), 2012.</p>

<p>[^10]: Li, L., 2021. Bayesian Inference on Ratios Subject to Differentially Private Noise (Doctoral dissertation, Duke University).</p>

<p>[^11]: Canonne, C., Kamath, G., Steinke, T., &quot;<a href="https://arxiv.org/abs/2004.00010"><strong>The Discrete Gaussian for Differential Privacy</strong></a>&quot;, arXiv:2004.00010 [cs.DS], 2020.</p>

<p>[^12]: Chewi, Sinho, Patrik R. Gerber, Chen Lu, Thibaut Le Gouic, and Philippe Rigollet. &quot;<a href="https://proceedings.mlr.press/v151/chewi22a.html"><strong>Rejection sampling from shape-constrained distributions in sublinear time</strong></a>.&quot; In International Conference on Artificial Intelligence and Statistics, pp. 2249-2265. PMLR, 2022.</p>

<p>[^13]: Hans-J. Boehm. 1987. Constructive Real Interpretation of Numerical Programs. In Proceedings of the SIGPLAN ’87 Symposium on Interpreters and Interpretive Techniques. 214-221</p>

<p>[^14]: Boehm, Hans-J. &quot;Towards an API for the real numbers.&quot; In Proceedings of the 41st ACM SIGPLAN Conference on Programming Language Design and Implementation, pp. 562-576. 2020.</p>

<p>[^15]: Huijben, I.A., Kool, W., Paulus, M.B. and Van Sloun, R.J., 2022. A Review of the Gumbel-max Trick and its Extensions for Discrete Stochasticity in Machine Learning. IEEE Transactions on Pattern Analysis and Machine Intelligence.  Also in <a href="https://arxiv.org/pdf/2110.01515"><strong>https://arxiv.org/pdf/2110.01515</strong></a></p>

<p>[^16]: Or as &minus;ln(<em>E</em>), where <em>E</em> is an exponential random variate with rate 1.</p>

<p>[^17]: Tillé, Y., &quot;Remarks on some misconceptions about unequal probability sampling without replacement&quot;, Computer Science Review 47 (Feb. 2023).</p>

<p>[^18]: Chakraborty, A., Vardeman, S. B., Modeling and inference for mixtures of simple symmetric exponential families of p-dimensional distributions for vectors with binary coordinates, Stat Anal Data Min: The ASA Data Sci Journal. 2021; 14: 352– 365. <a href="https://doi.org/10.1002/sam.11528"><strong>https://doi.org/10.1002/sam.11528</strong></a></p>

<p>[^19]: Ahmad, Z. et al. &quot;Recent Developments in Distribution Theory: A Brief Survey and Some New Generalized Classes of distributions.&quot; Pakistan Journal of Statistics and Operation Research 15 (2019): 87-110.</p>

<p>[^20]: Jones, M. C. &quot;On families of distributions with shape parameters.&quot; International Statistical Review 83, no. 2 (2015): 175-192.</p>

<p>[^21]: Eugene, N., Lee, C., Famoye, F., &quot;Beta-normal distribution and its applications&quot;, <em>Commun. Stat. Theory Methods</em> 31, 2002.</p>

<p>[^22]: Barreto-Souza, Wagner and Alexandre B. Simas. &quot;The exp-G family of probability distributions.&quot; <em>Brazilian Journal of Probability and Statistics</em> 27, 2013.  Also in arXiv:1003.1727v1 [stat.ME], 2010.</p>

<p>[^23]: Mahdavi, Abbas, and Debasis Kundu. &quot;A new method for generating distributions with an application to exponential distribution.&quot; <em>Communications in Statistics -- Theory and Methods</em> 46, no. 13 (2017): 6543-6557.</p>

<p>[^24]: M. C. Jones. Letter to the Editor concerning “A new method for generating distributions with an application to exponential distribution” and “Alpha power Weibull distribution: Properties and applications”, <em>Communications in Statistics - Theory and Methods</em> 47 (2018).</p>

<p>[^25]: Lehmann, E.L., &quot;The power of rank tests&quot;, Annals of Mathematical Statistics 24(1), March 1953.</p>

<p>[^26]: Durrans, S.R., &quot;Distributions of fractional order statistics in hydrology&quot;, Water Resources Research 28 (1992).</p>

<p>[^27]: Mudholkar, G. S., Srivastava, D. K., &quot;Exponentiated Weibull family for analyzing bathtub failure-rate data&quot;, <em>IEEE Transactions on Reliability</em> 42(2), 299-302, 1993.</p>

<p>[^28]: Shaw, W.T., Buckley, I.R.C., &quot;The alchemy of probability distributions: Beyond Gram-Charlier expansions, and a skew-kurtotic-normal distribution from a rank transmutation map&quot;, 2007.</p>

<p>[^29]: Granzotto, D.C.T., Louzada, F., et al., &quot;Cubic rank transmuted distributions: inferential issues and applications&quot;, <em>Journal of Statistical Computation and Simulation</em>, 2017.</p>

<p>[^30]: Alzaatreh, A., Famoye, F., Lee, C., &quot;A new method for generating families of continuous distributions&quot;, <em>Metron</em> 71:63–79 (2013).</p>

<p>[^31]: Aljarrah, M.A., Lee, C. and Famoye, F., &quot;On generating T-X family of distributions using quantile functions&quot;, Journal of Statistical Distributions and Applications,1(2), 2014.</p>

<p>[^32]: Gleaton, J.U., Lynch, J. D., &quot;Properties of generalized log-logistic families of lifetime distributions&quot;, <em>Journal of Probability and Statistical Science</em> 4(1), 2006.</p>

<p>[^33]: Hosseini, B., Afshari, M., &quot;The Generalized Odd Gamma-G Family of Distributions:  Properties and Applications&quot;, <em>Austrian Journal of Statistics</em> vol. 47, Feb. 2018.</p>

<p>[^34]: N.H. Al Noor and N.K. Assi, &quot;Rayleigh-Rayleigh Distribution: Properties and Applications&quot;, <em>Journal of Physics: Conference Series</em> 1591, 012038 (2020).  The underlying Rayleigh distribution uses a parameter <em>&theta;</em> (or <em>&lambda;</em>), which is different from <em>Mathematica</em>&#39;s parameterization with <em>&sigma;</em> = sqrt(1/<em>&theta;</em><sup>2</sup>) = sqrt(1/<em>&lambda;</em><sup>2</sup>).  The first Rayleigh distribution uses <em>&theta;</em> and the second, <em>&lambda;</em>.</p>

<p>[^35]: Boshi, M.A.A., et al., &quot;Generalized Gamma – Generalized Gompertz Distribution&quot;, <em>Journal of Physics: Conference Series</em> 1591, 012043 (2020).</p>

<p>[^36]: Tahir, M.H., Cordeiro, G.M., &quot;Compounding of distributions: a survey and new generalized classes&quot;, <em>Journal of Statistical Distributions and Applications</em> 3(13), 2016.</p>

<p>[^37]: Pérez-Casany, M., Valero, J., and Ginebra, J. (2016). Random-Stopped Extreme distributions. International Conference on Statistical Distributions and Applications.</p>

<p>[^38]: Amponsah, C.K., Kozubowski, T.J. &amp; Panorska, A.K. A general stochastic model for bivariate episodes driven by a gamma sequence. J Stat Distrib App 8, 7 (2021). <a href="https://doi.org/10.1186/s40488-021-00120-5"><strong>https://doi.org/10.1186/s40488-021-00120-5</strong></a></p>

<p>[^39]: Johnson, N. L., Kemp, A. W., and Kotz, S. (2005). Univariate discrete distributions.</p>

<p>[^40]: Duarte-López, A., Pérez-Casany, M. and Valero, J., 2021. Randomly stopped extreme Zipf extensions. Extremes, pp.1-34.</p>

<p>[^41]: This is simplified from the paper because <em>Y</em> can take on only values greater than 0 so that the probability of getting 0 is 0.</p>

<p>[^42]: Akdoğan, Y., Kus, C., et al., &quot;Geometric-Zero Truncated Poisson Distribution: Properties and Applications&quot;, <em>Gazi University Journal of Science</em> 32(4), 2019.</p>

<p>[^43]: Barreto-Souza, W.: &quot;Bivariate gamma-geometric law and its induced Lévy process&quot;, Journal of Multivariate Analysis 109 (2012).</p>

<p>[^44]: Kuş, C., &quot;A new lifetime distribution&quot;, <em>Computational Statistics &amp; Data Analysis</em> 51 (2007).</p>

<p>[^45]: Cancho, Vicente G., Franscisco Louzada-Neto, and Gladys DC Barriga. &quot;The Poisson-exponential lifetime distribution.&quot; Computational Statistics &amp; Data Analysis 55, no. 1 (2011): 677-686.</p>

<p>[^46]: Jodrá, P., &quot;A note on the right truncated Weibull distribution and the minimum of power function distributions&quot;, 2020.</p>

<p>[^47]: Keller, A.Z., Kamath A.R., &quot;Reliability analysis of CNC machine tools&quot;, <em>Reliability Engineering</em> 3 (1982).</p>

<p>[^48]: Rao, C.R., &quot;Weighted distributions arising out of methods of ascertainment&quot;, 1985.</p>

<p>[^49]: Ospina, R., Ferrari, S.L.P., &quot;Inflated Beta Distributions&quot;, 2010.</p>

<p>[^50]: Chakraborty, S., Bhattacharjee, S., &quot;<a href="https://arxiv.org/abs/2103.08916"><strong>Modeling proportion of success in high school leaving examination- A comparative study of Inflated Unit Lindley and Inflated Beta distribution</strong></a>&quot;, arXiv:2103.08916 [stat.ME], 2021.</p>

<p>[^51]: Mullahy, J., &quot;Specification and testing of some modified count data models&quot;, 1986.</p>

<p>[^52]: Grassia, A., &quot;On a family of distributions with argument between 0 and 1 obtained by transformation of the gamma and derived compound distributions&quot;, <em>Australian Journal of Statistics</em>, 1977.</p>

<p>[^53]: Elgohari, Hanaa, and Haitham Yousof. &quot;New Extension of Weibull Distribution: Copula, Mathematical Properties and Data Modeling.&quot; Stat., Optim. Inf. Comput., Vol.8, December 2020.</p>

<p>[^54]: Marshall, A.W. and Olkin, I., 1997. A new method for adding a parameter to a family of distributions with application to the exponential and Weibull families. Biometrika, 84(3), pp.641-652.</p>

<p>[^55]: Rady,  E.H.A.,  Hassanein,  W.A.,  Elhaddad,  T.A., &quot;The power Lomax distribution with an application to bladder cancer data&quot;, (2016).</p>

<p>[^56]: Castellares, F., Lemonte, A.J., Moreno, G., &quot;On the two-parameter Bell-Touchard discrete distribution&quot;, <em>Communications in Statistics
    - Theory and Methods</em> 4, (2020).</p>

<p>[^57]: The similar Bell&ndash;Touchard process is the sum of the first <em>N</em> variates from an infinite sequence of zero-truncated Poisson(<em>a</em>) random variates, where <em>N</em> is the number of events of a Poisson process with rate <em>b</em>*exp(<em>a</em>)&minus;<em>b</em> (Freud, T., Rodriguez, P.M., &quot;<a href="https://arxiv.org/abs/2203.16737v2"><strong>The Bell-Touchard counting process</strong></a>&quot;, arXiv:2203.16737v2 [math.PR], 2022).</p>

<p>[^58]: Buddana, Amrutha, and Tomasz J. Kozubowski. &quot;Discrete Pareto distributions.&quot; Economic Quality Control 29, no. 2 (2014): 143-156.</p>

<p>[^59]: Batsidis, A., Lemonte, A.J., &quot;On Goodness-of-Fit Tests for the Neyman Type A Distribution&quot;, REVSTAT-Statistical Journal (accepted Nov. 2021).</p>

<p>[^60]: Kudryavtsev, A.A., &quot;On the representation of gamma-exponential and generalized negative binomial distributions&quot;, Inform. Appl. 13 (2019)</p>

<p>[^61]: Saha, M., et al., &quot;<a href="https://arxiv.org/abs/1909.01103"><strong>The extended xgamma distribution</strong></a>&quot;, arXiv:1909.01103 [math.ST], 2019.</p>

<p>[^62]: McNeil, et al., &quot;Quantitative risk management&quot;, 2010.</p>

<p>[^63]: Azzalini, A., Capitanio, A., &quot;Distributions generated by perturbation of symmetry with emphasis on a multivariate skew t‐distribution.&quot; Journal of the Royal Statistical Society: Series B (Statistical Methodology) 65, no. 2 (2003): 367-389.</p>

<p>[^64]: Azzalini, A., &quot;An overview on the progeny of the skew-normal family&mdash; A personal perspective&quot;, Journal of Multivariate Analysis 188, March 2022.</p>

<p>[^65]: Azzalini, Adelchi. &quot;A class of distributions which includes the normal ones.&quot; Scandinavian journal of statistics (1985): 171-178.</p>

<p>[^66]: Gómez-Déniz, Emilio, and E. Calderín-Ojeda. &quot;<a href="https://www.hindawi.com/journals/mpe/2020/1420618/"><strong>On the usefulness of the logarithmic skew normal distribution for describing claims size data</strong></a>.&quot; Mathematical Problems in Engineering 2020 (2020). Lin and Stoyanov (2009, &quot;The logarithmic skew-normal distributions are moment-indeterminate&quot;, <em>Journal of Applied Probability</em> 46) studied the logarithmic skew normal distribution with <em>&mu;</em>=0 and <em>&sigma;</em>=1.</p>

<p>[^67]: Hahn, Eugene D. &quot;The Tilted Beta-Binomial Distribution in Overdispersed Data: Maximum Likelihood and Bayesian Estimation.&quot; Journal of Statistical Theory and Practice 16, no. 3 (2022): 1-22.</p>

<p>[^68]: Rubio, F.J. and Steel, M.F.J. (2020), The family of two-piece distributions. Significance, 17: 12-13. <a href="https://doi.org/10.1111/j.1740-9713.2020.01352.x"><strong>https://doi.org/10.1111/j.1740-9713.2020.01352.x</strong></a></p>

<p>[^69]: A. Tesei and C. S. Regazzoni, “The asymmetric generalized Gaussian function: a new HOS-based model for generic noise PDFs,” in Proceedings of 8th Workshop on Statistical Signal and Array Processing, Corfu, Greece, Jun. 1996, pp. 210-213</p>

<p>[^70]: Sadeghi, Parastoo, and Mehdi Korki. &quot;Offset-Symmetric Gaussians for Differential Privacy.&quot; arXiv preprint arXiv:2110.06412 (2021).</p>

<p>[^71]: Henze, Norbert. &quot;A probabilistic representation of the &#39;skew-normal&#39; distribution.&quot; Scandinavian journal of statistics (1986): 271-275. SNE(<em>&lambda;</em>,0) is distributed as Azzalini&#39;s skew normal distribution.</p>

<p>[^72]: Francis-Staite, Kelli, and Langford White. &quot;<a href="https://arxiv.org/abs/2206.10865"><strong>Analysis of sojourn time distributions for semi-Markov models</strong></a>&quot;, arXiv:2206.10865 (2022).</p>

<p>[^73]: Kozubowski, Tomasz J., and Krzysztof Podgórski. &quot;A generalized Sibuya distribution.&quot; Annals of the Institute of Statistical Mathematics 70, no. 4 (2018): 855-887.</p>

<p>[^74]: If <em>&nu;</em> = 0, this is the ordinary Sibuya distribution.</p>

<p>[^75]: Agarwal, A., Pandey, H., &quot;Himanshu distribution and its applications&quot;, Bulletin of Mathematics and Statistics Research 10(4), 2022.</p>

<p>[^76]: Hahn, E.D., López Martín, M.d.M., &quot;Robust project management with the tilted beta distribution&quot;, 2015.</p>

<p>[^77]: Devroye, L., Gravel, C., &quot;<a href="https://arxiv.org/abs/1502.02539v6"><strong>Random variate generation using only finitely many unbiased, independently and identically distributed random bits</strong></a>&quot;, arXiv:1502.02539v6  [cs.IT], 2020.</p>

<p>[^78]: A Lipschitz continuous function, with Lipschitz constant <em>L</em>, is a continuous function such that <em>f</em>(<em>x</em>) and <em>f</em>(<em>y</em>) are no more than <em>L</em>*<em>&epsilon;</em> apart whenever <em>x</em> and <em>y</em> are points in the domain that are no more than <em>&epsilon;</em> apart.  Roughly speaking, the function&#39;s slope is no &quot;steeper&quot; than that of <em>L</em>*<em>x</em>.</p>

<p>[^79]: Ker-I Ko makes heavy use of the inverse modulus of continuity in his complexity theory, for example, &quot;Computational complexity of roots of real functions.&quot; In <em>30th Annual Symposium on Foundations of Computer Science</em>, pp. 204-209. IEEE Computer Society, 1989.</p>

<p>[^80]: Here is a sketch of the proof: Because the quantile function <em>Q</em>(<em>x</em>) is continuous on a closed interval, it&#39;s uniformly continuous there.  For this reason, there is a positive function <em>&omega;</em><sup>&minus;1</sup>(<em>&epsilon;</em>) such that <em>Q</em>(<em>x</em>) is less than <em>&epsilon;</em>-away from <em>Q</em>(<em>y</em>), for every <em>&epsilon;</em>&gt;0, whenever <em>x</em> and <em>y</em> lie in that interval and whenever <em>x</em> is less than <em>&omega;</em><sup>&minus;1</sup>(<em>&epsilon;</em>)-away from <em>y</em>.  The inverse modulus of continuity is one such function, which is formed by inverting a modulus of continuity admitted by <em>Q</em>, as long as that modulus is continuous and strictly increasing on that interval to make that modulus invertible.  Finally, max(0, ceil(&minus;ln(<em>z</em>)/ln(<em>&beta;</em>))) is an upper bound on the number of base-<em>&beta;</em> fractional digits needed to store 1/<em>z</em> with an error of at most <em>&epsilon;</em>.</p>

<p>[^81]: A <a href="https://en.wikipedia.org/wiki/H%C3%B6lder_condition"><strong><em>Hölder continuous</em></strong></a> function  (with <em>M</em> being the <em>Hölder constant</em> and <em>&alpha;</em> being the <em>Hölder exponent</em>) is a continuous function <em>f</em> such that <em>f</em>(<em>x</em>) and <em>f</em>(<em>y</em>) are no more than <em>M</em>*<em>&delta;</em><sup><em>&alpha;</em></sup> apart whenever <em>x</em> and <em>y</em> are in the function&#39;s domain and no more than <em>&delta;</em> apart.<br>Here, <em>&alpha;</em> satisfies 0 &lt; <em>&alpha;</em> &le; 1.<br>Roughly speaking, the function&#39;s &quot;steepness&quot; is no greater than that of <em>M</em>*<em>x</em><sup><em>&alpha;</em></sup>.</p>

<p>[^82]: Knuth, Donald E. and Andrew Chi-Chih Yao. &quot;The complexity of nonuniform random number generation&quot;, in <em>Algorithms and Complexity: New Directions and Recent Results</em>, 1976.</p>

<p>[^83]: Jacob, P.E., Thiery, A.H., &quot;On nonnegative unbiased estimators&quot;, Ann. Statist., Volume 43, Number 2 (2015), 769-784.</p>

<p>[^84]: Duvignau, R., 2015. Maintenance et simulation de graphes aléatoires dynamiques (Doctoral dissertation, Université de Bordeaux).</p>

<p>[^85]: There are many distributions that can be sampled using the oracle, by first generating unbiased random bits via randomness extraction methods, but then these distributions won&#39;t use the unknown number of faces in general.  Duvignau proved Theorem 5.2 for an oracle that outputs <em>arbitrary</em> but still distinct items, as opposed to integers, but this case can be reduced to the integer case (see section 4.1.3).</p>

<p>[^86]: Keane,  M.  S.,  and  O&#39;Brien,  G.  L., &quot;A Bernoulli factory&quot;, <em>ACM Transactions on Modeling and Computer Simulation</em> 4(2), 1994.</p>

<p>[^87]: Lee, A., Doucet, A. and Łatuszyński, K., 2014. &quot;<a href="https://arxiv.org/abs/1407.5770v1"><strong>Perfect simulation using atomic regeneration with application to Sequential Monte Carlo</strong></a>&quot;, arXiv:1407.5770v1  [stat.CO].</p>

<p><a id=License></a></p>

<h2>License</h2>

<p>Any copyright to this page is released to the Public Domain.  In case this is not possible, this page is also licensed under <a href="https://creativecommons.org/publicdomain/zero/1.0/"><strong>Creative Commons Zero</strong></a>.</p>
</div><nav id="navigation"><ul>
<li><a href="/">Back to start site.</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io">This site's repository (source code)</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io/issues">Post an issue or comment</a></ul>

<div class="noprint">
<p>
<a href="//twitter.com/intent/tweet">Share via Twitter</a>, <a href="//www.facebook.com/sharer/sharer.php" id="sharer">Share via Facebook</a>
</p>
</div>
<p style='font-size:120%;font-weight:bold'><a href='https://peteroupc.github.io/randmisc.pdf'>Download a PDF of this page</a></p></nav></body></html>
