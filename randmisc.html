<!DOCTYPE html><html xmlns:dc="http://purl.org/dc/terms/" itemscope itemtype="http://schema.org/Article"><head><meta http-equiv=Content-Type content="text/html; charset=utf-8"><title>Miscellaneous Observations on Randomization</title><meta name="citation_title" content="Miscellaneous Observations on Randomization"><meta name="og:title" content="Miscellaneous Observations on Randomization"><meta name="og:type" content="article"><meta name="og:site_name" content="peteroupc.github.io"><meta name="twitter:title" content="Miscellaneous Observations on Randomization"><meta name="author" content="Peter Occil"/><meta name="viewport" content="width=device-width"><link rel=stylesheet type="text/css" href="/style.css"></head><body>  <div class="header">
<nav><p><a href="#navigation">Menu</a> - <a href="#top">Top</a> - <a href="/">Home</a></nav></div>
<div class="mainarea" id="top">
<h1>Miscellaneous Observations on Randomization</h1>

<p><a href="mailto:poccil14@gmail.com"><strong>Peter Occil</strong></a></p>

<p><a id=On_a_Binomial_Sampler></a></p>

<h2>On a Binomial Sampler</h2>

<p>Take the following sampler of a binomial(<em>n</em>, 1/2) distribution (where <em>n</em> is even), which is equivalent to the one that appeared in (Bringmann et al. 2014)<sup><a href="#Note1"><strong>(1)</strong></a></sup>, and adapted to be more programmer-friendly.</p>

<ol>
<li>Set <em>m</em> to floor(sqrt(<em>n</em>)) + 1.</li>
<li>(First, sample from an envelope of the binomial curve.) Generate unbiased random bits (zeros or ones) until a zero is generated this way.  Set <em>k</em> to the number of ones generated this way.</li>
<li>Set <em>s</em> to an integer in [0, <em>m</em>) chosen uniformly at random, then set <em>i</em> to <em>k</em>*<em>m</em> + <em>s</em>.</li>
<li>Set <em>ret</em> to either <em>n</em>/2+<em>i</em> or <em>n</em>/2&minus;<em>i</em>&minus;1 with equal probability.</li>
<li>(Second, accept or reject <em>ret</em>.) If <em>ret</em> &lt; 0 or <em>ret</em> &gt; <em>n2</em>, go to step 2.</li>
<li>With probability choose(<em>n</em>, <em>ret</em>)*<em>m</em>*2<sup><em>k</em>&minus;(<em>n</em>+2)</sup>, return <em>ret</em>.  Otherwise, go to step 2. (Here, choose(<em>n</em>, <em>k</em>) is a binomial coefficient.<sup><a href="#Note2"><strong>(2)</strong></a></sup>)</li>
</ol>

<p>This algorithm has an acceptance rate of 1/16 regardless of the value of <em>n</em>.  However, step 6 will generally require a growing amount of storage and time to exactly calculate the given probability as <em>n</em> gets large, notably due to the inherent factorial in the binomial coefficient.  The Bringmann paper suggests approximating this factorial via Spouge&#39;s approximation; however, it seems hard to do so without using floating-point arithmetic, which the paper ultimately resorts to. Alternatively, the logarithm of that probability can be calculated that is much more economical in terms of storage than the full exact probability.  Then, an exponential random number can be generated, negated, and compared with that logarithm to determine whether the step succeeds.</p>

<p>More specifically, step 6 can be changed as follows:</p>

<ul>
<li>(6.) Let <em>p</em> be loggamma(<em>n</em>+1)&minus;loggamma(<em>k</em>+1)&minus;loggamma((<em>n</em>&minus;<em>k</em>)+1)+ln(<em>m</em>)+ln(2)*<em>k</em>&minus;(<em>n</em>+2) (where loggamma(<em>x</em>) is the logarithm of the gamma function).</li>
<li>(6a.) Generate an exponential random number with rate 1 (which is the negative natural logarithm of a uniform(0,1) random number).  Set <em>e</em> to 0 minus that number.</li>
<li>(6b.) If <em>e</em> is greater than <em>p</em>, go to step 2.  Otherwise, return <em>ret</em>. (This step can be replaced by calculating lower and upper bounds that converge to <em>p</em>.  Then, go to step 2 if <em>e</em> is greater than the upper bound, or return <em>ret</em> if <em>e</em> is less than the lower bound, or compute better bounds and repeat this step otherwise.  See also chapter 4 of (Devroye 1986)<sup><a href="#Note3"><strong>(3)</strong></a></sup>.)</li>
</ul>

<p>My implementation of loggamma and the natural logarithm (<a href="https://peteroupc.github.io/interval.py"><strong>interval.py</strong></a>) relies on rational interval arithmetic (Daumas et al. 2007)<sup><a href="#Note4"><strong>(4)</strong></a></sup> and a fast converging version of Stirling&#39;s formula (Schumacher 2016)<sup><a href="#Note5"><strong>(5)</strong></a></sup>.</p>

<p><a id=Sampling_Unbounded_Monotone_Density_Functions></a></p>

<h2>Sampling Unbounded Monotone Density Functions</h2>

<p>This section shows a preprocessing algorithm to generate a random number in [0, 1] from a distribution whose probability density function (PDF)&mdash;</p>

<ul>
<li>is continuous in the interval [0, 1],</li>
<li>is monotonically decreasing in [0, 1], and</li>
<li>has an unbounded peak at 0.</li>
</ul>

<p>The trick here is to sample the peak in such a way that the result is either forced to be 0 or forced to belong to the bounded part of the PDF.  This algorithm does not require the area under the curve of the PDF in [0, 1] to be 1; in other words, this algorithm works even if the PDF is known up to a normalizing constant.  The algorithm is as follows.</p>

<ol>
<li>Set <em>i</em> to 1.</li>
<li>Calculate the cumulative probability of the interval [0, 2<sup>&minus;<em>i</em></sup>] and that of [0, 2<sup>&minus;(<em>i</em> &minus; 1)</sup>], call them <em>p</em> and <em>t</em>, respectively.</li>
<li>With probability <em>p</em>/<em>t</em>, add 1 to <em>i</em> and go to step 2. (Alternatively, if <em>i</em> is equal to or higher than the desired number of fractional bits in the result, return 0 instead of adding 1 and going to step 2.)</li>
<li>At this point, the PDF at [2<sup>&minus;<em>i</em></sup>, 2<sup>&minus;(<em>i</em> &minus; 1)</sup>) is bounded from above, so sample a random number in this interval using any appropriate algorithm, including rejection sampling.  Because the PDF is monotonically decreasing, the peak of the PDF at this interval is located at 2<sup>&minus;<em>i</em></sup>, so that rejection sampling becomes trivial.</li>
</ol>

<p>It is relatively straightforward to adapt this algorithm for monotonically increasing PDFs with the unbounded peak at 1, or to PDFs with a different domain than [0, 1].</p>

<p>This algorithm is similar to the &quot;inversion-rejection&quot; algorithm mentioned in section 4.4 of chapter 7 of Devroye&#39;s <em>Non-Uniform Random Variate Generation</em> (1986)<sup><a href="#Note3"><strong>(3)</strong></a></sup>.  I was unaware of that algorithm at the time I started writing the text that became this section (Jul. 25, 2020).  The difference here is that it assumes the whole distribution (including its PDF and cumulative distribution function) is supported on the interval [0, 1], while the algorithm presented in this article doesn&#39;t make that assumption (e.g., the interval [0, 1] can cover only part of the PDF&#39;s support).</p>

<p>By the way, this algorithm arose while trying to devise an algorithm that can generate an integer power of a uniform random number, with arbitrary precision, without actually calculating that power (a naïve calculation that is merely an approximation and usually introduces bias); for more information, see my other article on <a href="https://peteroupc.github.io/exporand.html"><strong>partially-sampled random numbers</strong></a>.  Even so, the algorithm I have come up with in this note may be of independent interest.</p>

<p>In the case of powers of a uniform [0, 1] random number <em>X</em>, namely <em>X</em><sup><em>n</em></sup>, the ratio <em>p</em>/<em>t</em> in this algorithm has a very simple form, namely (1/2)<sup>1/<em>n</em></sup>, which is possible to simulate using a so-called <em>Bernoulli factory</em> algorithm without actually having to calculate this ratio.  Note that this formula is the same regardless of <em>i</em>.  This is found by taking the PDF f(<em>x</em>) = <em>x</em><sup>1/<em>n</em></sup>/(<em>x</em> * <em>n</em>)</sup> and finding the appropriate <em>p</em>/<em>t</em> ratios by integrating <em>f</em> over the two intervals mentioned in step 2 of the algorithm.</p>

<p><a id=Certain_Families_of_Distributions></a></p>

<h2>Certain Families of Distributions</h2>

<p>This section is a note on certain families of univariate (one-variable) distributions of random numbers, with emphasis on sampling random numbers from them.</p>

<p>The &quot;odd X Y&quot; family uses two distributions, X and Y, where X is an arbitrary continuous distribution and Y is a distribution with an easy-to-sample quantile function (also known as inverse cumulative distribution function or inverse CDF).  The following algorithm samples a random number following a distribution from this family:</p>

<ol>
<li>Generate a random number that follows the distribution X, call it <em>x</em>.</li>
<li>Calculate the quantile for Y of <em>x</em>/(1+<em>x</em>), and return that quantile.</li>
</ol>

<p>Examples of this family include the &quot;odd log-logistic G&quot; family (where &quot;G&quot; or &quot;generated&quot; corresponds to Y) (Gleaton and Lynch 2006)<sup><a href="#Note6"><strong>(6)</strong></a></sup> and the &quot;generalized odd Weibull generated&quot; family (where X is the Weibull distribution and Y is arbitrary) (Korkmaz et al. 2018)<sup><a href="#Note7"><strong>(7)</strong></a></sup>.  Many special cases of this family have been proposed in many papers, and usually their names suggest the distributions that make up this family.  Some of these members have names that begin with the word &quot;generalized&quot;, and in most such cases the quantile in step 2 should be calculated as (<em>x</em>/(1+<em>x</em>))<sup>1/<em>a</em></sup>, where <em>a</em> is a shape parameter greater than 0; an example is the &quot;generalized odd gamma-G&quot; family (Hosseini et al. 2018)<sup><a href="#Note8"><strong>(8)</strong></a></sup>.</p>

<p>A <em>compound distribution</em> is simply the minimum of <em>N</em> random variables distributed as <em>X</em>, where <em>N</em> is distributed as the discrete distribution <em>Y</em> (Tahir and Cordeiro 2016)<sup><a href="#Note9"><strong>(9)</strong></a></sup>.  For example, the &quot;beta-G-geometric&quot; family represents the minimum of <em>N</em> beta-G random variables (beta-G is the quantile of a beta-distributed random number, where the quantile comes from an arbitrary distribution (Eugene et al. 2002)<sup><a href="#Note10"><strong>(10)</strong></a></sup>), where <em>N</em> is a (zero-truncated) geometric random number.  A <em>complementary compound distribution</em> is the maximum of <em>N</em> random variables distributed as <em>X</em>, where <em>N</em> is distributed as the discrete distribution <em>Y</em>.</p>

<p><a id=Notes></a></p>

<h2>Notes</h2>

<ul>
<li><small><sup id=Note1>(1)</sup> K. Bringmann, F. Kuhn, et al., “Internal DLA: Efficient Simulation of a Physical Growth Model.” In: <em>Proc. 41st International Colloquium on Automata, Languages, and Programming (ICALP&#39;14)</em>, 2014.</small></li>
<li><small><sup id=Note2>(2)</sup> choose(<em>n</em>, <em>k</em>) = <em>n</em>!/(<em>k</em>! * (<em>n</em> &minus; <em>k</em>)!) is a binomial coefficient.  It can be calculated, for example, by calculating <em>i</em>/(<em>n</em>&minus;<em>i</em>+1) for each integer <em>i</em> in [<em>n</em>&minus;<em>k</em>+1, <em>n</em>], then multiplying the results (Yannis Manolopoulos. 2002. &quot;<a href="https://doi.org/10.1145/820127.820168"><strong>Binomial coefficient computation: recursion or iteration?</strong></a>&quot;, SIGCSE Bull. 34, 4 (December 2002), 65–67).  Note that for all <em>m</em>&gt;0, choose(<em>m</em>, 0) = choose(<em>m</em>, <em>m</em>) = 1 and choose(<em>m</em>, 1) = choose(<em>m</em>, <em>m</em>&minus;1) = <em>m</em>.</small></li>
<li><small><sup id=Note3>(3)</sup> Devroye, L., <a href="http://luc.devroye.org/rnbookindex.html"><strong><em>Non-Uniform Random Variate Generation</em></strong></a>, 1986.</small></li>
<li><small><sup id=Note4>(4)</sup> Daumas, M., Lester, D., Muñoz, C., &quot;<a href="https://arxiv.org/abs/0708.3721"><strong>Verified Real Number Calculations: A Library for Interval Arithmetic</strong></a>&quot;, arXiv:0708.3721 [cs.MS], 2007.</small></li>
<li><small><sup id=Note5>(5)</sup> R. Schumacher, &quot;<a href="https://arxiv.org/abs/1602.00336v1"><strong>Rapidly Convergent Summation Formulas involving Stirling Series</strong></a>&quot;, arXiv:1602.00336v1 [math.NT], 2016</small></li>
<li><small><sup id=Note6>(6)</sup> Gleaton, J.U., Lynch, J. D., &quot;Properties of generalized log-logistic families of lifetime distributions&quot;, <em>Journal of Probability and Statistical Science</em> 4(1), 2006.</small></li>
<li><small><sup id=Note7>(7)</sup> Korkmaz, M.Ç., Alizadeh, M., et al., &quot;The Generalized Odd Weibull Generated Family of Distributions: Statistical Properties and Applications&quot;, <em>Pak. J. Stat. Oper. Res.</em> XIV(3), 2018.</small></li>
<li><small><sup id=Note8>(8)</sup> Hosseini, B., Afshari, M., &quot;The Generalized Odd Gamma-G Family of Distributions:  Properties and Application&quot;, <em>Austrian Journal of Statistics</em> vol. 47, Feb. 2018.</small></li>
<li><small><sup id=Note9>(9)</sup> Tahir, M.H., Cordeiro, G.M., &quot;Compounding of distributions: a survey and new generalized classes&quot;, <em>Journal of Statistical Distributions and Applications</em> 3(13), 2016.</small></li>
<li><small><sup id=Note10>(10)</sup> ugene, N., Lee, C., Famoye, F., &quot;Beta-normal distribution and its applications&quot;, <em>Commun. Stat. Theory Methods</em> 31, 2002.</small></li>
</ul>

<p><a id=License></a></p>

<h2>License</h2>

<p>Any copyright to this page is released to the Public Domain.  In case this is not possible, this page is also licensed under <a href="https://creativecommons.org/publicdomain/zero/1.0/"><strong>Creative Commons Zero</strong></a>.</p>
</div><nav id="navigation"><ul>
<li><a href="/">Back to start site.</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io">This site's repository (source code)</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io/issues">Post an issue or comment</a></ul>
<p>
If you like this software, you should consider donating to me, Peter O., at the link below:</p>
<p class="printonly"><b>peteroupc.github.io</b></p>
<div class="noprint">
<a href="https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=56E5T4FH7KD2S">
<img src="https://www.paypalobjects.com/en_US/i/btn/btn_donateCC_LG.gif"
name="submit" border="2" alt="PayPal - The safer, easier way to pay online!"></a>
<p>
<a href="//twitter.com/share">Share via Twitter</a>, <a href="//www.facebook.com/sharer/sharer.php" id="sharer">Share via Facebook</a>
</p>
</div>
</nav><script>
if("share" in navigator){
 document.getElementById("sharer").href="javascript:void(null)";
 document.getElementById("sharer").innerHTML="Share This Page";
 navigator.share({title:document.title,url:document.location.href}).then(
   function(){});
} else {
 document.getElementById("sharer").href="//www.facebook.com/sharer/sharer.php?u="+
    encodeURIComponent(document.location.href)
}
</script>
</body></html>
