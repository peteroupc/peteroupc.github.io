<!DOCTYPE html><html xmlns:dc="http://purl.org/dc/terms/" itemscope itemtype="http://schema.org/Article"><head><meta http-equiv=Content-Type content="text/html; charset=utf-8"><meta name="citation_pdf_url" content="https://peteroupc.github.io/bernoulli.pdf"><meta name="citation_url" content="https://peteroupc.github.io/bernoulli.html"><meta name="citation_date" content="2024/07/23"><meta name="citation_online_date" content="2024/07/23"><meta name="og:description" content="This page catalogs algorithms to turn unfair coins into differently unfair coins, also known as _Bernoulli factories_.  It provides step-by-step instructions to help programmers implement these Bernoulli factory algorithms.  This page also contains algorithms to exactly sample probabilities that are irrational numbers, using only fair coin flips, which is related to the Bernoulli factory problem. This page is devoted to methods that _exactly_ sample a given probability without introducing new errors, assuming &quot;truly random&quot; numbers are available.  The page links to a Python module that implements several Bernoulli factories."><meta name="description" content="This page catalogs algorithms to turn unfair coins into differently unfair coins, also known as _Bernoulli factories_.  It provides step-by-step instructions to help programmers implement these Bernoulli factory algorithms.  This page also contains algorithms to exactly sample probabilities that are irrational numbers, using only fair coin flips, which is related to the Bernoulli factory problem. This page is devoted to methods that _exactly_ sample a given probability without introducing new errors, assuming &quot;truly random&quot; numbers are available.  The page links to a Python module that implements several Bernoulli factories."><meta name="twitter:description" content="This page catalogs algorithms to turn unfair coins into differently unfair coins, also known as _Bernoulli factories_.  It provides step-by-step instructions to help programmers implement these Bernoulli factory algorithms.  This page also contains algorithms to exactly sample..."><meta name="og:type" content="article"><meta name="og:url" content="https://peteroupc.github.io/bernoulli.html"><meta name="og:site_name" content="peteroupc.github.io"><meta name="author" content="Peter Occil"/><meta name="citation_author" content="Peter Occil"/><meta name="viewport" content="width=device-width"><link rel=stylesheet type="text/css" href="/style.css">
            <script type="text/x-mathjax-config"> MathJax.Hub.Config({"HTML-CSS": { availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, preferredFont: "TeX" },
                    tex2jax: { displayMath: [ ["$$","$$"], ["\\[", "\\]"] ], inlineMath: [ ["$", "$"], ["\\\\(","\\\\)"] ], processEscapes: true } });
            </script><script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"></script></head><body>  <div class="header">
<nav><p><a href="#navigation">Menu</a> - <a href="#top">Top</a> - <a href="/">Home</a></nav></div>
<div class="mainarea" id="top">
<h1 id="bernoulli-factory-algorithms">Bernoulli Factory Algorithms</h1>

<p><a href="mailto:poccil14@gmail.com"><strong>Peter Occil</strong></a></p>

<p><strong>Abstract:</strong> This page catalogs algorithms to turn unfair coins into differently unfair coins, also known as <em>Bernoulli factories</em>.  It provides step-by-step instructions to help programmers implement these Bernoulli factory algorithms.  This page also contains algorithms to exactly sample probabilities that are irrational numbers, using only fair coin flips, which is related to the Bernoulli factory problem. This page is devoted to methods that <em>exactly</em> sample a given probability without introducing new errors, assuming “truly random” numbers are available.  The page links to a Python module that implements several Bernoulli factories.</p>

<p><strong>2020 Mathematics Subject Classification:</strong> 68W20, 60-08, 60-04.</p>

<p><a id="Introduction"></a></p>

<h2 id="introduction">Introduction</h2>

<p>Suppose a coin shows heads with an unknown probability, <em>λ</em>. The goal is to use that coin (and possibly also a fair coin) to build a “new” coin that shows heads with a probability that depends on <em>λ</em>, which is a <em>function</em> that can be called <em>f</em>(<em>λ</em>). This is the <em>Bernoulli factory problem</em>.</p>

<p>This page:</p>

<ul>
  <li>Catalogs methods to solve the Bernoulli factory problem for a wide variety of functions, methods known as <em>Bernoulli factories</em>.  For many of these algorithms, step-by-step instructions are provided.  Many of these methods were suggested in (Flajolet et al., 2010)<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>, but without step-by-step instructions in many cases.</li>
  <li>Brings together methods to exactly sample probabilities that are irrational numbers, which is related to the Bernoulli factory problem.  (An <em>irrational number</em> is a number that can’t be written as a ratio of two integers.) Again, many of these methods were suggested in (Flajolet et al., 2010)<sup id="fnref:1:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>.</li>
  <li>Assumes knowledge of <strong>computer programming and mathematics</strong>, but <strong>little or no familiarity with calculus</strong>.</li>
  <li>Is devoted to methods that <em>exactly</em> sample the probability described, without introducing rounding errors or other errors beyond those already present in the inputs (and assuming that a fair coin is available).</li>
</ul>

<p>The Python module <a href="https://peteroupc.github.io/bernoulli.py"><strong><em>bernoulli.py</em></strong></a> includes implementations of several Bernoulli factories.  For extra notes, see: <a href="https://peteroupc.github.io/bernsupp.html"><strong>Supplemental Notes for Bernoulli Factory Algorithms</strong></a>.</p>

<p><a id="About_This_Document"></a></p>

<h3 id="about-this-document">About This Document</h3>

<p><strong>This is an open-source document; for an updated version, see the</strong> <a href="https://github.com/peteroupc/peteroupc.github.io/raw/master/bernoulli.md"><strong>source code</strong></a> <strong>or its</strong> <a href="https://github.com/peteroupc/peteroupc.github.io/blob/master/bernoulli.md"><strong>rendering on GitHub</strong></a><strong>.  You can send comments on this document on the</strong> <a href="https://github.com/peteroupc/peteroupc.github.io/issues"><strong>GitHub issues page</strong></a><strong>.  See</strong> “<a href="#Requests_and_Open_Questions"><strong>Requests and Open Questions</strong></a>” <strong>for a list of things about this document that I seek answers to.</strong></p>

<p>My audience for this article is <strong>computer programmers with mathematics knowledge, but little or no familiarity with calculus</strong>.</p>

<p>I encourage readers to implement any of the algorithms given in this page, and report their implementation experiences.  In particular, <a href="https://github.com/peteroupc/peteroupc.github.io/issues/18"><strong>I seek comments on the following aspects</strong></a>:</p>

<ul>
  <li>Are the algorithms in the articles easy to implement? Is each algorithm written so that someone could write code for that algorithm after reading the article?</li>
  <li>Does this article have errors that should be corrected?</li>
  <li>Are there ways to make this article more useful to the target audience?</li>
</ul>

<p>Comments on other aspects of this document are welcome.</p>

<p><a id="Contents"></a></p>

<h2 id="contents">Contents</h2>

<ul>
  <li><a href="#Introduction"><strong>Introduction</strong></a>
    <ul>
      <li><a href="#About_This_Document"><strong>About This Document</strong></a></li>
    </ul>
  </li>
  <li><a href="#Contents"><strong>Contents</strong></a></li>
  <li><a href="#About_Bernoulli_Factories"><strong>About Bernoulli Factories</strong></a></li>
  <li><a href="#Algorithms"><strong>Algorithms</strong></a>
    <ul>
      <li><a href="#Implementation_Notes"><strong>Implementation Notes</strong></a></li>
      <li><a href="#Algorithms_for_General_Functions_of___lambda"><strong>Algorithms for General Functions of <em>λ</em></strong></a>
        <ul>
          <li><a href="#Certain_Polynomials"><strong>Certain Polynomials</strong></a></li>
          <li><a href="#Certain_Rational_Functions"><strong>Certain Rational Functions</strong></a></li>
          <li><a href="#Certain_Power_Series"><strong>Certain Power Series</strong></a></li>
          <li><a href="#General_Factory_Functions"><strong>General Factory Functions</strong></a></li>
        </ul>
      </li>
      <li><a href="#Algorithms_for_General_Irrational_Constants"><strong>Algorithms for General Irrational Constants</strong></a>
        <ul>
          <li><a href="#Digit_Expansions"><strong>Digit Expansions</strong></a></li>
          <li><a href="#Continued_Fractions"><strong>Continued Fractions</strong></a></li>
          <li><a href="#Continued_Logarithms"><strong>Continued Logarithms</strong></a></li>
          <li><a href="#Certain_Algebraic_Numbers"><strong>Certain Algebraic Numbers</strong></a></li>
          <li><a href="#Certain_Converging_Series"><strong>Certain Converging Series</strong></a></li>
        </ul>
      </li>
      <li><a href="#Other_General_Algorithms"><strong>Other General Algorithms</strong></a>
        <ul>
          <li><a href="#Convex_Combinations"><strong>Convex Combinations</strong></a></li>
          <li><a href="#Bernoulli_Race_and_Generalizations"><strong>Bernoulli Race and Generalizations</strong></a></li>
          <li><a href="#Flajolet_s_Probability_Simulation_Schemes"><strong>Flajolet’s Probability Simulation Schemes</strong></a></li>
          <li><a href="#Integrals"><strong>Integrals</strong></a></li>
        </ul>
      </li>
      <li><a href="#Algorithms_for_Specific_Functions_of___lambda"><strong>Algorithms for Specific Functions of <em>λ</em></strong></a>
        <ul>
          <li><a href="#ExpMinus_exp_minus__z"><strong>ExpMinus (exp(−<em>z</em>))</strong></a></li>
          <li><a href="#LogisticExp_1_minus_expit__z__2_prec"><strong>LogisticExp (1 − expit(<em>z</em>/2<sup><em>prec</em></sup>))</strong></a></li>
          <li><a href="#exp_minus___lambda____z"><strong>exp(−(<em>λ</em> * <em>z</em>))</strong></a></li>
          <li><a href="#exp_minus_exp__m____lambda"><strong>exp(−exp(<em>m</em> + <em>λ</em>))</strong></a></li>
          <li><a href="#exp_minus__m____lambda____k"><strong>exp(−(<em>m</em> + <em>λ</em>)<sup><em>k</em></sup>)</strong></a></li>
          <li><a href="#exp___lambda___1_minus___lambda"><strong>exp(<em>λ</em>)*(1−<em>λ</em>)</strong></a></li>
          <li><a href="#1_minus_exp_minus__m____lambda____m____lambda"><strong>(1 − exp(−(<em>m</em> + <em>λ</em>))) / (<em>m</em> + <em>λ</em>)</strong></a></li>
          <li><a href="#expit__z__or_1_minus_1_1_exp__z__or_exp__z__1_exp__z__or_1_1_exp_minus__z"><strong>expit(<em>z</em>) or 1−1/(1+exp(<em>z</em>)) or exp(<em>z</em>)/(1+exp(<em>z</em>)) or 1/(1+exp(−<em>z</em>))</strong></a></li>
          <li><a href="#expit__z__2_minus_1_or_tanh__z__2_or_exp__z__minus_1_exp__z__1"><strong>expit(<em>z</em>)*2 − 1 or tanh(<em>z</em>/2) or (exp(<em>z</em>)−1)/(exp(<em>z</em>)+1)</strong></a></li>
          <li><a href="#lambda___exp__z____lambda___exp__z__1_minus___lambda___or___lambda___exp__z__1___lambda___exp__z__minus_1"><strong><em>λ</em>*exp(<em>z</em>) / (<em>λ</em>*exp(<em>z</em>) + (1 − <em>λ</em>)) or <em>λ</em>*exp(<em>z</em>) / (1 + <em>λ</em>*(exp(<em>z</em>) − 1))</strong></a></li>
          <li><a href="#1_exp__z__minus__w__1_exp__z"><strong>(1 + exp(<em>z</em> − <em>w</em>)) / (1 + exp(<em>z</em>))</strong></a></li>
          <li><a href="#1_2_m_k_lambda_or_exp_k_lambda_cdot_ln_2_m"><strong>$1/(2^{m(k+\lambda)})$ or exp($-(k+\lambda)\cdot\ln(2^m)$)</strong></a></li>
          <li><a href="#1_2_x_y_cdot_lambda_or_exp_lambda_cdot_ln_2_x_y"><strong>$1/(2^{(x/y)\cdot\lambda})$ or exp($-\lambda\cdot\ln(2^{x/y})$)</strong></a></li>
          <li><a href="#Two_Coin_Algorithm__c____lambda_____beta_____beta____c____lambda____d____mu___minus___beta___minus_1__c___d"><strong>Two-Coin Algorithm (<em>c</em> * <em>λ</em> * <em>β</em> / (<em>β</em> * (<em>c</em> * <em>λ</em> + <em>d</em> * <em>μ</em>) − (<em>β</em> − 1) * (<em>c</em> + <em>d</em>)))</strong></a></li>
          <li><a href="#c____lambda____c____lambda____d__or__c___d____lambda___1__c___d____lambda"><strong><em>c</em> * <em>λ</em> / (<em>c</em> * <em>λ</em> + <em>d</em>) or (<em>c</em>/<em>d</em>) * <em>λ</em> / (1 + (<em>c</em>/<em>d</em>) * <em>λ</em>))</strong></a></li>
          <li><a href="#d____lambda____c"><strong>(<em>d</em> + <em>λ</em>) / <em>c</em></strong></a></li>
          <li><a href="#d___c____lambda"><strong><em>d</em> / (<em>c</em> + <em>λ</em>)</strong></a></li>
          <li><a href="#d____mu____c____lambda"><strong>(<em>d</em> + <em>μ</em>) / (<em>c</em> + <em>λ</em>)</strong></a></li>
          <li><a href="#d____mu____d____mu____c____lambda"><strong>(<em>d</em> + <em>μ</em>) / ((<em>d</em> + <em>μ</em>) + (<em>c</em> + <em>λ</em>))</strong></a></li>
          <li><a href="#d__k___c____lambda____k__or__d___c____lambda____k"><strong><em>d</em><sup><em>k</em></sup> / (<em>c</em> + <em>λ</em>)<sup><em>k</em></sup>, or (<em>d</em> / (<em>c</em> + <em>λ</em>))<sup><em>k</em></sup></strong></a></li>
          <li><a href="#1_1___lambda"><strong>1/(1+<em>λ</em>)</strong></a></li>
          <li><a href="#1_2_minus___lambda"><strong>1/(2 − <em>λ</em>)</strong></a></li>
          <li><a href="#1_1__m____lambda___2"><strong>1/(1+(<em>m</em>+<em>λ</em>)<sup>2</sup>)</strong></a></li>
          <li><a href="#1_1__x___y____lambda"><strong>1 / (1 + (<em>x</em>/<em>y</em>)*<em>λ</em>)</strong></a></li>
          <li><a href="#lambda_x_y"><strong>$\lambda^{x/y}$</strong></a></li>
          <li><a href="#sqrt___lambda"><strong>sqrt(<em>λ</em>)</strong></a></li>
          <li><a href="#arctan___lambda_____lambda"><strong>arctan(<em>λ</em>) /<em>λ</em></strong></a></li>
          <li><a href="#arctan___lambda_____pi"><strong>arctan(<em>λ</em>) /<em>π</em></strong></a></li>
          <li><a href="#arctan___lambda"><strong>arctan(<em>λ</em>)</strong></a></li>
          <li><a href="#cos___lambda"><strong>cos(<em>λ</em>)</strong></a></li>
          <li><a href="#sin___lambda___sqrt__c____lambda___sqrt__c"><strong>sin(<em>λ</em>*sqrt(<em>c</em>)) / (<em>λ</em>*sqrt(<em>c</em>))</strong></a></li>
          <li><a href="#sin___lambda"><strong>sin(<em>λ</em>)</strong></a></li>
          <li><a href="#ln_1___lambda"><strong>ln(1+<em>λ</em>)</strong></a></li>
          <li><a href="#ln__c____lambda____c____lambda"><strong>ln(<em>c</em>+<em>λ</em>)/(<em>c</em>+<em>λ</em>)</strong></a></li>
          <li><a href="#arcsin___lambda___sqrt_1_minus___lambda__2_minus_1"><strong>arcsin(<em>λ</em>) + sqrt(1 − <em>λ</em><sup>2</sup>) − 1</strong></a></li>
          <li><a href="#tanh__z"><strong>tanh(<em>z</em>)</strong></a></li>
          <li><a href="#Expressions_Involving_Polylogarithms"><strong>Expressions Involving Polylogarithms</strong></a></li>
          <li><a href="#min___lambda___1_2_and_min___lambda___1_minus___lambda"><strong>min(<em>λ</em>, 1/2) and min(<em>λ</em>, 1−<em>λ</em>)</strong></a></li>
        </ul>
      </li>
      <li><a href="#Algorithms_for_Specific_Functions_of___lambda___Probability_Sensitive"><strong>Algorithms for Specific Functions of <em>λ</em> (Probability-Sensitive)</strong></a>
        <ul>
          <li><a href="#lambda_____mu"><strong><em>λ</em> + <em>μ</em></strong></a></li>
          <li><a href="#lambda___minus___mu"><strong><em>λ</em> − <em>μ</em></strong></a></li>
          <li><a href="#x03F5_____lambda"><strong><em>ϵ</em> / <em>λ</em></strong></a></li>
          <li><a href="#mu_____lambda"><strong><em>μ</em> / <em>λ</em></strong></a></li>
          <li><a href="#lambda____x___y"><strong><em>λ</em> * <em>x</em>/<em>y</em></strong></a></li>
          <li><a href="#lambda____x___y___i"><strong>(<em>λ</em> * <em>x</em>/<em>y</em>)<sup><em>i</em></sup></strong></a></li>
          <li><a href="#Linear_Bernoulli_Factories"><strong>Linear Bernoulli Factories</strong></a></li>
          <li><a href="#lambda_mu"><strong>$\lambda^{\mu}$</strong></a></li>
          <li><a href="#1_minus___lambda___cos___lambda"><strong>(1−<em>λ</em>)/cos(<em>λ</em>)</strong></a></li>
          <li><a href="#1_minus___lambda___tan___lambda"><strong>(1−<em>λ</em>) * tan(<em>λ</em>)</strong></a></li>
          <li><a href="#ln__c___d____lambda____c"><strong>ln((<em>c</em> + <em>d</em> + <em>λ</em>)/<em>c</em>)</strong></a></li>
          <li><a href="#arcsin___lambda___2"><strong>arcsin(<em>λ</em>) / 2</strong></a></li>
        </ul>
      </li>
      <li><a href="#Other_Factory_Functions"><strong>Other Factory Functions</strong></a></li>
      <li><a href="#Algorithms_for_Specific_Constants"><strong>Algorithms for Specific Constants</strong></a>
        <ul>
          <li><a href="#1___phi___1_divided_by_the_golden_ratio"><strong>1 / <em>φ</em> (1 divided by the golden ratio)</strong></a></li>
          <li><a href="#sqrt_2_minus_1"><strong>sqrt(2) − 1</strong></a></li>
          <li><a href="#1_sqrt_2"><strong>1/sqrt(2)</strong></a></li>
          <li><a href="#tanh_1_2_or_exp_1_minus_1_exp_1_1"><strong>tanh(1/2) or (exp(1) − 1) / (exp(1) + 1)</strong></a></li>
          <li><a href="#arctan__x___y___y___x"><strong>arctan(<em>x</em>/<em>y</em>) * <em>y</em>/<em>x</em></strong></a></li>
          <li><a href="#pi___12"><strong><em>π</em> / 12</strong></a></li>
          <li><a href="#pi___4"><strong><em>π</em> / 4</strong></a></li>
          <li><a href="#pi___4_minus_1_2_or___pi___minus_2_4"><strong><em>π</em>/4 − 1/2 or (<em>π</em> − 2)/4</strong></a></li>
          <li><a href="#pi___minus_3_4"><strong>(<em>π</em> − 3)/4</strong></a></li>
          <li><a href="#pi___minus_3"><strong><em>π</em> − 3</strong></a></li>
          <li><a href="#4_3___pi"><strong>4/(3*<em>π</em>)</strong></a></li>
          <li><a href="#1___pi"><strong>1 / <em>π</em></strong></a></li>
          <li><a href="#a___b___z"><strong>(<em>a</em>/<em>b</em>)<sup><em>z</em></sup></strong></a></li>
          <li><a href="#1_exp_1__c__minus_2"><strong>1/(exp(1) + <em>c</em> − 2)</strong></a></li>
          <li><a href="#exp_1_minus_2"><strong>exp(1) − 2</strong></a></li>
          <li><a href="#zeta___3_3_4_and_Other_Zeta_Related_Constants"><strong><em>ζ</em>(3) * 3 / 4 and Other Zeta-Related Constants</strong></a></li>
          <li><a href="#erf__x__erf_1"><strong>erf(<em>x</em>)/erf(1)</strong></a></li>
          <li><a href="#Ratio_of_Lower_Gamma_Functions_gamma__m___x__gamma__m__1"><strong>Ratio of Lower Gamma Functions (γ(<em>m</em>, <em>x</em>)/γ(<em>m</em>, 1)).</strong></a></li>
          <li><a href="#Euler_ndash_Mascheroni_constant___gamma"><strong>Euler–Mascheroni constant <em>γ</em></strong></a></li>
          <li><a href="#exp_minus__x___y___z___t"><strong>exp(−<em>x</em>/<em>y</em>) * <em>z</em>/<em>t</em></strong></a></li>
          <li><a href="#Certain_Numbers_Based_on_the_Golden_Ratio"><strong>Certain Numbers Based on the Golden Ratio</strong></a></li>
          <li><a href="#ln_1__y___z"><strong>ln(1+<em>y</em>/<em>z</em>)</strong></a></li>
          <li><a href="#ln___pi_____pi"><strong>ln(<em>π</em>)/<em>π</em></strong></a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#Requests_and_Open_Questions"><strong>Requests and Open Questions</strong></a></li>
  <li><a href="#Correctness_and_Performance_Charts"><strong>Correctness and Performance Charts</strong></a></li>
  <li><a href="#Acknowledgments"><strong>Acknowledgments</strong></a></li>
  <li><a href="#Notes"><strong>Notes</strong></a></li>
  <li><a href="#Appendix"><strong>Appendix</strong></a>
    <ul>
      <li><a href="#Using_the_Input_Coin_Alone_for_Randomness"><strong>Using the Input Coin Alone for Randomness</strong></a></li>
      <li><a href="#The_Entropy_Bound"><strong>The Entropy Bound</strong></a></li>
      <li><a href="#Bernoulli_Factories_and_Unbiased_Estimation"><strong>Bernoulli Factories and Unbiased Estimation</strong></a></li>
      <li><a href="#Correctness_Proof_for_the_Continued_Logarithm_Simulation_Algorithm"><strong>Correctness Proof for the Continued Logarithm Simulation Algorithm</strong></a></li>
      <li><a href="#Correctness_Proof_for_Continued_Fraction_Simulation_Algorithm_3"><strong>Correctness Proof for Continued Fraction Simulation Algorithm 3</strong></a></li>
      <li><a href="#Proof_of_the_General_Martingale_Algorithm"><strong>Proof of the General Martingale Algorithm</strong></a></li>
      <li><a href="#Algorithm_for_sin___lambda_____pi___2"><strong>Algorithm for sin(<em>λ</em>*<em>π</em>/2)</strong></a></li>
      <li><a href="#Probabilities_Arising_from_Certain_Permutations"><strong>Probabilities Arising from Certain Permutations</strong></a></li>
      <li><a href="#Derivation_of_an_Algorithm_for___pi___4"><strong>Derivation of an Algorithm for <em>π</em> / 4</strong></a></li>
      <li><a href="#Sketch_of_Derivation_of_the_Algorithm_for_1___pi"><strong>Sketch of Derivation of the Algorithm for 1 / <em>π</em></strong></a></li>
      <li><a href="#Preparing_Rational_Functions"><strong>Preparing Rational Functions</strong></a></li>
    </ul>
  </li>
  <li><a href="#License"><strong>License</strong></a></li>
</ul>

<p><a id="About_Bernoulli_Factories"></a></p>

<h2 id="about-bernoulli-factories">About Bernoulli Factories</h2>

<p>A <em>Bernoulli factory</em> (Keane and O’Brien 1994)<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup> is an <em>algorithm</em> (or collection of instructions) that takes an input coin (a method that returns 1, or heads, with an unknown probability, or 0, or tails, otherwise) and returns 1 or 0 with a probability that depends on the input coin’s probability of heads.</p>

<ul>
  <li>The Greek letter lambda (<em>λ</em>) represents the unknown probability of heads.</li>
  <li>The Bernoulli factory’s outputs are statistically independent, and so are those of the input coin.</li>
  <li>Many Bernoulli factories also use a <em>fair coin</em> in addition to the input coin.  A fair coin shows heads or tails with equal probability, and represents a source of randomness outside the input coin.</li>
  <li>A <em>factory function</em> is a known function that relates the old probability to the new one.  Its domain is the closed unit interval (defined next) or a subset of that interval, and maps an input in its domain to an output in that interval.</li>
  <li>The <em>closed unit interval</em> is the set of numbers consisting of 0, 1, and all real numbers in between.</li>
  <li>If a Bernoulli factory algorithm exists for a given function, then it’s said that the function <em>admits a Bernoulli factory</em> and is <em>simulated</em> by that algorithm.</li>
</ul>

<blockquote>
  <p><strong>Example:</strong> A Bernoulli factory algorithm can take a coin that returns heads with probability <em>λ</em> and produce a coin that returns heads with probability exp(−<em>λ</em>).  In this example, exp(−<em>λ</em>) is the factory function and is simulated by the algorithm.</p>

  <p><strong>Note:</strong> Although Keane and O’Brien introduced the term “Bernoulli factory”, the problem was first raised much earlier than 1994, such as by Basu (1975, p. 12)<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup>.</p>
</blockquote>

<p>Keane and O’Brien (1994)<sup id="fnref:2:1" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup> showed that a function <em>f</em> that maps the closed unit interval (or a subset of it) to the closed unit interval admits a Bernoulli factory if and only if—</p>

<ul>
  <li><em>f</em> is continuous on its domain and equals the same value everywhere on its domain, or</li>
  <li><em>f</em> is continuous and polynomially bounded on its domain.</li>
</ul>

<p><em>Polynomially bounded</em> means that both <em>f</em>(<em>λ</em>) and 1−<em>f</em>(<em>λ</em>) are not less than min(<em>λ</em><sup><em>n</em></sup>, (1−<em>λ</em>)<sup><em>n</em></sup>) for some integer <em>n</em>.  In other words, there are two non-negative polynomials that do not equal the same value everywhere: one can be “sandwiched” between the <em>λ</em>-axis and <em>f</em>, and another between the <em>λ</em>-axis and 1−<em>f</em>.</p>

<p>The following shows some functions that are factory functions and some that are not.  In the table below, <em>ϵ</em> is a number greater than 0 and less than 1/2.</p>

<table>
  <thead>
    <tr>
      <th>Function <em>f</em>(<em>λ</em>)</th>
      <th>Domain</th>
      <th>Can <em>f</em> be a factory function?</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>0≤<em>λ</em>≤1</td>
      <td>Yes; constant.</td>
    </tr>
    <tr>
      <td>1</td>
      <td>0≤<em>λ</em>≤1</td>
      <td>Yes; constant.</td>
    </tr>
    <tr>
      <td>1/2</td>
      <td>0&lt;<em>λ</em>&lt;1</td>
      <td>Yes; constant.</td>
    </tr>
    <tr>
      <td>1/4 if <em>λ</em>&lt;1/2, and 3/4 elsewhere</td>
      <td>0&lt;<em>λ</em>&lt;1</td>
      <td>No; discontinuous.</td>
    </tr>
    <tr>
      <td>2*<em>λ</em></td>
      <td>[0, 1] or [0, 1/2)</td>
      <td>No; not polynomially bounded since <em>f</em>(<em>λ</em>) approaches 1 as <em>λ</em> approaches 1/2 (as opposed to 0 or 1).<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">4</a></sup>.</td>
    </tr>
    <tr>
      <td>1−2*<em>λ</em></td>
      <td>[0, 1] or [0, 1/2)</td>
      <td>No; not polynomially bounded since <em>f</em>(<em>λ</em>) approaches 0 as <em>λ</em> approaches 1/2.</td>
    </tr>
    <tr>
      <td>2*<em>λ</em></td>
      <td>[0, 1/2−ϵ]</td>
      <td>Yes; continuous and polynomially bounded on domain (Keane and O’Brien 1994)<sup id="fnref:2:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>.</td>
    </tr>
    <tr>
      <td>min(2 * <em>λ</em>, 1 − <em>ϵ</em>)</td>
      <td>0≤<em>λ</em>≤1</td>
      <td>Yes; continuous and polynomially bounded on domain (Huber 2014, introduction)<sup id="fnref:5" role="doc-noteref"><a href="#fn:5" class="footnote" rel="footnote">5</a></sup>.</td>
    </tr>
    <tr>
      <td>exp(−1/<em>λ</em>)</td>
      <td>0&lt;<em>λ</em>&lt;1</td>
      <td>No; not polynomially bounded since no polynomial that does not equal the same value everywhere can come between the <em>λ</em>-axis and $f$.</td>
    </tr>
    <tr>
      <td>(exp(−1/<em>λ</em>))/4.</td>
      <td>0&lt;<em>λ</em>&lt;1</td>
      <td>No, for same reason.</td>
    </tr>
    <tr>
      <td>(<em>λ</em>+<em>λ</em>*sin(1/<em>λ</em>)+exp(−1/<em>λ</em>))/4.</td>
      <td>0&lt;<em>λ</em>&lt;1</td>
      <td>No, for same reason.</td>
    </tr>
    <tr>
      <td>(<em>λ</em>+<em>λ</em>*sin(1/<em>λ</em>)+exp(−1/<em>λ</em>))/4.</td>
      <td>0&lt;<em>λ</em>&lt;1</td>
      <td>No, for same reason.</td>
    </tr>
    <tr>
      <td><em>λ</em>*min(1/<em>λ</em>−floor(1/<em>λ</em>),1-(1/<em>λ</em>−floor(1/<em>λ</em>)))+exp(−1/<em>λ</em>).</td>
      <td>0&lt;<em>λ</em>&lt;1</td>
      <td>No, for same reason.</td>
    </tr>
    <tr>
      <td>(<em>λ</em>*abs(sin(1/<em>λ</em>))<sup><em>α</em></sup>+exp(−1/<em>λ</em>))/4, where <em>α</em>&gt;0.</td>
      <td>0&lt;<em>λ</em>&lt;1</td>
      <td>No, for same reason.</td>
    </tr>
    <tr>
      <td>exp(−1/<em>λ</em>) + ϵ</td>
      <td>0&lt;<em>λ</em>&lt;1</td>
      <td>Yes; continuous, minimum greater than 0, maximum less than 1.</td>
    </tr>
    <tr>
      <td>exp(−1/<em>λ</em>)</td>
      <td>[ϵ, 1)</td>
      <td>Yes; same reason.</td>
    </tr>
    <tr>
      <td><em>λ</em><sup><em>n</em></sup> where <em>n</em>≥2 is an integer.</td>
      <td>0≤<em>λ</em>≤1</td>
      <td>Yes; continuous and the polynomial $\lambda^{n+1}$ can go below $f$, and the polynomial $\lambda^{n-1}$ can go above $f$.</td>
    </tr>
  </tbody>
</table>

<p>If <em>f</em>’s domain includes 0, 1, or both (so that the input coin is allowed to return 0 every time, 1 every time, or either, respectively), then <em>f</em> can be a factory function only if—</p>

<ol>
  <li>the function equals the same value everywhere on its domain, or is continuous and polynomially bounded on its domain, and</li>
  <li><em>f</em>(0) equals 0 or 1 whenever 0 is in the function’s domain, and</li>
  <li><em>f</em>(1) equals 0 or 1 whenever 1 is in the function’s domain,</li>
</ol>

<p>unless outside randomness (besides the input coin) is available.</p>

<p><a id="Algorithms"></a></p>

<h2 id="algorithms">Algorithms</h2>

<p>This section will show algorithms for a number of factory functions, allowing different kinds of probabilities to be sampled from input coins.</p>

<p>The algorithms as described here are not always the fastest.  Indeed, there are many ways to write computer code that <em>implements</em> the algorithms given here, that is, they have the same results as the results of following those algorithms step by step.</p>

<blockquote>
  <p><strong>Notes:</strong></p>

  <ol>
    <li>Most of the algorithms assume that a fair coin (see the previous section) is available, in addition to the input coins.  But in many cases, the algorithms can be written using nothing but those coins as a source of randomness.  See the <a href="#Appendix"><strong>appendix</strong></a> for details.</li>
    <li>Bernoulli factory algorithms that sample the probability <em>f</em>(<em>λ</em>) act as unbiased estimators of <em>f</em>(<em>λ</em>) (their “long run average” equals <em>f</em>(<em>λ</em>)). See the <a href="#Bernoulli_Factories_and_Unbiased_Estimation"><strong>appendix</strong></a> for details.</li>
  </ol>
</blockquote>

<p><a id="Implementation_Notes"></a></p>

<h3 id="implementation-notes">Implementation Notes</h3>

<p>This section shows notes that apply to the algorithms in this article.  When writing computer code that implements the algorithms, they should be followed to avoid introducing errors.</p>

<p>The rest of this page may draw from the following concepts and language from mathematics:</p>

<ul>
  <li><strong>Binomial coefficients</strong>: choose(<em>n</em>, <em>k</em>) = (1*2*3*…*<em>n</em>)/((1*…*<em>k</em>)*(1*…*(<em>n</em>−<em>k</em>))) =  <em>n</em>!/(<em>k</em>! * (<em>n</em> − <em>k</em>)!) $={n \choose k}$ is a <em>binomial coefficient</em>, or the number of ways to choose <em>k</em> out of <em>n</em> labeled items.  It can be calculated, for example, by calculating <em>i</em>/(<em>n</em>−<em>i</em>+1) for each integer <em>i</em> satisfying <em>n</em>−<em>k</em>+1 ≤ <em>i</em> ≤ <em>n</em>, then multiplying the results (Manolopoulos 2002)<sup id="fnref:6" role="doc-noteref"><a href="#fn:6" class="footnote" rel="footnote">6</a></sup>.  For every <em>m</em>&gt;0, choose(<em>m</em>, 0) = choose(<em>m</em>, <em>m</em>) = 1 and choose(<em>m</em>, 1) = choose(<em>m</em>, <em>m</em>−1) = <em>m</em>; also, in this document, choose(<em>n</em>, <em>k</em>) is 0 when <em>k</em> is less than 0 or greater than <em>n</em>.</li>
  <li><strong>Factorials</strong>: <em>n</em>! = 1*2*3*…*<em>n</em> is also known as <em>n</em> factorial; in this document, (0!) = 1.</li>
  <li><strong>Summation notation</strong>, involving the Greek capital letter sigma (Σ), is a way to write the sum of one or more terms of similar form. For example, $\sum_{k=0}^n g(k)$ means $g(0)+g(1)+…+g(n)$, and $\sum_{k\ge 0} g(k)$ means $g(0)+g(1)+…$.</li>
</ul>

<p>In the following algorithms:</p>

<ul>
  <li>The Greek letter lambda (<em>λ</em>) represents the unknown probability of heads of the input coin.</li>
  <li>The instruction to “generate a uniform random variate between 0 and 1” can be implemented—
    <ul>
      <li>by creating a <a href="https://peteroupc.github.io/exporand.html"><strong>uniform partially-sampled random number (PSRN)</strong></a> with a positive sign, an integer part of 0, and an empty fractional part (most accurate), or</li>
      <li>by generating a uniform random variate greater than 0 and less than 1 (for example, <code>RNDRANGEMinMaxExc(0, 1)</code> in “<a href="https://peteroupc.github.io/randomfunc.html"><strong>Randomization and Sampling Methods</strong></a>” (less accurate).</li>
    </ul>
  </li>
  <li>The instruction to “choose [integers] with probability proportional to [<em>weights</em>]” can be implemented in one of the following ways:
    <ul>
      <li>If the weights are rational numbers, take the result of <strong>WeightedChoice</strong>(<strong>NormalizeRatios</strong>(<em>weights</em>))), where <strong>WeightedChoice</strong> and <strong>NormalizeRatios</strong> are given in “<a href="https://peteroupc.github.io/randomfunc.html#Weighted_Choice_With_Replacement"><strong>Randomization and Sampling Methods</strong></a>”.</li>
      <li>If the weights are uniform PSRNs, use the algorithm given in “<a href="https://peteroupc.github.io/randmisc.html#Weighted_Choice_Involving_PSRNs"><strong>Weighted Choice Involving PSRNs</strong></a>”.</li>
    </ul>

    <p>For example, “Choose 0, 1, or 2 with probability proportional to the weights [A, B, C]” means to choose 0, 1, or 2 at random so that 0 is chosen with probability A/(A+B+C), 1 with probability B/(A+B+C), and 2 with probability C/(A+B+C).</p>
  </li>
  <li>Where an algorithm says “if <em>a</em> is less than <em>b</em>”, where <em>a</em> and <em>b</em> are random variates, it means to run the <strong>RandLess</strong> algorithm on the two numbers (if they are both PSRNs), or do a less-than operation on <em>a</em> and <em>b</em>, as appropriate. (<strong>RandLess</strong> is described in my <a href="https://peteroupc.github.io/exporand.html"><strong>article on PSRNs</strong></a>.)</li>
  <li>Where an algorithm says “if <em>a</em> is less than (or equal to) <em>b</em>”, where <em>a</em> and <em>b</em> are random variates, it means to run the <strong>RandLess</strong> algorithm on the two numbers (if they are both PSRNs), or do a less-than-or-equal operation on <em>a</em> and <em>b</em>, as appropriate.</li>
  <li>To <strong>sample from a number <em>u</em></strong> means to generate a number that is 1 with probability <em>u</em> and 0 otherwise.
    <ul>
      <li>If the number is a uniform PSRN, call the <strong>SampleGeometricBag</strong> algorithm with the PSRN and take the result of that call (which will be 0 or 1) (most accurate). (<strong>SampleGeometricBag</strong> is described in my <a href="https://peteroupc.github.io/exporand.html"><strong>article on PSRNs</strong></a>.)</li>
      <li>Otherwise, this can be implemented by generating a uniform random variate between 0 and 1, call it <em>v</em> (see above), and generating 1 if <em>v</em> is less than <em>u</em> (see above) or 0 otherwise.</li>
    </ul>
  </li>
  <li>Where a step in the algorithm says “with probability <em>x</em>” to refer to an event that may or may not happen, then this can be implemented in one of the following ways:
    <ul>
      <li>Generate a uniform random variate between 0 and 1 <em>v</em> (see above). The event occurs if <em>v</em> is less than <em>x</em> (see above).</li>
      <li>Convert <em>x</em> to a rational number <em>y</em>/<em>z</em>, then call <code>ZeroOrOne(y, z)</code>.  The event occurs if the call returns 1. For example, if an instruction says “With probability 3/5, return 1”, then implement it as “Call <code>ZeroOrOne(3, 5)</code>. If the call returns 1, return 1.”  <code>ZeroOrOne</code> is described in my article on <a href="https://peteroupc.github.io/randomfunc.html#Boolean_True_False_Conditions"><strong>random sampling methods</strong></a>.  If <em>x</em> is not a rational number, then rounding error will result, however.</li>
    </ul>
  </li>
  <li>For best results, the algorithms should be implemented using exact rational arithmetic (such as <code>Fraction</code> in Python or <code>Rational</code> in Ruby).  Floating-point arithmetic is discouraged because it can introduce errors due to fixed-precision calculations, such as rounding and cancellations.</li>
</ul>

<p><a id="Algorithms_for_General_Functions_of___lambda"></a></p>

<h3 id="algorithms-for-general-functions-of-lambda">Algorithms for General Functions of <em>λ</em></h3>

<p>This section describes general-purpose algorithms for sampling probabilities that are polynomials, rational functions, or functions in general.</p>

<p><a id="Certain_Polynomials"></a></p>

<h4 id="certain-polynomials">Certain Polynomials</h4>

<p>Any polynomial can be written in <em>Bernstein form</em> as—</p>

\[{n\choose 0}\lambda^0 (1-\lambda)^{n-0} a[0] + {n\choose 1}\lambda^1 (1-\lambda)^{n-1} a[1] + ... + {n\choose n}\lambda^n (1-\lambda)^{n-n} a[n],\]

<p>where <em>n</em> is the polynomial’s <em>degree</em> and <em>a</em>[0], <em>a</em>[1], …, <em>a</em>[<em>n</em>] are its <em>n</em> plus one <em>Bernstein coefficients</em>.</p>

<p>But a polynomial admits a Bernoulli factory only if it can be written to have Bernstein coefficients that are each 0 or greater and less than 1, and a function admits a Bernoulli factory with a fixed number of coin flips only if it’s a polynomial of that kind (Goyal and Sigman 2012<sup id="fnref:7" role="doc-noteref"><a href="#fn:7" class="footnote" rel="footnote">7</a></sup>; Qian et al. 2011<sup id="fnref:8" role="doc-noteref"><a href="#fn:8" class="footnote" rel="footnote">8</a></sup>; see also Wästlund 1999, section 4<sup id="fnref:9" role="doc-noteref"><a href="#fn:9" class="footnote" rel="footnote">9</a></sup>).</p>

<p>Goyal and Sigman give an algorithm for simulating these polynomials, which is given below.</p>

<ol>
  <li>Flip the input coin <em>n</em> times, and let <em>j</em> be the number of times the coin returned 1 this way.<sup id="fnref:10" role="doc-noteref"><a href="#fn:10" class="footnote" rel="footnote">10</a></sup></li>
  <li>Return a number that is 1 with probability <em>a</em>[<em>j</em>], or 0 otherwise.</li>
</ol>

<p>For certain polynomials with duplicate Bernstein coefficients, the following is an optimized version of this algorithm, not given by Goyal and Sigman:</p>

<ol>
  <li>Set <em>j</em> to 0 and <em>i</em> to 0.  If <em>n</em> is 0, return 0.</li>
  <li>If <em>i</em> is <em>n</em> or greater, or if the Bernstein coefficients <em>a</em>[<em>k</em>], with <em>k</em> in the interval [<em>j</em>, <em>j</em>+(<em>n</em>−<em>i</em>)], are all equal, return a number that is 1 with probability <em>a</em>[<em>j</em>], or 0 otherwise.</li>
  <li>Flip the input coin.  If it returns 1, add 1 to <em>j</em>.</li>
  <li>Add 1 to <em>i</em> and go to step 2.</li>
</ol>

<p>And here is another optimized algorithm:</p>

<ol>
  <li>Set <em>j</em> to 0 and <em>i</em> to 0.  If <em>n</em> is 0, return 0.  Otherwise, generate a uniform random variate between 0 and 1, call it <em>u</em>.</li>
  <li>If <em>u</em> is less than a lower bound of the lowest Bernstein coefficient, return 1.  Otherwise, if <em>u</em> is less than (or equal to) an upper bound of the highest Bernstein coefficient, go to the next step.  Otherwise, return 0.</li>
  <li>If <em>i</em> is <em>n</em> or greater, or if the Bernstein coefficients <em>a</em>[<em>k</em>], with <em>k</em> in the interval [<em>j</em>, <em>j</em>+(<em>n</em>−<em>i</em>)], are all equal, return a number that is 1 if <em>u</em> is less than <em>a</em>[<em>j</em>], or 0 otherwise.</li>
  <li>Flip the input coin.  If it returns 1, add 1 to <em>j</em>.</li>
  <li>Add 1 to <em>i</em> and go to step 3.</li>
</ol>

<p>Because the Bernstein coefficients <em>a</em>[<em>i</em>] must be 0 or greater, but not greater than 1, some or all of them can themselves be coins with unknown probability of heads.  In that case, the first algorithm can read as follows:</p>

<ol>
  <li>Flip the input coin <em>n</em> times, and let <em>j</em> be the number of times the coin returned 1 this way.</li>
  <li>If <em>a</em>[<em>j</em>] is a coin, flip it and return the result.  Otherwise, return a number that is 1 with probability <em>a</em>[<em>j</em>], or 0 otherwise.</li>
</ol>

<blockquote>
  <p><strong>Notes</strong>:</p>

  <ol>
    <li>Each <em>a</em>[<em>i</em>] acts as a control point for a 1-dimensional <a href="https://en.wikipedia.org/wiki/Bézier_curve"><strong>Bézier curve</strong></a>, where <em>λ</em> is the relative position on that curve, the curve begins at  <em>a</em>[0], and the curve ends at <em>a</em>[<em>n</em>].  For example, given control points 0.2, 0.3, and 0.6, the curve is at 0.2 when <em>λ</em> = 0, and 0.6 when <em>λ</em> = 1.  (The curve, however, is not at 0.3 when <em>λ</em> = 1/2; in general, Bézier curves do not cross their control points other than the first and the last.)</li>
    <li>The problem of simulating polynomials in Bernstein form is related to <em>stochastic logic</em>, which involves simulating probabilities that arise out of Boolean functions (functions that use only AND, OR, NOT, and exclusive-OR operations) that take a fixed number of bits as input, where each bit has a separate probability of being 1 rather than 0, and output a single bit (for further discussion see (Qian et al. 2011)<sup id="fnref:8:1" role="doc-noteref"><a href="#fn:8" class="footnote" rel="footnote">8</a></sup>, Qian and Riedel 2008<sup id="fnref:11" role="doc-noteref"><a href="#fn:11" class="footnote" rel="footnote">11</a></sup>).</li>
  </ol>

  <p><strong>Examples:</strong></p>

  <ol>
    <li>Take the following function discussed in Thomas and Blanchet (2012)<sup id="fnref:12" role="doc-noteref"><a href="#fn:12" class="footnote" rel="footnote">12</a></sup>: (1−4*(<em>λ</em>−1/2)<sup>2</sup>)*<em>c</em>, where 0 &lt; <em>c</em> &lt; 1.  This is a quadratic function (a polynomial of degree 2) that can be rewritten as −4*<em>c</em>*<em>λ</em><sup>2</sup>+4*<em>c</em>*<em>λ</em>, so that this <em>power form</em> has <em>power coefficients</em> (0, 4*<em>c</em>, −4*<em>c</em>) and a degree (<em>n</em>) of 2. Rewriting the polynomial from power form to Bernstein form (such as via the matrix method by Ray and Nataraj (2012)<sup id="fnref:13" role="doc-noteref"><a href="#fn:13" class="footnote" rel="footnote">13</a></sup>) leads to Bernstein coefficients (0, 2*<em>c</em>, 0).  Thus, for this polynomial, <em>a</em>[0] is 0,  <em>a</em>[1] is 2*<em>c</em>, and  <em>a</em>[2] is 0.  Thus:
      <ul>
        <li>If 0 &lt; <em>c</em> ≤ 1/2, this function can be simulated as follows: “Flip the input coin twice.  If exactly one of the flips returns 1, return a number that is 1 with probability 2*<em>c</em> and 0 otherwise.  Otherwise, return 0.”</li>
        <li>If 1/2 &lt; <em>c</em> &lt; 1, the algorithm requires rewriting the polynomial to Bernstein form, then elevating the degree of the rewritten polynomial enough times to bring its Bernstein coefficients in the closed unit interval; the required degree approaches infinity as <em>c</em> approaches 1.<sup id="fnref:14" role="doc-noteref"><a href="#fn:14" class="footnote" rel="footnote">14</a></sup></li>
      </ul>
    </li>
    <li>The <em>conditional</em> construction, mentioned in Flajolet et al. (2010)<sup id="fnref:1:2" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>, has the form $\lambda a[0] + (1-\lambda) a[1]$.  This is a degree-1 polynomial with variable <em>λ</em> and Bernstein coefficients <em>a</em>[0] and <em>a</em>[1]. It has the following algorithm: “Flip the <em>λ</em> input coin.  If the result is 0, flip the <em>a</em>[0] input coin and return the result.  Otherwise, flip the <em>a</em>[1] input coin and return the result.”  Special cases of the conditional construction include complement, mean, product, and logical OR; see “<a href="#Other_Factory_Functions"><strong>Other Factory Functions</strong></a>”.</li>
  </ol>
</blockquote>

<p> </p>

<p><strong>Multiple coins.</strong> Niazadeh et al. (2021)<sup id="fnref:15" role="doc-noteref"><a href="#fn:15" class="footnote" rel="footnote">15</a></sup> describes monomials (involving one or more coins) of the form <em>λ</em>[1]<sup><em>a</em>[1]</sup> * (1−<em>λ</em>[1])<sup><em>b</em>[1]</sup>*<em>λ</em>[2]<sup><em>a</em>[2]</sup> * (1−<em>λ</em>[2])<sup><em>b</em>[2]</sup>* … * <em>λ</em>[<em>n</em>]<sup><em>a</em>[<em>n</em>]</sup> * (1−<em>λ</em>[<em>n</em>])<sup><em>b</em>[<em>n</em>]</sup>, where there are <em>n</em> coins, <em>λ</em>[<em>i</em>] is the probability of heads of coin <em>i</em>, and <em>a</em>[<em>i</em>] ≥ 0 and <em>b</em>[<em>i</em>] ≥ 0 are parameters for coin <em>i</em> (specifically, of <em>a</em>+<em>b</em> flips, the first <em>a</em> flips must return heads and the rest must return tails to succeed).</p>

<ol>
  <li>For each <em>i</em> in [1, <em>n</em>]:
    <ol>
      <li>Flip the <em>λ</em>[<em>i</em>] input coin <em>a</em>[<em>i</em>] times.  If any of the flips returns 0, return 0.</li>
      <li>Flip the <em>λ</em>[<em>i</em>] input coin <em>b</em>[<em>i</em>] times.  If any of the flips returns 1, return 0.</li>
    </ol>
  </li>
  <li>Return 1.</li>
</ol>

<p>The same paper also describes polynomials that are weighted sums of this kind of monomials, namely polynomials of the form <em>P</em> = $\sum_{j=1}^k$ <em>c</em>[<em>j</em>]*<em>M</em>[<em>j</em>](<strong><em>λ</em></strong>), where there are <em>k</em> monomials, <em>M</em>[<em>j</em>](.) identifies monomial <em>j</em>, <strong><em>λ</em></strong> identifies the coins’ probabilities of heads, and <em>c</em>[<em>j</em>] ≥ 0 is the weight for monomial <em>j</em>.</p>

<p>Let <em>C</em> be the sum of all <em>c</em>[<em>j</em>].  To simulate the probability <em>P</em>/<em>C</em>, choose one of the monomials with probability proportional to its weight (see “<a href="https://peteroupc.github.io/randomfunc.html#Weighted_Choice_With_Replacement"><strong>Weighted Choice With Replacement</strong></a>”), then run the algorithm above on that monomial (see also “<a href="#Convex_Combinations"><strong>Convex Combinations</strong></a>”, later).</p>

<p>The following is a special case:</p>

<ul>
  <li>If there is only one coin, the polynomials <em>P</em> are in Bernstein form if <em>c</em>[<em>j</em>] is <em>α</em>[<em>j</em>]*choose(<em>k</em>−1, <em>j</em>−1) where <em>α</em>[<em>j</em>] is 0 or greater, but not greater than 1, and if <em>a</em>[1] = <em>j</em>−1 and <em>b</em>[1] = <em>k</em>−<em>j</em> for each monomial <em>j</em>.</li>
</ul>

<p><a id="Certain_Rational_Functions"></a></p>

<h4 id="certain-rational-functions">Certain Rational Functions</h4>

<p>A <em>rational function</em> is a ratio of polynomials.</p>

<p>According to Mossel and Peres (2005)<sup id="fnref:16" role="doc-noteref"><a href="#fn:16" class="footnote" rel="footnote">16</a></sup>, if a function <em>f</em>(<em>λ</em>) satisfies 0 &lt; <em>f</em>(<em>λ</em>) &lt; 1 whenever 0 &lt; <em>λ</em> &lt; 1, it can be simulated by a finite-state machine if and only if the function can be written as a rational function whose Bernstein coefficients are rational numbers.</p>

<p>The following algorithm is suggested from the Mossel and Peres paper and from (Thomas and Blanchet 2012)<sup id="fnref:12:1" role="doc-noteref"><a href="#fn:12" class="footnote" rel="footnote">12</a></sup>.  It assumes the rational function is written as <em>D</em>(<em>λ</em>)/<em>E</em>(<em>λ</em>), where—</p>

<ul>
  <li><em>D</em>(<em>λ</em>) = $\sum_{i=0}^n \lambda^i (1-\lambda)^{n-i} d[i]$,</li>
  <li><em>E</em>(<em>λ</em>) = $\sum_{i=0}^n \lambda^i (1-\lambda)^{n-i} e[i]$,</li>
  <li>every <em>d</em>[<em>i</em>] is less than or equal to the corresponding <em>e</em>[<em>i</em>], and</li>
  <li>each <em>d</em>[<em>i</em>] and each <em>e</em>[<em>i</em>] is an integer or rational number in the interval [0, choose(<em>n</em>, <em>i</em>)], where the upper bound is the total number of <em>n</em>-bit words with <em>i</em> ones.</li>
</ul>

<p>Here, <em>d</em>[<em>i</em>] is akin to the number of “passing” <em>n</em>-bit words with <em>i</em> ones, and <em>e</em>[<em>i</em>] is akin to that number plus the number of “failing” <em>n</em>-bit words with <em>i</em> ones.  (Because of the assumptions, <em>D</em> and <em>E</em> are polynomials that map the closed unit interval to itself.)</p>

<p>The algorithm follows.</p>

<ol>
  <li>Flip the input coin <em>n</em> times, and let <em>heads</em> be the number of times the coin returned 1 this way.</li>
  <li>Choose 0, 1, or 2 with probability proportional to these weights: [<em>e</em>[<em>heads</em>] − <em>d</em>[<em>heads</em>], <em>d</em>[<em>heads</em>], choose(<em>n</em>, <em>heads</em>) − <em>e</em>[<em>heads</em>]].  If 0 or 1 is chosen this way, return it.  Otherwise, go to step 1.</li>
</ol>

<blockquote>
  <p><strong>Notes:</strong></p>

  <ol>
    <li>
      <p>In the formulas above—</p>

      <ul>
        <li><em>d</em>[<em>i</em>] can be replaced with <em>δ</em>[<em>i</em>] * choose(<em>n</em>,<em>i</em>), where <em>δ</em>[<em>i</em>] is a rational number in the interval [0, 1] (and thus expresses the probability that a given word is a “passing” word among all <em>n</em>-bit words with <em>i</em> ones), and</li>
        <li><em>e</em>[<em>i</em>] can be replaced with <em>η</em>[<em>i</em>] * choose(<em>n</em>,<em>i</em>), where <em>η</em>[<em>i</em>] is a rational number in the interval [0, 1] (and thus expresses the probability that a given word is a “passing” or “failing” word among all <em>n</em>-bit words with <em>i</em> ones),</li>
      </ul>

      <p>and then <em>δ</em>[<em>i</em>] and <em>η</em>[<em>i</em>] can be seen as control points for two different 1-dimensional <a href="https://en.wikipedia.org/wiki/Bézier_curve"><strong>Bézier curves</strong></a>, where the <em>δ</em> curve is always on or “below” the <em>η</em> curve.  For each curve, <em>λ</em> is the relative position on that curve, the curve begins at  <em>δ</em>[0] or <em>η</em>[0], and the curve ends at <em>δ</em>[<em>n</em>] or <em>η</em>[<em>n</em>]. See also the next section.</p>
    </li>
    <li>This algorithm could be modified to avoid additional randomness besides the input coin flips by packing the coin flips into an <em>n</em>-bit word and looking up whether that word is “passing”, “failing”, or neither, among all <em>n</em>-bit words with <em>j</em> ones, but this can be impractical (in general, a lookup table of size 2<sup>n</sup> first has to be built in a setup step; as <em>n</em> grows, the table size grows exponentially).  Moreover, this approach works only if <em>d</em>[<em>i</em>] and <em>e</em>[<em>i</em>] are integers (or if <em>d</em>[<em>i</em>] is replaced with floor(<em>d</em>[<em>i</em>]) and <em>e</em>[<em>i</em>] with ceil(<em>e</em>[<em>i</em>]) (Nacu and Peres 2005)<sup id="fnref:17" role="doc-noteref"><a href="#fn:17" class="footnote" rel="footnote">17</a></sup>, but this suffers from rounding error when done in this algorithm for simulating rational numbers).  See also (Thomas and Blanchet 2012)<sup id="fnref:12:2" role="doc-noteref"><a href="#fn:12" class="footnote" rel="footnote">12</a></sup>.</li>
    <li>In the formulas above, <em>e</em>[<em>i</em>] can be replaced with choose(<em>n</em>,<em>i</em>).  In that case, the algorithm will simulate a polynomial equal to <em>D</em>, and the values <em>d</em>[0], …, <em>d</em>[<em>n</em>] are the polynomial’s coefficients in <em>homogeneous form</em>, also known as <em>scaled Bernstein form</em> (Farouki and Rajan 1988)<sup id="fnref:18" role="doc-noteref"><a href="#fn:18" class="footnote" rel="footnote">18</a></sup>.</li>
  </ol>

  <p><strong>Example</strong>: Take the function <em>f</em>(<em>λ</em>) = 1/(<em>λ</em>−2)<sup>2</sup>.  This is a rational function, in this case a ratio of two polynomials that are both nonnegative on the closed unit interval.  One algorithm to simulate this function follows.<br />(1) Flip the input coin twice, and let <em>heads</em> be the number of times the coin returned 1 this way.<br />(2) Depending on <em>heads</em>, choose 0, 1, or 2 with probability proportional to the following weights: <em>heads</em>=0 → [3, 1, 0], <em>heads</em>=1 → [1, 1, 2], <em>heads</em>=2 → [0, 1, 3]; if 0 or 1 is chosen this way, return it; otherwise, go to step 1.<br />Here is how <em>f</em> was prepared to derive this algorithm:<br />(1) Take the numerator 1, and the denominator (<em>λ</em>−2)<sup>2</sup>.  Rewrite the denominator as 1*<em>λ</em><sup>2</sup> − 4*<em>λ</em> + 4.<br />(2) Rewrite the numerator and denominator into homogeneous polynomials (polynomials whose terms have the same degree) of degree 2; see the “homogenizing” section in “<a href="#Preparing_Rational_Functions"><strong>Preparing Rational Functions</strong></a>”.  The result has homogeneous coefficients (1, 2, 1) and (4, 4, 1) respectively.<br />(3) Divide both polynomials (actually their homogeneous coefficients) by the same value so that both polynomials are 1 or less.  An easy (but not always best) choice is to divide them by their maximum homogeneous coefficient, which is 4 in this case.  The result is <em>d</em> = (1/4, 1/2, 1/4), <em>e</em> = (1, 1, 1/4).<br />(4) Prepare the weights as given in step 2 of the original algorithm.  The result is [3/4, 1/4, 0], [1/2, 1/2, 1], and [0, 1/4, 3/4], for different counts of heads.  Because the weights in this case are multiples of 1/4, they can be simplified to integers without affecting the algorithm: [3, 1, 0], [1, 1, 2], [0, 1, 3], respectively.</p>
</blockquote>

<p><strong>“Dice Enterprise” special case.</strong> The following algorithm implements a special case of the “Dice Enterprise” method of Morina et al. (2022)<sup id="fnref:19" role="doc-noteref"><a href="#fn:19" class="footnote" rel="footnote">19</a></sup>.  The algorithm returns one of <em>m</em> outcomes (namely <em>X</em>, an integer in [0, <em>m</em>)) with probability <em>P</em><sub><em>X</em></sub>(<em>λ</em>) / (<em>P</em><sub>0</sub>(<em>λ</em>) + <em>P</em><sub>1</sub>(<em>λ</em>) + … + <em>P</em><sub><em>m</em>−1</sub>(<em>λ</em>)), where <em>λ</em> is the input coin’s probability of heads and <em>m</em> is 2 or greater.  Specifically, the probability is a <em>rational function</em>, or ratio of polynomials.  Here, all the <em>P</em><sub><em>k</em></sub>(<em>λ</em>) are in the form of polynomials as follows:
- The polynomials are <em>homogeneous</em>, that is, they are written as $\sum_{i=0}^n$ <em>λ</em><sup><em>i</em></sup> * (1 − <em>λ</em>)<sup><em>n</em> − <em>i</em></sup> * <em>a</em>[<em>i</em>], where <em>n</em> is the polynomial’s degree and <em>a</em>[<em>i</em>] is a <em>homogeneous coefficient</em>.
- The polynomials have the same degree (namely <em>n</em>) and all its homogeneous coefficients are 0 or greater.
- The sum of <em>j</em><sup>th</sup> homogeneous coefficients is greater than 0, for each <em>j</em> starting at 0 and ending at <em>n</em>, except that the list of sums may begin with zeros, end with zeros, or both.  Call this list <em>R</em>.  For example, this condition holds true if <em>R</em> is (2, 4, 4, 2) or (0, 2, 4, 0), but not if <em>R</em> is (2, 0, 4, 3).</p>

<p>Any rational function that admits a Bernoulli factory can be brought into the form just described, as detailed in the appendix under “<a href="#Preparing_Rational_Functions"><strong>Preparing Rational Functions</strong></a>”.  In this algorithm, let <em>R</em>[<em>j</em>] be the sum of <em>j</em><sup>th</sup> homogeneous coefficients of the polynomials (with <em>j</em> starting at 0).  First, define the following operation:</p>

<ul>
  <li><strong>Get the new state given <em>state</em>, <em>b</em>, <em>u</em>, and <em>n</em></strong>:
    <ol>
      <li>If <em>state</em> &gt; 0 and <em>b</em> is 0, return either <em>state−1</em> if <em>u</em> is less than (or equal to) <em>PA</em>, or <em>state</em> otherwise, where <em>PA</em> is <em>R</em>[<em>state</em>−1]/max(<em>R</em>[<em>state</em>], <em>R</em>[<em>state</em>−1]).</li>
      <li>If <em>state</em> &lt; <em>n</em> and <em>b</em> is 1, return either <em>state+1</em> if <em>u</em> is less than (or equal to) <em>PB</em>, or <em>state</em> otherwise, where <em>PB</em> is <em>R</em>[<em>state</em>+1]/max(<em>R</em>[<em>state</em>], <em>R</em>[<em>state</em>+1]).</li>
      <li>Return <em>state</em>.</li>
    </ol>
  </li>
</ul>

<p>Then the algorithm is as follows:</p>

<ol>
  <li>Create two empty lists: <em>blist</em> and <em>ulist</em>.</li>
  <li>Set <em>state1</em> to the position of the first non-zero item in <em>R</em>.  Set <em>state2</em> to the position of the last non-zero item in <em>R</em>.  In both cases, positions start at 0.  If all the items in <em>R</em> are zeros, return 0.</li>
  <li>Flip the input coin and append the result (which is 0 or 1) to the end of <em>blist</em>.  Generate a uniform random variate between 0 and 1 and append it to the end of <em>ulist</em>.</li>
  <li>(Monotonic coupling from the past (Morina et al., 2022)<sup id="fnref:19:1" role="doc-noteref"><a href="#fn:19" class="footnote" rel="footnote">19</a></sup>, (Propp and Wilson 1996)<sup id="fnref:20" role="doc-noteref"><a href="#fn:20" class="footnote" rel="footnote">20</a></sup>.) Set <em>i</em> to the number of items in <em>blist</em> minus 1, then while <em>i</em> is 0 or greater:
    <ol>
      <li>Let <em>b</em> be the item at position <em>i</em> (starting at 0) in <em>blist</em>, and let <em>u</em> be the item at that position in <em>ulist</em>.</li>
      <li><strong>Get the new state given <em>state1</em>, <em>b</em>, <em>u</em>, and <em>n</em></strong>, and set <em>state1</em> to the new state.</li>
      <li><strong>Get the new state given <em>state2</em>, <em>b</em>, <em>u</em>, and <em>n</em></strong>, and set <em>state2</em> to the new state.</li>
      <li>Subtract 1 from <em>i</em>.</li>
    </ol>
  </li>
  <li>If <em>state1</em> and <em>state2</em> are not equal, go to step 2.</li>
  <li>Let  <em>b</em>(<em>j</em>) be the value of <em>a</em>[<em>state1</em>] for the polynomial for <em>j</em>. Choose an integer in [0, <em>m</em>) with probability proportional to these weights: [<em>b</em>(0), <em>b</em>(1), …, <em>b</em>(<em>m</em>−1)].  Then return the chosen integer.</li>
</ol>

<blockquote>
  <p><strong>Notes:</strong></p>

  <ol>
    <li>If there are only two outcomes, then this is the special Bernoulli factory case; the algorithm would then return 1 with probability <em>P</em><sub>1</sub>(<em>λ</em>) / (<em>P</em><sub>0</sub>(<em>λ</em>) + <em>P</em><sub>1</sub>(<em>λ</em>)).</li>
    <li>If <em>R</em>[<em>j</em>] = choose(<em>n</em>, <em>j</em>), steps 1 through 5 have the same effect as counting the number of ones from <em>n</em> input coin flips (which would be stored in <em>state1</em> in this case), but unfortunately, these steps wouldn’t be more efficient.  In this case, <em>PA</em> is equivalent to “1 if <em>state</em> is greater than floor(<em>n</em>/2), and <em>state</em>/(<em>n</em>+1−<em>state</em>) otherwise”, and <em>PB</em> is equivalent to “1 if <em>state</em> is less than floor(<em>n</em>/2), and (<em>n</em>−<em>state</em>)/(<em>state</em>+1) otherwise”.</li>
  </ol>

  <p><strong>Example:</strong> Let <em>P</em><sub>0</sub>(<em>λ</em>) = 2*<em>λ</em>*(1−<em>λ</em>) and <em>P</em><sub>1</sub>(<em>λ</em>) = (4*<em>λ</em>*(1−<em>λ</em>))<sup>2</sup>/2.  The goal is to produce 1 with probability <em>P</em><sub>1</sub>(<em>λ</em>) / (<em>P</em><sub>0</sub>(<em>λ</em>) + <em>P</em><sub>1</sub>(<em>λ</em>)). <a href="#Preparing_Rational_Functions"><strong>Preparing this function</strong></a> (along with noting that the maximum degree is <em>n</em> = 4) results in the coefficient sums <em>R</em> = (0, 2, 12, 2, 0).  Since <em>R</em> begins and ends with 0, step 2 of the algorithm sets <em>state1</em> and <em>state2</em>, respectively, to the position of the first or last nonzero item, namely 1 or 3.  (Alternatively, because <em>R</em> begins and ends with 0, a third polynomial is included, namely the constant <em>P</em><sub>2</sub>(<em>λ</em>) = 0.001, so that the new coefficient sums would be <em>R′</em> = (0.001, 10.004, 12.006, 2.006, 0.001) [formed by adding 0.001*choose(<em>n</em>, <em>i</em>) to the sum at <em>i</em>, starting at <em>i</em> = 0].  Now run the algorithm using <em>R′</em>, and if it returns 2 [meaning that the constant polynomial was chosen], try again until the algorithm no longer returns 2.)</p>
</blockquote>

<p><a id="Certain_Power_Series"></a></p>

<h4 id="certain-power-series">Certain Power Series</h4>

<p>Some functions can be written as—</p>

\[f(\lambda) = a_0 (g(\lambda))^0 + a_1 (g(\lambda))^1 + ... + a_i (g(\lambda))^i + ...,\tag{1}\]

<p>where $a_i$ are <em>power coefficients</em> and $g(\lambda)$ is a function in the variable $\lambda$.  The right-hand side of (1) is called a <em>power series</em> as long as $g(\lambda) = \lambda$.  A function writable as (1) will be called a <em>generalized power series</em> here. Not all power series sum to a definite value, but all generalized power series that matter in this section do, and they must be Bernoulli factory functions.  (In particular, $g(\lambda)$ must be a Bernoulli factory function, too.)</p>

<p>Depending on the power coefficients, different algorithms can be built to simulate a generalized power series:</p>

<ul>
  <li>The power coefficients are arbitrary, but can be split into two parts.</li>
  <li>The power coefficients alternate in sign and decrease in their <em>absolute values</em> (their values without regard to sign).</li>
  <li>The power coefficients are nonnegative and sum to 1 or less.</li>
  <li>The power coefficients are nonnegative and may sum to 1 or greater.</li>
</ul>

<blockquote>
  <p><strong>Note:</strong> In theory, the series (1) can contain power coefficients that are irrational numbers or sum to an irrational number, but the algorithms for such series can be inexact in practice.  Also, not all generalized power series that admit a Bernoulli factory are covered by the algorithms in this section.  They include:</p>

  <ul>
    <li>Series with power coefficients that alternate in sign, but do not satisfy the <strong>general martingale algorithm</strong> or <strong>Algorithm 1</strong> below.  This includes nearly all such series that equal 0 at 0 and 1 at 1, or equal 0 at 1 and 1 at 0. (An example is $\sin(\lambda\pi/2)$.)</li>
    <li>Series with negative and positive power coefficients that do not eventually alternate in sign (ignoring zeros).</li>
  </ul>
</blockquote>

<p><strong><em>Certain Alternating Series</em></strong>:</p>

<p>Suppose the following holds true for a generalized power series $f(\lambda)$:</p>

<ul>
  <li>$f$ is written as in equation $(1)$.</li>
  <li>Suppose $(a_i)$ is the sequence formed from the power coefficients.</li>
  <li>Let $(d_j)$ be the sequence formed from $(a_i)$ by deleting the zeros from $(a_i)$.  Then suppose that:
    <ul>
      <li>$d_0$ is greater than 0, and the elements in $(d_j)$ alternate in sign (example: 1/2, −1/3, 1/4, −1/5, …).</li>
      <li>The absolute values of $(d_j)$’s elements are 1 or less and form a nowhere increasing sequence that is finite or converges to 0.</li>
    </ul>
  </li>
</ul>

<p>In addition, the power coefficients should be rational numbers.</p>

<blockquote>
  <p><strong>Example:</strong> Let $f(\lambda) = (1/2)\lambda^0 - (1/4)\lambda^2 + (1/8)\lambda^4 - …$.  Then $(a_i) = (1/2, 0, -1/4, 0, 1/8, …)$ (for example, $a_0 = 1/2$) and deleting the zeros leads to $(d_i) = (1/2, -1/4, 1/8, …)$  (for example, $d_0 = 1/2$), which meets the requirements above.</p>
</blockquote>

<p>Then the algorithm below, based on an algorithm by Łatuszyński et al. (2009/2011, especially section 3.1)<sup id="fnref:21" role="doc-noteref"><a href="#fn:21" class="footnote" rel="footnote">21</a></sup>, returns 1 with probability $f(\lambda)$ given a coin that shows heads (returns 1) with probability $g(\lambda)$.</p>

<p><strong>General martingale algorithm:</strong></p>

<ol>
  <li>Set <em>u</em> to abs($d_0$) ($d_0$ is the value of the first nonzero power coefficient in the sequence $(a_i)$), set <em>w</em> to 1, set <em>ℓ</em> to 0, and set <em>n</em> to 1.</li>
  <li>Generate a uniform random variate between 0 and 1 <em>ret</em>.</li>
  <li>Do the following process repeatedly, until this algorithm returns a value:
    <ol>
      <li>If <em>w</em> is not 0, run a Bernoulli factory algorithm for $g(\lambda)$ (if $g(\lambda) = \lambda$, this is done by flipping the input coin), then multiply <em>w</em> by the result of the run.</li>
      <li>If $a_n$ is greater than 0: Set <em>u</em> to <em>ℓ</em> + <em>w</em> * $a_n$, then, if no further nonzero power coefficients follow $a_n$, set <em>ℓ</em> to <em>u</em>.</li>
      <li>If $a_n$ is less than 0: Set <em>ℓ</em> to <em>u</em> − <em>w</em> * abs($a_n$), then, if no further nonzero power coefficients follow $a_n$, set <em>u</em> to <em>ℓ</em>.</li>
      <li>If <em>ret</em> is less than (or equal to) <em>ℓ</em>, return 1.  Otherwise, if <em>ret</em> is less than <em>u</em>, add 1 to <em>n</em>.  Otherwise, return 0.  (If <em>ret</em> is a uniform partially-sampled random number [PSRN], these comparisons should be done via the <strong>URandLessThanReal algorithm</strong>, which is described in my <a href="https://peteroupc.github.io/exporand.html"><strong>article on PSRNs</strong></a>.)</li>
    </ol>
  </li>
</ol>

<blockquote>
  <p><strong>Note:</strong> The <strong>general martingale algorithm</strong>, as it’s called in this article, supports more functions than in section 3.1 of Łatuszyński et al. (2019/2011), which supports only functions writable as a power series whose power coefficients alternate in sign and decrease in absolute value, with no zeros in between nonzero power coefficients.  However, the general martingale algorithm uses that paper’s framework.  A proof of its correctness is given in the appendix.</p>
</blockquote>

<p><strong><em>General Power Series</em></strong>:</p>

<p>Suppose the following for a generalized power series $f(\lambda)$:</p>

<ul>
  <li>$f$ is written as in equation $(1)$.</li>
  <li>There is a rational number $Z$ defined as follows. For every $\lambda$ that satisfies $0 \le \lambda \le 1$, it is true that $0 \le f(\lambda) \le Z \lt 1$.</li>
  <li>
    <p>There is an even integer $m$ defined as follows. The series in equation $(1)$ can be split into two parts: the first part ($A$) is the sum of the first $m$ terms, and the second part ($C$) is the sum of the remaining terms.  Moreover, both parts admit a Bernoulli factory algorithm (see “<a href="https://peteroupc.github.io/bernoulli.html#About_Bernoulli_Factories"><strong>About Bernoulli Factories</strong></a>”).  Specifically:</p>

\[C(\lambda) = \sum_{i\ge m} a_i (g(\lambda))^i, A(\lambda) = f(\lambda) - C(\lambda).\]

    <p>As an example, if $C$ is a generalized power series described in the section “Certain Alternating Series”, above, then $C$ admits a Bernoulli factory algorithm, namely the <strong>general martingale algorithm</strong>.</p>
  </li>
</ul>

<p>In addition, the algorithm will be simpler if each power coefficient $a_i$ is a rational number.</p>

<p>Then rewrite the function as—</p>

<p>\(f(\lambda) = A(\lambda) + (g(\lambda))^{m} B(\lambda),\)
where—</p>

<ul>
  <li>$A(\lambda) = f(\lambda) - C(\lambda) = \sum_{i=0}^{m-1} a_i (g(\lambda))^i$ is a polynomial in $g(\lambda)$ of degree $m-1$, and</li>
  <li>$B(\lambda) = C(\lambda) / (g(\lambda))^{m} = \sum_{i\ge m} a_{m+i} (g(\lambda))^i$.</li>
</ul>

<p>Rewrite $A$ as a polynomial in Bernstein form, in the variable $g(\lambda)$. (One way to transform a polynomial from power form to Bernstein form, given the power coefficients $a_0, …, a_{m-1}$, is the so-called “matrix method” from Ray and Nataraj (2012)<sup id="fnref:13:1" role="doc-noteref"><a href="#fn:13" class="footnote" rel="footnote">13</a></sup>.)  Let $b_0, …, b_{m-1}$ be the polynomial’s Bernstein coefficients.  Then if those coefficients all lie on the closed unit interval, then the following algorithm simulates $f(\lambda)$.</p>

<p><strong>Algorithm 1:</strong> Run a <a href="https://peteroupc.github.io/bernoulli.html#Linear_Bernoulli_Factories"><strong>linear Bernoulli factory</strong></a>, with parameters $x=2$, $y=1$, and $\epsilon=1-Z$.  Whenever the linear Bernoulli factory “flips the input coin”, it runs the sub-algorithm below.</p>

<ul>
  <li><strong>Sub-algorithm:</strong> Generate 1 or 0 with equal probability.  If that bit is 1, sample the polynomial $A$ as follows (Goyal and Sigman (2012)<sup id="fnref:7:1" role="doc-noteref"><a href="#fn:7" class="footnote" rel="footnote">7</a></sup>):
    <ol>
      <li>Run a Bernoulli factory algorithm for $g(\lambda)$, $m-1$ times.  Let $j$ be the number of runs that return 1.</li>
      <li>With probability $b_j$, return 1.  Otherwise, return 0.</li>
    </ol>

    <p>If the bit is 0, do the following:</p>

    <ol>
      <li>Run a Bernoulli factory algorithm for $g(\lambda)$, $m$ times.  Return 0 if any of the runs returns 0.</li>
      <li>Run a Bernoulli factory algorithm for $B(\lambda)$, and return the result.</li>
    </ol>
  </li>
</ul>

<p><strong><em>Series with Non-Negative Power Coefficients Summing to 1 or Less</em></strong>:</p>

<p>Now, suppose $f(\lambda)$ can be written as in equation $(1)$, at the beginning of this section, but this time, the <em>power coefficients</em> $a_i$ are 0 or greater and their sum is 1 or less.</p>

<p>If $g(\lambda) = \lambda$, this kind of function—</p>

<ul>
  <li>satisfies $0\le f(\lambda)\le 1$ whenever 0 ≤ <em>λ</em> ≤ 1,</li>
  <li>is either constant or strictly increasing, and</li>
  <li>is <em>convex</em> (its “slope” or “velocity” doesn’t decrease as <em>λ</em> increases; for a proof, see Lemma A1 in “<a href="https://peteroupc.github.io/bernapprox.html"><strong>Approximations in Bernstein Form</strong></a>”).</li>
</ul>

<p>In addition, suppose $f$ can be written as $f(\lambda)= f_0(g(\lambda))$, where—</p>

<p>\(f_0(\lambda) = \sum_{n} a_n \lambda^n = \sum_{n} w(n) \frac{a_n}{w(n)}\lambda^n,\)
where each sum is taken over all nonnegative values of $n$ where $a_n &gt; 0$. (For notation details, see “<a href="#Implementation_Notes"><strong>Implementation Notes</strong></a>”.)</p>

<p>Then the key to simulating $f(\lambda)$ is to “tuck” the values $a_n$ under a function $w(n)$ such that—</p>

<ul>
  <li>$1 \ge w(n)\ge a_n\ge 0$ for every allowed <em>n</em>, and</li>
  <li>$w(0)+w(1)+…=1$ (required for a valid distribution of integers 0 or greater).</li>
</ul>

<blockquote>
  <p><strong>Notes:</strong></p>

  <ol>
    <li>Assuming $f_0(1)$ does not equal 0, an appropriate $w(n)$ is trivial to find — $w(n)=a_n/f_0(1)$ (because $a_n \le f_0(1)$ for every allowed $n$).  But in general, this can make $w(n)$ an irrational number and thus harder to handle with arbitrary precision.</li>
    <li>If the power coefficients $a_n$ sum to 1, then $w(n)$ can equal $a_n$.  In this case, $f_0(\lambda)$ is what’s called the <em>probability generating function</em> for getting $X$ with probability $a_X$ (or $w(X)$), and the expected value (“long-run average”) of $X$ equals the “slope” of $f_0(\lambda)$ at 1.  See also (Dughmi et al. 2021)<sup id="fnref:22" role="doc-noteref"><a href="#fn:22" class="footnote" rel="footnote">22</a></sup>.</li>
    <li>Assuming $f_0(1)$ is an irrational number, $w(n)$ can equal $a_n + c_n/2^n$, where $c_n$ is the $n$-th base-2 digit after the point in the binary expansion of $1 - f_0(1)$ (or 0 if $n=0$).  Here, a number’s <em>binary expansion</em> is written as <code>0.bbbbb...</code> in base 2, where each <code>b</code> is a base-2 digit (either 0 or 1).  See my <a href="https://math.stackexchange.com/questions/4495216"><strong>Stack Exchange question</strong></a>.</li>
  </ol>
</blockquote>

<p>Once $a_n$ and $w(n)$ are found, the function $f(\lambda)$ can be simulated using the following algorithm, which takes advantage of the <a href="https://peteroupc.github.io/bernoulli.html#Convex_Combinations"><strong>convex combination method</strong></a>.</p>

<p><strong>Algorithm 2:</strong></p>

<ol>
  <li>Choose at random an integer <em>n</em> that equals <em>i</em> with probability $w(i)$.</li>
  <li>(The next two steps succeed with probability $\frac{a_n}{w(n)} (g(\lambda))^n$.) Let <em>P</em> be $a_n/w(n)$.  With probability <em>P</em>, go to the next step.  Otherwise, return 0.</li>
  <li>(At this point, <em>n</em> equals <em>i</em> with probability $a_i$.) Run a Bernoulli factory algorithm for $g(\lambda)$, <em>n</em> times or until a run returns 0, whichever happens first. (For example, if $g(\lambda)=\lambda$, flip the input coin each time.)  Return 1 if all the runs, including the last, returned 1 (or if <em>n</em> is 0).  Otherwise, return 0.</li>
</ol>

<p>Step 1 is rather general, and doesn’t fully describe how to generate the value $n$ at random.  That depends on the function $w(n)$.  See “<a href="#Power_Series_Examples"><strong>Power Series Examples</strong></a>”, later, for examples of generalized power series $f(\lambda)$ that can be simulated using Algorithm 2.</p>

<blockquote>
  <p><strong>Note:</strong> Part of <strong>Algorithm 2</strong> involves choosing $X$ at random with probability $w(X)$, then doing $X$ coin flips.  Thus, the algorithm uses, on average, at least the number of fair coin flips needed to generate $X$ on average (Knuth and Yao 1976)<sup id="fnref:23" role="doc-noteref"><a href="#fn:23" class="footnote" rel="footnote">23</a></sup>.</p>
</blockquote>

<p><strong>Algorithm 2</strong> covers an algorithm that was given by Luis Mendo (2019)<sup id="fnref:24" role="doc-noteref"><a href="#fn:24" class="footnote" rel="footnote">24</a></sup> for simulating certain functions writable as power series, but that works only if the power coefficients ($a_n$) sum to 1 or less and only if $a_0$ is 0.</p>

<p>To get to an algorithm equivalent to Mendo’s, first <strong>Algorithm 2</strong> is modified to simulate $f_0(\lambda)$/<em>CS</em> as follows, where <em>CS</em> is the sum of all power coefficients $a_i$, starting with $i=1$.  This shows Mendo’s algorithm, like <strong>Algorithm 2</strong>, is actually a special case of the <a href="https://peteroupc.github.io/bernoulli.html#Convex_Combinations"><strong>convex combination algorithm</strong></a>.</p>

<ul>
  <li>Step 1 of <strong>Algorithm 2</strong> becomes: “(1a.) Set <em>dsum</em> to 0 and $n$ to 1; (1b.) With probability $a_n$/(<em>CS</em> − <em>dsum</em>), go to step 2. Otherwise, add $a_n$ to <em>dsum</em>; (1c.) Add 1 to <em>i</em> and go to step 1b.” (Choose at random $n$ with probability $w(n)=a_n$/<em>CS</em>.)</li>
  <li>Step 2 becomes “Go to step 3”. (The <em>P</em> in <strong>Algorithm 2</strong> is not used; it’s effectively $w(n)/\frac{a_n}{CS}=\frac{a_n}{CS}/\frac{a_n}{CS} = 1$.)</li>
  <li>In step 3, $g(\lambda)$ is either $\lambda$ (flip the input coin) or $1-\lambda$ (flip the input coin and take 1 minus the flip).</li>
</ul>

<p>Mendo’s algorithm and extensions of it mentioned by him cover several variations of functions writable as power series as follows:</p>

<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Power Series</th>
      <th>Algorithm</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>$f(\lambda)=1-f_0(1-\lambda)$</td>
      <td>With probability <em>CS</em>, run the modified algorithm with $g(\lambda)=1-\lambda$ and return 1 minus the result.  Otherwise, return 1.</td>
    </tr>
    <tr>
      <td>2</td>
      <td>$f(\lambda)=f_0(1-\lambda)$</td>
      <td>With probability <em>CS</em>, run the modified algorithm with $g(\lambda)=1-\lambda$ and return the result.  Otherwise, return 0.</td>
    </tr>
    <tr>
      <td>3</td>
      <td>$f(\lambda)=f_0(\lambda)$</td>
      <td>With probability <em>CS</em>, run the modified algorithm with $g(\lambda)=\lambda$ and return the result.  Otherwise, return 0.</td>
    </tr>
    <tr>
      <td>4</td>
      <td>$f(\lambda)=1-f_0(\lambda)$</td>
      <td>With probability <em>CS</em>, run the modified algorithm with $g(\lambda)=\lambda$ and return 1 minus the result.  Otherwise, return 1.</td>
    </tr>
  </tbody>
</table>

<p>The conditions on $f$ given above mean that—</p>

<ul>
  <li>for series of type 1, <em>f</em>(0) = 1−<em>CS</em> and <em>f</em>(1) = 1 (series of type 1 with <em>CS</em>=1 is the main form in Mendo’s paper),</li>
  <li>for series of type 2, <em>f</em>(0) = <em>CS</em> and <em>f</em>(1) = 0,</li>
  <li>for series of type 3, <em>f</em>(0) = 0 and <em>f</em>(1) = <em>CS</em>, and</li>
  <li>for series of type 4, <em>f</em>(0) = 1 and <em>f</em>(1) = 1−<em>CS</em>.</li>
</ul>

<p><strong><em>Series with General Non-Negative Power Coefficients</em></strong>:</p>

<p>If $f$ is written as equation (1), in the beginning of this section, but—</p>

<ul>
  <li>each of the power coefficients is positive or zero, and</li>
  <li>the power coefficients sum to greater than 1,</li>
</ul>

<p>then Nacu and Peres (2005, proposition 16)<sup id="fnref:21:1" role="doc-noteref"><a href="#fn:21" class="footnote" rel="footnote">21</a></sup> gave an algorithm which takes the following parameters:</p>

<ul>
  <li><em>t</em> is a rational number such that <em>B</em> &lt; <em>t</em> ≤ 1 and  <em>f</em>(<em>t</em>) &lt; 1.</li>
  <li><em>ϵ</em> is a rational number such that 0 &lt; <em>ϵ</em> ≤ (<em>t</em> − <em>B</em>)/2.</li>
</ul>

<p><em>B</em> is not a parameter, but is the maximum allowed value for $g(\lambda)$ (probability of heads), and is greater than 0 and less than 1.  The following algorithm is based on that algorithm, but runs a Bernoulli factory for $g(\lambda)$ instead of flipping the input coin with probability of heads $\lambda$.</p>

<ol>
  <li>Create a <em>ν</em> input coin that does the following: “(1) Set <em>n</em> to 0. (2) With probability <em>ϵ</em>/<em>t</em>, go to the next substep.  Otherwise, add 1 to <em>n</em> and repeat this substep. (3) With probability 1 − $a_n\cdot t^n$, return 0. (4) Run a <a href="https://peteroupc.github.io/bernoulli.html#Linear_Bernoulli_Factories"><strong>linear Bernoulli factory</strong></a> <em>n</em> times, with parameters <em>x</em>/<em>y</em> = 1/(<em>t</em> − <em>ϵ</em>), and <em>ϵ</em> = <em>ϵ</em>.  If the linear Bernoulli factory would flip the input coin, the coin is ‘flipped’ by running a Bernoulli factory for $g(\lambda)$.  If any run of the linear Bernoulli factory returns 0, return 0.  Otherwise, return 1.”</li>
  <li>Run a <a href="https://peteroupc.github.io/bernoulli.html#Linear_Bernoulli_Factories"><strong>linear Bernoulli factory</strong></a> once, using the <em>ν</em> input coin described earlier, with parameters <em>x</em>/<em>y</em> = <em>t</em>/<em>ϵ</em>, and <em>ϵ</em> = <em>ϵ</em>, and return the result.</li>
</ol>

<p><strong><em>Power Series Examples</em></strong>:</p>

<p>Examples 1 to 4 show how <strong>Algorithm 1</strong> leads to algorithms for simulating certain factory functions.</p>

<blockquote>
  <p><strong>Note:</strong> In the SymPy computer algebra library, the <code>series(func, x, n=20)</code> method computes the terms of a function’s power series up to the term with $x^{19}$.  An example is: <code>series(sin(x), x, n=20)</code>.</p>
</blockquote>

<p><strong>Example 1:</strong> Take $f(\lambda) = \sin(3\lambda)/2$, which is writable as a power series.</p>

<ul>
  <li>$f$ is less than or equal to $Z=1/2 \lt 1$.</li>
  <li>$f$ satisfies $m=8$ since splitting the series at 8 leads to two functions that admit Bernoulli factories.</li>
  <li>Thus, $f$ can be written as—</li>
</ul>

<p>\(f(\lambda) = A(\lambda) + \lambda^m \left(\sum_{i\ge 0} a_{m+i} \lambda^i\right),\)
where $m=8$, and where $a_i = \frac{3^i}{i! \times 2}(-1)^{(i-1)/2}$ if $i$ is odd and 0 otherwise.
- $A$ has power coefficients $a_0, …, a_{m-1}$.  Those power coefficients are transformed to the following <em>Bernstein coefficients</em>, in order: [0, 3/14, 3/7, 81/140, 3/5, 267/560, 81/280, 51/1120].
- Now, <strong>Algorithm 1</strong> can be used to simulate $f$ given a coin that shows heads (returns 1) with probability $\lambda$, where:
    - $g(\lambda) = \lambda$, so the Bernoulli factory algorithm for $g(\lambda)$ is simply to flip the coin for $\lambda$.
    - The values $b_0, …, b_{m-1}$, in order, are $A$’s Bernstein coefficients.
    - The Bernoulli factory algorithm for $B(\lambda)$ is as follows: Let $h_i = a_i$.  Then run the <strong>general martingale algorithm</strong> with $g(\lambda) = \lambda$ and $a_i = h_{m+i}$.</p>

<p><strong>Example 2:</strong> Take $f(\lambda) = 1/2 + \sin(6\lambda)/4$, rewritable as another power series.  This is as in Example 1, except:</p>

<ul>
  <li>$f$ is less than or equal to $Z=3/4 \lt 1$.</li>
  <li>$f$ satisfies $m=16$ since splitting the series at 16 leads to two functions that admit Bernoulli factories.</li>
  <li>$a_i$ is $1/2$ if $i = 0$; $\frac{6^i}{i! \times 4}(-1)^{(i-1)/2}$ if $i$ is odd; and 0 otherwise.</li>
  <li>The Bernstein coefficients of $A$, in order, are [1/2, 3/5, 7/10, 71/91, 747/910, 4042/5005, 1475/2002, 15486/25025, 167/350, 11978/35035, 16869/70070, 167392/875875, 345223/1751750, 43767/175175, 83939/250250, 367343/875875].</li>
</ul>

<p><strong>Example 3:</strong> Take $f(\lambda) = 1/2 + \cos(6\lambda)/4$.  This is as in Example 1, except:</p>

<ul>
  <li>$Z=3/4$ and $m=16$.</li>
  <li>$a_i$ is $3/4$ if $i = 0$; $\frac{6^i}{i! \times 4}(-1)^{i/2}$ if $i$ is even and greater than 0; and 0 otherwise.</li>
  <li>The Bernstein coefficients of $A$, in order, are [3/4, 3/4, 255/364, 219/364, 267/572, 1293/4004, 4107/20020, 417/2860, 22683/140140, 6927/28028, 263409/700700, 2523/4900, 442797/700700, 38481/53900, 497463/700700].</li>
</ul>

<p><strong>Example 4:</strong> Take $f(\lambda) = 1/2 + \sin(\pi\lambda)/4$ = $1/2 + \sin(6 g(\lambda))/4$, where $g(\lambda)=\lambda\pi/6$.  To simulate this probability:</p>

<ol>
  <li>Create a <em>μ</em> coin that does the following: “Flip the input coin.  If it returns 0, return 0.  Otherwise: With probability 1/3, return 0.  Otherwise, run the algorithm for <strong><em>π</em>/4</strong> (in ‘Bernoulli Factory Algorithms’) and return the result.” (Simulates <em>λ</em> × <em>π</em>/6.)</li>
  <li>Run the algorithm for $1/2 + \sin(6\lambda)/4$ in Example 2, using the <em>μ</em> coin.</li>
</ol>

<p><strong>Example 5:</strong> Take $f(\lambda) = 1/2 + \cos(\pi\lambda)/4$ = $1/2 + \cos(6 g(\lambda))/4$, where $g(\lambda)=\lambda\pi/6$.  This is as in Example 4, except step 2 runs the algorithm for $1/2 + \cos(6\lambda)/4$ in Example 3.</p>

<p><strong>Examples 6:</strong> The following functions can be written as power series that satisfy the <strong>general martingale algorithm</strong>.  In the table, $B(i)$ is the $i$<sup>th</sup> <em>Bernoulli number</em> (see the note after the table), and ${n \choose m}$ = choose($n$, $m$) is a binomial coefficient.</p>

<table>
  <thead>
    <tr>
      <th>Function $f(\lambda)$</th>
      <th>Power Coefficients</th>
      <th>Value of $d_0$</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>$\lambda/(\exp(\lambda)-1)$</td>
      <td>$a_i = -1/2$ if $i=1$, or $B(i)/(i!)$ otherwise.</td>
      <td>1.</td>
    </tr>
    <tr>
      <td>Hyperbolic tangent: $\tanh(\lambda)$</td>
      <td>$a_i = \frac{B(i+1) 2^{i+1} (2^{i+1}-1)}{(i+1)!}$ if $i$ is odd<sup id="fnref:25" role="doc-noteref"><a href="#fn:25" class="footnote" rel="footnote">25</a></sup>, or 0 otherwise.</td>
      <td>1.</td>
    </tr>
    <tr>
      <td>$\cos(\sqrt \lambda)$</td>
      <td>$a_i = \frac{(-1)^i}{(2i)!}$.</td>
      <td>1.</td>
    </tr>
    <tr>
      <td>$\sum_{i\ge 0} a_i x^i$ (<a href="https://math.stackexchange.com/questions/855517"><strong>source</strong></a>)</td>
      <td>$a_i = \frac{(-1)^i 4^i}{(2i+1)^2 {2i \choose i}}$.</td>
      <td>1.</td>
    </tr>
  </tbody>
</table>

<p>To simulate a function in the table, run the <strong>general martingale algorithm</strong> with $g(\lambda) = \lambda$ and with the given power coefficients and value of $d_0$ ($d_0$ is the first nonzero power coefficient).</p>

<blockquote>
  <p><strong>Note:</strong> Bernoulli numbers can be computed with the following algorithm, namely <strong>Get the <em>m</em><sup>th</sup> Bernoulli number</strong>:</p>

  <ol>
    <li>If <em>m</em> is 0, 1, 2, 3, or 4, return 1, 1/2, 1/6, 0, or −1/30, respectively.  Otherwise, if <em>m</em> is odd<sup id="fnref:25:1" role="doc-noteref"><a href="#fn:25" class="footnote" rel="footnote">25</a></sup>, return 0.</li>
    <li>Set <em>i</em> to 2 and <em>v</em> to 1 − (<em>m</em>+1)/2.</li>
    <li>While <em>i</em> is less than <em>m</em>:
      <ol>
        <li><strong>Get the <em>i</em><sup>th</sup> Bernoulli number</strong>, call it <em>b</em>.  Add <em>b</em>*choose(<em>m</em>+1, <em>i</em>) to <em>v</em>.</li>
        <li>Add 2 to <em>i</em>.</li>
      </ol>
    </li>
    <li>Return −<em>v</em>/(<em>m</em>+1).</li>
  </ol>
</blockquote>

<p>Examples 7 to 9 use <strong>Algorithm 2</strong> to simulate generalized power series where the power coefficients $a_0$ are nonnegative.</p>

<p><strong>Example 7:</strong> The hyperbolic cosine minus 1, denoted as cosh(<em>λ</em>)−1, can be written as follows: \(f(\lambda)=\cosh(\lambda)-1 = \sum_{n} a_n \lambda^n = \sum_{n} w(n) \frac{a_n \lambda^n}{w(n)},\)
where:</p>

<ul>
  <li>Each sum given above is taken over all values of <em>n</em> that can occur after step 1 is complete (in this case, all values of <em>n</em> that are even and greater than 0).</li>
  <li>$a_n$ is $1/(n!)$.<sup id="fnref:26" role="doc-noteref"><a href="#fn:26" class="footnote" rel="footnote">26</a></sup></li>
  <li>The power coefficients $a_n$ are tucked under a function $w(n)$, which in this case is $\frac{1}{2^{n-2}}$ if <em>n</em>&gt;0 and <em>n</em> is even<sup id="fnref:27" role="doc-noteref"><a href="#fn:27" class="footnote" rel="footnote">27</a></sup>, or 0 otherwise.</li>
</ul>

<p>For this particular function:</p>

<ul>
  <li>Step 1 of <strong>Algorithm 2</strong> can read: “(1a.) Generate numbers that are each 1 or 0 with equal probability until a zero is generated this way, then set <em>n</em> to the number of ones generated this way; (1b.) Set <em>n</em> to 2*<em>n</em> + 2.”</li>
  <li>In step 2, <em>P</em> is $a_n/w(n) = \frac{1}{n!} / \frac{1}{2^{n-2}} = \frac{2^{n/2}}{n!}$ for each allowed $n$.</li>
  <li>In step 3, $g(\lambda)$ is simply $\lambda$.</li>
</ul>

<p><strong>Examples 8:</strong> cosh(<em>λ</em>)−1 and additional target functions are shown in the following table.  (In the table below, $w(n)=1/(2^{z^{-1}(n)+1})$ where $z^{-1}(n)$ is the inverse of the “Step 1b” column, and the $g(\lambda)$ in step 3 is simply $\lambda$.)</p>

<table>
  <thead>
    <tr>
      <th>Target function <em>f</em>(<em>λ</em>)</th>
      <th>Step 1b in <strong>Example 7</strong> reads “Set <em>n</em> to …”</th>
      <th>$a_n$</th>
      <th>$w(n)$</th>
      <th>Value of <em>P</em></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>cosh(<em>λ</em>)−1.</td>
      <td>2*<em>n</em> + 2.</td>
      <td>1/(<em>n</em>!).</td>
      <td>1/(2<sup>(n−2)/2+1</sup>).</td>
      <td>2<sup>n/2</sup>/(<em>n</em>!).</td>
    </tr>
    <tr>
      <td>exp(<em>λ</em>/4)/2.</td>
      <td><em>n</em>.</td>
      <td>1/(<em>n</em>!*2*4<sup><em>n</em></sup>)</td>
      <td>$1/(2^{n+1})$.</td>
      <td>1/(2<sup>n</sup>*(<em>n</em>!)).</td>
    </tr>
    <tr>
      <td>exp(<em>λ</em>)/4.</td>
      <td><em>n</em>.</td>
      <td>1/(<em>n</em>!*4).</td>
      <td>$1/(2^{n+1})$.</td>
      <td>2<sup>n−1</sup>/(<em>n</em>!).</td>
    </tr>
    <tr>
      <td>exp(<em>λ</em>)/6.</td>
      <td><em>n</em>.</td>
      <td>1/(<em>n</em>!*6).</td>
      <td>$1/(2^{n+1})$.</td>
      <td>2<sup>n</sup>/(3*(<em>n</em>!)).</td>
    </tr>
    <tr>
      <td>exp(<em>λ</em>/2)/2.</td>
      <td><em>n</em>.</td>
      <td>1/(<em>n</em>!*2*2<sup>n</sup>)</td>
      <td>$1/(2^{n+1})$.</td>
      <td>1/(<em>n</em>!).</td>
    </tr>
    <tr>
      <td>(exp(<em>λ</em>)−1)/2.</td>
      <td><em>n</em> + 1.</td>
      <td>1/((<em>n</em>+1)!*4).</td>
      <td>1/(2<sup>n</sup>).</td>
      <td>2<sup>n−1</sup>/(<em>n</em>!).</td>
    </tr>
    <tr>
      <td>sinh(<em>λ</em>)/2</td>
      <td>2*<em>n</em> + 1.</td>
      <td>1/(<em>n</em>!*2).</td>
      <td>1/(2<sup>(<em>n</em>−1)/2+1</sup>).</td>
      <td>2<sup>(<em>n</em>−1)/2</sup>/(<em>n</em>!).</td>
    </tr>
    <tr>
      <td>cosh(<em>λ</em>)/2</td>
      <td>2*<em>n</em>.</td>
      <td>1/(<em>n</em>!*2).</td>
      <td>1/(2<sup>n/2+1</sup>).</td>
      <td>2<sup>n/2</sup>/(<em>n</em>!).</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p><strong>Note:</strong> sinh(<em>λ</em>) is the hyperbolic sine function.</p>
</blockquote>

<p><strong>Examples 9:</strong> The table below shows generalized power series shifted downward and shows the algorithm changes needed to simulate the modified function.  In the table, <em>D</em> is a rational number such that 0 ≤ <em>D</em> ≤ <em>φ</em>(0), where <em>φ</em>(.) is the original function.</p>

<table>
  <thead>
    <tr>
      <th>Original function (<em>φ</em>(<em>λ</em>))</th>
      <th>Target function <em>f</em>(<em>λ</em>)</th>
      <th>Step 1b in <strong>Example 7</strong> reads “Set <em>n</em> to …”</th>
      <th>Value of <em>P</em></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>exp(<em>λ</em>)/4.</td>
      <td><em>φ</em>(<em>λ</em>) − <em>D</em>.</td>
      <td><em>n</em>.</td>
      <td>(1/4−<em>D</em>)*2 or (<em>φ</em>(0)−<em>D</em>)*2 if <em>n</em> = 0;<br />2<sup>n−1</sup>/(<em>n</em>!) otherwise.</td>
    </tr>
    <tr>
      <td>exp(<em>λ</em>)/6.</td>
      <td><em>φ</em>(<em>λ</em>) − <em>D</em>.</td>
      <td><em>n</em>.</td>
      <td>(1/6−<em>D</em>)*2 if <em>n</em> = 0;<br />2<sup>n</sup>/(3*(<em>n</em>!)) otherwise.</td>
    </tr>
    <tr>
      <td>exp(<em>λ</em>/2)/2.</td>
      <td><em>φ</em>(<em>λ</em>) − <em>D</em>.</td>
      <td><em>n</em>.</td>
      <td>(1/2−<em>D</em>)*2 if <em>n</em> = 0;<br />1/(<em>n</em>!) otherwise.</td>
    </tr>
    <tr>
      <td>cosh(<em>λ</em>)/4.</td>
      <td><em>φ</em>(<em>λ</em>) − <em>D</em>.</td>
      <td>2*<em>n</em>.</td>
      <td>(1/4−<em>D</em>)*2 if <em>n</em> = 0;<br />2<sup>n/2</sup>/(2*(<em>n</em>!)) otherwise.</td>
    </tr>
  </tbody>
</table>

<p><strong>Example 10:</strong> Let $f = \exp(\lambda)/3$.  Then this function is a generalized power series, with nonnegative power coefficients, which can be tucked under probabilities of the form $w(n) = \left(\frac{2}{3}(1-\frac{2}{3})^n\right)$.</p>

<ul>
  <li>Step 1 of <strong>Algorithm 2</strong> can read: “(1a.) Set <em>n</em> to 0.  (1b.) With probability 2/3, go to substep 1c.  Otherwise, add 1 to <em>n</em> and repeat this substep. (1c.) Set <em>n</em> to <em>n</em>.”</li>
  <li>In step 2, <em>P</em> is $a_n/w(n) = \frac{1}{3\cdot n!} / \left(\frac{2}{3}(1-\frac{2}{3})^n\right) = \frac{(3/2)^{n + 1}}{n!}$ for each allowed $n$.</li>
  <li>In step 3, $g(\lambda)$ is simply $\lambda$.</li>
</ul>

<p><strong>Example 11:</strong> Let $f(\lambda)=\exp(\lambda)\cdot (1-\lambda)$.  Run Mendo’s algorithm for series of type 1, with $a_i = \frac{i-1}{i!}$ and $CS = 1$.</p>

<p><a id="General_Factory_Functions"></a></p>

<h4 id="general-factory-functions">General Factory Functions</h4>

<p>A coin with unknown probability of heads of <em>λ</em> can be turned into a coin with probability of heads of <em>f</em>(<em>λ</em>), where <em>f</em> is any factory function, via an algorithm that builds randomized bounds on <em>f</em>(<em>λ</em>) based on the outcomes of the coin flips.  These randomized bounds come from two sequences of polynomials:</p>

<ul>
  <li>One sequence of polynomials converges from above to <em>f</em>, the other from below.</li>
  <li>For each sequence, the polynomials must have increasing degree.</li>
  <li>The polynomials are written in <em>Bernstein form</em> (see “<a href="#Certain_Polynomials"><strong>Certain Polynomials</strong></a>”).</li>
  <li>For each <em>n</em>, the degree-_n_ polynomials’ Bernstein coefficients must lie at or “inside” those of the previous upper polynomial and the previous lower one (once the polynomials are elevated to degree <em>n</em>).</li>
</ul>

<p>The following algorithm can be used to simulate factory functions via polynomials.  In the algorithm:</p>

<ul>
  <li><strong>fbelow</strong>(<em>n</em>, <em>k</em>) is a lower bound of the <em>k</em><sup>th</sup> Bernstein coefficient for a degree-_n_ polynomial that comes close to <em>f</em> from below, where 0 ≤ <em>k</em> ≤ <em>n</em>.  For example, this can be <em>f</em>(<em>k</em>/<em>n</em>) minus a constant that depends on <em>n</em>. (See note 1 below.)</li>
  <li><strong>fabove</strong>(<em>n</em>, <em>k</em>) is an upper bound of the <em>k</em><sup>th</sup> Bernstein coefficient for a degree-_n_ polynomial that comes close to <em>f</em> from above.  For example, this can be <em>f</em>(<em>k</em>/<em>n</em>) plus a constant that depends on <em>n</em>. (See note 1.)</li>
</ul>

<p>The algorithm implements the reverse-time martingale framework (Algorithm 4) in Łatuszyński et al. (2009/2011)<sup id="fnref:21:2" role="doc-noteref"><a href="#fn:21" class="footnote" rel="footnote">21</a></sup> and the degree-doubling suggestion in Algorithm I of Flegal and Herbei (2012)<sup id="fnref:28" role="doc-noteref"><a href="#fn:28" class="footnote" rel="footnote">28</a></sup>, although an error in Algorithm I is noted below.  The first algorithm follows.</p>

<ol>
  <li>Generate a uniform random variate between 0 and 1, call it <em>ret</em>.</li>
  <li>Set <em>ℓ</em> and <em>LT</em> to 0.  Set <em>u</em> and <em>ut</em> to 1. Set <em>lastdegree</em> to 0, and set <em>ones</em> to 0.</li>
  <li>Set <em>degree</em> so that the first pair of polynomials has degree equal to <em>degree</em> and has Bernstein coefficients all lying in the closed unit interval.  For example, this can be done as follows: Let <strong>fbound</strong>(<em>n</em>) be the minimum value for <strong>fbelow</strong>(<em>n</em>, <em>k</em>) and the maximum value for <strong>fabove</strong>(<em>n</em>,<em>k</em>) with <em>k</em> in the interval [0, <em>n</em>]; then set <em>degree</em> to 1; then while <strong>fbound</strong>(<em>degree</em>) returns an upper or lower bound that is less than 0 or greater than 1, multiply <em>degree</em> by 2; then go to the next step.</li>
  <li>Set <em>startdegree</em> to <em>degree</em>.</li>
  <li>(The remaining steps are now done repeatedly until the algorithm finishes by returning a value.) Flip the input coin <em>t</em> times, where <em>t</em> is <em>degree</em> − <em>lastdegree</em>.  For each time the coin returns 1 this way, add 1 to <em>ones</em>.</li>
  <li>Calculate <em>ℓ</em> and <em>u</em> as follows:
    <ol>
      <li>Define <strong>FB</strong>(<em>a</em>, <em>b</em>) as follows: Let <em>c</em> be choose(<em>a</em>, <em>b</em>). (Optionally, multiply <em>c</em> by 2<sup><em>a</em></sup>; see note 3.)  Calculate <strong>fbelow</strong>(<em>a</em>, <em>b</em>) as lower and upper bounds <em>LB</em> and <em>UB</em> that are accurate enough that floor(<em>LB</em>*<em>c</em>) = floor(<em>UB</em>*<em>c</em>), then return floor(<em>LB</em>*<em>c</em>)/<em>c</em>.</li>
      <li>Define <strong>FA</strong>(<em>a</em>, <em>b</em>) as follows: Let <em>c</em> be choose(<em>a</em>, <em>b</em>). (Optionally, multiply <em>c</em> by 2<sup><em>a</em></sup>; see note 3.)  Calculate <strong>fabove</strong>(<em>a</em>, <em>b</em>) as lower and upper bounds <em>LB</em> and <em>UB</em> that are accurate enough that ceil(<em>LB</em>*<em>c</em>) = ceil(<em>UB</em>*<em>c</em>), then return ceil(<em>LB</em>*<em>c</em>)/<em>c</em>.</li>
      <li>Set <em>ℓ</em> to <strong>FB</strong>(<em>degree</em>, <em>ones</em>) and set <em>u</em> to <strong>FA</strong>(<em>degree</em>, <em>ones</em>).</li>
    </ol>
  </li>
  <li>(This step and the next find the means of the previous <em>ℓ</em> and of <em>u</em> given the current coin flips.) If <em>degree</em> equals <em>startdegree</em>, set <em>LS</em> to 0 and <em>us</em> to 1. (Algorithm I of Flegal and Herbei 2012 doesn’t take this into account.)</li>
  <li>If <em>degree</em> is greater than <em>startdegree</em>:
    <ol>
      <li>Let <em>nh</em> be choose(<em>degree</em>, <em>ones</em>), and let <em>k</em> be min(<em>lastdegree</em>, <em>ones</em>).</li>
      <li>Set <em>LS</em> to $\sum_{j=0}^k$ <strong>FB</strong>(<em>lastdegree</em>,<em>j</em>)*choose(<em>degree</em>−<em>lastdegree</em>, <em>ones</em>−<em>j</em>)*choose(<em>lastdegree</em>,<em>j</em>)/<em>nh</em>.</li>
      <li>Set <em>us</em> to $\sum_{j=0}^k$ <strong>FA</strong>(<em>lastdegree</em>,<em>j</em>)*choose(<em>degree</em>−<em>lastdegree</em>, <em>ones</em>−<em>j</em>)*choose(<em>lastdegree</em>,<em>j</em>)/<em>nh</em>.</li>
    </ol>
  </li>
  <li>Let <em>m</em> be (<em>ut</em>−<em>LT</em>)/(<em>us</em>−<em>LS</em>).  Set <em>LT</em> to <em>LT</em>+(<em>ℓ</em>−<em>LS</em>)*<em>m</em>, and set <em>ut</em> to <em>ut</em>−(<em>us</em>−<em>u</em>)*<em>m</em>.</li>
  <li>If <em>ret</em> is less than (or equal to) <em>LT</em>, return 1.  If <em>ret</em> is less than <em>ut</em>, go to the next step.  If neither is the case, return 0.  (If <em>ret</em> is a uniform PSRN, these comparisons should be done via the <strong>URandLessThanReal algorithm</strong>, which is described in my <a href="https://peteroupc.github.io/exporand.html"><strong>article on PSRNs</strong></a>.)</li>
  <li>(Find the next pair of polynomials and restart the loop.) Set <em>lastdegree</em> to <em>degree</em>, then increase <em>degree</em> so that the next pair of polynomials has degree equal to a higher value of <em>degree</em> and gets closer to the target function (for example, multiply <em>degree</em> by 2).  Then, go to step 5.</li>
</ol>

<p>Another algorithm, given in Thomas and Blanchet (2012)<sup id="fnref:12:3" role="doc-noteref"><a href="#fn:12" class="footnote" rel="footnote">12</a></sup>, was based on the one from Nacu and Peres (2005)<sup id="fnref:17:1" role="doc-noteref"><a href="#fn:17" class="footnote" rel="footnote">17</a></sup>.  That algorithm is not given here, however.</p>

<blockquote>
  <p><strong>Notes:</strong></p>

  <ol>
    <li>The efficiency of this algorithm depends on many things, including how “smooth” <em>f</em> is (Holtz et al. 2011)<sup id="fnref:29" role="doc-noteref"><a href="#fn:29" class="footnote" rel="footnote">29</a></sup> and how easy it is to calculate the appropriate values for <strong>fbelow</strong> and <strong>fabove</strong>.  The best way to implement <strong>fbelow</strong> and <strong>fabove</strong> for a given function <em>f</em> will require a deep mathematical analysis of that function.  For more information, see my <a href="https://peteroupc.github.io/bernsupp.html"><strong>Supplemental Notes on Bernoulli Factories</strong></a>.</li>
    <li>In some cases, a single pair of polynomial sequences may not converge quickly to the desired function <em>f</em>, especially when <em>f</em> is not “smooth” enough.  An intriguing suggestion from Thomas and Blanchet (2012)<sup id="fnref:12:4" role="doc-noteref"><a href="#fn:12" class="footnote" rel="footnote">12</a></sup> is to use multiple pairs of polynomial sequences that converge to <em>f</em>, where each pair is optimized for particular ranges of <em>λ</em>: first flip the input coin several times to get a rough estimate of <em>λ</em>, then choose the pair that’s optimized for the estimated <em>λ</em>, and run either algorithm in this section on that pair.</li>
    <li>Normally, the algorithm works only if 0 &lt; <em>λ</em> &lt; 1. If <em>λ</em> can be 0 or 1 (meaning the input coin is allowed to return 1 every time or 0 every time), then based on a suggestion in Holtz et al. (2011)<sup id="fnref:29:1" role="doc-noteref"><a href="#fn:29" class="footnote" rel="footnote">29</a></sup>, the <em>c</em> in <strong>FA</strong> and <strong>FB</strong> can be multiplied by 2<sup><em>a</em></sup> (as shown in step 6) to ensure correctness for every value of <em>λ</em>.</li>
  </ol>
</blockquote>

<p><a id="Algorithms_for_General_Irrational_Constants"></a></p>

<h3 id="algorithms-for-general-irrational-constants">Algorithms for General Irrational Constants</h3>

<p>This section shows general-purpose algorithms to generate heads with a probability equal to an <em>irrational number</em> (a number that isn’t a ratio of two integers), when that number is known by its digit or series expansion, continued fraction, or continued logarithm.</p>

<p>But on the other hand, probabilities that are <em>rational</em> constants are trivial to simulate.  If fair coins are available, the <code>ZeroOrOne</code> method, which is described in my article on <a href="https://peteroupc.github.io/randomfunc.html#Boolean_True_False_Conditions"><strong>random sampling methods</strong></a>, should be used.  If coins with unknown probability of heads are available, then a <a href="https://peteroupc.github.io/randextract.html"><strong><em>randomness extraction</em></strong></a> method should be used to turn them into fair coins.</p>

<p><a id="Digit_Expansions"></a></p>

<h4 id="digit-expansions">Digit Expansions</h4>

<p>Probabilities can be expressed as a digit expansion (of the form <code>0.dddddd...</code>).  The following algorithm returns 1 with probability <code>p</code> and 0 otherwise, where 0 ≤ <code>p</code> &lt; 1.  (The number 0 is also an infinite digit expansion of zeros, and the number 1 is also an infinite digit expansion of base-minus-ones.)  Irrational numbers always have infinite digit expansions, which must be calculated “on-the-fly”.</p>

<p>In the algorithm (see also (Brassard et al., 2019)<sup id="fnref:29:2" role="doc-noteref"><a href="#fn:29" class="footnote" rel="footnote">29</a></sup>, (Devroye 1986, p. 769)<sup id="fnref:30" role="doc-noteref"><a href="#fn:30" class="footnote" rel="footnote">30</a></sup>), <code>BASE</code> is the digit base, such as 2 for binary or 10 for decimal.</p>

<ol>
  <li>Set <code>u</code> to 0 and <code>k</code> to 1.</li>
  <li>Set <code>u</code> to <code>(u * BASE) + v</code>, where <code>v</code> is a uniform random integer in the interval [0, <code>BASE</code>) (if <code>BASE</code> is 2, then <code>v</code> is simply equal to 1 or 0 with equal probability).  Calculate <code>pa</code>, which is an approximation to <code>p</code> such that abs(<code>p</code>−<code>pa</code>) ≤ <code>BASE</code><sup>−<code>k</code></sup>.  Set <code>pk</code> to <code>pa</code>’s digit expansion up to the <code>k</code> digits after the point.  Example: If <code>p</code> is <em>π</em>/4, <code>BASE</code> is 10, and <code>k</code> is 5, then <code>pk = 78539</code>.</li>
  <li>If <code>pk + 1 &lt;= u</code>, return 0.<sup id="fnref:31" role="doc-noteref"><a href="#fn:31" class="footnote" rel="footnote">31</a></sup> If <code>pk - 2 &gt;= u</code>, return 1.  If neither is the case, add 1 to <code>k</code> and go to step 2.</li>
</ol>

<p><a id="Continued_Fractions"></a></p>

<h4 id="continued-fractions">Continued Fractions</h4>

<p>A <em>simple continued fraction</em> is a way to write a real number between 0 and 1. A simple continued fraction has the form—</p>

<p>\(0 + 1 / (a[1] + 1 / (a[2] + 1 / (a[3] + ... ))),\)
where the <em>a</em>[<em>i</em>] are the <em>partial denominators</em>, none of which may have an absolute value less than 1.</p>

<p>Inspired by (Flajolet et al., 2010, “Finite graphs (Markov chains) and rational functions”)<sup id="fnref:1:3" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>, I developed the following algorithm.</p>

<p><strong>Algorithm 1.</strong> The following algorithm returns 1 with a probability expressed as a simple continued fraction.  This algorithm works only if each <em>a</em>[<em>i</em>]’s absolute value is 1 or greater and <em>a</em>[1] is greater than 0, but otherwise, each  <em>a</em>[<em>i</em>] may be negative, be a non-integer, or both.  The algorithm begins with <em>pos</em> equal to 1.  Then the following steps are taken.</p>

<ol>
  <li>Set <em>k</em> to <em>a</em>[<em>pos</em>].</li>
  <li>If the partial denominator at <em>pos</em> is the last, return a number that is 1 with probability 1/<em>k</em> and 0 otherwise.</li>
  <li>If <em>a</em>[<em>pos</em>] is less than 0, set <em>kp</em> to <em>k</em> − 1 and <em>s</em> to 0.  Otherwise, set <em>kp</em> to <em>k</em> and <em>s</em> to 1. (This step accounts for negative partial denominators.)</li>
  <li>Do the following process repeatedly until this run of the algorithm returns a value:
    <ol>
      <li>With probability <em>kp</em>/(1+<em>kp</em>), return a number that is 1 with probability 1/<em>kp</em> and 0 otherwise.</li>
      <li>Do a separate run of the currently running algorithm, but with <em>pos</em> = <em>pos</em> + 1.  If the separate run returns <em>s</em>, return 0.</li>
    </ol>
  </li>
</ol>

<p><strong>Algorithm 2.</strong></p>

<p>A <em>generalized continued fraction</em> has the form 0 + <em>b</em>[1] / (<em>a</em>[1] + <em>b</em>[2] / (<em>a</em>[2] + <em>b</em>[3] / (<em>a</em>[3] + … ))).  The <em>a</em>[<em>i</em>] are the same as before, but the <em>b</em>[<em>i</em>] are the <em>partial numerators</em>. The following are two algorithms to simulate a probability in the form of a generalized continued fraction.</p>

<p>The following algorithm works only if each ratio <em>b</em>[<em>i</em>]/<em>a</em>[<em>i</em>] has an absolute value of 1 or less, but otherwise, each <em>b</em>[<em>i</em>] and each  <em>a</em>[<em>i</em>] may be negative, be a non-integer, or both.  This algorithm employs an equivalence transform from generalized to simple continued fractions.  The algorithm begins with <em>pos</em> and <em>r</em> both equal to 1.  Then the following steps are taken.</p>

<ol>
  <li>Set <em>r</em> to 1 / (<em>r</em> * <em>b</em>[<em>pos</em>]), then set <em>k</em> to <em>a</em>[<em>pos</em>] * <em>r</em>. (<em>k</em> is the partial denominator for the equivalent simple continued fraction.)</li>
  <li>If the partial numerator/denominator pair at <em>pos</em> is the last, return a number that is 1 with probability 1/abs(<em>k</em>) and 0 otherwise.</li>
  <li>Set <em>kp</em> to abs(<em>k</em>) and <em>s</em> to 1.</li>
  <li>Set <em>r2</em> to 1 / (<em>r</em> * <em>b</em>[<em>pos</em> + 1]).  If <em>a</em>[<em>pos</em> + 1] * <em>r2</em> is less than 0, set <em>kp</em> to <em>kp</em> − 1 and <em>s</em> to 0. (This step accounts for negative partial numerators and denominators.)</li>
  <li>Do the following process repeatedly until this run of the algorithm returns a value:
    <ol>
      <li>With probability <em>kp</em>/(1+<em>kp</em>), return a number that is 1 with probability 1/<em>kp</em> and 0 otherwise.</li>
      <li>Do a separate run of the currently running algorithm, but with <em>pos</em> = <em>pos</em> + 1 and <em>r</em> = <em>r</em>.  If the separate run returns <em>s</em>, return 0.</li>
    </ol>
  </li>
</ol>

<p><strong>Algorithm 3.</strong> This algorithm works only if each ratio <em>b</em>[<em>i</em>]/<em>a</em>[<em>i</em>] is 1 or less and if each <em>b</em>[<em>i</em>] and each  <em>a</em>[<em>i</em>] is greater than 0, but otherwise, each <em>b</em>[<em>i</em>] and each <em>a</em>[<em>i</em>] may be a non-integer.  The algorithm begins with <em>pos</em> equal to 1.  Then the following steps are taken.</p>

<ol>
  <li>If the partial numerator/denominator pair at <em>pos</em> is the last, return a number that is 1 with probability <em>b</em>[<em>pos</em>]/<em>a</em>[<em>pos</em>] and 0 otherwise.</li>
  <li>Do the following process repeatedly until this run of the algorithm returns a value:
    <ol>
      <li>With probability <em>a</em>[<em>pos</em>]/(1 + <em>a</em>[<em>pos</em>]), return a number that is 1 with probability <em>b</em>[<em>pos</em>]/<em>a</em>[<em>pos</em>] and 0 otherwise.</li>
      <li>Do a separate run of the currently running algorithm, but with <em>pos</em> = <em>pos</em> + 1.  If the separate run returns 1, return 0.</li>
    </ol>
  </li>
</ol>

<p>See the appendix for a correctness proof of Algorithm 3.</p>

<blockquote>
  <p><strong>Notes:</strong></p>

  <ul>
    <li>
      <p>If any of these algorithms encounters a probability outside the closed unit interval, the entire algorithm will fail for that continued fraction.</p>
    </li>
    <li>These algorithms will work for continued fractions of the form “1 − …” (rather than “0 + …”) if—
      <ul>
        <li>before running the algorithm, the first partial numerator and denominator have their sign removed, and</li>
        <li>after running the algorithm, 1 minus the result (rather than just the result) is taken.</li>
      </ul>
    </li>
    <li>These algorithms are designed to allow the partial numerators and denominators to be calculated “on the fly”.</li>
    <li>The following is an alternative way to write Algorithm 1, which better shows the inspiration because it shows how the so-called “even-parity construction”<sup id="fnref:32" role="doc-noteref"><a href="#fn:32" class="footnote" rel="footnote">32</a></sup> (or the two-coin algorithm) as well as the “1 − <em>x</em>” construction can be used to develop rational number simulators that are as big as their continued fraction expansions, as suggested in the cited part of the Flajolet paper.  However, it only works if the size of the continued fraction expansion (here, <em>size</em>) is known in advance.
      <ol>
        <li>Set <em>i</em> to <em>size</em>.</li>
        <li>Create an input coin that does the following: “Return a number that is 1 with probability 1/<em>a</em>[<em>size</em>] or 0 otherwise”.</li>
        <li>While <em>i</em> is 1 or greater:
          <ol>
            <li>Set <em>k</em> to <em>a</em>[<em>i</em>].</li>
            <li>Create an input coin that takes the previous input coin and <em>k</em> and does the following: “(a) With probability <em>k</em>/(1+<em>k</em>), return a number that is 1 with probability 1/<em>k</em> and 0 otherwise; (b) Flip the previous input coin.  If the result is 1, return 0.  Otherwise, go to step (a)”.  (The probability <em>k</em>/(1+<em>k</em>) is related to <em>λ</em>/(1+<em>λ</em>) = 1 − 1/(1+<em>λ</em>), which involves the even-parity construction—or the two-coin algorithm—for 1/(1+<em>λ</em>) as well as complementation for “1 − <em>x</em>”.)</li>
            <li>Subtract 1 from <em>i</em>.</li>
          </ol>
        </li>
        <li>Flip the last input coin created by this algorithm, and return the result.</li>
      </ol>
    </li>
  </ul>
</blockquote>

<p><a id="Continued_Logarithms"></a></p>

<h4 id="continued-logarithms">Continued Logarithms</h4>

<p>The <em>continued logarithm</em> (Gosper 1978)<sup id="fnref:33" role="doc-noteref"><a href="#fn:33" class="footnote" rel="footnote">33</a></sup>, (Borwein et al., 2016)<sup id="fnref:34" role="doc-noteref"><a href="#fn:34" class="footnote" rel="footnote">34</a></sup> of a number greater than 0 and less than 1 has the following continued fraction form: 0 + (1 / 2<sup><em>c</em>[1]</sup>) / (1 + (1 / 2<sup><em>c</em>[2]</sup>) / (1 + …)), where <em>c</em>[<em>i</em>] are the parameters of the continued logarithm and all 0 or greater.  I have come up with the following algorithm that simulates a probability expressed as a continued logarithm expansion.</p>

<p>The algorithm begins with <em>pos</em> equal to 1.  Then the following steps are taken.</p>

<ol>
  <li>If the parameter at <em>pos</em> is the last, return a number that is 1 with probability 1/(2<sup><em>c</em>[<em>pos</em>]</sup>) and 0 otherwise.</li>
  <li>Do the following process repeatedly until this run of the algorithm returns a value:
    <ol>
      <li>Generate 1 or 0 with equal probability.  If 1 was generated this way, return a number that is 1 with probability 1/(2<sup><em>c</em>[<em>pos</em>]</sup>) and 0 otherwise.</li>
      <li>Do a separate run of the currently running algorithm, but with <em>pos</em> = <em>pos</em> + 1.  If the separate run returns 1, return 0.</li>
    </ol>
  </li>
</ol>

<p>For a correctness proof, see the appendix.</p>

<p><a id="Certain_Algebraic_Numbers"></a></p>

<h4 id="certain-algebraic-numbers">Certain Algebraic Numbers</h4>

<p>A method to sample a probability equal to a polynomial’s root appears in a French-language article by Penaud and Roques (2002)<sup id="fnref:35" role="doc-noteref"><a href="#fn:35" class="footnote" rel="footnote">35</a></sup>.  The following is an implementation of that method, using the discussion in the paper’s section 1 and Algorithm 2, and incorporates a correction to Algorithm 2.  The algorithm takes a polynomial as follows:</p>

<ul>
  <li>It has the form <em>P</em>(<em>x</em>) = <em>a</em>[0]*<em>x</em><sup>0</sup> + <em>a</em>[1]*<em>x</em><sup>1</sup> + … + <em>a</em>[<em>n</em>]*<em>x</em><sup><em>n</em></sup>, where <em>a</em>[<em>i</em>], the <em>power coefficients</em>, are all rational numbers, and 0 ≤ <em>x</em> ≤ 1.</li>
  <li>It equals 0 (has a <em>root</em>) at exactly one point, and that point is greater than 0 and less than 1.</li>
</ul>

<p>And the algorithm returns 1 with probability equal to the root, and 0 otherwise.  The root <em>R</em> is known as an <em>algebraic number</em> because it satisfies the polynomial equation <em>P</em>(<em>R</em>) = 0.  The algorithm follows.</p>

<ol>
  <li>Set <em>r</em> to 0 and <em>d</em> to 2.</li>
  <li>Do the following process repeatedly, until this algorithm returns a value:
    <ol>
      <li>Generate 1 or 0 with equal probability, call it <em>z</em>.</li>
      <li>Set <em>t</em> to (<em>r</em>*2+1)/<em>d</em>.</li>
      <li>If <em>P</em>(0) &gt; 0:
        <ol>
          <li>If <em>z</em> is 1 and <em>P</em>(<em>t</em>) is less than 0, return 0.</li>
          <li>If <em>z</em> is 0 and <em>P</em>(<em>t</em>) is greater than 0, return 1.</li>
        </ol>
      </li>
      <li>If <em>P</em>(0) &lt; 0:
        <ol>
          <li>If <em>z</em> is 1 and <em>P</em>(<em>t</em>) is greater than 0, return 0.</li>
          <li>If <em>z</em> is 0 and <em>P</em>(<em>t</em>) is less than 0, return 1.</li>
        </ol>
      </li>
      <li>Set <em>r</em> to <em>r</em>*2+<em>z</em>, then multiply <em>d</em> by 2.</li>
    </ol>
  </li>
</ol>

<blockquote>
  <p><strong>Example</strong> (Penaud and Roques 2002)<sup id="fnref:35:1" role="doc-noteref"><a href="#fn:35" class="footnote" rel="footnote">35</a></sup>:  Let <em>P</em>(<em>x</em>) = 1 − <em>x</em> − <em>x</em><sup>2</sup>.  When 0 ≤ <em>x</em> ≤ 1, this is a polynomial whose only root 1 is 2/(1+sqrt(5)), that is, 1 divided by the golden ratio or 1/<em>φ</em> or about 0.618, and <em>P</em>(0) &gt; 0.  Then given <em>P</em>, the algorithm above samples the probability 1/<em>φ</em> exactly.</p>
</blockquote>

<p><a id="Certain_Converging_Series"></a></p>

<h4 id="certain-converging-series">Certain Converging Series</h4>

<p>A general-purpose algorithm was given by Mendo (2020/2021)<sup id="fnref:36" role="doc-noteref"><a href="#fn:36" class="footnote" rel="footnote">36</a></sup> that can simulate any probability, as long as—</p>

<ul>
  <li>the probability is greater than 0 and less than 1,</li>
  <li>the probability can be written as a (possibly infinite) sum of rational numbers greater than 0, that is, as <em>p</em> = <em>a</em>[0] + <em>a</em>[1] + …, and</li>
  <li>a sequence of rational numbers <em>err</em>[0], <em>err</em>[1], … is available that is nowhere increasing and approaches 0 (<em>converges</em> to 0), where <em>err</em>[<em>n</em>] is not less than <em>p</em> − (<em>a</em>[0] + … + <em>a</em>[<em>n</em>]).</li>
</ul>

<p>The algorithm follows.</p>

<ol>
  <li>Set <em>ϵ</em> to 1, then set <em>n</em>, <em>lamunq</em>, <em>lam</em>, <em>s</em>, and <em>k</em> to 0 each.</li>
  <li>Add 1 to <em>k</em>, then add <em>s</em>/(2<sup><em>k</em></sup>) to <em>lam</em>.</li>
  <li>If <em>lamunq</em>+<em>ϵ</em> ≤ <em>lam</em> + 1/(2<sup><em>k</em></sup>), go to step 8.</li>
  <li>If <em>lamunq</em> &gt; <em>lam</em> + 1/(2<sup><em>k</em></sup>), go to step 8.</li>
  <li>If <em>lamunq</em> &gt; <em>lam</em> + 1/(2<sup><em>k</em>+1</sup>) and <em>lamunq</em>+<em>ϵ</em> &lt; 3/(2<sup><em>k</em>+1</sup>), go to step 8.</li>
  <li>Add <em>a</em>[<em>n</em>] to <em>lamunq</em> and set <em>ϵ</em> to <em>err</em>[<em>n</em>].</li>
  <li>Add 1 to <em>n</em>, then go to step 3.</li>
  <li>Let <em>bound</em> be <em>lam</em>+1/(2<sup><em>k</em></sup>).  If <em>lamunq</em>+<em>ϵ</em> ≤ <em>bound</em>, set <em>s</em> to 0.  Otherwise, if <em>lamunq</em> &gt; <em>bound</em>, set <em>s</em> to 2.  Otherwise, set <em>s</em> to 1.</li>
  <li>Generate 1 or 0 with equal probability.  If 1 was generated this way, go to step 2.  Otherwise, return a number that is 0 if <em>s</em> is 0; otherwise, 1 if <em>s</em> is 2; otherwise, either 1 or 0 with equal probability.</li>
</ol>

<p>If <em>a</em>, given above, sums to the <em>base-2 logarithm</em> of the probability rather than that probability, the following algorithm I developed returns 1 with that probability.  For simplicity’s sake, even though logarithms for such probabilities are negative, all the <em>a</em>[<em>i</em>] must be 0 or greater (and thus are the negated values of the already negative logarithm approximations) and must form a nowhere decreasing sequence, and all the <em>err</em>[<em>i</em>] must be 0 or greater.</p>

<ol>
  <li>Set <em>intinf</em> to floor(max(0, abs(<em>a</em>[0]))).  (This is the absolute integer part of the first term in the series, or 0, whichever is greater.)</li>
  <li>If <em>intinf</em> is greater than 0, generate numbers that are each 1 or 0 with equal probability until the number zero or <em>intinf</em> many numbers were generated this way, whichever comes first.  If a zero was generated this way, return 0.</li>
  <li>Generate an exponential random variate <em>E</em> with rate ln(2).  This can be done, for example, by using the <strong>exponential distribution with rate ln(<em>x</em>)</strong> algorithm given in “<a href="https://peteroupc.github.io/exporand.html#Exponential_Distribution_with_Rate_ln__x"><strong>Partially-Sampled Random Numbers</strong></a>”. (This step takes advantage of the exponential distribution’s <em>memoryless property</em>: given that an exponential random variate <em>E</em> is greater than <em>intinf</em>, <em>E</em> minus <em>intinf</em> has the same distribution.)</li>
  <li>Set <em>n</em> to 0.</li>
  <li>Do the following process repeatedly until the algorithm returns a value:
    <ol>
      <li>Set <em>inf</em> to max(0, <em>a</em>[<em>n</em>]), then set <em>sup</em> to min(0, <em>inf</em>+<em>err</em>[<em>n</em>]).</li>
      <li>If <em>E</em> is less than <em>inf</em>+<em>intinf</em>, return 0.  If <em>E</em> is less than <em>sup</em>+<em>intinf</em>, go to the next step.  If neither is the case, return 1.</li>
      <li>Set <em>n</em> to 1.</li>
    </ol>
  </li>
</ol>

<p>The case when the sequence <em>a</em> converges to a <em>natural logarithm</em> rather than a base-2 logarithm is trivial by comparison.  Again for this algorithm, all the <em>a</em>[<em>i</em>] must be 0 or greater and form a nowhere decreasing sequence, and all the <em>err</em>[<em>i</em>] must be 0 or greater.</p>

<ol>
  <li>Generate an exponential random variate <em>E</em> with rate 1.  This can be done, for example, by using the <strong>ExpRand</strong> or <strong>ExpRand2</strong> algorithm given in “<a href="https://peteroupc.github.io/exporand.html#Exponential_Distribution"><strong>Partially-Sampled Random Numbers</strong></a>”.</li>
  <li>Set <em>n</em> to 0.</li>
  <li>Do the following process repeatedly until the algorithm returns a value:
    <ol>
      <li>Set <em>inf</em> to max(0, <em>a</em>[<em>n</em>]), then set <em>sup</em> to min(0, <em>inf</em>+<em>err</em>[<em>n</em>]).</li>
      <li>If <em>E</em> is less than <em>inf</em>+<em>intinf</em>, return 0.  If <em>E</em> is less than <em>sup</em>+<em>intinf</em>, go to the next step.  If  neither is the case, return 1.</li>
      <li>Set <em>n</em> to 1.</li>
    </ol>
  </li>
</ol>

<blockquote>
  <p><strong>Notes:</strong></p>

  <ol>
    <li>Mendo (2020/2021)<sup id="fnref:36:1" role="doc-noteref"><a href="#fn:36" class="footnote" rel="footnote">36</a></sup> as well as Carvalho and Moreira (2022)<sup id="fnref:37" role="doc-noteref"><a href="#fn:37" class="footnote" rel="footnote">37</a></sup> discuss how to find error bounds on “cutting off” a series that work for many infinite series.  This can be helpful in finding the appropriate sequences <em>a</em> and <em>err</em> needed for the first algorithm in this section.</li>
    <li>If a number is known as a simple continued fraction whose partial denominators are integers, Citterio and Pavani (2016)<sup id="fnref:38" role="doc-noteref"><a href="#fn:38" class="footnote" rel="footnote">38</a></sup> show how to calculate lower and upper bounds for that number.  The bounds will be rational numbers whose numerator has at most a given number of digits.</li>
  </ol>

  <p><strong>Examples</strong>:</p>

  <ul>
    <li>Let <em>f</em>(<em>λ</em>) = cosh(1)−1, namely, the hyperbolic cosine, minus 1, of 1.  This function can be rewritten as a sum required by the first algorithm in this section, namely <em>f</em>’s <em>Taylor series</em> at 0.  Then this algorithm can be used with <em>a</em>[<em>i</em>] = 1/(((<em>i</em>+1)*2)!) and <em>err</em>[<em>i</em>] = 2/((((<em>i</em>+1)*2)+1)!). <sup id="fnref:39" role="doc-noteref"><a href="#fn:39" class="footnote" rel="footnote">39</a></sup></li>
    <li>Logarithms can form the basis of efficient algorithms to simulate the probability <em>z</em> = choose(<em>n</em>, <em>k</em>)/2<sup>n</sup> when <em>n</em> can be very large (for example, as large as 2<sup>30</sup>), without relying on floating-point arithmetic.  In this example, the trivial algorithm for choose(<em>n</em>, <em>k</em>), a binomial coefficient, will generally require a growing amount of storage that depends on <em>n</em> and <em>k</em>. On the other hand, any constant can be simulated using up to two fair coin flips on average, and even slightly less than that for the constants at hand here (Kozen 2014)<sup id="fnref:40" role="doc-noteref"><a href="#fn:40" class="footnote" rel="footnote">40</a></sup>.  Instead of calculating binomial coefficients directly, a series can be calculated that sums to that coefficient’s logarithm, such as ln(choose(<em>n</em>, <em>k</em>)), which is economical in space even for large <em>n</em> and <em>k</em>.  Then the algorithm above can be used with that series to simulate the probability <em>z</em>. See also an appendix in (Bringmann et al. 2014)<sup id="fnref:41" role="doc-noteref"><a href="#fn:41" class="footnote" rel="footnote">41</a></sup>.</li>
  </ul>
</blockquote>

<p><a id="Other_General_Algorithms"></a></p>

<h3 id="other-general-algorithms">Other General Algorithms</h3>

<p> </p>

<p><a id="Convex_Combinations"></a></p>

<h4 id="convex-combinations">Convex Combinations</h4>

<p>Assume there is one or more input coins <em>h</em><sub><em>i</em></sub>(<em>λ</em>) that return heads with a probability that depends on <em>λ</em>.  (The number of coins may be infinite.) The following algorithm chooses one of these coins at random then flips that coin.  Specifically, the algorithm generates 1 with probability equal to the following weighted sum: <em>g</em>(0) * <em>h</em><sub>0</sub>(<em>λ</em>) + <em>g</em>(1) * <em>h</em><sub>1</sub>(<em>λ</em>) + …, where <em>g</em>(<em>i</em>) is the probability that coin <em>i</em> will be chosen, <em>h</em><sub><em>i</em></sub> is the function simulated by coin <em>i</em>, and all the <em>g</em>(<em>i</em>) sum to 1.  See (Wästlund 1999, Theorem 2.7)<sup id="fnref:9:1" role="doc-noteref"><a href="#fn:9" class="footnote" rel="footnote">9</a></sup>.  (Alternatively, the algorithm can be seen as returning heads with probability <strong>E</strong>[<em>h</em><sub><em>X</em></sub>(<em>λ</em>)], that is, the expected value, or “long-run average”, of <em>h</em><sub><em>X</em></sub> where <em>X</em> is the number that identifies the randomly chosen coin.)</p>

<ol>
  <li>Generate a random integer <em>X</em> in some way.  For example, it could be a uniform random integer greater than 1 and less than 6, or it could be a Poisson random variate.  (Specifically, the number <em>X</em> is generated with probability <em>g</em>(<em>X</em>).  If every <em>g</em>(<em>i</em>) is a rational number, the following <a href="https://www.keithschwarz.com/darts-dice-coins/"><strong>algorithm</strong></a> can generate <em>X</em>: “(1) Set <em>X</em> to 0 and <em>d</em> to 1. (2) With probability <em>g</em>(<em>X</em>)/<em>d</em>, return <em>X</em>; otherwise subtract <em>g</em>(<em>X</em>) from <em>d</em>, add 1 to <em>X</em>, and repeat this step.”)</li>
  <li>Flip the coin represented by <em>X</em> and return the result.</li>
</ol>

<blockquote>

  <p><strong>Notes:</strong></p>

  <ol>
    <li>
      <p><strong>Building convex combinations.</strong> Suppose the following:</p>

      <ul>
        <li>A function <em>f</em>(<em>λ</em>) is written as <em>f</em>(<em>λ</em>) = $w_1(\lambda)+w_2(\lambda)+…$, where $w_1, w_2, …$ are continuous functions.</li>
        <li>Let <em>g</em>(<em>n</em>) be a number such that 0 &lt; <em>g</em>(1) + <em>g</em>(2) + … = <em>T</em>, and <em>T</em> is 1 or less.</li>
        <li>Define <em>X</em> as a randomly chosen number as follows: <em>X</em> is 0 with probability 1−<em>T</em>, and <em>X</em> is <em>n</em> (where <em>n</em>≥1) with probability <em>g</em>(<em>n</em>).</li>
        <li>For each integer <em>n</em>≥1, $1 \ge g(n) \ge w_n(\lambda) \ge 0$, wherever $0 \le \lambda \le 1$.</li>
        <li>For each integer <em>n</em>≥1, if $g(n)&gt;0$, the function $w_n(\lambda)/g(n)$ admits a Bernoulli factory; see the section “About Bernoulli Factories”.</li>
      </ul>

      <p>Then by <strong>generating <em>X</em> and outputting 0 if <em>X</em> is 0, and otherwise flipping a coin with probability of heads of <em>w</em><sub><em>X</em></sub>(<em>λ</em>)/<em>g</em>(<em>X</em>)</strong>, the probability <em>f</em>(<em>λ</em>) can be simulated as the convex combination—</p>
    </li>
  </ol>
</blockquote>

<p>\(f(\lambda)=(1-T) \frac{0}{1-T} + g(1) \frac{w_1(\lambda)}{g(1)} + g(2) \frac{w_2(\lambda)}{g(2)} + ...,\) letting 0/0 = 0.  See also Mendo (2019)<sup id="fnref:24:1" role="doc-noteref"><a href="#fn:24" class="footnote" rel="footnote">24</a></sup>.
&gt;
&gt; 2. <strong>Constants writable as a sum of nonnegative numbers.</strong> A special case of note 1.  Let <em>g</em> be as in note 1 (except <em>T</em> must equal 1), and let $c$ be a constant written as—</p>

<p>\(c=a_1+a_2+a_3+...,\)
where—
&gt;
&gt;     - $a_n$ are each 0 or greater and sum to 1 or less, and
&gt;     - $1 \ge g(n) \ge a_n \ge 0$ for each integer $n\ge 1$.
&gt;
&gt;     Then by <strong>generating <em>X</em> and flipping a coin with probability of heads of <em>a</em><sub><em>X</em>−1</sub>/<em>g</em>(<em>X</em>)</strong>, the probability  <em>c</em> can be simulated as the convex combination—</p>

<p>\(f(\lambda)=g(1) \frac{a_1}{g(1)} + g(2) \frac{a_2}{g(2)} + ...,\) letting 0/0 = 0.
&gt;
&gt; <strong>Examples:</strong>
&gt;
&gt; 1. Generate <em>X</em>, a Poisson random variate with mean <em>μ</em>, then flip the input coin.  With probability 1/(1+<em>X</em>), return the result of the coin flip; otherwise, return 0.  This corresponds to <em>g</em>(<em>i</em>) being the Poisson probabilities and the coin for <em>h</em><sub><em>i</em></sub> returning 1 with probability 1/(1+<em>i</em>), and 0 otherwise.  The probability that this method returns 1 is <strong>E</strong>[1/(1+<em>X</em>)], or (exp(<em>μ</em>)−1)/(exp(<em>μ</em>)*<em>μ</em>).
&gt; 2. (Wästlund 1999)<sup id="fnref:9:2" role="doc-noteref"><a href="#fn:9" class="footnote" rel="footnote">9</a></sup>: Generate a Poisson random variate <em>X</em> with mean 1, then flip the input coin <em>X</em> times.  Return 0 if any of the flips returns 1, or 1 otherwise.  This is a Bernoulli factory for exp(−<em>λ</em>), and corresponds to <em>g</em>(<em>i</em>) being the Poisson probabilities, namely 1/(<em>i</em>!*exp(1)), and <em>h</em><sub><em>i</em></sub>() being (1−<em>λ</em>)<sup><em>i</em></sup>.
&gt; 3. Generate <em>X</em>, a Poisson random variate with mean <em>μ</em>, run the <strong>ExpMinus</strong> algorithm with <em>z</em> = <em>X</em>, and return the result.  The probability of returning 1 this way is <strong>E</strong>[exp(−<em>X</em>)], or exp(<em>μ</em>*exp(−1)−<em>μ</em>).  The following Python code uses the computer algebra library SymPy to find this probability: <code>from sympy.stats import *; E(exp(-Poisson('P', x))).simplify()</code>.
&gt; 4. A multivariate Bernoulli factory (Huber 2016)<sup id="fnref:42" role="doc-noteref"><a href="#fn:42" class="footnote" rel="footnote">42</a></sup> of the form <em>R</em> = <em>C</em><sub>0</sub>*<em>λ</em><sub>0</sub> + <em>C</em><sub>1</sub>*<em>λ</em><sub>1</sub> + … + <em>C</em><sub><em>m</em>−1</sub>*<em>λ</em><sub><em>m</em>−1</sub>, where <em>C</em><sub><em>i</em></sub> are known constants greater than 0,  <em>ϵ</em> &gt; 0, and <em>R</em> ≤ 1 − <em>ϵ</em>: Choose an integer in [0, <em>m</em>) uniformly at random, call it <em>i</em>, then run a linear Bernoulli factory for (<em>m</em>*<em>C</em><sub><em>i</em></sub>)*<em>λ</em><sub><em>i</em></sub>.  This differs from Huber’s suggestion of “thinning” a random process driven by multiple input coins.
&gt; 5. <strong>Probability generating function</strong> (PGF) (Dughmi et al. 2021)<sup id="fnref:43" role="doc-noteref"><a href="#fn:43" class="footnote" rel="footnote">43</a></sup>. Generates heads with probability <strong>E</strong>[<em>λ</em><sup><em>X</em></sup>], that is, the expected value (“long-run average”) of <em>λ</em><sup><em>X</em></sup>.  <strong>E</strong>[<em>λ</em><sup><em>X</em></sup>] is the PGF for the distribution of <em>X</em>.  The algorithm follows: (1) Generate a random integer <em>X</em> in some way; (2) Flip the input coin until the flip returns 0 or the coin is flipped <em>X</em> times, whichever comes first.  Return 1 if all the coin flips, including the last, returned 1 (or if <em>X</em> is 0); or return 0 otherwise.
&gt; 6. Assume <em>X</em> is the number of fair coin flips that show 0 (tails) before the first 1 (heads) is generated.  Then <em>g</em>(<em>n</em>) = $1/(2^{n+1})$.
&gt; 7. <strong>Poisson to Bernoulli.</strong> Suppose there is a stream of independent Poisson random variates with unknown mean $p$.  Also suppose there is a continuous function $f(p)$ satisfying $0\le f(p)\le 1$ whenever $p\ge 0$.  Then consider the following simple algorithm, which takes an integer $n\gt 0$:
&gt;
&gt;     1. Take $n$ variates from the stream and sum them.  Call the sum $X$.  (The result is then a Poisson random variate with mean $n\cdot p$.)
&gt;     2. With probability $f(X/n)$, return 1.  Otherwise, return 0.
&gt;
&gt;     Then this algorithm outputs 1 with probability equal to $\phi(p)$, where $\phi(p)$ is the <em>Szász operator</em> (or <em>Szász–Mirakyan operator</em>) of $f$ of degree $n$ (e.g., Szász (1950)<sup id="fnref:44" role="doc-noteref"><a href="#fn:44" class="footnote" rel="footnote">44</a></sup>).  Indeed, the Szász operator can be written as a convex combination with $g(i)$ equal to the probability of getting $i$ in step 1 and with $h_X$ equal to $f(X/n)$. The algorithm is the same as in Goyal and Sigman (2012)<sup id="fnref:7:2" role="doc-noteref"><a href="#fn:7" class="footnote" rel="footnote">7</a></sup>, except coin flips with heads probability $\lambda$ are replaced with Poisson variates of mean $p$.
&gt; 8. <strong>The original Bernoulli factories.</strong>  Keane and O’Brien’s (1994)<sup id="fnref:2:3" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup> paper introducing Bernoulli factories showed that any Bernoulli factory function $f(\lambda)$ can be written as a convex combination of polynomials.  In their proof, $g(i) = (1/4)\cdot(3/4)^{i-1}$ (and $g(0)=0$), and each $h_i(\lambda)$ is a polynomial, not necessarily of degree <em>i</em>, whose Bernstein coefficients are each either 0 or 1 (see “<a href="#Certain_Polynomials"><strong>Certain Polynomials</strong></a>”).
&gt; 9. <strong>Polynomials to zero-and-one polynomials.</strong> Suppose $f(\lambda)$ is a polynomial of degree-$n$  and each of its Bernstein coefficients $(a[0], a[1], …, a[n])$ (see “<a href="#Certain_Polynomials"><strong>Certain Polynomials</strong></a>”) is 0 or greater and 1 or less. Then $f$ can be written as a convex combination of polynomials with only 0 and 1 as Bernstein coefficients.<br />Specifically, $g(i)=(1/2)^i$ and $g(0)=0$, and $h_i(\lambda)$ is a polynomial whose Bernstein coefficients are $(b[i][0], b[i][1], …, b[i][n])$, where $b[i][j]$ is 1 if $a[j]$ is 1 or if floor($a[j]\cdot 2^i$) (or the $i$-th binary digit after the point in $a[j]$’s binary expansion) is odd<sup id="fnref:25:2" role="doc-noteref"><a href="#fn:25" class="footnote" rel="footnote">25</a></sup>, or 0 otherwise.</p>

<p>The previous algorithm can be generalized further, so that an input coin that simulates the probability <em>λ</em> helps generate the random integer in step 1.  Now, the overall algorithm returns 1 with probability—</p>

\[\sum_{k\ge 0} g(k,\lambda) h_k(\lambda).\]

<p>This algorithm, called <strong>Algorithm CC</strong> in this document, follows.</p>

<ol>
  <li>Choose an integer 0 or greater at random, with help of the input coin for $\lambda$, so that $k$ is chosen with probability $g(k,\lambda)$. Call the chosen integer <em>X</em>.</li>
  <li>Flip the coin represented by <em>X</em> and return the result.</li>
</ol>

<blockquote>
  <p><strong>Notes:</strong></p>

  <ol>
    <li>Step 1 of this algorithm is incomplete, since it doesn’t explain how to generate $X$ exactly.  That depends on the probability $g(k,\lambda)$.</li>
    <li>If we define <em>S</em> to be a set of integers 0 or greater, and replace step 2 with “If <em>X</em> is in the set <em>S</em>, return 1.  Otherwise, return 0”, then the algorithm returns 1 with probability $\sum_{k\text{ in }S} g(k,\lambda)$ (because $h_k(\lambda)$ is either 1 if $k$ is in <em>S</em>, or 0 otherwise). Then the so-called “even-parity” construction<sup id="fnref:32:1" role="doc-noteref"><a href="#fn:32" class="footnote" rel="footnote">32</a></sup> is a special case of this algorithm, if <em>S</em> is the even positive integers and zero and if the example below is used.</li>
  </ol>

  <p><strong>Example:</strong> Step 1 can read “Flip the input coin for <em>λ</em> repeatedly until it returns 0.  Set <em>X</em> to the number of times the coin returned 1 this way.” Then step 1 generates <em>X</em> with probability $\lambda^X (1-\lambda)$.<sup id="fnref:45" role="doc-noteref"><a href="#fn:45" class="footnote" rel="footnote">45</a></sup></p>
</blockquote>

<p><a id="Bernoulli_Race_and_Generalizations"></a></p>

<h4 id="bernoulli-race-and-generalizations">Bernoulli Race and Generalizations</h4>

<p>The Bernoulli factory approach, which simulates a coin with unknown heads probability, leads to an algorithm to roll an <em>n</em>-face die where the chance of each face is unknown.  Here is one such die-rolling algorithm (Schmon et al. 2019)<sup id="fnref:46" role="doc-noteref"><a href="#fn:46" class="footnote" rel="footnote">46</a></sup>.  It generalizes the so-called Bernoulli Race (see note 1 below) and returns <em>i</em> with probability—</p>

\[\phi_i = \frac{g(i)\cdot h_i(\pmb\mu)}{\sum_{k=0}^r g(k)\cdot h_k(\pmb\mu)},\]

<p>where:</p>

<ul>
  <li><em>r</em> is an integer greater than 0.  There are <em>r</em>+1 values this algorithm can choose from.</li>
  <li><em>g</em>(<em>i</em>) takes an integer <em>i</em> and returns a number 0 or greater.  This serves as a <em>weight</em> for the “coin” labeled <em>i</em>; the higher the weight, the greater the probability the “coin” will be “flipped”.</li>
  <li><em>h</em><sub><em>i</em></sub>(<strong><em>μ</em></strong>) takes in a number <em>i</em> and the probabilities of heads of one or more input coins, and returns a number that is 0 or greater and 1 or less.  This represents the “coin” for one of the <em>r</em>+1 choices.</li>
</ul>

<p>The algorithm follows.</p>

<ol>
  <li>Generate a random integer <em>i</em> in some way, so that <em>i</em> is generated with probability proportional to the following weights: [<em>g</em>(0), <em>g</em>(1), …, <em>g</em>(<em>r</em>)].</li>
  <li>Run a Bernoulli factory algorithm for <em>h</em><sub><em>i</em></sub>(<strong><em>μ</em></strong>).  If the run returns 0 (<em>i</em> is rejected), go to step 1.</li>
  <li><em>i</em> is accepted, so return <em>i</em>.</li>
</ol>

<blockquote>
  <p><strong>Notes:</strong></p>

  <ol>
    <li>The <em>Bernoulli Race</em> (Dughmi et al. 2021)<sup id="fnref:43:1" role="doc-noteref"><a href="#fn:43" class="footnote" rel="footnote">43</a></sup> is a special case of this algorithm with <em>g</em>(<em>k</em>) = 1 for every <em>k</em>. Say there are <em>n</em> coins, then choose one of them uniformly at random and flip that coin. If the flip returns 1, return <em>X</em>; otherwise, repeat this algorithm.  This algorithm chooses a random coin based on its probability of heads.</li>
    <li>If we define <em>S</em> to be the integers [0, <em>r</em>] or a subset of them and replace step 3 with “If <em>i</em> is in the set <em>S</em>, return 1.  Otherwise, return 0.”, the algorithm returns 1 with probability $\sum_{k\text{ in }S} \phi_k$, and 0 otherwise.  In that case, the modified algorithm has the so-called “die-coin algorithm” of Agrawal et al. (2023, Appendix D)<sup id="fnref:47" role="doc-noteref"><a href="#fn:47" class="footnote" rel="footnote">47</a></sup> as a special case with—<br /><em>g</em>(<em>k</em>) = <em>c</em><sup><em>k</em></sup>*<em>d</em><sup><em>r</em>−<em>k</em></sup>,<br /><em>h</em><sub><em>k</em></sub>(<em>λ</em>, <em>μ</em>) = <em>λ</em><sup><em>k</em></sup>*<em>μ</em><sup><em>r</em>−<em>k</em></sup> (for the following algorithm: flip the <em>λ</em> coin <em>k</em> times and the <em>μ</em> coin <em>r</em>−<em>k</em> times; return 1 if all flips return 1, or 0 otherwise), and<br /><em>S</em> is the set of integers that are 1 or greater and <em>r</em> or less,<br />where <em>c</em>≥0, <em>d</em>≥0, and <em>λ</em> and <em>μ</em> are the probabilities of heads of two input coins.  In that paper, <em>c</em>, <em>d</em>, <em>λ</em>, and <em>μ</em> correspond to <em>c</em><sub><em>y</em></sub>, <em>c</em><sub><em>x</em></sub>, <em>p</em><sub><em>y</em></sub>, and <em>p</em><sub><em>x</em></sub>, respectively.</li>
    <li>Although not noted in the Schmon paper, the <em>r</em> in the algorithm can be infinity (see also Wästlund 1999, Theorem 2.7<sup id="fnref:9:3" role="doc-noteref"><a href="#fn:9" class="footnote" rel="footnote">9</a></sup>).  In that case, Step 1 is changed to say “Choose an integer 0 or greater at random with probability <em>g</em>(<em>k</em>) for integer <em>k</em>.  Call the chosen integer <em>i</em>.”  As an example, step 1 can sample from a Poisson distribution, which can take on any integer 0 or greater.</li>
  </ol>
</blockquote>

<p>The previous algorithm can be generalized further, so that an input coin that simulates the probability <em>λ</em> helps generate the random integer in step 1.  Now, the overall algorithm generates an integer <em>X</em> with probability—</p>

\[\frac{g(X,\lambda) h_X(\pmb \mu)}{\sum_{k\ge 0} g(k,\lambda) h_k(\pmb \mu)}.\]

<p>In addition, the set of integers to choose from can be infinite.  This algorithm, called <strong>Algorithm BR</strong> in this document, follows.</p>

<ol>
  <li>Choose an integer 0 or greater at random, with help of the input coin for $\lambda$, so that $k$ is chosen with probability proportional to $g(k,\lambda)$. Call the chosen integer <em>X</em>.  (If the integer must be less than or equal to an integer <em>r</em>, then the integer will have probability proportional to the following weights: [<em>g</em>(0, <em>λ</em>), <em>g</em>(1, <em>λ</em>), …, <em>g</em>(<em>r</em>, <em>λ</em>)].)</li>
  <li>Run a Bernoulli factory algorithm for <em>h</em><sub><em>X</em></sub>(<strong><em>μ</em></strong>).  If the run returns 0 (<em>i</em> is rejected), go to step 1.</li>
  <li><em>X</em> is accepted, so return <em>X</em>.</li>
</ol>

<blockquote>
  <p><strong>Notes:</strong></p>

  <ol>
    <li>Step 1 of this algorithm is incomplete, since it doesn’t explain how to generate $X$ exactly.  That depends on the weights $g(k,\lambda)$.</li>
    <li>The probability that $s$ many values of <em>X</em> are rejected by this algorithm is $p(1 − p)^s$, where—</li>
  </ol>
</blockquote>

<p>\(p=\frac{\sum_{k\ge 0} g(k,\lambda) h_k(\pmb \mu)}{\sum_{k\ge 0} g(k,\lambda)}.\)
&gt;
&gt; <strong>Example:</strong> Step 1 can read “Flip the input coin for <em>λ</em> repeatedly until it returns 0.  Set <em>X</em> to the number of times the coin returned 1 this way.” Then step 1 generates <em>X</em> with probability $g(X,\lambda)=\lambda^X (1-\lambda)$.<sup id="fnref:45:1" role="doc-noteref"><a href="#fn:45" class="footnote" rel="footnote">45</a></sup></p>

<p><a id="Flajolet_s_Probability_Simulation_Schemes"></a></p>

<h4 id="flajolets-probability-simulation-schemes">Flajolet’s Probability Simulation Schemes</h4>

<p>Flajolet et al. (2010)<sup id="fnref:1:4" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup> described two schemes for probability simulation, inspired by restricted models of computing.</p>

<p><strong>Certain algebraic functions.</strong> Flajolet et al. (2010)<sup id="fnref:1:5" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup> showed a sampling method modeled on <em>pushdown automata</em> (state machines with a stack) that are given flips of a coin with unknown heads probability <em>λ</em>.<sup id="fnref:48" role="doc-noteref"><a href="#fn:48" class="footnote" rel="footnote">48</a></sup> These flips form a <em>bitstring</em>, and each pushdown automaton accepts only a certain class of bitstrings.  The rules for determining whether a bitstring belongs to that class are called a <em>binary stochastic grammar</em>, which uses an alphabet of only two “letters”.  If a pushdown automaton terminates, it accepts a bitstring with probability <em>f</em>(<em>λ</em>), where <em>f</em> must be an <em>algebraic function over rationals</em> (a function that can be a solution of a nonzero polynomial equation whose power coefficients are rational numbers) (Mossel and Peres 2005)<sup id="fnref:16:1" role="doc-noteref"><a href="#fn:16" class="footnote" rel="footnote">16</a></sup>.</p>

<p>Specifically, the method simulates the following function (not necessarily algebraic): \(f(\lambda) = \sum_{k\ge 0} g(k,\lambda) h_k(\lambda),\)
where the paper uses $g(k, \lambda) = \lambda^k (1-\lambda)$ and $h_k(\lambda) = W(k)/\beta^k$, so that—</p>

<p>\(f(\lambda) = (1-\lambda) OGF(\lambda/\beta),\)
where:</p>

<ul>
  <li>$W(k)$ returns a number in the interval [0, $\beta^k$].  If $W(k)$ is an integer for every $k$, then $W(k)$ is the number of $k$-letter words that can be produced by the stochastic grammar in question.</li>
  <li>$\beta \ge 2$ is an integer.  This is the alphabet size, or the number of “letters” in the alphabet.  This is 2 for the cases discussed in the Flajolet paper (binary stochastic grammars), but it can be greater than 2 for more general stochastic grammars.</li>
  <li>$OGF(x) = W(0) + W(1) x + W(2) x^2 + W(3) x^3 + …$ is an <em>ordinary generating function</em>.  This is a <em>power series</em> whose <em>power coefficients</em> are $W(i)$ (for example, $W(2)$ is power coefficient 2).</li>
</ul>

<p>The method uses <strong>Algorithm CC</strong>, where step 1 is done as follows: “Flip the input coin repeatedly until it returns 0.  Set <em>X</em> to the number of times the coin returned 1 this way.”<sup id="fnref:45:2" role="doc-noteref"><a href="#fn:45" class="footnote" rel="footnote">45</a></sup>  Optionally, step 2 can be done as described in Flajolet et al., (2010)<sup id="fnref:1:6" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>: generate an <em>X</em>-letter word uniformly at random and “parse” that word using a stochastic grammar to determine whether that word can be produced by that grammar.</p>

<blockquote>
  <p><strong>Note:</strong> The <em>radius of convergence</em> of OGF is the greatest number <em>ρ</em> such that OGF is defined at every point less than <em>ρ</em> away from the origin (0, 0).  In this algorithm, the radius of convergence is in the interval [1/<em>β</em>, 1] (Flajolet 1987)<sup id="fnref:49" role="doc-noteref"><a href="#fn:49" class="footnote" rel="footnote">49</a></sup>.  For example, the OGF involved in the square root construction given in the examples below has radius of convergence 1/2.</p>

  <p><strong>Examples:</strong></p>

  <ol>
    <li>The following is an example from the Flajolet et al. paper. An <em>X</em>-letter binary word can be “parsed” as follows to determine whether that word encodes a ternary tree: “2. If <em>X</em> is 0, return 0.  Otherwise, set <em>i</em> to 1 and <em>d</em> to 1.; 2a. Generate 1 or 0 with equal probability (that is, either 0 or 1, chosen with equal probability), then subtract 1 from <em>d</em> if that bit is 0, or add 2 to <em>d</em> otherwise.; 2b. Add 1 to <em>i</em>. Then, if <em>i</em> &lt; <em>X</em> and <em>d</em> &gt; 0, go to step 3a.; 2c. Return 1 if <em>d</em> is 0 and <em>i</em> is <em>X</em>, or 0 otherwise.”</li>
    <li>
      <p>$h_X(\lambda)$ can have the form—</p>

\[{X\choose X/t}\cdot(1-\mathtt{Coin}(\lambda))^{X-X/t}\cdot(\mathtt{Coin}(\lambda))^{X/t},\]

      <p>if <em>X</em> is divisible by <em>t</em>, and 0 otherwise, where <code>Coin</code>(<em>λ</em>) is a Bernoulli factory function, and <em>t</em> ≥ 2 is an integer.  One special case is when <code>Coin</code>(<em>λ</em>) = 1/<em>β</em>, where <em>β</em> ≥ 2 is the alphabet size and is an integer.  In that case, $W(X)$ is <strong>the number of <em>X</em>-letter words with exactly <em>X</em>/<em>t</em> A’s, for an alphabet size of <em>β</em></strong>, is equal to $h_X(\lambda) \beta^X$, and also has the following form:</p>

\[{X\choose X/t} (\beta-1)^{X-X/t} = {X\choose X/t} (1-1/\beta)^{X-X/t} (1/\beta)^{X/t} \beta^X,\]

      <p>if <em>X</em> is divisible by <em>t</em>, and 0 otherwise. (Here, $\beta-1^{X-X/t}$ is the number of (<em>X</em>−<em>X</em>/t)-letter words with only letters other than A.) Then step 2 of the algorithm can be done as follows: “2. If <em>X</em> is not divisible by <em>t</em>, return 0. Otherwise, run a Bernoulli factory algorithm for <code>Coin</code>(<em>λ</em>), <em>X</em> times, and set <em>y</em> to the number of runs that return 1 this way (for example, if <code>Coin</code>(<em>λ</em>) = 1/<em>β</em>, generate <em>X</em> uniform random integers in the interval [0, <em>β</em>), then set <em>y</em> to the number of zeros generated this way), then return 1 if <em>y</em> equals <em>X</em>/<em>t</em>, or 0 otherwise.”  If <em>β</em> = 2, then this reproduces another example from the Flajolet paper, namely, lattice paths with upward steps of size <em>t</em>−1 and downward steps of size 1.<br />Although not required, <code>Coin</code>(<em>λ</em>) can be a rational function (a ratio of two polynomials) whose Bernstein coefficients are rational numbers; if so, <em>f</em> will be an <em>algebraic function</em> and can be simulated by a <em>pushdown automaton</em>.<br />An alternative algorithm is: “Set <em>d</em> to 0, then do the following process repeatedly until this run of the algorithm returns a value: (a) Flip the input coin. If it returns 1, go to substep (b). Otherwise, return either 1 if <em>d</em> is 0, or 0 otherwise. (b) Run a Bernoulli factory algorithm for <code>Coin</code>(<em>λ</em>). If the run returns 1, add (<em>t</em>−1) to <em>d</em>. Otherwise, subtract 1 from <em>d</em>.”</p>
    </li>
    <li>
      <p>$h_X(\lambda)$ can have the form—</p>

\[{X\alpha\choose X}\cdot(1-\mathtt{Coin}(\lambda))^{X\cdot \alpha-X}\cdot(\mathtt{Coin}(\lambda))^{X},\]

      <p>where <code>Coin</code>(<em>λ</em>) is a Bernoulli factory function (as in example 2), and <em>α</em> ≥ 1 is an integer.  One special case is when <code>Coin</code>(<em>λ</em>) = 1/<em>β</em>, where <em>β</em> ≥ 2 is the alphabet size and is an integer.  In that case, $W(X)$ is equal to $h_X(\lambda) \beta^X$ and also has the following form:\({X\alpha\choose X}\cdot(\beta-1)^{X\cdot \alpha-X} (1/\beta)^{X\cdot \alpha-X} = {X\alpha\choose X}\cdot(1-1/\beta)^{X\cdot \alpha-X}.\) Then step 2 of the algorithm can be done as follows: “2. Run a Bernoulli factory algorithm for <code>Coin</code>(<em>λ</em>), <em>X</em> * <em>α</em> times, and set <em>y</em> to the number of runs that return 1 this way, then return 1 if <em>y</em> equals <em>X</em>, or 0 otherwise.”  If <em>α</em> = 2 and <em>β</em> = 2 (or <code>Coin</code>(<em>λ</em>) = 1/2), then this expresses the <em>square-root construction</em> sqrt(1 − <em>λ</em>), mentioned in the Flajolet et al. paper.  If <em>α</em> is 1, the modified algorithm simulates the following probability: (<em>λ</em>−1)/(<em>λ</em>*<code>Coin</code>(<em>λ</em>)−1).  If <em>α</em>=2, the probability is $(1-\lambda)/\sqrt{1+4\lambda\mathtt{Coin}(\lambda)(\mathtt{Coin}(\lambda)-1)}$.<br />Interestingly, I have found that if <em>α</em> is 2 or greater, the probability simplifies to involve a hypergeometric function.  Specifically, if <code>Coin</code>(<em>λ</em>) = 1/<em>β</em>, the probability becomes—</p>

      <p>\(f(\lambda)=(1-\lambda)\times_{\alpha-1} F_{\alpha-2} \left(\frac{1}{\alpha},\frac{2}{\alpha},...,\frac{\alpha-1}{\alpha}; \frac{1}{\alpha-1},\frac{2}{\alpha-1},...,\frac{\alpha-2}{\alpha-1}; \lambda\frac{\alpha^\alpha}{(\alpha-1)^{\alpha-1}2^{\alpha}}\right),\) if <em>β</em> = 2, or more generally—
 \(f(\lambda)=(1-\lambda)\times_{\alpha-1} F_{\alpha-2} \left(\frac{1}{\alpha},\frac{2}{\alpha},...,\frac{\alpha-1}{\alpha}; \frac{1}{\alpha-1},\frac{2}{\alpha-1},...,\frac{\alpha-2}{\alpha-1}; \lambda\frac{\alpha^\alpha(\beta-1)^{\alpha-1}}{(\alpha-1)^{\alpha-1}\beta^{\alpha}}\right).\)
 The ordinary generating function for this modified algorithm is thus—
 \(OGF(z) = 1\times_{\alpha-1} F_{\alpha-2} \left(\frac{1}{\alpha},\frac{2}{\alpha},...,\frac{\alpha-1}{\alpha}; \frac{1}{\alpha-1},\frac{2}{\alpha-1},...,\frac{\alpha-2}{\alpha-1}; z\frac{\alpha^\alpha (\beta-1)^{\alpha-1}}{(\alpha-1)^{\alpha-1}\beta^{\alpha-1}}\right).\)</p>
    </li>
    <li>The probability involved in example 2 likewise involves hypergeometric functions: \(f(\lambda)=(1-\lambda)\times_{t-1} F_{t-2}\left(\frac{1}{t},\frac{2}{t},...,\frac{t-1}{t}; \frac{1}{t-1},\frac{2}{t-1},...,\frac{t-2}{t-1}; \lambda^t \frac{t^t (\beta-1)^{t-1}}{(t-1)^{t-1} \beta^t}\right).\)</li>
    <li>If $W(X)$ is <strong>the number of $X$-letter words with a two-letter alphabet that meet some condition</strong>, where the chance of the letter “heads” is <code>Coin</code>(<em>λ</em>), and <code>Coin</code>(<em>λ</em>) is a Bernoulli factory function (as in example 2), then $h_X(\lambda)$ can be written as—
 \(\sum_{m=0}^X V(X,m) (\mathtt{Coin}(\lambda))^m (1-\mathtt{Coin}(\lambda))^{X-m},\)
where $V(X,m)$ satisfies $0\le V(X,m)\le {X\choose m}$ and is the number of $X$-letter words that have $m$ heads and meet that condition, so that—
 \(W(X) = h_X(\lambda) (1/\mathtt{Coin}(\lambda))^X = \sum_{m=0}^X V(X,m) \left(\frac{1-\mathtt{Coin}(\lambda)}{\mathtt{Coin}(\lambda)}\right)^{X-m}.\)</li>
  </ol>
</blockquote>

<p><strong>The von Neumann schema.</strong> Flajolet et al. (2010)<sup id="fnref:1:7" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>, section 2, describes what it calls the <em>von Neumann schema</em>, which produces random integers based on a coin with unknown heads probability.  To describe the schema, the following definition is needed:</p>

<ul>
  <li>A <em>permutation class</em> is a rule that gives how a sequence of numbers must be ordered.  The ordering of the numbers is called a <em>permutation</em>.  Two examples of permutation classes cover permutations sorted in high-to-low order, and permutations whose highest number appears first.  When checking whether a sequence follows a permutation class, only less-than and greater-than comparisons between two numbers are allowed.</li>
</ul>

<p>Now, given a permutation class and an input coin, the von Neumann schema generates a random integer $n\ge 0$, with probability equal to—</p>

<p>\(w_n(\lambda) = \frac{g(n,\lambda) h_n(\lambda)}{\sum_{k\ge 0} g(k,\lambda) h_k(\lambda)},\)
where the schema uses $g(k, \lambda) = \lambda^k (1-\lambda)$ and $h_k(\lambda) = \frac{V(k)}{k!}$, so that—</p>

<p>\(w_n(\lambda)=\frac{(1-\lambda) \lambda^n V(n)/(n!)}{(1-\lambda) EGF(\lambda)} = \frac{\lambda^n V(n)/(n!)}{EGF(\lambda)},\)
where:</p>

<ul>
  <li>$V(n)$ returns a number in the interval [0, <em>n</em>!].  If $V(n)$ is an integer for every $n$, this is the number of permutations of size $n$ that belong in the permutation class.</li>
  <li>$EGF(\lambda) = \sum_{k\ge 0} \lambda^k \frac{V(k)}{k!}$ is an <em>exponential generating function</em>, which completely determines a permutation class.</li>
  <li>The probability that $r$ many values of $X$ are rejected by the von Neumann schema (for the choices of $g$ and $h$ above) is $p(1 − p)^r$, where $p=(1-\lambda) EGF(\lambda)$.</li>
</ul>

<p>The von Neumann schema uses <strong>Algorithm BR</strong>, where in step 1, the von Neumann schema as given in the Flajolet paper does the following: “Flip the input coin repeatedly until it returns 0.  Set <em>X</em> to the number of times the coin returned 1 this way.”<sup id="fnref:45:3" role="doc-noteref"><a href="#fn:45" class="footnote" rel="footnote">45</a></sup>  Optionally, step 2 can be implemented as described in Flajolet et al., (2010)<sup id="fnref:1:8" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>: generate  <em>X</em> uniform random variates between 0 and 1, then determine whether those numbers satisfy the given permutation class, or generate as many of those numbers as necessary to make this determination.</p>

<blockquote>
  <p><strong>Note:</strong> The von Neumann schema can sample from any <em>power series distribution</em> (such as Poisson, negative binomial, and logarithmic series), given a suitable exponential generating function.  However, the number of input coin flips required by the schema grows without bound as <em>λ</em> approaches 1.</p>

  <p><strong>Examples:</strong></p>

  <ol>
    <li>
      <p>Examples of permutation classes include the following (using the notation in “Analytic Combinatorics” (Flajolet and Sedgewick 2009)<sup id="fnref:50" role="doc-noteref"><a href="#fn:50" class="footnote" rel="footnote">50</a></sup>):</p>

      <ul>
        <li>Single-cycle permutations, or permutations whose highest number appears first (EGF(<em>λ</em>) = Cyc(<em>λ</em>) = ln(1/(1 − <em>λ</em>)); V(<em>n</em>) = ((<em>n</em> − 1)!) [or 0 if <em>n</em> is 0)]).</li>
        <li>Sorted permutations, or permutations whose numbers are sorted in high-to-low order (EGF(<em>λ</em>) = Set(<em>λ</em>) = exp(<em>λ</em>); V(<em>n</em>) = 1).</li>
        <li>All permutations (EGF(<em>λ</em>) = Seq(<em>λ</em>) = 1/(1 − <em>λ</em>); V(<em>n</em>) = <em>n</em>!),</li>
        <li>Alternating permutations of even size (EGF(<em>λ</em>) = 1/cos(<em>λ</em>) = sec(<em>λ</em>); V(<em>n</em>) = W(<em>n</em>/2) if <em>n</em> is even<sup id="fnref:27:1" role="doc-noteref"><a href="#fn:27" class="footnote" rel="footnote">27</a></sup> and 0 otherwise, where the W(<em>m</em>) starting at <em>m</em> = 0 is <a href="https://oeis.org/A000364"><strong>A000364</strong></a> in the <em>On-Line Encyclopedia of Integer Sequences</em>).</li>
        <li>Alternating permutations of odd size (EGF(<em>λ</em>) = tan(<em>λ</em>); V(<em>n</em>) = W((<em>n</em>+1)/2) if <em>n</em> is odd<sup id="fnref:25:3" role="doc-noteref"><a href="#fn:25" class="footnote" rel="footnote">25</a></sup> and 0 otherwise, where the W(<em>m</em>) starting at <em>m</em> = 1 is <a href="https://oeis.org/A000182"><strong>A000182</strong></a>).</li>
      </ul>
    </li>
    <li>Using the class of <em>sorted permutations</em>, we can generate a Poisson random variate with mean <em>λ</em> via the von Neumann schema, where <em>λ</em> is the probability of heads of the input coin.  This would lead to an algorithm for exp(−<em>λ</em>) — outputting 1 if a Poisson random variate with mean <em>λ</em> is 0, or 0 otherwise — but for the reason given in the note, this algorithm gets slower as <em>λ</em> approaches 1.  Also, if <em>c</em> &gt; 0 is a real number, adding a Poisson random variate with mean floor(<em>c</em>) to one with mean <em>c</em>−floor(<em>c</em>) generates a Poisson random variate with mean <em>c</em>.</li>
    <li>
      <p>The algorithm for exp(−<em>λ</em>), described in example 2, is as follows:</p>

      <ol>
        <li>Flip the input coin repeatedly until it returns 0.  Set <em>X</em> to the number of times the coin returned 1 this way.</li>
        <li>With probability 1/((<em>X</em>)!), <em>X</em> is accepted so return a number that is 1 if <em>X</em> is 0 and 0 otherwise.  Otherwise, go to the previous step.</li>
      </ol>
    </li>
    <li>
      <p>For the class of <em>alternating permutations of even size</em> (see example 1), step 2 in <strong>Algorithm BR</strong> can be implemented as follows (Flajolet et al. 2010, sec. 2.2)<sup id="fnref:1:9" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>:</p>

      <ul>
        <li>(2a.) (Limited to even-sized permutations.) If <em>X</em> is odd<sup id="fnref:25:4" role="doc-noteref"><a href="#fn:25" class="footnote" rel="footnote">25</a></sup>, reject <em>X</em> (and go to step 1).</li>
        <li>(2b.) Generate a uniform random variate between 0 and 1, call it U, then set <em>i</em> to 1.</li>
        <li>(2c.) While <em>i</em> is less than <em>X</em>:
          <ul>
            <li>Generate a uniform random variate between 0 and 1, call it V.</li>
            <li>If <em>i</em> is odd<sup id="fnref:25:5" role="doc-noteref"><a href="#fn:25" class="footnote" rel="footnote">25</a></sup> and V is less than U, or if <em>i</em> is even<sup id="fnref:27:2" role="doc-noteref"><a href="#fn:27" class="footnote" rel="footnote">27</a></sup> and U is less than V, reject <em>X</em> (and go to step 1).</li>
            <li>Add 1 to i, then set U to V.</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>For the class of <em>alternating permutations of odd size</em> (see example 1), step 2 in <strong>Algorithm BR</strong> can be implemented as in example 4, except 2a reads: “(2a.) (Limited to odd-sized permutations.) If <em>X</em> is even<sup id="fnref:27:3" role="doc-noteref"><a href="#fn:27" class="footnote" rel="footnote">27</a></sup>, reject <em>X</em> (and go to step 1).” (Flajolet et al. 2010, sec. 2.2)<sup id="fnref:1:10" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>.</li>
    <li>By computing—
 \(\frac{\sum_{k\ge 0} g(2k+1,\lambda) h_{2k+1}(\lambda)}{\sum_{k\ge 0} g(k,\lambda) h_k(\lambda)}\)
 (which is the probability of getting an odd-numbered output), and using the class of sorted permutations ($h_i(\lambda)=1/(i!)$), it is found that the von Neumann schema’s output is odd with probability $\exp(-\lambda)\times \sinh(\lambda)$, where $sinh$ is the hyperbolic sine function.</li>
    <li>The <em>X</em> generated in step 1 can follow any distribution of integers 0 or greater, not just the distribution used by the von Neumann schema (because <strong>Algorithm BR</strong> is more general than the von Neumann schema).  (In that case, the function $g(k, \lambda)$ will be the probability of getting $k$ under the new distribution.) For example, if <em>X</em> is a Poisson random variate with mean <em>z</em><sup>2</sup>/4, where <em>z</em> &gt; 0, and if the sorted permutation class is used, the algorithm will return 0 with probability 1/<em>I</em><sub>0</sub>(<em>z</em>), where <em>I</em><sub>0</sub>(.) is the modified Bessel function of the first kind.</li>
  </ol>
</blockquote>

<p><strong>Examples for the von Neumann schema</strong>.  Examples contained in Theorem 2.3 of Flajolet et al. (2010)<sup id="fnref:1:11" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>.  In the table:</p>

<ul>
  <li><em>λ</em> is the unknown heads probability of a coin.</li>
  <li><em>μ</em> is another coin that flips the <em>λ</em> coin and returns 1 minus the result (thus simulating 1 − <em>λ</em>).</li>
</ul>

<table>
  <thead>
    <tr>
      <th>Function</th>
      <th>Values Allowed</th>
      <th>Algorithm</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>exp(−<em>λ</em>)</td>
      <td>0 ≤ <em>λ</em> &lt; 1</td>
      <td>Uses von Neumann schema algorithm (VNS) with <strong>sorted</strong> permutations, and the <em>λ</em> coin.  Return 1 if VNS returns 0, and 0 otherwise.</td>
    </tr>
    <tr>
      <td>exp(<em>λ</em> − 1) = exp(−(1 − <em>λ</em>))</td>
      <td>0 &lt; <em>λ</em> ≤ 1</td>
      <td>Uses VNS with sorted permutations, and the <em>μ</em> coin.  Return 1 if VNS returns 0, and 0 otherwise.</td>
    </tr>
    <tr>
      <td>(1−<em>λ</em>)*exp(<em>λ</em>)</td>
      <td>0 ≤ <em>λ</em> &lt; 1</td>
      <td>Uses VNS with sorted permutations, and the <em>λ</em> coin.  Return 1 if VNS finishes in one iteration, and 0 otherwise.</td>
    </tr>
    <tr>
      <td><em>λ</em>*exp(1−<em>λ</em>)</td>
      <td>0 &lt; <em>λ</em> ≤ 1</td>
      <td>Uses VNS with sorted permutations, and the <em>μ</em> coin.  Return 1 if VNS finishes in one iteration, and 0 otherwise.</td>
    </tr>
    <tr>
      <td><em>λ</em>/ln(1/(1−<em>λ</em>))</td>
      <td>0 ≤ <em>λ</em> &lt; 1</td>
      <td>Uses VNS with <strong>single-cycle</strong> permutations, and the <em>λ</em> coin.  Return 1 if VNS returns <strong>1</strong>, and 0 otherwise.</td>
    </tr>
    <tr>
      <td>(1−<em>λ</em>)/ln(1/<em>λ</em>)</td>
      <td>0 &lt; <em>λ</em> ≤ 1</td>
      <td>Uses VNS with single-cycle permutations, and the <em>μ</em> coin.  Return 1 if VNS returns <strong>1</strong>, and 0 otherwise.</td>
    </tr>
    <tr>
      <td>(1−<em>λ</em>)*ln(1/(1−<em>λ</em>))</td>
      <td>0 ≤ <em>λ</em> &lt; 1</td>
      <td>Uses VNS with single-cycle permutations, and the <em>λ</em> coin.  Return 1 if VNS finishes in one iteration, and 0 otherwise.</td>
    </tr>
    <tr>
      <td><em>λ</em>*ln(1/<em>λ</em>)</td>
      <td>0 &lt; <em>λ</em> ≤ 1</td>
      <td>Uses VNS with single-cycle permutations, and the <em>μ</em> coin.  Return 1 if VNS finishes in one iteration, and 0 otherwise.</td>
    </tr>
    <tr>
      <td>cos(<em>λ</em>)</td>
      <td>0 ≤ <em>λ</em> &lt; 1</td>
      <td>Uses VNS with <strong>alternating even-sized</strong> permutations, and the <em>λ</em> coin.  Return 1 if VNS returns <strong>0</strong>, and 0 otherwise.</td>
    </tr>
    <tr>
      <td>(1−<em>λ</em>)/cos(<em>λ</em>) = (1−<em>λ</em>)*sec(<em>λ</em>)</td>
      <td>0 ≤ <em>λ</em> &lt; 1</td>
      <td>Uses VNS with alternating even-sized permutations, and the <em>λ</em> coin.  Return 1 if VNS finishes in one iteration, and 0 otherwise.</td>
    </tr>
    <tr>
      <td><em>λ</em>/tan(<em>λ</em>)</td>
      <td>0 ≤ <em>λ</em> &lt; 1</td>
      <td>Uses VNS with <strong>alternating odd-sized</strong> permutations, and the <em>λ</em> coin.  Return 1 if VNS returns <strong>1</strong>, and 0 otherwise.</td>
    </tr>
    <tr>
      <td>(1−<em>λ</em>)*tan(<em>λ</em>)</td>
      <td>0 ≤ <em>λ</em> &lt; 1</td>
      <td>Uses VNS with alternating odd-sized permutations, and the <em>λ</em> coin.  Return 1 if VNS finishes in one iteration, and 0 otherwise.</td>
    </tr>
  </tbody>
</table>

<p><strong>Recap.</strong>  As can be seen—</p>

<ul>
  <li>the scheme for algebraic functions uses <strong>Algorithm CC</strong> with $g(k, \lambda) = \lambda^k (1-\lambda)$ and $h_k(\lambda) = W(k)/\beta^k$, and</li>
  <li>the <em>von Neumann schema</em> uses <strong>Algorithm BR</strong> with $g(k, \lambda) = \lambda^k (1-\lambda)$ and $h_k(\lambda) = V(k)/(k!)$,</li>
</ul>

<p>and both schemes implement step 1 of the algorithm in the same way.  However, different choices for $g$ and $h$ will lead to modified schemes that could lead to Bernoulli factory algorithms for new functions.</p>

<p><a id="Integrals"></a></p>

<h4 id="integrals">Integrals</h4>

<p>Roughly speaking, the <em>integral</em> of <em>f</em>(<em>x</em>) on an interval [<em>a</em>, <em>b</em>] is the “area under the graph” of that function when the function is restricted to that interval.  If <em>f</em> is continuous there, this is the value that $\frac{1}{n} (f(a+(b-a)(1-\frac{1}{2})/n)+f(a+(b-a)(2-\frac{1}{2})/n)+…+f(a+(b-a)(n-\frac{1}{2})/n))$ approaches as $n$ gets larger and larger.</p>

<p><strong>Algorithm 1.</strong> (Flajolet et al., 2010)<sup id="fnref:1:12" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup> showed how to turn an algorithm that simulates <em>f</em>(<em>λ</em>) into an algorithm that simulates the probability—</p>

<ul>
  <li>$\frac{1}{\lambda} \int_0^\lambda f(u)\,du$ ($\frac{1}{\lambda}$ times the integral of $f(u)$ on $[0, \lambda]$), or equivalently,</li>
  <li>$\int_0^1 f(\lambda u)\,du$ (the integral of $f(\lambda u)$ on the closed unit interval),</li>
</ul>

<p>namely the following algorithm:</p>

<ol>
  <li>Generate <em>u</em>, a uniform random variate between 0 and 1, call it <em>u</em>.</li>
  <li>Create an input coin that does the following: “Flip the original input coin, then <a href="#Implementation_Notes"><strong>sample from the number <em>u</em></strong></a>.  Return 1 if both the call and the flip return 1, and return 0 otherwise.”</li>
  <li>Run the original Bernoulli factory algorithm, using the input coin described in step 2 rather than the original input coin.  Return the result of that run.</li>
</ol>

<p><strong>Algorithm 2.</strong> A special case of Algorithm 1 is the integral $\int_0^1 f(u)\,du$, when the original input coin always returns 1:</p>

<ol>
  <li>Generate a uniform random variate between 0 and 1, call it <em>u</em>.</li>
  <li>Create an input coin that does the following: “<a href="#Implementation_Notes"><strong>Sample from the number <em>u</em></strong></a> and return the result.”</li>
  <li>Run the original Bernoulli factory algorithm, using the input coin described in step 2 rather than the original input coin.  Return the result of that run.</li>
</ol>

<p><strong>Algorithm 3.</strong> I have found that it’s possible to simulate the following integral, namely—</p>

<p>\(\int_a^b f(\lambda u)\,du,\)
where $0\le a\lt b\le 1$, using the following algorithm:</p>

<ol>
  <li>Generate <em>u</em>, a uniform random variate between 0 and 1.  Then if <em>u</em> is less than <em>a</em> or is greater than <em>b</em>, repeat this step. (If <em>u</em> is a uniform PSRN, these comparisons should be done via the <strong>URandLessThanReal</strong> algorithm.)</li>
  <li>Create an input coin that does the following: “<a href="#Implementation_Notes"><strong>Sample from the number <em>u</em></strong></a> and return the result.”</li>
  <li>Run the original Bernoulli factory algorithm, using the input coin described in step 2.  If the run returns 0, return 0.  Otherwise, generate a uniform random variate between 0 and 1 <em>v</em> and return a number that is 0 if <em>v</em> is less than <em>a</em> or is greater than <em>b</em>, or 1 otherwise.</li>
</ol>

<blockquote>
  <p><strong>Note</strong>: If <em>a</em> is 0 and <em>b</em> is 1, the function $f(\lambda)$ that can be simulated by this algorithm will be strictly increasing (will keep going up), have a slope no greater than 1, and equal 0 at the point 0.</p>
</blockquote>

<p><a id="Algorithms_for_Specific_Functions_of___lambda"></a></p>

<h3 id="algorithms-for-specific-functions-of-lambda">Algorithms for Specific Functions of <em>λ</em></h3>

<p>This section and the next one describe algorithms for specific functions, especially when they have a more convenient simulation than the general-purpose algorithms given earlier.  They can be grouped as follows:</p>

<ul>
  <li>Functions involving the exponential function exp(<em>x</em>).</li>
  <li>Rational functions of several variables.</li>
  <li>Addition, subtraction, and division.</li>
  <li>Powers and roots.</li>
  <li>Linear Bernoulli factories.</li>
  <li>Transcendental functions.</li>
  <li>Other factory functions.</li>
</ul>

<p><a id="ExpMinus_exp_minus__z"></a></p>

<h4 id="expminus-expminusz">ExpMinus (exp(−<em>z</em>))</h4>

<p>In this document, the <strong>ExpMinus</strong> algorithm is a Bernoulli factory taking a parameter <em>z</em>.  The parameter <em>z</em> is 0 or greater and can be written in any of the following ways:</p>

<ol>
  <li>As a rational number, namely <em>x</em>/<em>y</em> where <em>x</em>≥0 and <em>y</em>&gt;0 are integers.</li>
  <li>As an integer and fractional part, namely <em>m</em> + <em>ν</em> where <em>m</em> ≥ 0 is an integer and <em>ν</em> (0 ≤ <em>ν</em> ≤ 1) is the probability of heads of a coin.  (Specifically, the “coin” must implement a Bernoulli factory algorithm that returns 1 [or outputs heads] with probability equal to the fractional part <em>ν</em>.<sup id="fnref:51" role="doc-noteref"><a href="#fn:51" class="footnote" rel="footnote">51</a></sup>)</li>
  <li>As a finite sum of positive numbers, each of which can be written as in case 1, case 2, or case 4.  For example, if <em>z</em> = π, it can be written as a sum of four numbers, each of which is (π / 4), that is, <em>m</em> = 0 and <em>ν</em> = (π / 4).  (This case makes use of the identity exp(−(<em>b</em>+<em>c</em>)) = exp(−<em>b</em>) * exp(−<em>c</em>).  Here, π/4 has a not-so-trivial Bernoulli factory algorithm described in this article.)</li>
  <li>As the expression <em>ρ</em>*(<em>m</em>+<em>ν</em>), where <em>m</em> and <em>ν</em> are described in case 2, and where <em>ρ</em> (0 ≤ <em>ρ</em> ≤ 1) is the probability of heads of another coin.</li>
</ol>

<p>The <strong>ExpMinus</strong> algorithm is as follows.  To flip a coin with probability of heads of exp(−<em>z</em>):</p>

<ul>
  <li>In case 1, use the following algorithm (Canonne et al. (2020)<sup id="fnref:52" role="doc-noteref"><a href="#fn:52" class="footnote" rel="footnote">52</a></sup>) <sup id="fnref:53" role="doc-noteref"><a href="#fn:53" class="footnote" rel="footnote">53</a></sup>:
    <ol>
      <li>Special case: If <em>x</em> is 0, return 1. (This is because the probability becomes <code>exp(0) = 1</code>.)</li>
      <li>If <code>x &gt; y</code> (so <em>x</em>/<em>y</em> is greater than 1), call this algorithm (recursively) <code>floor(x/y)</code> times with <em>x</em> = <em>y</em> = 1 and once with <em>x</em> = <em>x</em> − floor(<em>x</em>/<em>y</em>) * <em>y</em> and <em>y</em> = <em>y</em>.  Return 1 if all these calls return 1; otherwise, return 0.</li>
      <li>Set <em>r</em> to 1 and <em>i</em> to 1.</li>
      <li>Return <em>r</em> with probability (<em>y</em> * <em>i</em> − <em>x</em>) / (<em>y</em> * <em>i</em>).</li>
      <li>Set <em>r</em> to 1 − <em>r</em>, add 1 to <em>i</em>, and go to step 4.</li>
    </ol>

    <p>Or the following algorithm:</p>

    <ul>
      <li>If <em>x</em> is 0, return 1.  Otherwise, generate <em>N</em>, a Poisson random variate with mean <em>x</em>/<em>y</em> (see “<a href="https://peteroupc.github.io/randomfunc.html#Poisson_Distribution"><strong>Poisson Distribution</strong></a>” for one way to do this), and return a number that is 1 if <em>N</em> is 0, or 0 otherwise.</li>
    </ul>
  </li>
  <li>In case 2, use case 2 of the <strong>algorithm for exp(−(<em>λ</em> * <em>z</em>))</strong> with parameter <em>z</em> = <em>m</em> + <em>ν</em>, where <em>λ</em> represents a coin that always returns 1.</li>
  <li>In case 3, rewrite the <em>z</em> parameter as a sum of positive numbers.  For each number, run either case 1, case 2, or case 4 (depending on how the number is written) of the <strong>ExpMinus</strong> algorithm with that number as the parameter.  If any of these runs returns 0, return 0; otherwise, return 1.  (See also (Canonne et al. 2020)<sup id="fnref:52:1" role="doc-noteref"><a href="#fn:52" class="footnote" rel="footnote">52</a></sup>.)</li>
  <li>In case 4, use case 2 of the <strong>algorithm for exp(−(<em>λ</em> * <em>z</em>))</strong> with parameter <em>z</em> = <em>m</em> + <em>ν</em>, where <em>λ</em> represents the coin for <em>ρ</em>.</li>
</ul>

<blockquote>
  <p><strong>Examples:</strong> The <strong>ExpMinus</strong> algorithm with the following parameters can be implemented as follows:</p>

  <ul>
    <li>Parameter <em>π</em>:  Run the <strong>algorithm for exp(−(<em>λ</em> * <em>z</em>))</strong>, four times, with parameter <em>z</em> = 0 + <em>ν</em>, where <em>ν</em> is a Bernoulli factory for (<em>π</em>/4), and <em>λ</em> represents a coin that always returns 1.  If any of these runs returns 0, return 0; otherwise, return 1.</li>
    <li>Parameter 3: Run case 1 of the algorithm where <em>x</em>=3 and <em>y</em>=1.</li>
    <li>Parameter 7/5: Run case 1 of the algorithm where <em>x</em>=7 and <em>y</em>=5.</li>
  </ul>

  <p><strong>Note:</strong> exp(−<em>z</em>) = exp(1−<em>z</em>)/exp(1) = 1/exp(<em>z</em>) = 1−(exp(<em>z</em>)−1)/exp(<em>z</em>).</p>
</blockquote>

<p><a id="LogisticExp_1_minus_expit__z__2_prec"></a></p>

<h4 id="logisticexp-1-minus-expitz2supprecsup">LogisticExp (1 − expit(<em>z</em>/2<sup><em>prec</em></sup>))</h4>

<p>This is the probability that the binary digit at <em>prec</em> (the <em>prec</em><sup>th</sup> binary digit after the point, where <em>prec</em> is greater than 0) is set for an exponential random variate with rate <em>z</em>.  In this document, the <strong>LogisticExp</strong> algorithm is a Bernoulli factory taking the following parameters in this order:</p>

<ol>
  <li><em>z</em> is 0 or greater, and written in one of the ways described in the <a href="#ExpMinus_exp_minus__z"><strong>“ExpMinus” section</strong></a>.</li>
  <li><em>prec</em> is an integer 0 or greater.</li>
</ol>

<p>The <strong>LogisticExp</strong> algorithm is as follows.  To flip a coin with probability of heads of 1/(1+exp(<em>z</em>/2<sup><em>prec</em></sup>)) = 1 − expit(<em>λ</em>/2<sup><em>prec</em></sup>):</p>

<ul>
  <li>Run the <strong>algorithm for expit(<em>λ</em>*<em>z</em>)</strong> where <em>z</em> = <em>z</em>, and where <em>λ</em> represents a coin that returns a number that is 1 with probability 1/(2<sup><em>prec</em></sup>) or 0 otherwise.  Return 1 minus the result of that run (leading to <strong>1 − expit(<em>λ</em>*<em>z</em>)</strong>).</li>
</ul>

<p><a id="exp_minus___lambda____z"></a></p>

<h4 id="expminuslambda--z">exp(−(<em>λ</em> * <em>z</em>))</h4>

<p>In the following algorithm:</p>

<ul>
  <li><em>z</em> is 0 or greater, and written as a rational number (case 1), as an integer and fractional part (case 2), or as a sum of positive numbers (case 3), as described in the <a href="#ExpMinus_exp_minus__z"><strong>“ExpMinus” section</strong></a>.</li>
  <li><em>λ</em> is the probability of heads of an input coin, with 0 ≤ <em>λ</em> ≤ 1.</li>
</ul>

<p>The algorithm follows.</p>

<ul>
  <li>In case 1 (<em>z</em> = <em>x</em>/<em>y</em>) (see also algorithm for exp(−((1−<em>λ</em>)<sup>1</sup> * <em>c</em>)) in “Other Factory Functions”):
    <ol>
      <li>Special case: If <em>x</em> is 0, return 1.</li>
      <li>Generate <em>N</em>, a Poisson random variate with mean <em>x</em>/<em>y</em>.  (See “<a href="https://peteroupc.github.io/randomfunc.html#Poisson_Distribution"><strong>Poisson Distribution</strong></a>” for one way to do this.)</li>
      <li>Flip the <em>λ</em> input coin until a flip returns 1 or the coin is flipped <em>N</em> times, whichever comes first.  Return 0 if <em>N</em> is greater than 0 and any of the flips, including the last, returns 1.  Otherwise, return 1. (The flips transform a Poisson variate with mean <em>x</em>/<em>y</em> to one with mean <em>λ</em>*<em>x</em>/<em>y</em>; see (Devroye 1986, p. 487)<sup id="fnref:30:1" role="doc-noteref"><a href="#fn:30" class="footnote" rel="footnote">30</a></sup>.)</li>
    </ol>
  </li>
  <li>In case 2 (<em>z</em> = <em>m</em> + <em>ν</em>):
    <ol>
      <li>Set <em>j</em> to 0, then while <em>j</em> &lt; <em>m</em>+1:
        <ol>
          <li>Generate <em>N</em>, a Poisson random variate with mean 1.</li>
          <li>If <em>j</em> = <em>m</em>, flip the <em>ν</em> input coin <em>N</em> times and set <em>N</em> to the number of flips that return 1 this way.  (This transforms a Poisson variate with mean 1 to one with mean <em>ν</em>; see (Devroye 1986, p. 487)<sup id="fnref:30:2" role="doc-noteref"><a href="#fn:30" class="footnote" rel="footnote">30</a></sup>.)</li>
          <li>Flip the <em>λ</em> input coin until a flip returns 1 or the coin is flipped <em>N</em> times, whichever comes first.  Return 0 if <em>N</em> is greater than 0 and any of the flips, including the last, returns 1.</li>
          <li>Add 1 to <em>j</em>.</li>
        </ol>
      </li>
      <li>Return 1.</li>
    </ol>
  </li>
  <li>In case 3, rewrite the <em>z</em> parameter as a sum of positive numbers.  For each number, run either case 1 or case 2 (depending on how the number is written) of this algorithm with that number as the parameter.  If any of these runs returns 0, return 0; otherwise, return 1.</li>
</ul>

<blockquote>
  <p><strong>Notes:</strong></p>

  <ol>
    <li>The following is a proof of case 2 of this algorithm.  First, suppose $\lambda = 1$.  Each iteration of the loop in the algorithm returns 0 if a Poisson random variate with mean $t$ (see second substep of step 1) is other than 0, where $t$ is $\nu$ in the last iteration, or 1 otherwise. Since the Poisson variate is 0 with probability $\exp(-t)$, the iteration will terminate the algorithm with probability $1-\exp(-t)$ and “succeed” with probability $\exp(-t)$.  If all the iterations “succeed”, the algorithm will return 1, which will happen with probability $\exp(-\nu) \cdot (\exp(-1))^m = \exp(-(m+\nu))$.  Now suppose 0 ≤ $\lambda$ &lt; 1.  Then (due to the third substep of step 1) the Poisson variate just mentioned has mean $t\lambda$ rather than $t$, so that each iteration succeeds with probability $1-\exp(-t\lambda)$ and the final algorithm returns 1 with probability $\exp(-\nu\lambda) \cdot (\exp(-\lambda))^m = \exp(-(m+\nu)\lambda)$.</li>
    <li>When <em>z</em> is a rational number with 0 ≤ <em>z</em> ≤ 1, this function can be rewritten as a power series expansion.  In that case, one way to simulate the function is to run the <strong>general martingale algorithm</strong> (see “<a href="#Certain_Power_Series"><strong>Certain Power Series</strong></a>”), with $g(\lambda) = \lambda$, and with parameter $d_0 = 1$ and power coefficients $a_i = \frac{(-1)^i z^i}{i!}$, and return the result of that algorithm.</li>
    <li>When <em>z</em> is a rational number 0 or greater, this function can be simulated as follows: Let <em>m</em> be floor(<em>c</em>).  Call the algorithm in note 2 <em>m</em> times with <em>z</em> = 1.  If any of these calls returns 0, return 0. Otherwise, if <em>z</em> is an integer (that is, if floor(<em>z</em>) = <em>z</em>), return 1.  Otherwise, call the algorithm in note 2 once, with <em>z</em> = <em>z</em> − floor(<em>z</em>).  Return the result of this call.</li>
    <li>When <em>m</em> = 0 and <em>μ</em> = 1, this function, in case 2, becomes exp(−<em>λ</em>) and can be rewritten as a power series expansion.  In that case, one way to simulate the function is to use the <strong>general martingale algorithm</strong> (see “<a href="#Certain_Power_Series"><strong>Certain Power Series</strong></a>”), with $g(\lambda)=\lambda$, and with $d_0 = 1$ and power coefficients $a_i = (-1)^i/(i!)$.<sup id="fnref:53:1" role="doc-noteref"><a href="#fn:53" class="footnote" rel="footnote">53</a></sup></li>
  </ol>
</blockquote>

<p><a id="exp_minus_exp__m____lambda"></a></p>

<h4 id="expminusexpm--lambda">exp(−exp(<em>m</em> + <em>λ</em>))</h4>

<p>In the following algorithm, <em>m</em> is an integer 0 or greater.</p>

<ol>
  <li>Generate <em>n</em>, a Poisson random variate with mean 3<sup><em>m</em>+1</sup>.  (See “<a href="https://peteroupc.github.io/randomfunc.html#Poisson_Distribution"><strong>Poisson Distribution</strong></a>” for one way to do this.)</li>
  <li>If <em>n</em> is greater than 0, do the following <em>n</em> times or until this algorithm returns a value:
    <ul>
      <li>Run the algorithm for <strong>exp(<em>λ</em>)/3</strong> (see “Certain Power Series”), <em>m</em> times, with <em>λ</em> being a coin that always returns 0.  Then run the algorithm for <strong>exp(<em>λ</em>)/3</strong> once, with <em>λ</em> being the input coin.  If all these runs return 1, return 0.</li>
    </ul>
  </li>
  <li>Return 1.</li>
</ol>

<blockquote>
  <p><strong>Note:</strong> The following is a proof this algorithm is valid.  Rewrite $\exp(m+\lambda)$ = $3^{m+1}\cdot\left(\frac{\exp(1)}{3}\right)^m\cdot\frac{\exp(\lambda)}{3}$.  Step 1 generates a Poisson variate with mean $3^{m+1}$.  This variate is then thinned to a Poisson variate with mean $\exp(m+\lambda)$ in step 2, returning early if the new variate would be greater than 0 (because a Poisson variate with mean $\exp(m+\lambda)$ is 0 with probability $\exp(-\exp(m+\lambda))$).</p>
</blockquote>

<p><a id="exp_minus__m____lambda____k"></a></p>

<h4 id="expminusm--lambdasupksup">exp(−(<em>m</em> + <em>λ</em>)<sup><em>k</em></sup>)</h4>

<p>In the following algorithm, <em>m</em> and <em>k</em> are both integers 0 or greater.</p>

<ol>
  <li>If <em>k</em> is 0, run the <strong>ExpMinus</strong> algorithm with parameter 1, and return the result.</li>
  <li>If <em>k</em> is 1, run the <strong>ExpMinus</strong> algorithm with parameter <em>m</em> + <em>λ</em>, and return the result.</li>
  <li>(Expand (<em>m</em> + <em>λ</em>)<sup><em>k</em></sup> to a polynomial in <em>λ</em> in rest of algorithm.  First the <em>λ</em><sup>0</sup> term.) Run the <strong>ExpMinus</strong> algorithm with parameter <em>m</em><sup><em>k</em></sup>.  If the algorithm returns 0, return 0.</li>
  <li>(Now the <em>λ</em><sup><em>k</em></sup> term.) Run the <strong>ExpMinus</strong> algorithm with parameter 0 + <em>μ</em>, where <em>μ</em> represents an input coin that does: “Flip the <em>λ</em> input coin <em>k</em> times and return either 1 if all the flips return 1, or 0 otherwise”. If the algorithm returns 0, return 0.</li>
  <li>(Now the other terms.) If <em>m</em> is 0, return 1.</li>
  <li>Set <em>i</em> to 1, then while <em>i</em> &lt; <em>k</em>:
    <ol>
      <li>Set <em>w</em> to choose(<em>k</em>, <em>i</em>) * <em>m</em><sup><em>k</em> − <em>i</em></sup>.</li>
      <li>(Now the <em>λ</em><sup><em>i</em></sup> term.) Run the <strong>ExpMinus</strong> algorithm, <em>w</em> times, with parameter 0 + <em>μ</em>, where <em>μ</em> represents an input coin that does: “Flip the <em>λ</em> input coin <em>i</em> times and return either 1 if all the flips return 1, or 0 otherwise”.  If any of these calls returns 0, return 0.</li>
      <li>Add 1 to <em>i</em>.</li>
    </ol>
  </li>
  <li>Return 1.</li>
</ol>

<p><a id="exp___lambda___1_minus___lambda"></a></p>

<h4 id="explambda1minuslambda">exp(<em>λ</em>)*(1−<em>λ</em>)</h4>

<p>(Flajolet et al., 2010)<sup id="fnref:1:13" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>:</p>

<ol>
  <li>Set <em>k</em> and <em>w</em> each to 0.</li>
  <li>Flip the input coin.  If it returns 0, return 1.</li>
  <li>Generate <em>u</em>, a uniform random variate between 0 and 1.</li>
  <li>If <em>k</em> &gt; 0 and <em>w</em> is less than <em>U</em>, return 0.</li>
  <li>Set <em>w</em> to <em>U</em>, add 1 to <em>k</em>, and go to step 2.</li>
</ol>

<p><a id="1_minus_exp_minus__m____lambda____m____lambda"></a></p>

<h4 id="minus-expminusm--lambda--m--lambda">(1 − exp(−(<em>m</em> + <em>λ</em>))) / (<em>m</em> + <em>λ</em>)</h4>

<p>In this algorithm, <em>m</em> + <em>λ</em> must be greater than 0.</p>

<ol>
  <li>If <em>m</em> = 0, run the <strong>general martingale algorithm</strong> (see “<a href="#Certain_Power_Series"><strong>Certain Power Series</strong></a>”), with $g(\lambda)=\lambda$, and with $d_0 = 1$ and power coefficients $a_i = \frac{(-1)^i}{(i+1)!}$, and return the result of that algorithm.</li>
  <li>(<em>m</em>&gt;0.) Run the <strong>ExpMinus</strong> algorithm with parameter <em>z</em> = <em>m</em> + <em>λ</em>.  If it returns 1, return 0.</li>
  <li>Run the algorithm for <strong><em>d</em>/(<em>c</em>+<em>λ</em>)</strong> with <em>d</em>=1 and <em>c</em>=<em>m</em>, and return the result of that algorithm.</li>
</ol>

<p><a id="expit__z__or_1_minus_1_1_exp__z__or_exp__z__1_exp__z__or_1_1_exp_minus__z"></a></p>

<h4 id="expitz-or-1minus11expz-or-expz1expz-or-11expminusz">expit(<em>z</em>) or 1−1/(1+exp(<em>z</em>)) or exp(<em>z</em>)/(1+exp(<em>z</em>)) or 1/(1+exp(−<em>z</em>))</h4>

<p>expit(<em>z</em>), also known as the <em>logistic function</em>, is the probability that a random variate from the logistic distribution is <em>z</em> or less.</p>

<p><em>z</em> is a number (positive or not) whose absolute value (abs(<em>z</em>)) is written in one of the ways described in the <a href="#ExpMinus_exp_minus__z"><strong>“ExpMinus” section</strong></a>.</p>

<ul>
  <li>If <em>z</em> is known to be 0 or greater:
    <ol>
      <li>Create an <em>R</em> coin that runs the <strong>ExpMinus</strong> algorithm with parameter <em>z</em>.</li>
      <li>Run the algorithm for <strong><em>d</em>/(<em>c</em>+<em>λ</em>)</strong> with <em>d</em>=1, <em>c</em>=1, and with  <em>λ</em> being the <em>R</em> coin, and return the result of that run.</li>
    </ol>
  </li>
  <li>If <em>z</em> is known to be 0 or less:
    <ol>
      <li>Create a <em>R</em> coin that runs the <strong>ExpMinus</strong> algorithm with parameter abs(<em>z</em>).</li>
      <li>Run the algorithm for <strong><em>d</em>/(<em>c</em>+<em>λ</em>)</strong> with <em>d</em>=1, <em>c</em>=1, and with  <em>λ</em> being the <em>R</em> coin, and return <strong>1 minus the result</strong> of that run.</li>
    </ol>
  </li>
</ul>

<blockquote>
  <p><strong>Note</strong>:</p>

  <ol>
    <li>This algorithm can be used to simulate <strong>expit(<em>λ</em>* <em>z</em>)</strong>, where <em>λ</em> is the probability of heads of an input coin, with 0 ≤ <em>λ</em> ≤ 1, except it runs the <strong>algorithm for exp(−(<em>λ</em> * <em>z</em>))</strong> instead of the <strong>ExpMinus</strong> algorithm.</li>
    <li>expit(<em>z</em>) = (tanh(<em>z</em>/2)+1)/2.  <code>tanh</code> is the hyperbolic tangent function.</li>
  </ol>
</blockquote>

<p><a id="expit__z__2_minus_1_or_tanh__z__2_or_exp__z__minus_1_exp__z__1"></a></p>

<h4 id="expitz2-minus-1-or-tanhz2-or-expzminus1expz1">expit(<em>z</em>)*2 − 1 or tanh(<em>z</em>/2) or (exp(<em>z</em>)−1)/(exp(<em>z</em>)+1)</h4>

<p>In this algorithm, <em>z</em> is 0 or greater and is written in one of the ways described in the <a href="#ExpMinus_exp_minus__z"><strong>“ExpMinus” section</strong></a>.  <code>tanh</code> is the hyperbolic tangent function.</p>

<ul>
  <li>Do the following process repeatedly, until this algorithm returns a value:
    <ol>
      <li>Run the <strong>ExpMinus</strong> algorithm with parameter <em>z</em>.  Let <em>r</em> be the result of that run.</li>
      <li>Generate 1 or 0 with equal probability.  If 1 was generated this way, return 1−<em>r</em>.  Otherwise, if <em>r</em> is 1, return 0.</li>
    </ol>
  </li>
</ul>

<blockquote>
  <p><strong>Note:</strong> Follows from observing that tanh(<em>z</em>/2) = (<em>d</em> + (1 − <em>μ</em>)) / (<em>c</em> + <em>μ</em>), where <em>μ</em> = exp(−<em>z</em>), <em>d</em> = 0, and <em>c</em> = 1.  (See <strong>algorithm for (<em>d</em> + <em>μ</em>) / (<em>c</em> + <em>λ</em>)</strong>.)</p>
</blockquote>

<p><a id="lambda___exp__z____lambda___exp__z__1_minus___lambda___or___lambda___exp__z__1___lambda___exp__z__minus_1"></a></p>

<h4 id="lambdaexpz--lambdaexpz--1-minus-lambda-or-lambdaexpz--1--lambdaexpz-minus-1"><em>λ</em>*exp(<em>z</em>) / (<em>λ</em>*exp(<em>z</em>) + (1 − <em>λ</em>)) or <em>λ</em>*exp(<em>z</em>) / (1 + <em>λ</em>*(exp(<em>z</em>) − 1))</h4>

<p>In this algorithm:</p>

<ul>
  <li><em>z</em> is an “exponential shift” (Peres et al. 2021)<sup id="fnref:54" role="doc-noteref"><a href="#fn:54" class="footnote" rel="footnote">54</a></sup> or “exponential twist” (Sadowsky and Bucklew 1990)<sup id="fnref:55" role="doc-noteref"><a href="#fn:55" class="footnote" rel="footnote">55</a></sup>. Its absolute value is written in one of the ways described in the <a href="#ExpMinus_exp_minus__z"><strong>“ExpMinus” section</strong></a>.</li>
  <li><em>λ</em> is a coin that shows heads with probability equal to the probability to be shifted.</li>
</ul>

<p>The algorithm follows:</p>

<ul>
  <li>Do the following process repeatedly, until this algorithm returns a value:
    <ol>
      <li>Flip the <em>λ</em> input coin.  Let <em>flip</em> be the result of that flip.</li>
      <li>Run the algorithm for <strong>expit(<em>z</em>)</strong> with <em>z</em>=<em>z</em>. If the run returns 1 and if <em>flip</em> is 1, return 1.  If the run returns 0 and if <em>flip</em> is 0, return 0.</li>
    </ol>
  </li>
</ul>

<blockquote>
  <p><strong>Note:</strong> This is also a special case of the two-coin algorithm, where <em>β</em>=1, <em>c</em>=exp(<em>z</em>), <em>d</em>=1, <em>λ</em> = <em>λ</em>, and <em>μ</em> = 1 − <em>λ</em>.</p>
</blockquote>

<p><a id="1_exp__z__minus__w__1_exp__z"></a></p>

<h4 id="expz-minus-w--1--expz">(1 + exp(<em>z</em> − <em>w</em>)) / (1 + exp(<em>z</em>))</h4>

<p>In this algorithm, <em>z</em> is a number (positive or not), and <em>w</em> is 0 or greater, and their absolute values are each written in one of the ways described in the <a href="https://peteroupc.github.io/bernoulli.html#ExpMinus_exp_minus__z"><strong>“ExpMinus” section</strong></a>”.</p>

<ul>
  <li>If <em>z</em> is known to be 0 or greater:
    <ul>
      <li>Run the <strong>ExpMinus</strong> algorithm with parameter <em>w</em>, then run the <strong>expit(<em>z</em>)</strong> algorithm with parameter <em>z</em>.  If the <strong>ExpMinus</strong> run returns 1 and the <strong>expit</strong> run returns 0, return 0.  Otherwise, return 1.</li>
    </ul>
  </li>
  <li>If <em>z</em> is known to be 0 or less:
    <ul>
      <li>Run the <strong>ExpMinus</strong> algorithm with parameter <em>w</em>, then run the <strong>expit(<em>z</em>)</strong> algorithm with parameter abs(<em>z</em>).  If both runs return 0, return 0.  Otherwise, return 1.</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p><strong>Notes:</strong></p>

  <ol>
    <li>(1 + exp(<em>z</em>−1)) / (1 + exp(<em>z</em>)) = $1-\frac{1 - e^{-1}}{e^{-z} + 1}$. (1 + exp(1−1)) / (1 + exp(1)) = 2 / (1 + exp(2)) = (1 + exp(0)) / (1 + exp(1)).</li>
    <li>For the similar function <strong>(1 + exp(<em>z</em>)) / (1 + exp(<em>z</em>+1))</strong>, use this algorithm with <em>w</em> = 1, except add 1 to <em>z</em> (if <em>z</em> is written as an integer and fractional part, add 1 to the integer part; if written as a sum of numbers, append 1 to those numbers).</li>
  </ol>
</blockquote>

<p><a id="1_2_m_k_lambda_or_exp_k_lambda_cdot_ln_2_m"></a></p>

<h4 id="mklambda-or-exp-klambdacdotln2m">$1/(2^{m(k+\lambda)})$ or exp($-(k+\lambda)\cdot\ln(2^m)$)</h4>

<p>This new algorithm uses the base-2 logarithm <em>k</em> + <em>λ</em> and is useful when this logarithm is very large.  In this algorithm, <em>k</em> ≥ 0 is an integer, and <em>m</em> ≥ 0 is an integer.</p>

<ol>
  <li>(Factor function in two parts.  First, simulate 1/(2<sup><em>mk</em></sup>).) If <em>k</em> &gt; 0, generate numbers that are each 1 or 0 with equal probability until <em>k</em>*<em>m</em> many bits or the number 0 was generated this way, whichever comes first.  If zero was generated this way, return 0.</li>
  <li>(Rest of algorithm simulates $1/(2^{m\lambda})$.) Create an input coin <em>μ</em> that does the following: “Flip the input coin, then run the <strong>algorithm for ln(1+<em>y</em>/<em>z</em>)</strong> (given later) with <em>y</em>/<em>z</em> = 1/1.  If both the call and the flip return 1, return 1.  Otherwise, return 0.” (Simulates $\ln(2) \lambda$.)</li>
  <li>Run the <strong>ExpMinus</strong> algorithm, with parameter 0 + <em>μ</em> (using the <em>μ</em> input coin), <em>m</em> times.  If any of the runs returns 0, return 0.  Otherwise, return 1.</li>
</ol>

<p><a id="1_2_x_y_cdot_lambda_or_exp_lambda_cdot_ln_2_x_y"></a></p>

<h4 id="xycdotlambda-or-exp-lambdacdotln2xy">$1/(2^{(x/y)\cdot\lambda})$ or exp($-\lambda\cdot\ln(2^{x/y})$)</h4>

<p>Based on the previous algorithm.  In this algorithm, <em>x</em> ≥ 0 and <em>y</em> &gt; 0 are integers.</p>

<ol>
  <li>Special case: If <em>x</em> is 0, return 1.</li>
  <li>Let <em>c</em> = ceil(<em>x</em>/<em>y</em>). Create an input coin <em>μ</em> that does the following: “Flip the input coin, then run the <strong>algorithm for ln(1+<em>y</em>/<em>z</em>)</strong> (given later) with <em>y</em>/<em>z</em> = 1/1.  If both the call and the flip return 1, return a number that is 1 with probability <em>x</em>/(<em>y</em>*<em>c</em>) and 0 otherwise.  Otherwise, return 0.” (Simulates $\ln(2) \frac{xy}{c} \lambda$.)</li>
  <li>Run the <strong>ExpMinus</strong> algorithm, with parameter 0 + <em>μ</em> (using the <em>μ</em> input coin), <em>c</em> times.  If any of the runs returns 0, return 0.  Otherwise, return 1.</li>
</ol>

<p><a id="Two_Coin_Algorithm__c____lambda_____beta_____beta____c____lambda____d____mu___minus___beta___minus_1__c___d"></a></p>

<h4 id="two-coin-algorithm-c--lambda--beta--beta--c--lambda--d--mu-minus-beta-minus-1--c--d">Two-Coin Algorithm (<em>c</em> * <em>λ</em> * <em>β</em> / (<em>β</em> * (<em>c</em> * <em>λ</em> + <em>d</em> * <em>μ</em>) − (<em>β</em> − 1) * (<em>c</em> + <em>d</em>)))</h4>

<p>This is the general <strong>two-coin algorithm</strong> of (Gonçalves et al., 2017)<sup id="fnref:56" role="doc-noteref"><a href="#fn:56" class="footnote" rel="footnote">56</a></sup> and (Vats et al. 2022)<sup id="fnref:57" role="doc-noteref"><a href="#fn:57" class="footnote" rel="footnote">57</a></sup>.  It takes two input coins that each output heads (1) with probability <em>λ</em> or <em>μ</em>, respectively.  It also takes parameters <em>c</em> and <em>d</em>, each 0 or greater, and <em>β</em> in the interval [0, 1], which is a so-called “portkey” or early rejection parameter (when <em>β</em> = 1, the formula simplifies to <em>c</em> * <em>λ</em> / (<em>c</em> * <em>λ</em> + <em>d</em> * <em>μ</em>)).  In Vats et al. (2022)<sup id="fnref:57:1" role="doc-noteref"><a href="#fn:57" class="footnote" rel="footnote">57</a></sup>, <em>β</em>, <em>c</em>, <em>d</em>, <em>λ</em> and <em>μ</em> correspond to <em>β</em>, <em>c</em><sub><em>y</em></sub>, <em>c</em><sub><em>x</em></sub>, <em>p</em><sub><em>y</em></sub>, and <em>p</em><sub><em>x</em></sub>, respectively, in the “portkey” algorithm, or to <em>β</em>, <em>c̃</em><sub><em>x</em></sub>, <em>c̃</em><sub><em>y</em></sub>, <em>p̃</em><sub><em>x</em></sub>, and <em>p̃</em><sub><em>y</em></sub>, respectively, in the “flipped portkey” algorithm.</p>

<ol>
  <li>With probability <em>β</em>, go to step 2.  Otherwise, return 0. (For example, call <code>ZeroOrOne</code> with <em>β</em>’s numerator and denominator, and return 0 if that call returns 0, or go to step 2 otherwise.  <code>ZeroOrOne</code> is described in my article on <a href="https://peteroupc.github.io/randomfunc.html#Boolean_True_False_Conditions"><strong>random sampling methods</strong></a>.)</li>
  <li>With probability <em>c</em> / (<em>c</em> + <em>d</em>), flip the <em>λ</em> input coin.  Otherwise, flip the <em>μ</em> input coin.  If the <em>λ</em> input coin returns 1, return 1.  If the <em>μ</em> input coin returns 1, return 0.  If the corresponding coin returns 0, go to step 1.</li>
</ol>

<p><a id="c____lambda____c____lambda____d__or__c___d____lambda___1__c___d____lambda"></a></p>

<h4 id="c--lambda--c--lambda--d-or-cd--lambda--1--cd--lambda"><em>c</em> * <em>λ</em> / (<em>c</em> * <em>λ</em> + <em>d</em>) or (<em>c</em>/<em>d</em>) * <em>λ</em> / (1 + (<em>c</em>/<em>d</em>) * <em>λ</em>))</h4>

<p>This algorithm, also known as the <strong>logistic Bernoulli factory</strong> (Huber 2016)<sup id="fnref:42:1" role="doc-noteref"><a href="#fn:42" class="footnote" rel="footnote">42</a></sup>, (Morina et al., 2022)<sup id="fnref:19:2" role="doc-noteref"><a href="#fn:19" class="footnote" rel="footnote">19</a></sup>, is a special case of the two-coin algorithm above, but this time uses only one input coin.</p>

<ol>
  <li>With probability <em>d</em> / (<em>c</em> + <em>d</em>), return 0.</li>
  <li>Flip the input coin.  If the flip returns 1, return 1.  Otherwise, go to step 1.</li>
</ol>

<blockquote>
  <p><strong>Note:</strong> Huber (2016) specifies this Bernoulli factory in terms of a Poisson point process, which seems to require much more randomness on average.</p>
</blockquote>

<p><a id="d____lambda____c"></a></p>

<h4 id="d--lambda--c">(<em>d</em> + <em>λ</em>) / <em>c</em></h4>

<p>In this algorithm, <em>d</em> and <em>c</em> must be integers, and 0 ≤ <em>d</em> &lt; <em>c</em>.</p>

<ol>
  <li>Generate an integer in [0, <em>c</em>) uniformly at random, call it <em>i</em>.</li>
  <li>If <em>i</em> &lt; <em>d</em>, return 1.  If <em>i</em> = <em>d</em>, flip the input coin and return the result.  If neither is the case, return 0.</li>
</ol>

<p><a id="d___c____lambda"></a></p>

<h4 id="d--c--lambda"><em>d</em> / (<em>c</em> + <em>λ</em>)</h4>

<p>In this algorithm, <em>c</em> and <em>d</em> must be rational numbers, <em>c</em> ≥ 1, and 0 ≤ <em>d</em> ≤ <em>c</em>.  See also the algorithms for continued fractions.  (For example, when <em>d</em> = 1, this algorithm can simulate a probability of the form 1 / <em>z</em>, where <em>z</em> is 1 or greater and made up of an integer part (<em>c</em>) and a fractional part (<em>λ</em>) that can be simulated by a Bernoulli factory.)</p>

<ol>
  <li>With probability <em>c</em> / (1 + <em>c</em>), return a number that is 1 with probability <em>d</em>/<em>c</em> and 0 otherwise.</li>
  <li>Flip the input coin.  If the flip returns 1, return 0.  Otherwise, go to step 1.</li>
</ol>

<blockquote>
  <p><strong>Note</strong>: A quick proof this algorithm works: Let <em>x</em> be the desired probability.  Then—<br /><em>x</em> = (<em>c</em> / (1 + <em>c</em>)) * (<em>d</em>/<em>c</em>) +<br />(1−<em>c</em> / (1 + <em>c</em>)) * (<em>λ</em>*0 + (1−<em>λ</em>)*<em>x</em>),<br />and solving for <em>x</em> leads to <em>x</em>=<em>d</em>/(<em>c</em>+<em>λ</em>).</p>
</blockquote>

<p><a id="d____mu____c____lambda"></a></p>

<h4 id="d--mu--c--lambda">(<em>d</em> + <em>μ</em>) / (<em>c</em> + <em>λ</em>)</h4>

<p>Combines the algorithms in the previous two sections.</p>

<p>In this algorithm, <em>c</em> and <em>d</em> must be integers, and 0 ≤ <em>d</em> &lt; <em>c</em>.</p>

<ol>
  <li>With probability <em>c</em> / (1 + <em>c</em>), do the following:
    <ol>
      <li>Generate an integer in [0, <em>c</em>) uniformly at random, call it <em>i</em>.</li>
      <li>If <em>i</em> &lt; <em>d</em>, return 1.  If <em>i</em> = <em>d</em>, flip the <em>μ</em> input coin and return the result.  If neither is the case, return 0.</li>
    </ol>
  </li>
  <li>Flip the <em>λ</em> input coin.  If the flip returns 1, return 0.  Otherwise, go to step 1.</li>
</ol>

<p><a id="d____mu____d____mu____c____lambda"></a></p>

<h4 id="d--mu--d--mu--c--lambda">(<em>d</em> + <em>μ</em>) / ((<em>d</em> + <em>μ</em>) + (<em>c</em> + <em>λ</em>))</h4>

<p>In this algorithm, <em>c</em> and <em>d</em> are integers 0 or greater, and <em>λ</em> and <em>μ</em> are the probabilities of heads of two different input coins.  In the intended use of this algorithm, <em>λ</em> and <em>μ</em> are backed by the fractional parts of two uniform partially-sampled random numbers (PSRNs), and <em>c</em> and <em>d</em> are their integer parts, respectively.</p>

<ol>
  <li>Let <em>D</em> = <em>d</em> and <em>C</em> = <em>c</em>. Run the algorithm for <strong>(<em>d</em> + <em>μ</em>) / (<em>c</em> + <em>λ</em>)</strong> with <em>λ</em> and <em>μ</em> both being the <em>μ</em> input coin, with <em>d</em> = <em>D</em>+<em>C</em>, and with <em>c</em> = 1+<em>D</em> + <em>C</em>.  If the run returns 1:
    <ol>
      <li>If <em>c</em> is 0, return 1.</li>
      <li>Run the algorithm for <strong>(<em>d</em> + <em>μ</em>) / (<em>c</em> + <em>λ</em>)</strong> with <em>λ</em> and <em>μ</em> both being the <em>μ</em> input coin, with <em>d</em> = <em>D</em>, and with <em>c</em> = <em>D</em> + <em>C</em>.  If the run returns 1, return 1.  Otherwise, return 0.</li>
    </ol>
  </li>
  <li>Flip the <em>λ</em> input coin. If the flip returns 1, return 0. Otherwise, go to step 1.</li>
</ol>

<p><a id="d__k___c____lambda____k__or__d___c____lambda____k"></a></p>

<h4 id="dsupksup--c--lambdasupksup-or-d--c--lambdasupksup"><em>d</em><sup><em>k</em></sup> / (<em>c</em> + <em>λ</em>)<sup><em>k</em></sup>, or (<em>d</em> / (<em>c</em> + <em>λ</em>))<sup><em>k</em></sup></h4>

<p>In this algorithm, <em>c</em> and <em>d</em> must be rational numbers, <em>c</em> ≥ 1, and 0 ≤ <em>d</em> ≤ <em>c</em>, and <em>k</em> must be an integer 0 or greater.</p>

<ol>
  <li>Set <em>i</em> to 0.</li>
  <li>If <em>k</em> is 0, return 1.</li>
  <li>With probability <em>c</em> / (1 + <em>c</em>), do the following:
    <ol>
      <li>With probability <em>d</em>/<em>c</em>, add 1 to <em>i</em> and then either return 1 if <em>i</em> is now <em>k</em> or greater, or abort these substeps and go to step 2 otherwise.</li>
      <li>Return 0.</li>
    </ol>
  </li>
  <li>Flip the input coin.  If the flip returns 1, return 0.  Otherwise, go to step 2.</li>
</ol>

<p><a id="1_1___lambda"></a></p>

<h4 id="lambda">1/(1+<em>λ</em>)</h4>

<p>This algorithm is a special case of the two-coin algorithm of (Gonçalves et al., 2017)<sup id="fnref:56:1" role="doc-noteref"><a href="#fn:56" class="footnote" rel="footnote">56</a></sup> and has bounded expected running time for all <em>λ</em> parameters.<sup id="fnref:58" role="doc-noteref"><a href="#fn:58" class="footnote" rel="footnote">58</a></sup></p>

<ol>
  <li>Generate 1 or 0 with equal probability.  If 1 was generated this way, return 1.</li>
  <li>Flip the input coin.  If it returns 1, return 0.  Otherwise, go to step 1.</li>
</ol>

<blockquote>
  <p><strong>Note:</strong> In this special case of the two-coin algorithm, <em>β</em>=1, <em>c</em>=1, <em>d</em>=1, old <em>λ</em> equals 1, and <em>μ</em> equals new <em>λ</em>.</p>
</blockquote>

<p><a id="1_2_minus___lambda"></a></p>

<h4 id="minus-lambda">1/(2 − <em>λ</em>)</h4>

<ol>
  <li>Generate 1 or 0 with equal probability.  If 1 was generated this way, return 1.</li>
  <li>Flip the input coin.  <strong>If it returns 0</strong>, return 0.  Otherwise, go to step 1.</li>
</ol>

<blockquote>
  <p><strong>Note:</strong> Can be derived from the previous algorithm by observing that 1/(2 − <em>λ</em>) = 1/(1 + (1 − <em>λ</em>)).</p>
</blockquote>

<p><a id="1_1__m____lambda___2"></a></p>

<h4 id="mlambdasup2sup">1/(1+(<em>m</em>+<em>λ</em>)<sup>2</sup>)</h4>

<p>This is a rational function (ratio of two polynomials) with variable <em>λ</em>, and this rational function admits the following algorithm.  In this algorithm, <em>m</em> must be an integer 0 or greater, and <em>λ</em> is the unknown heads probability of a coin.</p>

<ol>
  <li>Let <em>d</em> be the three-item list [1, 2, 1] (for numerator 1).  Let <em>e</em> be the three-item list [1+m<sup>2</sup>, 2*(1+m<sup>2</sup>+m), 1+m<sup>2</sup>+2*m+1] (for denominator).  Find the highest number in <em>e</em>, then divide each item in <em>d</em> and in <em>e</em> by that number (using rational arithmetic).</li>
  <li>Run the first algorithm for <a href="https://peteroupc.github.io/bernoulli.html#Certain_Rational_Functions"><strong>rational functions</strong></a> in “Bernoulli Factory Algorithms”, with <em>n</em> = 2, and with <em>d</em> and <em>e</em> given above.</li>
</ol>

<p><a id="1_1__x___y____lambda"></a></p>

<h4 id="xylambda">1 / (1 + (<em>x</em>/<em>y</em>)*<em>λ</em>)</h4>

<p>Another special case of the two-coin algorithm.  In this algorithm, <em>x</em>/<em>y</em> must be 0 or greater.</p>

<ol>
  <li>With probability <em>y</em>/(<em>x</em>+<em>y</em>), return 1.</li>
  <li>Flip the input coin.  If the flip returns 1, return 0.  Otherwise, go to step 1.</li>
</ol>

<blockquote>
  <p><strong>Note:</strong> In this special case of the two-coin algorithm, <em>β</em>=1, <em>c</em>=1, <em>d</em>=<em>x</em>/<em>y</em>, old <em>λ</em> equals 1, and <em>μ</em> equals new <em>λ</em>.</p>

  <p><strong>Example</strong>:  <strong><em>μ</em> / (1 + (<em>x</em>/<em>y</em>)*<em>λ</em>)</strong> (takes two input coins that simulate <em>λ</em> or <em>μ</em>, respectively): Run the <strong>algorithm for 1 / (1 + (<em>x</em>/<em>y</em>)*<em>λ</em>)</strong> using the <em>λ</em> input coin.  If it returns 0, return 0.  Otherwise, flip the <em>μ</em> input coin and return the result.</p>
</blockquote>

<p><a id="lambda_x_y"></a></p>

<h4 id="lambdaxy">$\lambda^{x/y}$</h4>

<p>In the algorithm below, the case where 0 &lt; <em>x</em>/<em>y</em> &lt; 1 is due to Mendo (2019)<sup id="fnref:24:2" role="doc-noteref"><a href="#fn:24" class="footnote" rel="footnote">24</a></sup>.  The algorithm works only when <em>x</em>/<em>y</em> is 0 or greater.</p>

<ol>
  <li>If <em>x</em>/<em>y</em> is 0, return 1.</li>
  <li>If <em>x</em>/<em>y</em> is equal to 1, flip the input coin and return the result.</li>
  <li>If <em>x</em>/<em>y</em> is greater than 1:
    <ol>
      <li>Set <em>ipart</em> to floor(<em>x</em>/<em>y</em>) and <em>fpart</em> to rem(<em>x</em>, <em>y</em>) (equivalent to <em>x</em> - <em>y</em>*floor(<em>x</em>/<em>y</em>)).</li>
      <li>If <em>fpart</em> is greater than 0, subtract 1 from <em>ipart</em>, then call this algorithm recursively with <em>x</em> = floor(<em>fpart</em>/2) and <em>y</em> = <em>y</em>, then call this algorithm, again recursively, with <em>x</em> = <em>fpart</em> − floor(<em>fpart</em>/2) and <em>y</em> = <em>y</em>. Return 0 if either call returns 0.  (This is done rather than the more obvious approach in order to avoid calling this algorithm with fractional parts very close to 0, because the algorithm runs much more slowly than for fractional parts closer to 1.)</li>
      <li>If <em>ipart</em> is 1 or greater, flip the input coin <em>ipart</em> many times.  Return 0 if any of these flips returns 1.</li>
      <li>Return 1.</li>
    </ol>
  </li>
  <li><em>x</em>/<em>y</em> is less than 1, so set <em>i</em> to 1.</li>
  <li>Do the following process repeatedly, until this algorithm returns a value:
    <ol>
      <li>Flip the input coin; if it returns 1, return 1.</li>
      <li>With probability <em>x</em>/(<em>y</em>*<em>i</em>), return 0. (Note: <em>x</em>/(<em>y</em>*<em>i</em>) = (<em>x</em>/<em>y</em>) * (1/<em>i</em>).)</li>
      <li>Add 1 to <em>i</em>.</li>
    </ol>
  </li>
</ol>

<blockquote>
  <p><strong>Notes:</strong></p>

  <ol>
    <li>When <em>x</em>/<em>y</em> is less than 1, the expected number of flips grows without bound as <em>λ</em> approaches 0.  In fact, no fast Bernoulli factory algorithm can avoid this unbounded growth without additional information on <em>λ</em> (Mendo 2019)<sup id="fnref:24:3" role="doc-noteref"><a href="#fn:24" class="footnote" rel="footnote">24</a></sup>.</li>
    <li>The problem of simulating $\lambda^{x/y}$ where $0\lt x/y$, was also treated by Banerjee and Sinha (1979)<sup id="fnref:59" role="doc-noteref"><a href="#fn:59" class="footnote" rel="footnote">59</a></sup>.</li>
  </ol>
</blockquote>

<p><a id="sqrt___lambda"></a></p>

<h4 id="sqrtlambda">sqrt(<em>λ</em>)</h4>

<p>Special case of the previous algorithm with <em>μ</em> = 1/2.</p>

<ul>
  <li>Set <em>i</em> to 1.  Then do the following process repeatedly, until this algorithm returns a value:
    <ol>
      <li>Flip the input coin. If it returns 1, return 1.</li>
      <li>With probability 1/(<em>i</em>*2), return 0.</li>
      <li>Add 1 to <em>i</em> and go to step 1.</li>
    </ol>
  </li>
</ul>

<p><a id="arctan___lambda_____lambda"></a></p>

<h4 id="arctanlambda-lambda">arctan(<em>λ</em>) /<em>λ</em></h4>

<p>arctan(<em>λ</em>) is the inverse tangent of <em>λ</em>.</p>

<p>Based on the algorithm from Flajolet et al. (2010)<sup id="fnref:1:14" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>, but uses the two-coin algorithm (which has bounded expected running time for every <em>λ</em> parameter) rather than the even-parity construction (which does not).<sup id="fnref:32:2" role="doc-noteref"><a href="#fn:32" class="footnote" rel="footnote">32</a></sup><sup id="fnref:54:1" role="doc-noteref"><a href="#fn:54" class="footnote" rel="footnote">54</a></sup></p>

<ul>
  <li>Do the following process repeatedly, until this algorithm returns a value:
    <ol>
      <li>Generate 1 or 0 with equal probability.  If 1 was generated this way, return 1.</li>
      <li>Generate <em>u</em>, a uniform random variate between 0 and 1, if it wasn’t generated yet.</li>
      <li><a href="#Implementation_Notes"><strong>Sample from the number <em>u</em></strong></a> twice, and flip the input coin twice.  If all of these calls and flips return 1, return 0.</li>
    </ol>
  </li>
</ul>

<p><a id="arctan___lambda_____pi"></a></p>

<h4 id="arctanlambda-pi">arctan(<em>λ</em>) /<em>π</em></h4>

<ol>
  <li>Run the <strong>algorithm for 1/<em>π</em></strong>.  If the run returns 0, return 0.</li>
  <li>Do the following process repeatedly, until this algorithm returns a value:
    <ol>
      <li>Generate 1 or 0 with equal probability.  If 1 was generated this way, flip the input coin and return the result.</li>
      <li>Generate <em>u</em>, a uniform random variate between 0 and 1, if it wasn’t generated yet.</li>
      <li><a href="#Implementation_Notes"><strong>Sample from the number <em>u</em></strong></a> twice, and flip the input coin twice.  If all of these calls and flips return 1, return 0.</li>
    </ol>
  </li>
</ol>

<p><a id="arctan___lambda"></a></p>

<h4 id="arctanlambda">arctan(<em>λ</em>)</h4>

<p>(Flajolet et al., 2010)<sup id="fnref:1:15" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>: Call the <strong>algorithm for arctan(<em>λ</em>) /<em>λ</em></strong> and flip the input coin.  Return 1 if the call and flip both return 1, or 0 otherwise.</p>

<p><a id="cos___lambda"></a></p>

<h4 id="coslambda">cos(<em>λ</em>)</h4>

<p>This function can be rewritten as a power series expansion.  To simulate it, use the <strong>general martingale algorithm</strong> (see “<a href="#Certain_Power_Series"><strong>Certain Power Series</strong></a>”), with $g(\lambda)=\lambda$, and with $d_0 = 1$ and power coefficients $a_i = (-1)^{i/2} / (i!)$ if $i$ is even<sup id="fnref:27:4" role="doc-noteref"><a href="#fn:27" class="footnote" rel="footnote">27</a></sup> and 0 otherwise.</p>

<p><a id="sin___lambda___sqrt__c____lambda___sqrt__c"></a></p>

<h4 id="sinlambdasqrtc--lambdasqrtc">sin(<em>λ</em>*sqrt(<em>c</em>)) / (<em>λ</em>*sqrt(<em>c</em>))</h4>

<p>This function can be rewritten as a power series expansion.  To simulate it, use the <strong>general martingale algorithm</strong> (see “<a href="#Certain_Power_Series"><strong>Certain Power Series</strong></a>”), with $g(\lambda)=\lambda$, and with $d_0 = 1$ and power coefficients $a_i = \frac{ (-1)^{i/2} c^{i/2}}{(i+1)!}$ if $i$ is even<sup id="fnref:27:5" role="doc-noteref"><a href="#fn:27" class="footnote" rel="footnote">27</a></sup> and 0 otherwise.  In this algorithm, <em>c</em> must be a rational number in the interval (0, 6].</p>

<p><a id="sin___lambda"></a></p>

<h4 id="sinlambda">sin(<em>λ</em>)</h4>

<p>Equals the previous function times <em>λ</em>, with <em>c</em> = 1.</p>

<ul>
  <li>Flip the input coin.  If it returns 0, return 0.  Otherwise, run the algorithm for <strong>sin(<em>λ</em>*sqrt(<em>c</em>)) / (<em>λ</em>*sqrt(<em>c</em>))</strong> with <em>c</em> = 1, then return the result.</li>
</ul>

<p><a id="ln_1___lambda"></a></p>

<h4 id="ln1lambda">ln(1+<em>λ</em>)</h4>

<p>Based on the algorithm from Flajolet et al. (2010)<sup id="fnref:1:16" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>, but uses the two-coin algorithm (which has bounded expected running time for every <em>λ</em> parameter) rather than the even-parity construction (which does not).<sup id="fnref:32:3" role="doc-noteref"><a href="#fn:32" class="footnote" rel="footnote">32</a></sup><sup id="fnref:55:1" role="doc-noteref"><a href="#fn:55" class="footnote" rel="footnote">55</a></sup></p>

<ul>
  <li>Do the following process repeatedly, until this algorithm returns a value:
    <ol>
      <li>Generate 1 or 0 with equal probability.  If 1 was generated this way, flip the input coin and return the result.</li>
      <li>Generate <em>u</em>, a uniform random variate between 0 and 1, if <em>u</em> wasn’t generated yet.</li>
      <li><a href="#Implementation_Notes"><strong>Sample from the number <em>u</em></strong></a>, then flip the input coin.  If the call and the flip both return 1, return 0.</li>
    </ol>
  </li>
</ul>

<p><a id="ln__c____lambda____c____lambda"></a></p>

<h4 id="lnclambdaclambda">ln(<em>c</em>+<em>λ</em>)/(<em>c</em>+<em>λ</em>)</h4>

<p>In this algorithm:</p>

<ul>
  <li><em>c</em> is a rational number and is 1 or greater.</li>
  <li><em>λ</em> is the unknown heads probability of a coin.</li>
</ul>

<p>The algorithm follows.</p>

<ol>
  <li>Run the algorithm for <strong><em>d</em> / (<em>c</em> + <em>λ</em>)</strong>, with <em>d</em>=1 and <em>c</em>=<em>c</em>, repeatedly, until the run returns 1, then set <em>g</em> to the number of runs that returned 0 this way.</li>
  <li>If <em>g</em> is 0, return 0.  Otherwise, return a number that is 1 with probability 1/<em>g</em> or 0 otherwise.</li>
</ol>

<blockquote>
  <p><strong>Note:</strong> This algorithm is based on the <a href="https://peteroupc.github.io/bernoulli.html#Flajolet_s_Probability_Simulation_Schemes"><strong>von Neumann schema</strong></a> with the single-cycle permutation class.  In this case, given a coin that shows heads with probability <em>z</em>, the schema will terminate in one iteration with probability (1−<em>z</em>)*ln(1/(1−<em>z</em>)).  (In step 2 of the algorithm, returning 0 means that the von Neumann schema would require another iteration.) Thus, if the coin shows heads with probability 1 − <em>z</em>, the one-iteration probability is <em>z</em>*ln(1/<em>z</em>), so if the coin shows heads with probability 1 − 1/(<em>m</em>+<em>z</em>), the one-iteration probability is (1/(<em>m</em>+<em>z</em>))*ln(1/(1/(<em>m</em>+<em>z</em>))) = ln(<em>m</em>+<em>z</em>)/(<em>m</em>+<em>z</em>).</p>
</blockquote>

<p><a id="arcsin___lambda___sqrt_1_minus___lambda__2_minus_1"></a></p>

<h4 id="arcsinlambda--sqrt1-minus-lambdasup2sup-minus-1">arcsin(<em>λ</em>) + sqrt(1 − <em>λ</em><sup>2</sup>) − 1</h4>

<p>(Flajolet et al., 2010)<sup id="fnref:1:17" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>.  arcsin(<em>λ</em>) is the inverse sine of <em>λ</em>.  The algorithm given here uses the two-coin algorithm rather than the even-parity construction<sup id="fnref:32:4" role="doc-noteref"><a href="#fn:32" class="footnote" rel="footnote">32</a></sup>.</p>

<ol>
  <li>Generate <em>u</em>, a uniform random variate between 0 and 1.</li>
  <li>Create a secondary coin <em>μ</em> that does the following: “<a href="#Implementation_Notes"><strong>Sample from the number <em>u</em></strong></a> twice, and flip the input coin twice.  If all of these calls and flips return 1, return 0.  Otherwise, return 1.”</li>
  <li>Call the <strong>algorithm for <em>μ</em><sup>1/2</sup></strong> using the secondary coin <em>μ</em>.  If it returns 0, return 0.</li>
  <li>Generate 1 or 0 with equal probability.  If 1 was generated this way, flip the input coin and return the result.</li>
  <li><a href="#Implementation_Notes"><strong>Sample from the number <em>u</em></strong></a> once, and flip the input coin once.  If both the call and flip return 1, return 0.  Otherwise, go to step 4.</li>
</ol>

<p><a id="tanh__z"></a></p>

<h4 id="tanhz">tanh(<em>z</em>)</h4>

<p><code>tanh</code> is the hyperbolic tangent function.  In this algorithm, <em>z</em> is 0 or greater and is written in one of the ways described in the <a href="#ExpMinus_exp_minus__z"><strong>“ExpMinus” section</strong></a>.<sup id="fnref:60" role="doc-noteref"><a href="#fn:60" class="footnote" rel="footnote">60</a></sup></p>

<ul>
  <li>Do the following process repeatedly, until this algorithm returns a value:
    <ol>
      <li>Run the <strong>ExpMinus</strong> algorithm, with parameter <em>z</em>, twice.  Let <em>r</em> be a number that is 1 if both runs returned 1, or 0 otherwise.</li>
      <li>Generate 1 or 0 with equal probability.  If 1 was generated this way, return 1−<em>r</em>.  Otherwise, if <em>r</em> is 1, return 0.</li>
    </ol>
  </li>
</ul>

<blockquote>
  <p><strong>Note:</strong> Follows from observing that tanh(<em>z</em>) = (<em>d</em> + (1 − <em>μ</em>)) / (<em>c</em> + <em>μ</em>), where <em>μ</em> = (exp(−<em>z</em>))<sup>2</sup>, <em>d</em> = 0, and <em>c</em> = 1.</p>
</blockquote>

<p><a id="Expressions_Involving_Polylogarithms"></a></p>

<h4 id="expressions-involving-polylogarithms">Expressions Involving Polylogarithms</h4>

<p>The following algorithm simulates the expression Li<sub><em>r</em></sub>(<em>λ</em>) * (1 / <em>λ</em> − 1), where Li<sub><em>r</em></sub>(.) is a polylogarithm of order <em>r</em>, and <em>r</em> is an integer 1 or greater.    However, even with a relatively small <em>r</em> such as 6, the expression quickly approaches a straight line.</p>

<p>If <em>λ</em> is 1/2, this expression simplifies to Li<sub><em>r</em></sub>(1/2). See also (Flajolet et al., 2010)<sup id="fnref:1:18" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>.  See also “<a href="#Convex_Combinations"><strong>Convex Combinations</strong></a>” (the case of 1/2 works by decomposing the series forming the polylogarithmic constant into <em>g</em>(<em>i</em>) = (1/2)<sup><em>i</em></sup>, which sums to 1, and <em>h</em><sub><em>i</em></sub>() = 1/<em>i</em><sup><em>r</em></sup>, where <em>i</em> ≥ 1).</p>

<ol>
  <li>Flip the input coin until it returns 0, and let <em>t</em> be 1 plus the number of times the coin returned 1 this way.</li>
  <li>Return a number that is 1 with probability 1/<em>t</em><sup><em>r</em></sup> and 0 otherwise.</li>
</ol>

<p><a id="min___lambda___1_2_and_min___lambda___1_minus___lambda"></a></p>

<h4 id="minlambda-12-and-minlambda-1minuslambda">min(<em>λ</em>, 1/2) and min(<em>λ</em>, 1−<em>λ</em>)</h4>

<p>My own algorithm for min(<em>λ</em>, 1/2) is as follows.  See the end of this section for the derivation of this algorithm.</p>

<ol>
  <li>Generate 1 or 0 with equal probability.  If 1 was generated this way, flip the input coin and return the result.</li>
  <li>Run the algorithm for min(<em>λ</em>, 1−<em>λ</em>) given later, and return the result of that run.</li>
</ol>

<p>And the algorithm for min(<em>λ</em>, 1−<em>λ</em>) is as follows:</p>

<ol>
  <li>(Random walk.) Generate numbers that are each 1 or 0 with equal probability until more zeros than ones are generated this way for the first time.  Then set <em>m</em> to (<em>n</em>−1)/2+1, where <em>n</em> is how many numbers were generated this way.</li>
  <li>(Build a degree-_m_*2 polynomial equivalent to (4*<em>λ</em>*(1−<em>λ</em>))<sup><em>m</em></sup>/2.) Let <em>z</em> be (4<sup><em>m</em></sup>/2)/choose(<em>m</em>*2,<em>m</em>).  Define a polynomial of degree <em>m</em>*2 whose (<em>m</em>*2)+1 Bernstein coefficients are all zero except the <em>m</em><sup>th</sup> Bernstein coefficient (starting at 0), whose value is <em>z</em>.  Elevate the degree of this polynomial enough times so that all its Bernstein coefficients are 1 or less (degree elevation increases the polynomial’s degree without changing its shape or position; see the derivation at the end of this section).  Let <em>d</em> be the new polynomial’s degree.</li>
  <li>(Simulate the polynomial, whose degree is <em>d</em> (Goyal and Sigman 2012)<sup id="fnref:7:3" role="doc-noteref"><a href="#fn:7" class="footnote" rel="footnote">7</a></sup>.) Flip the input coin <em>d</em> times and set <em>h</em> to the number of ones generated this way.  Let <em>a</em> be the <em>h</em><sup>th</sup> Bernstein coefficient (starting at 0) of the new polynomial.  With probability <em>a</em>, return 1.  Otherwise, return 0.</li>
</ol>

<p>I suspected that the required degree <em>d</em> would be floor(<em>m</em>*2/3)+1, as described in the appendix.  With help from the <a href="https://mathoverflow.net/questions/381419"><strong>MathOverflow community</strong></a>, steps 2 and 3 of the algorithm above can be described more efficiently as follows:</p>

<ul>
  <li>(2.) Let <em>r</em> be floor(<em>m</em>*2/3)+1, and let <em>d</em> be <em>m</em>*2+<em>r</em>.</li>
  <li>(3.) (Simulate the polynomial, whose degree is <em>d</em>.) Flip the input coin <em>d</em> times and set <em>h</em> to the number of ones generated this way.  Let <em>a</em> be (1/2) * 2<sup><em>m</em>*2</sup>*choose(<em>r</em>,<em>h</em>−<em>m</em>)/choose(<em>d</em>, <em>h</em>) (the polynomial’s <em>h</em><sup>th</sup> Bernstein coefficient starting at 0; the first term is 1/2 because the polynomial being simulated has the value 1/2 at the point 1/2).  With probability <em>a</em>, return 1.  Otherwise, return 0.</li>
</ul>

<p>The min(<em>λ</em>, 1−<em>λ</em>) algorithm can be used to simulate certain other piecewise linear functions with three breakpoints, and algorithms for those functions are shown in the following table.  In the table, <em>μ</em> is the unknown probability of heads of a second input coin, and <em>ν</em> is the unknown probability of heads of a third input coin.</p>

<table>
  <thead>
    <tr>
      <th>Breakpoints</th>
      <th>Algorithm</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0 at 0; <em>ν</em>/2 at 1/2; and <em>ν</em>*<em>μ</em> at 1.</td>
      <td>Flip the <em>ν</em> input coin.  If it returns 0, return 0.  Otherwise, flip the <em>μ</em> input coin.  If it returns 1, flip the <em>λ</em> input coin and return the result.  Otherwise, run the algorithm for min(<em>λ</em>, 1−<em>λ</em>) using the <em>λ</em> input coin, and return the result of that run.</td>
    </tr>
    <tr>
      <td>(1−<em>μ</em>)/2 at 0; 1/2 at 1/2; and <em>μ</em>/2 at 1.</td>
      <td>Generate 1 or 0 with equal probability.  If that bit is 1, run the algorithm for min(<em>λ</em>, 1−<em>λ</em>) using the <em>λ</em> input coin, and return the result of that run.  Otherwise, flip the <em>μ</em> input coin.  If it returns 1, flip the <em>λ</em> input coin and return the result.  Otherwise, flip the <em>λ</em> input coin and return 1 minus the result.</td>
    </tr>
    <tr>
      <td>0 at 0; <em>μ</em>/2 at 1/2; and <em>μ</em>/2 at 1.</td>
      <td>Flip the <em>μ</em> input coin.  If it returns 0, return 0.  Otherwise, generate 1 or 0 with equal probability.  If 1 was generated this way, flip the <em>λ</em> input coin and return the result.  Otherwise, run the algorithm for min(<em>λ</em>, 1−<em>λ</em>) using the <em>λ</em> input coin, and return the result of that run.</td>
    </tr>
    <tr>
      <td><em>μ</em> at 0; 1/2 at 1/2; and 0 at 1.</td>
      <td>Flip the <em>μ</em> input coin.  If it returns 1, flip the <em>λ</em> input coin and return 1 minus the result.  Otherwise, run the algorithm for min(<em>λ</em>, 1−<em>λ</em>) using the <em>λ</em> input coin, and return the result of that run.</td>
    </tr>
    <tr>
      <td>1 at 0; 1/2 at 1/2; and <em>μ</em> at 1.</td>
      <td>Flip the <em>μ</em> input coin.  If it returns 0, flip the <em>λ</em> input coin and return 1 minus the result.  Otherwise, run the algorithm for min(<em>λ</em>, 1−<em>λ</em>) using the <em>λ</em> input coin, and return 1 minus the result of that run.</td>
    </tr>
    <tr>
      <td><em>μ</em> at 0; 1/2 at 1/2; and 1 at 1.</td>
      <td>Flip the <em>μ</em> input coin.  If it returns 0, flip the <em>λ</em> input coin and return the result.  Otherwise, run the algorithm for min(<em>λ</em>, 1−<em>λ</em>) using the <em>λ</em> input coin, and return 1 minus the result of that run.</td>
    </tr>
    <tr>
      <td><em>B</em> at 0; <em>B</em>+(<em>A</em>/2) at 1/2; and <em>B</em>+(<em>A</em>/2) at 1.</td>
      <td>(<em>A</em>≤1 and <em>B</em>≤1−<em>A</em> are rational numbers.) With probability 1−<em>A</em>, return a number that is 1 with probability <em>B</em>/(1−<em>A</em>) and 0 otherwise.  Otherwise, generate 1 or 0 with equal probability.  If that bit is 1, flip the <em>λ</em> input coin and return the result.  Otherwise, run the algorithm for min(<em>λ</em>, 1−<em>λ</em>) using the <em>λ</em> input coin, and return the result of that run.</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p><strong>Example:</strong> Let $f$ be $\lambda/2$ if $\lambda\le 1/2$, and $1/2-\lambda/2$ otherwise.  Then use the algorithm for 0 at 0; <em>ν</em>/2 at 1/2; and <em>ν</em>*<em>μ</em> at 1, where <em>ν</em> is a coin that returns 1 with probability 1/2 and 0 otherwise, and <em>μ</em> is a coin that always returns 0.</p>

  <p><strong>Note:</strong> The following explains how the algorithm is derived. The function min(<em>λ</em>, 1/2) can be rewritten as <em>A</em> + <em>B</em> where—</p>

  <ul>
    <li><em>A</em>  = (1/2) * <em>λ</em>, and</li>
    <li><em>B</em> = (1/2) * min(<em>λ</em>, 1−<em>λ</em>)<br />  = (1/2) * ((1−sqrt(1−4*<em>λ</em>*(1−<em>λ</em>)))/2)<br />  = (1/2) * $\sum_{k\ge 1} h_k(\lambda)$,</li>
  </ul>

  <p>revealing that the function is a <a href="#Convex_Combinations"><strong>convex combination</strong></a>, and <em>B</em> is itself a convex combination where—</p>

  <ul>
    <li><em>g</em>(<em>k</em>) = choose(2*<em>k</em>,<em>k</em>)/((2*<em>k</em>−1)*2<sup>2*<em>k</em></sup>), and</li>
    <li><em>h</em><sub><em>k</em></sub>(<em>λ</em>) = (4*<em>λ</em>*(1−<em>λ</em>))<sup><em>k</em></sup> / 2 = (<em>λ</em>*(1−<em>λ</em>))<sup><em>k</em></sup> * 4<sup><em>k</em></sup> / 2</li>
  </ul>

  <p>(see also Wästlund (1999)<sup id="fnref:9:4" role="doc-noteref"><a href="#fn:9" class="footnote" rel="footnote">9</a></sup>; Dale et al. (2015)<sup id="fnref:61" role="doc-noteref"><a href="#fn:61" class="footnote" rel="footnote">61</a></sup>).  The right-hand side of <em>h</em>, which is the polynomial built in step 3 of the algorithm for min(<em>λ</em>, 1−<em>λ</em>), is a polynomial of degree <em>k</em>*2 with Bernstein coefficients—</p>

  <ul>
    <li><em>z</em> = (4<sup><em>v</em></sup>/2) / choose(<em>v</em>*2,<em>v</em>) at <em>v</em>=<em>k</em>, and</li>
    <li>0 elsewhere.</li>
  </ul>

  <p>Unfortunately, <em>z</em> can be greater than 1, so that the polynomial can’t be simulated, as is, using the Bernoulli factory algorithm for <a href="https://peteroupc.github.io/bernoulli.html#Certain_Polynomials"><strong>polynomials in Bernstein form</strong></a>.  Fortunately, the polynomial’s degree can be elevated to bring the Bernstein coefficients to 1 or less (for degree elevation and other algorithms, see Tsai and Farouki (2001)<sup id="fnref:62" role="doc-noteref"><a href="#fn:62" class="footnote" rel="footnote">62</a></sup>).  Moreover, due to the special form of the Bernstein coefficients in this case, the degree elevation process can be greatly simplified.  Given an even degree <em>d</em> as well as <em>z</em> (as defined above), the degree elevation is as follows:</p>

  <ol>
    <li>Set <em>r</em> to floor(<em>d</em>/3) + 1. (This starting value is because when this routine finishes, <em>r</em>/<em>d</em> appears to converge to 1/3 as <em>d</em> gets large, for the polynomial in question.)  Let <em>c</em> be choose(<em>d</em>,<em>d</em>/2).</li>
    <li>Create a list of <em>d</em>+<em>r</em>+1 Bernstein coefficients, all zeros.</li>
    <li>For each integer <em>i</em> satisfying 0 ≤ <em>i</em> ≤ <em>d</em>+<em>r</em>:
      <ul>
        <li>If max(0, <em>i</em>−<em>r</em>) ≤ <em>d</em>/2 and if <em>d</em>/2 ≤ min(<em>d</em>, <em>i</em>), set the <em>i</em><sup>th</sup> Bernstein coefficient (starting at 0) to <em>z</em>*<em>c</em>*choose(<em>r</em>,<em>i</em>−<em>d</em>/2)* / choose(<em>d</em>+<em>r</em>, <em>i</em>).</li>
      </ul>
    </li>
    <li>If all the Bernstein coefficients are 1 or less, return them.  Otherwise, add <em>d</em>/2 to <em>r</em> and go to step 2.</li>
  </ol>
</blockquote>

<p><a id="Algorithms_for_Specific_Functions_of___lambda___Probability_Sensitive"></a></p>

<h3 id="algorithms-for-specific-functions-of-lambda-probability-sensitive">Algorithms for Specific Functions of <em>λ</em> (Probability-Sensitive)</h3>

<p>This section describes algorithms for specific functions that require knowing certain information on the probability of input coins.</p>

<p><a id="lambda_____mu"></a></p>

<h4 id="lambda--mu"><em>λ</em> + <em>μ</em></h4>

<p>(Nacu and Peres 2005, proposition 14(iii))<sup id="fnref:17:2" role="doc-noteref"><a href="#fn:17" class="footnote" rel="footnote">17</a></sup>.  This algorithm takes two input coins that simulate <em>λ</em> or <em>μ</em>, respectively, and a parameter <em>ϵ</em> such that 0 &lt; <em>ϵ</em> ≤ 1 − <em>λ</em> − <em>μ</em>.</p>

<ol>
  <li>Create a <em>ν</em> input coin that does the following: “Generate 1 or 0 with equal probability.  If 1 was generated this way, flip the <em>λ</em> input coin and return the result.  Otherwise, flip the <em>μ</em> input coin and return the result.”</li>
  <li>Run a <a href="#Linear_Bernoulli_Factories"><strong>linear Bernoulli factory</strong></a> using the <em>ν</em> input coin, <em>x</em>/<em>y</em> = 2/1, and <em>ϵ</em> = <em>ϵ</em>, and return the result.</li>
</ol>

<p><a id="lambda___minus___mu"></a></p>

<h4 id="lambda-minus-mu"><em>λ</em> − <em>μ</em></h4>

<p>(Nacu and Peres 2005, proposition 14(iii-iv))<sup id="fnref:17:3" role="doc-noteref"><a href="#fn:17" class="footnote" rel="footnote">17</a></sup>.  This algorithm takes two input coins that simulate <em>λ</em> or <em>μ</em>, respectively, and a parameter <em>ϵ</em> such that 0 &lt; <em>ϵ</em> ≤ <em>λ</em> − <em>μ</em> (the greater <em>ϵ</em> is, the more efficient).</p>

<ol>
  <li>Create a <em>ν</em> input coin that does the following: “Generate 1 or 0 with equal probability.  If 1 was generated this way, flip the <em>λ</em> input coin and return <strong>1 minus the result</strong>.  Otherwise, flip the <em>μ</em> input coin and return the result.”</li>
  <li>Run a <a href="#Linear_Bernoulli_Factories"><strong>linear Bernoulli factory</strong></a> using the <em>ν</em> input coin, <em>x</em>/<em>y</em> = 2/1, and <em>ϵ</em> = <em>ϵ</em>, and return 1 minus the result.</li>
</ol>

<p><a id="x03F5_____lambda"></a></p>

<h4 id="x03f5--lambda"><em>ϵ</em> / <em>λ</em></h4>

<p>(Lee et al. 2014)<sup id="fnref:63" role="doc-noteref"><a href="#fn:63" class="footnote" rel="footnote">63</a></sup>.  In the following algorithm:</p>

<ul>
  <li><em>λ</em> is the probability of heads of an input coin.</li>
  <li><em>ϵ</em> is a rational number that satisfies 0 &lt; <em>ϵ</em> ≤ <em>λ</em> ≤ 1.</li>
</ul>

<p>The algorithm follows.</p>

<ol>
  <li>Set <em>β</em> to max(<em>ϵ</em>, 1/2) and set <em>γ</em> to 1 − (1 − <em>β</em>) / (1 − (<em>β</em> / 2)).</li>
  <li>Create a <em>μ</em> input coin that flips the input coin and returns 1 minus the result.</li>
  <li>With probability <em>ϵ</em>, return 1.</li>
  <li>Run a <a href="#Linear_Bernoulli_Factories"><strong>linear Bernoulli factory</strong></a> with the <em>μ</em> input coin, <em>x</em>/<em>y</em> = 1 / (1 − <em>ϵ</em>), and <em>ϵ</em> = <em>γ</em>. If the result is 0, return 0.  Otherwise, go to step 3.  (Running the linear Bernoulli factory this way simulates the probability (<em>λ</em> − <em>ϵ</em>)/(1 − <em>ϵ</em>) or 1 − (1 − <em>λ</em>)/(1 − <em>ϵ</em>)).</li>
</ol>

<p><a id="mu_____lambda"></a></p>

<h4 id="mu--lambda"><em>μ</em> / <em>λ</em></h4>

<p>(Morina 2021)<sup id="fnref:64" role="doc-noteref"><a href="#fn:64" class="footnote" rel="footnote">64</a></sup>.  In this division algorithm:</p>

<ul>
  <li><em>μ</em> is the probability of heads of an input coin and represents the dividend.</li>
  <li><em>λ</em> is the probability of heads of another input coin, represents the divisor, and satisfies 0 ≤ <em>μ</em> &lt; <em>λ</em> ≤ 1.</li>
  <li><em>ϵ</em> is a rational number that satisfies 0 &lt; <em>ϵ</em> ≤ <em>λ</em> − <em>μ</em>.  <em>ϵ</em> can be a positive rational number that equals a lower bound for <em>λ</em> minus an upper bound for <em>μ</em>.</li>
</ul>

<p>The algorithm follows.</p>

<ul>
  <li>Do the following process repeatedly, until this algorithm returns a value:
    <ol>
      <li>Generate 1 or 0 with equal probability.</li>
      <li>If 1 was generated in step 1, flip the <em>μ</em> input coin.  If it returns 1, return 1.</li>
      <li>If 0 was generated in step 1, run the <strong>algorithm for <em>λ</em> − <em>μ</em></strong> with <em>ϵ</em> = <em>ϵ</em>. If it returns 1, return 0.</li>
    </ol>
  </li>
</ul>

<p><a id="lambda____x___y"></a></p>

<h4 id="lambda--xy"><em>λ</em> * <em>x</em>/<em>y</em></h4>

<p>In general, this function will touch 0 or 1 at some point greater than 0 and less than 1, when <em>x</em>/<em>y</em> &gt; 1.  This makes the function relatively non-trivial to simulate in this case.</p>

<p>Huber has suggested several algorithms for this function over the years.</p>

<p>The first algorithm in this document comes from Huber (2014)<sup id="fnref:5:1" role="doc-noteref"><a href="#fn:5" class="footnote" rel="footnote">5</a></sup>.  It uses three parameters:</p>

<ul>
  <li><em>x</em> and <em>y</em> are integers such that <em>x</em>/<em>y</em> &gt; 0 and <em>y</em>!=0.</li>
  <li><em>ϵ</em> is a rational number greater than 0 and less than 1.  If <em>x</em>/<em>y</em> is greater than 1, <em>ϵ</em> must be such that 0 &lt; <em>ϵ</em> ≤1 − <em>λ</em> * <em>x</em>/<em>y</em>, in order to bound the function away from 0 and 1.  The greater <em>ϵ</em> is, the more efficient.</li>
</ul>

<p>As a result, some knowledge of <em>λ</em> has to be available to the algorithm. The algorithm as described below also includes certain special cases, not mentioned in Huber, to make it more general.</p>

<ol>
  <li>Special cases: If <em>x</em> is 0, return 0.  Otherwise, if <em>x</em> equals <em>y</em>, flip the input coin and return the result.  Otherwise, if <em>x</em> is less than <em>y</em>, then do the following: “With probability <em>x</em>/<em>y</em>, flip the input coin and return the result; otherwise return 0.”</li>
  <li>Set <em>c</em> to <em>x</em>/<em>y</em>, and set <em>k</em> to 23 / (5 * <em>ϵ</em>).</li>
  <li>If <em>ϵ</em> is greater than 644/1000, set <em>ϵ</em> to 644/1000.</li>
  <li>Set <em>i</em> to 1.</li>
  <li>While <em>i</em> is not 0:
    <ol>
      <li>Flip the input coin.  If it returns 0, then generate numbers that are each 1 with probability (<em>c</em> − 1) / <em>c</em> and 0 otherwise, until 1 is generated this way, then add 1 to <em>i</em> for each number generated this way (including the last).</li>
      <li>Subtract 1 from <em>i</em>.</li>
      <li>If <em>i</em> is <em>k</em> or greater:
        <ol>
          <li>Generate <em>i</em> numbers that are each 1 with probability 2 / (<em>ϵ</em> + 2) or 0 otherwise.  If any of those numbers is 0, return 0.</li>
          <li>Multiply <em>c</em> by 2 / (<em>ϵ</em> + 2), then divide <em>ϵ</em> by 2, then multiply <em>k</em> by 2.</li>
        </ol>
      </li>
    </ol>
  </li>
  <li>(<em>i</em> is 0.) Return 1.</li>
</ol>

<p>Huber (2016)<sup id="fnref:42:2" role="doc-noteref"><a href="#fn:42" class="footnote" rel="footnote">42</a></sup> presented a second algorithm using the same three parameters, but it’s omitted here because it appears to perform worse than the algorithm given above and the <strong>algorithm for (<em>λ</em> * <em>x</em>/<em>y</em>)<sup><em>i</em></sup></strong> below (see also Morina 2021<sup id="fnref:64:1" role="doc-noteref"><a href="#fn:64" class="footnote" rel="footnote">64</a></sup>).</p>

<p>Huber (2016) also included a third algorithm that simulates <em>λ</em> * <em>x</em> / <em>y</em>.  The algorithm works only if <em>λ</em> * <em>x</em> / <em>y</em> is known to be less than 1/2.  This third algorithm takes three parameters:</p>

<ul>
  <li><em>x</em> and <em>y</em> are integers such that <em>x</em>/<em>y</em> &gt; 0 and <em>y</em>!=0.</li>
  <li><em>m</em> is a rational number such that <em>λ</em> * <em>x</em> / <em>y</em> ≤ <em>m</em> &lt; 1/2.</li>
</ul>

<p>The algorithm follows.</p>

<ol>
  <li>The same special cases as for the first algorithm in this section apply.</li>
  <li>Run the <strong>logistic Bernoulli factory</strong> algorithm with <em>c</em>/<em>d</em> = (<em>x</em>/<em>y</em>) / (1 − 2 * <em>m</em>).  If it returns 0, return 0.</li>
  <li>With probability 1 − 2 * <em>m</em>, return 1.</li>
  <li>Run a <a href="#Linear_Bernoulli_Factories"><strong>linear Bernoulli factory</strong></a> with <em>x</em>/<em>y</em> = (<em>x</em>/<em>y</em>) / (2 * <em>m</em>) and <em>ϵ</em> = 1 − <em>m</em>.</li>
</ol>

<blockquote>
  <p><strong>Note:</strong> For approximate methods to simulate <em>λ</em>*(<em>x</em>/<em>y</em>), see the page “<a href="https://peteroupc.github.io/bernsupp.html"><strong>Supplemental Notes for Bernoulli Factory Algorithms</strong></a>”.</p>
</blockquote>

<p><a id="lambda____x___y___i"></a></p>

<h4 id="lambda--xysupisup">(<em>λ</em> * <em>x</em>/<em>y</em>)<sup><em>i</em></sup></h4>

<p>(Huber 2019)<sup id="fnref:65" role="doc-noteref"><a href="#fn:65" class="footnote" rel="footnote">65</a></sup>.  This algorithm uses four parameters:</p>

<ul>
  <li><em>x</em> and <em>y</em> are integers such that <em>x</em>/<em>y</em> &gt; 0 and <em>y</em>!=0.</li>
  <li><em>i</em> is an integer 0 or greater.</li>
  <li><em>ϵ</em> is a rational number such that 0 &lt; <em>ϵ</em> &lt; 1.  If <em>x</em>/<em>y</em> is greater than 1, <em>ϵ</em> must be such that 0 &lt; <em>ϵ</em> ≤1 − <em>λ</em> * <em>x</em>/<em>y</em>.</li>
</ul>

<p>The algorithm also has special cases not mentioned in Huber 2019.</p>

<ol>
  <li>Special cases: If <em>i</em> is 0, return 1.  If <em>x</em> is 0, return 0.  Otherwise, if <em>x</em> equals <em>y</em> and <em>i</em> equals 1, flip the input coin and return the result.</li>
  <li>Special case: If <em>x</em> is less than <em>y</em> and <em>i</em> = 1, then do the following: “With probability <em>x</em>/<em>y</em>, flip the input coin and return the result; otherwise return 0.”</li>
  <li>Special case: If <em>x</em> is less than <em>y</em>, then create a secondary coin that does the following: “With probability <em>x</em>/<em>y</em>, flip the input coin and return the result; otherwise return 0”, then flip the secondary coin <em>i</em> times until a flip returns 0, whichever comes first, then return a number that is 1 if all the flips, including the last, return 1, or 0 otherwise.</li>
  <li>Set <em>t</em> to 355/100 and <em>c</em> to <em>x</em>/<em>y</em>.</li>
  <li>While <em>i</em> is not 0:
    <ol>
      <li>While <em>i</em> &gt; <em>t</em> / <em>ϵ</em>:
        <ol>
          <li>Set <em>β</em> to (1 − <em>ϵ</em> / 2) / (1 − <em>ϵ</em>).</li>
          <li>Run the <strong>algorithm for (<em>a</em>/<em>b</em>)<sup><em>z</em></sup></strong> (given in the irrational constants section) with <em>a</em>=1, <em>b</em>=<em>β</em>, and <em>z</em> = <em>i</em>.  If the run returns 0, return 0.</li>
          <li>Multiply <em>c</em> by <em>β</em>, then divide <em>ϵ</em> by 2.</li>
        </ol>
      </li>
      <li>Run the <strong>logistic Bernoulli factory</strong> with <em>c</em>/<em>d</em> = <em>c</em>, then set <em>z</em> to the result.  Set <em>i</em> to <em>i</em> + 1 − <em>z</em> * 2.</li>
    </ol>
  </li>
  <li>(<em>i</em> is 0.) Return 1.</li>
</ol>

<p><a id="Linear_Bernoulli_Factories"></a></p>

<h4 id="linear-bernoulli-factories">Linear Bernoulli Factories</h4>

<p>In this document, a <strong>linear Bernoulli factory</strong> refers to one of the following:</p>

<ul>
  <li>The first algorithm for <a href="#lambda____x___y"><strong><em>λ</em> * <em>x</em>/<em>y</em></strong></a> with the stated parameters <em>x</em>, <em>y</em>, and <em>ϵ</em>.</li>
  <li>The <a href="#lambda____x___y___i"><strong>algorithm for (<em>λ</em> * <em>x</em>/<em>y</em>)<sup><em>i</em></sup></strong></a> with the stated parameters <em>x</em>, <em>y</em>, and <em>ϵ</em>, and with <em>i</em> = 1 (see previous section).</li>
</ul>

<p><a id="lambda_mu"></a></p>

<h4 id="lambdamu">$\lambda^{\mu}$</h4>

<p>This algorithm is based on the <strong>algorithm for <em>λ</em><sup><em>x</em>/<em>y</em></sup></strong>, but changed to accept a second input coin (which outputs heads with probability <em>μ</em>) rather than a fixed value for the exponent.  For this algorithm, <em>λ</em> and <em>μ</em> may not both be 0.</p>

<ul>
  <li>Set <em>i</em> to 1.  Then do the following process repeatedly, until this algorithm returns a value:
    <ol>
      <li>Flip the input coin that simulates the base, <em>λ</em>; if it returns 1, return 1.</li>
      <li>Flip the input coin that simulates the exponent, <em>μ</em>; if it returns 1, return 0 with probability 1/<em>i</em>.</li>
      <li>Add 1 to <em>i</em>.</li>
    </ol>
  </li>
</ul>

<p><a id="1_minus___lambda___cos___lambda"></a></p>

<h4 id="minuslambdacoslambda">(1−<em>λ</em>)/cos(<em>λ</em>)</h4>

<p>(Flajolet et al., 2010)<sup id="fnref:1:19" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>.  Uses an average number of flips that grows without bound as <em>λ</em> goes to 1.</p>

<ol>
  <li>Flip the input coin until the flip returns 0.  Then set <em>G</em> to the number of times the flip returns 1 this way.</li>
  <li>If <em>G</em> is <strong>odd</strong>, return 0.</li>
  <li>Generate <em>u</em>, a uniform random variate between 0 and 1, then set <em>i</em> to 1.</li>
  <li>While <em>i</em> is less than <em>G</em>:
    <ol>
      <li>Generate a uniform random variate between 0 and 1 <em>V</em>.</li>
      <li>If <em>i</em> is odd<sup id="fnref:25:6" role="doc-noteref"><a href="#fn:25" class="footnote" rel="footnote">25</a></sup> and <em>V</em> is less than <em>U</em>, return 0.</li>
      <li>If <em>i</em> is even<sup id="fnref:27:6" role="doc-noteref"><a href="#fn:27" class="footnote" rel="footnote">27</a></sup> and <em>U</em> is less than <em>V</em>, return 0.</li>
      <li>Add 1 to <em>i</em>, then set <em>U</em> to <em>V</em>.</li>
    </ol>
  </li>
  <li>Return 1.</li>
</ol>

<p><a id="1_minus___lambda___tan___lambda"></a></p>

<h4 id="minuslambda--tanlambda">(1−<em>λ</em>) * tan(<em>λ</em>)</h4>

<p>(Flajolet et al., 2010)<sup id="fnref:1:20" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>.  Uses an average number of flips that grows without bound as <em>λ</em> goes to 1.</p>

<ol>
  <li>Flip the input coin until the flip returns 0.  Then set <em>G</em> to the number of times the flip returns 1 this way.</li>
  <li>If <em>G</em> is <strong>even</strong>, return 0.</li>
  <li>Generate <em>u</em>, a uniform random variate between 0 and 1, then set <em>i</em> to 1.</li>
  <li>While <em>i</em> is less than <em>G</em>:
    <ol>
      <li>Generate a uniform random variate between 0 and 1 <em>V</em>.</li>
      <li>If <em>i</em> is odd<sup id="fnref:25:7" role="doc-noteref"><a href="#fn:25" class="footnote" rel="footnote">25</a></sup> and <em>V</em> is less than <em>U</em>, return 0.</li>
      <li>If <em>i</em> is even<sup id="fnref:27:7" role="doc-noteref"><a href="#fn:27" class="footnote" rel="footnote">27</a></sup> and <em>U</em> is less than <em>V</em>, return 0.</li>
      <li>Add 1 to <em>i</em>, then set <em>U</em> to <em>V</em>.</li>
    </ol>
  </li>
  <li>Return 1.</li>
</ol>

<p><a id="ln__c___d____lambda____c"></a></p>

<h4 id="lnc--d--lambdac">ln((<em>c</em> + <em>d</em> + <em>λ</em>)/<em>c</em>)</h4>

<p>In this algorithm, <em>d</em> and <em>c</em> are integers, 0 &lt; <em>c</em>, and <em>c</em> &gt; <em>d</em> ≥ 0, and (<em>c</em> + <em>d</em> + <em>λ</em>)/<em>c</em> ≤ exp(1).</p>

<ul>
  <li>Do the following process repeatedly, until this algorithm returns a value:
    <ol>
      <li>Generate 1 or 0 with equal probability.  If 1 was generated this way, run the <strong>algorithm for (<em>d</em> + <em>λ</em>) / <em>c</em></strong> with <em>d</em> = <em>d</em> and <em>c</em> = <em>c</em>, and return the result.</li>
      <li>Generate <em>u</em>, a uniform random variate between 0 and 1, if <em>u</em> wasn’t generated yet.</li>
      <li><a href="#Implementation_Notes"><strong>Sample from the number <em>u</em></strong></a>, then run the <strong>algorithm for (<em>d</em> + <em>λ</em>) / <em>c</em></strong> with <em>d</em> = <em>d</em> and <em>c</em> = <em>c</em>.  If both calls return 1, return 0.</li>
    </ol>
  </li>
</ul>

<p><a id="arcsin___lambda___2"></a></p>

<h4 id="arcsinlambda--2">arcsin(<em>λ</em>) / 2</h4>

<p>The Flajolet paper doesn’t explain in detail how arcsin(<em>λ</em>)/2 arises out of arcsin(<em>λ</em>) + sqrt(1 − <em>λ</em><sup>2</sup>) − 1 via Bernoulli factory constructions, but here is an algorithm.<sup id="fnref:66" role="doc-noteref"><a href="#fn:66" class="footnote" rel="footnote">66</a></sup> However, the number of input coin flips is expected to grow without bound as <em>λ</em> approaches 1.</p>

<ol>
  <li>Generate 1 or 0 with equal probability.  If 1 was generated this way, run the <strong>algorithm for arcsin(<em>λ</em>) + sqrt(1 − <em>λ</em><sup>2</sup>) − 1</strong> and return the result.</li>
  <li>Create a secondary coin <em>μ</em> that does the following: “Flip the input coin twice.  If both flips return 1, return 0.  Otherwise, return 1.” (The coin simulates 1 − <em>λ</em><sup>2</sup>.)</li>
  <li>Call the <strong>algorithm for <em>μ</em><sup>1/2</sup></strong> using the secondary coin <em>μ</em>.  If it returns 0, return 1; otherwise, return 0. (This step effectively cancels out the sqrt(1 − <em>λ</em><sup>2</sup>) − 1 part and divides by 2.)</li>
</ol>

<p><a id="Other_Factory_Functions"></a></p>

<h3 id="other-factory-functions">Other Factory Functions</h3>

<p>Algorithms in bold are given in this page.</p>

<table>
  <thead>
    <tr>
      <th>To simulate:</th>
      <th>Follow this algorithm:</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1/sqrt(<em>π</em>)</td>
      <td>Create <em>λ</em> coin for algorithm <strong>1/<em>π</em></strong>.<br />Run algorithm for <strong>sqrt(<em>λ</em>)</strong>.</td>
    </tr>
    <tr>
      <td>1/sqrt(<em>h</em>+<em>λ</em>)</td>
      <td>(<em>λ</em> is unknown heads probability of a coin; <em>h</em>≥1 is a rational number.)<br />Create <em>μ</em> coin for algorithm <strong><em>d</em>/(<em>c</em>+<em>λ</em>)</strong> with <em>c</em>=<em>h</em> and <em>d</em>=1.<br />Run algorithm for <strong>sqrt(<em>λ</em>)</strong> with <em>λ</em> being the <em>μ</em> coin.</td>
    </tr>
    <tr>
      <td>1 / (<em>c</em> + <em>λ</em>)</td>
      <td>(<em>λ</em> is unknown heads probability of a coin; <em>c</em>≥1 is a rational number.)<br />Run algorithm for <strong><em>d</em> / (<em>c</em> + <em>λ</em>)</strong> with <em>d</em> = 1.</td>
    </tr>
    <tr>
      <td>1 / (1 + <em>λ</em><sup>2</sup>)</td>
      <td>(Slope function of arctan(<em>λ</em>).  <em>λ</em> is unknown heads probability of a coin.)<br />Create <em>μ</em> coin that flips <em>λ</em> coin twice and returns either 1 if both flips return 1, or 0 otherwise.<br />Run algorithm for <strong><em>d</em> / (<em>c</em> + <em>λ</em>)</strong> with <em>d</em>=1, <em>c</em>=1, and <em>λ</em> being the <em>μ</em> coin.</td>
    </tr>
    <tr>
      <td>1 / (<em>c</em> + exp(− <em>z</em>))</td>
      <td>(<em>z</em>≥0 is written as described in <a href="#ExpMinus_exp_minus__z"><strong>“ExpMinus” section</strong></a>; <em>c</em>≥1 is a rational number.)<br />Create <em>μ</em> coin for <strong>ExpMinus</strong> algorithm with parameter <em>z</em>.<br />Run algorithm for <strong><em>d</em> / (<em>c</em> + <em>λ</em>)</strong> with <em>d</em>=1, <em>c</em>=<em>c</em>, and <em>λ</em> being the <em>μ</em> coin.</td>
    </tr>
    <tr>
      <td>1/(2<sup><em>k</em> + <em>λ</em></sup>) or<br />exp(−(<em>k</em> + <em>λ</em>)*ln(2))</td>
      <td>(<em>λ</em> is unknown heads probability of a coin.  <em>k</em> ≥ 0 is an integer.)<br />Run algorithm <strong>1/(2<sup><em>m</em>*(<em>k</em> + <em>λ</em></sup>))</strong> with <em>k</em>=<em>k</em> and <em>m</em>=1.</td>
    </tr>
    <tr>
      <td>1−exp(− <em>z</em>) = (exp(<em>z</em>)−1) * exp(−<em>z</em>) = (exp(<em>z</em>)−1) / exp(<em>z</em>)</td>
      <td>(<em>z</em>≥0 is written as described in <a href="#ExpMinus_exp_minus__z"><strong>“ExpMinus” section</strong></a>.)<br />Run <strong>ExpMinus</strong> algorithm with parameter <em>z</em>, and return 1 minus the result.</td>
    </tr>
    <tr>
      <td>exp(−((1−<em>λ</em>)<sup>1</sup> * <em>c</em>))</td>
      <td>((Dughmi et al. 2021)<sup id="fnref:43:2" role="doc-noteref"><a href="#fn:43" class="footnote" rel="footnote">43</a></sup>; applies an exponential weight—here, <em>c</em>—to an input coin.  <em>λ</em> is unknown heads probability of a coin.)<br />(1) If <em>c</em> is 0, return 1.<br />(2) Generate <em>N</em>, a Poisson random variate with mean <em>c</em>.<br />(3) Flip the input coin until the flip returns 0 or the coin is flipped <em>N</em> times, whichever comes first, then return a number that is 1 if <em>N</em> is 0 or all of the coin flips (including the last) return 1, or 0 otherwise.</td>
    </tr>
    <tr>
      <td>exp(<em>λ</em><sup>2</sup>) − <em>λ</em>*exp(<em>λ</em><sup>2</sup>)</td>
      <td>(<em>λ</em> is unknown heads probability of a coin.)<br />Run <strong>general martingale algorithm</strong> with $g(\lambda)=\lambda$, $d_0=1$, and $a_i=\frac{(-1)^i}{(\text{floor}(i/2))!}$.</td>
    </tr>
    <tr>
      <td>1 − 1 / (1+(<em>μ</em>*<em>λ</em>/(1 − <em>μ</em>)) =<br />(<em>μ</em>*<em>λ</em>/(1 − <em>μ</em>) / (1+(<em>μ</em>*<em>λ</em>/(1 − <em>μ</em>))</td>
      <td>(Special case of <strong>logistic Bernoulli factory</strong>; 0 ≤ <em>λ</em> ≤ 1, 0 ≤ <em>μ</em> &lt; 1, and both are unknown heads probabilities of two coins.)<br />(1) Flip the <em>μ</em> coin.  If it returns 0, return 0. (Coin samples probability <em>μ</em>/(<em>μ</em> + (1 − <em>μ</em>)) = <em>μ</em>.) <br />(2) Flip the <em>λ</em> coin.  If it returns 1, return 1.  Otherwise, go to step 1.</td>
    </tr>
    <tr>
      <td><em>λ</em>/(1+<em>λ</em>)</td>
      <td>(<em>λ</em> is unknown heads probability of a coin.)<br />Run algorithm for <strong>1/(1+<em>λ</em>)</strong>, then return 1 minus the result.</td>
    </tr>
    <tr>
      <td><em>c</em> * <em>λ</em> / (<em>c</em> * <em>λ</em> + (<em>d</em>+<em>μ</em>)) = (<em>c</em>/(<em>d</em>+<em>μ</em>)) * <em>λ</em> / (1 + (<em>c</em>/(<em>d</em>+<em>μ</em>)) * <em>λ</em>))</td>
      <td>(<em>c</em>≥0 is an integer; <em>d</em>≥0 is an integer; 0 ≤ <em>λ</em> ≤ 1, 0 ≤ <em>μ</em> &lt; 1, and both are unknown heads probabilities of two coins.)<br />(1) If <em>c</em> is 0, return 0.<br />(2) Let <em>D</em> = <em>d</em> and <em>C</em> = <em>c</em>, then run the algorithm for <strong>(<em>d</em> + <em>μ</em>) / (<em>c</em> + <em>λ</em>)</strong> with <em>λ</em> and <em>μ</em> both being the <em>μ</em> input coin, with <em>d</em> = <em>D</em>, and with <em>c</em> = <em>D</em> + <em>C</em>.  If the run returns 1, return 0.<br />(3) Flip the <em>λ</em> input coin.  If the flip returns 1, return 1.  Otherwise, go to step 2.</td>
    </tr>
    <tr>
      <td>(<em>d</em>+<em>μ</em>) / (<em>c</em> * <em>λ</em> + (<em>d</em>+<em>μ</em>))</td>
      <td>(<em>c</em>, <em>d</em>, <em>λ</em>, and <em>μ</em> are as in the previous algorithm.)<br /> Run the previous algorithm and return 1 minus the result.</td>
    </tr>
    <tr>
      <td>exp(<em>z</em>)/(1+exp(<em>z</em>))<sup>2</sup></td>
      <td>(Equals expit(<em>z</em>)*(1−expit(<em>z</em>)). <em>z</em> is described in “expit(<em>z</em>)” section.)<br />Run the algorithm for <strong>expit(<em>z</em>)</strong> twice, with <em>m</em>=0. If the first run returns 1 and the second returns 0, return 1.  Otherwise, return 0.</td>
    </tr>
    <tr>
      <td><em>ν</em> * 1 + (1 − <em>ν</em>) * <em>μ</em> = <em>ν</em> + <em>μ</em> − (<em>ν</em>*<em>μ</em>)</td>
      <td>(<em>Logical OR</em>. Flajolet et al., 2010<sup id="fnref:1:21" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>.  Special case of <em>ν</em> * <em>λ</em> + (1 − <em>ν</em>) * <em>μ</em> with <em>λ</em> = 1. <em>ν</em> and <em>μ</em> are unknown heads probabilities of two coins.)<br />Flip the <em>ν</em> input coin and the <em>μ</em> input coin.  Return 1 if either flip returns 1, and 0 otherwise.</td>
    </tr>
    <tr>
      <td>1 − <em>ν</em></td>
      <td>(<em>Complement</em>. Flajolet et al., 2010<sup id="fnref:1:22" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>.  Special case of <em>ν</em> * <em>λ</em> + (1 − <em>ν</em>) * <em>μ</em> with <em>λ</em> = 0 and <em>μ</em> = 1. <em>ν</em> is unknown heads probability of a coin.)<br />Flip the <em>ν</em> input coin and return 1 minus the result.</td>
    </tr>
    <tr>
      <td><em>ν</em> * <em>λ</em></td>
      <td>(<em>Logical AND</em> or <em>Product</em>. Flajolet et al., 2010<sup id="fnref:1:23" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>.  Special case of <em>ν</em> * <em>λ</em> + (1 − <em>ν</em>) * <em>μ</em> with <em>μ</em> = 0. <em>ν</em> and <em>λ</em> are unknown heads probabilities of two coins.)<br />Flip the <em>ν</em> input coin and the <em>λ</em> input coin.  Return 1 if both flips return 1, and 0 otherwise.</td>
    </tr>
    <tr>
      <td>(<em>λ</em> + <em>μ</em>)/2 = (1/2)*<em>λ</em> + (1/2)*<em>μ</em></td>
      <td>(<em>Mean</em>. Nacu and Peres 2005, proposition 14(iii)<sup id="fnref:17:4" role="doc-noteref"><a href="#fn:17" class="footnote" rel="footnote">17</a></sup>; Flajolet et al., 2010<sup id="fnref:1:24" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>.  Special case of <em>ν</em> * <em>λ</em> + (1 − <em>ν</em>) * <em>μ</em> with <em>ν</em> = 1/2. <em>λ</em> and <em>μ</em> are unknown heads probabilities of two coins.)<br /> Generate 1 or 0 with equal probability.  If 1 was generated this way, flip the <em>λ</em> input coin and return the result.  Otherwise, flip the <em>μ</em> input coin and return the result.</td>
    </tr>
    <tr>
      <td>(1+<em>λ</em>)/2 = (1/2) + (1/2)*<em>λ</em></td>
      <td>(<em>λ</em> is unknown heads probability of a coin.)<br />Generate 1 or 0 with equal probability.  If that bit is 1, return 1.  Otherwise, flip the input coin and return the result.</td>
    </tr>
    <tr>
      <td>(1−<em>λ</em>)/2</td>
      <td>(<em>λ</em> is unknown heads probability of a coin.)<br />Generate 1 or 0 with equal probability.  If that bit is 1, return 0.  Otherwise, flip the input coin and return 1 minus the result.</td>
    </tr>
    <tr>
      <td>1 − ln(1+<em>λ</em>)</td>
      <td>(<em>λ</em> is unknown heads probability of a coin.)<br />Run algorithm for <strong>ln(1+<em>λ</em>)</strong>, then return 1 minus the result.<sup id="fnref:67" role="doc-noteref"><a href="#fn:67" class="footnote" rel="footnote">67</a></sup></td>
    </tr>
    <tr>
      <td>sin(sqrt(<em>λ</em>)*sqrt(<em>c</em>)) / (sqrt(<em>λ</em>)*sqrt(<em>c</em>))</td>
      <td>(<em>c</em> is a rational number; 0 &lt; <em>c</em> ≤ 6.  <em>λ</em> is unknown heads probability of a coin.)<br />Run <strong>general martingale algorithm</strong> with $g(\lambda)=\lambda$, and with $d_0 = 1$ and power coefficients $a_i = \frac{ (-1)^{i} c^{i}}{(i+i+1)!}$.</td>
    </tr>
    <tr>
      <td>3 − exp(1)</td>
      <td>Run the algorithm for <strong>exp(1) − 2</strong>, then return 1 minus the result.</td>
    </tr>
    <tr>
      <td>1/(exp(1)−1)</td>
      <td>Run the algorithm for <strong>1/(exp(1)+<em>c</em>−2)</strong> with <em>c</em> = 1.</td>
    </tr>
    <tr>
      <td><em>r</em>/<em>π</em></td>
      <td>(<em>r</em> is a rational number; 0≤<em>r</em>≤3.)<br />Create <em>λ</em> coin for algorithm <strong><em>π</em> − 3</strong>.<br />Create <em>μ</em> coin that does: “With probability <em>r</em> − floor(<em>r</em>), return 1; otherwise return 0.”<br />If <em>r</em>=0, return 0.  If <em>r</em>=3, run algorithm for <strong><em>d</em> / (<em>c</em> + <em>λ</em>)</strong> with <em>d</em>=<em>n</em> and <em>c</em>=3.  If 0 &lt; <em>r</em> &lt; 3, run algorithm for <strong>(<em>d</em> + <em>μ</em>) / (<em>c</em> + <em>λ</em>)</strong> with <em>d</em>=floor(<em>r</em>) and <em>c</em>=3.</td>
    </tr>
    <tr>
      <td>exp(1)/<em>π</em></td>
      <td>Create <em>μ</em> coin for algorithm <strong>exp(1) − 2</strong>.<br />Create <em>λ</em> coin for algorithm <strong><em>π</em> − 3</strong>.<br />Run algorithm for <strong>(<em>d</em> + <em>μ</em>) / (<em>c</em> + <em>λ</em>)</strong> with <em>d</em>=2 and <em>c</em>=3.</td>
    </tr>
    <tr>
      <td>exp(1)/4</td>
      <td>Generate numbers that are each 1 or 0 with equal probability until a zero is generated this way, then set <em>n</em> to the number of ones generated this way.<br />Set <em>n</em> to 2*<em>n</em> + 2.<br />With probability 2<sup>n−1</sup>/(<em>n</em>!), return 1.  Otherwise return 0.</td>
    </tr>
    <tr>
      <td><em>r</em>*<em>λ</em> − <em>r</em> + <em>r</em>*exp(−<em>λ</em>)</td>
      <td>(<em>r</em> is a rational number greater than 0, but not greater than 2.  <em>λ</em> is the unknown heads probability of a coin.)<br />Run the <strong>general martingale algorithm</strong> with $g(\lambda) = \lambda$, and with $d_0 = r/2$  and power coefficients $a_i = \frac{r}{(i)!} (-1)^i$ if $i\ge 2$ and $a_i=0$ otherwise.</td>
    </tr>
    <tr>
      <td><em>r</em>*exp(−1) = <em>r</em>/exp(1)</td>
      <td>(<em>r</em> is a rational number; 0≤<em>r</em>≤2.)<br />If <em>r</em>=0, return 0.  If <em>r</em>=2, run algorithm for <strong><em>d</em> / (<em>c</em> + <em>λ</em>)</strong> with <em>d</em>=<em>n</em> and <em>c</em>=2.  If 0&lt;<em>r</em>&lt;2, run algorithm for <strong><em>c</em>*<em>λ</em> − <em>c</em> + <em>c</em>*exp(−<em>λ</em>)</strong> with <em>r</em>=<em>r</em> and <em>λ</em> being a coin that always returns 1.</td>
    </tr>
    <tr>
      <td><em>λ</em>/(2−<em>λ</em>) = (<em>λ</em>/2)/(1−(<em>λ</em>/2))</td>
      <td>(<em>λ</em> is the unknown heads probability of a coin.)<br />(1) Flip <em>λ</em> coin; return 0 if it returns 0.<br />(2) Run algorithm for <strong>1/(2−<em>λ</em>)</strong>.</td>
    </tr>
    <tr>
      <td>(1−<em>λ</em>)/(1+<em>λ</em>)</td>
      <td>(<em>λ</em> is the unknown heads probability of a coin.)<br />(1) Flip <em>λ</em> coin; return 0 if it returns 1.<br />(2) Run algorithm for <strong><em>d</em> / (<em>c</em> + <em>λ</em>)</strong> with <em>d</em>=1 and <em>c</em>=1.</td>
    </tr>
  </tbody>
</table>

<p><a id="Algorithms_for_Specific_Constants"></a></p>

<h3 id="algorithms-for-specific-constants">Algorithms for Specific Constants</h3>

<p>This section shows algorithms to simulate a probability equal to a specific
kind of irrational number.</p>

<p><a id="1___phi___1_divided_by_the_golden_ratio"></a></p>

<h4 id="phi-1-divided-by-the-golden-ratio">1 / <em>φ</em> (1 divided by the golden ratio)</h4>

<p>This algorithm uses the algorithm described in the section on <a href="#Continued_Fractions"><strong>continued fractions</strong></a> to simulate 1 divided by the golden ratio (about 0.618), whose continued fraction’s partial denominators are 1, 1, 1, 1, ….</p>

<ol>
  <li>Generate 1 or 0 with equal probability (a “fair coin flip”).  If 1 was generated this way, return 1.</li>
  <li>Do a separate run of the currently running algorithm.  If the separate run returns 1, return 0.  Otherwise, go to step 1.</li>
</ol>

<blockquote>
  <p><strong>Note:</strong> The following is a running time analysis of this algorithm.  A similar analysis to the one below can be used to find the expected (“long-run average”) time complexity of many Bernoulli factory algorithms.  Let <strong>E</strong>[<em>N</em>] be the expected (“long-run average”) number of “fair coin flips” generated by the algorithm.  Then, since each bit is independent, <strong>E</strong>[<em>N</em>] = 2*<em>φ</em> as shown below.</p>

  <ul>
    <li>Each iteration stops the algorithm with probability <em>p</em> = (1/2) + (1−(1/2)) * (1/<em>φ</em>) (1/2 for the initial bit and 1/<em>φ</em> for the recursive run; (1−(1/2)) because the (1/2) is being subtracted earlier on the right-hand side from 1).</li>
    <li>Thus, the expected number of iterations is <strong>E</strong>[<em>T</em>] = 1/<em>p</em> by a well-known rejection sampling argument, since the algorithm doesn’t depend on iteration counts.</li>
    <li>Each iteration uses 1 * (1/2) + (1 + <strong>E</strong>[<em>N</em>]) * (1/2) bits on average, so the whole algorithm uses <strong>E</strong>[<em>N</em>] = (1 * (1/2) + (1 + <strong>E</strong>[<em>N</em>]) * (1/2)) * <strong>E</strong>[<em>T</em>] bits on average (each iteration consumes either 1 bit with probability 1/2, or (1 + <strong>E</strong>[<em>N</em>]) bits with probability 1/2). This equation has the solution <strong>E</strong>[<em>N</em>] = 1 + sqrt(5) = 2*<em>φ</em>.</li>
  </ul>

  <p>Also, on average, half of these flips (<em>φ</em>) show 1 and half show 0, since the algorithm’s only randomness comes from “fair coin flips”.</p>
</blockquote>

<p><a id="sqrt_2_minus_1"></a></p>

<h4 id="sqrt2-minus-1">sqrt(2) − 1</h4>

<p>Another example of a continued fraction is that of the fractional part of the square root of 2, where the partial denominators are 2, 2, 2, 2, …. The algorithm to simulate this number is as follows:</p>

<ol>
  <li>With probability 2/3, return either 1 or 0 with equal probability.</li>
  <li>Do a separate run of the currently running algorithm.  If the separate run returns 1, return 0.  Otherwise, go to step 1.</li>
</ol>

<p><a id="1_sqrt_2"></a></p>

<h4 id="sqrt2">1/sqrt(2)</h4>

<p>This third example of a continued fraction shows how to simulate a probability 1/<em>z</em>, where <em>z</em> &gt; 1 has a known simple continued fraction expansion.  In this case, the partial denominators are as follows: floor(<em>z</em>), <em>a</em>[1], <em>a</em>[2], …, where the <em>a</em>[<em>i</em>] are <em>z</em>’s partial denominators (not including <em>z</em>’s integer part).  In the example of 1/sqrt(2), the partial denominators are 1, 2, 2, 2, …, where 1 comes first since floor(sqrt(2)) = 1.  The algorithm to simulate 1/sqrt(2) is as follows:</p>

<p>The algorithm begins with <em>pos</em> equal to 1.  Then the following steps are taken.</p>

<ol>
  <li>If <em>pos</em> is 1, return 1 with probability 1/2.  If <em>pos</em> is greater than 1, then with probability 2/3, return either 1 or 0 with equal probability.</li>
  <li>Do a separate run of the currently running algorithm, but with <em>pos</em> = <em>pos</em> + 1.  If the separate run returns 1, return 0.  Otherwise, go to step 1.</li>
</ol>

<p><a id="tanh_1_2_or_exp_1_minus_1_exp_1_1"></a></p>

<h4 id="tanh12-or-exp1-minus-1--exp1--1">tanh(1/2) or (exp(1) − 1) / (exp(1) + 1)</h4>

<p>The algorithm begins with <em>k</em> equal to 2.  Then the following steps are taken.</p>

<ol>
  <li>With probability <em>k</em>/(1+<em>k</em>), return a number that is 1 with probability 1/<em>k</em> and 0 otherwise.</li>
  <li>Do a separate run of the currently running algorithm, but with <em>k</em> = <em>k</em> + 4.  If the separate run returns 1, return 0.  Otherwise, go to step 1.</li>
</ol>

<p><a id="arctan__x___y___y___x"></a></p>

<h4 id="arctanxy--yx">arctan(<em>x</em>/<em>y</em>) * <em>y</em>/<em>x</em></h4>

<p>(Flajolet et al., 2010)<sup id="fnref:1:25" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>:</p>

<ol>
  <li>Generate <em>u</em>, a uniform random variate between 0 and 1.</li>
  <li>Generate a number that is 1 with probability <em>x</em> * <em>x</em>/(<em>y</em> * <em>y</em>), or 0 otherwise.  If the number is 0, return 1.</li>
  <li><a href="#Implementation_Notes"><strong>Sample from the number <em>u</em></strong></a> twice.  If either of these calls returns 0, return 1.</li>
  <li>Generate a number that is 1 with probability <em>x</em> * <em>x</em>/(<em>y</em> * <em>y</em>), or 0 otherwise.  If the number is 0, return 0.</li>
  <li><a href="#Implementation_Notes"><strong>Sample from the number <em>u</em></strong></a> twice.  If either of these calls returns 0, return 0.  Otherwise, go to step 2.</li>
</ol>

<p>Observing that the even-parity construction used in the Flajolet paper<sup id="fnref:32:5" role="doc-noteref"><a href="#fn:32" class="footnote" rel="footnote">32</a></sup> is equivalent to the two-coin algorithm, which has bounded expected running time for all <em>λ</em> parameters, the algorithm above can be modified as follows:</p>

<ol>
  <li>Generate 1 or 0 with equal probability.  If 1 was generated this way, return 1.</li>
  <li>Generate <em>u</em>, a uniform random variate between 0 and 1, if it wasn’t generated yet.</li>
  <li>With probability <em>x</em> * <em>x</em>/(<em>y</em> * <em>y</em>), <a href="#Implementation_Notes"><strong>sample from the number <em>u</em></strong></a> twice.  If both of these calls return 1, return 0.</li>
  <li>Go to step 1.</li>
</ol>

<p><a id="pi___12"></a></p>

<h4 id="pi--12"><em>π</em> / 12</h4>

<p>Two algorithms:</p>

<ul>
  <li>First algorithm: Use the algorithm for <strong>arcsin(<em>λ</em>) / 2</strong>, but where the algorithm says to “flip the input coin”, instead generate 1 or 0 with equal probability.</li>
  <li>Second algorithm: With probability 2/3, return 0.  Otherwise, run an algorithm for <strong>π / 4</strong> and return the result.</li>
</ul>

<p><a id="pi___4"></a></p>

<h4 id="pi--4"><em>π</em> / 4</h4>

<p>Three algorithms:</p>

<ul>
  <li>First algorithm (Flajolet et al., 2010)<sup id="fnref:1:26" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>: Generate a random integer <em>n</em> satisfying 0 ≤ <em>n</em> ≤ 5, call it <em>n</em>.  If <em>n</em> is less than 3, return the result of the <strong>algorithm for arctan(<em>x</em>/<em>y</em>) * <em>y</em>/<em>x</em></strong> with <em>x</em>=1 and <em>y</em>=2.  Otherwise, if <em>n</em> is 3, return 0.  Otherwise, return the result of the <strong>algorithm for arctan(<em>x</em>/<em>y</em>) * <em>y</em>/<em>x</em></strong> with <em>x</em>=1 and <em>y</em>=3.</li>
  <li>Second algorithm (since arctan(1) = <em>π</em> / 4): Run the second <strong>algorithm for arctan(<em>x</em>/<em>y</em>) * <em>y</em>/<em>x</em></strong> with <em>x</em>=1 and <em>y</em>=1.</li>
  <li>Third algorithm: See the appendix.</li>
</ul>

<p>A fourth algorithm to sample <em>π</em>/4 is based on the section “<a href="https://peteroupc.github.io/exporand.html#Uniform_Distribution_Inside_N_Dimensional_Shapes"><strong>Uniform Distribution Inside N-Dimensional Shapes</strong></a>”, especially its Note 5, in “More Algorithms for Arbitrary-Precision Sampling”.  In effect, it samples a 2-dimensional point with coordinates between 0 and 1 and determines if that point is within 1 unit of the origin (0, 0), which will happen with probability <em>π</em>/4.</p>

<ol>
  <li>Set <em>S</em> to 2.  Then set <em>c1</em> and <em>c2</em> to 0.</li>
  <li>Do the following process repeatedly, until the algorithm returns a value:
    <ol>
      <li>Set <em>c1</em> to 2*<em>c1</em> plus either 1 or 0 with equal probability.  Then, set <em>c2</em> to 2*<em>c2</em> plus either 1 or 0 with equal probability.</li>
      <li>If ((<em>c1</em>+1)<sup>2</sup> + (<em>c2</em>+1)<sup>2</sup>) &lt; <em>S</em><sup>2</sup>, return 1.  (Point is inside the quarter disk, whose area is <em>π</em>/4.)</li>
      <li>If ((<em>c1</em>)<sup>2</sup> + (<em>c2</em>)<sup>2</sup>) &gt; <em>S</em><sup>2</sup>, return 0.  (Point is outside the quarter disk.)</li>
      <li>Multiply <em>S</em> by 2.</li>
    </ol>
  </li>
</ol>

<p><a id="pi___4_minus_1_2_or___pi___minus_2_4"></a></p>

<h4 id="pi4-minus-12-or-pi-minus-24"><em>π</em>/4 − 1/2 or (<em>π</em> − 2)/4</h4>

<p>Follows the <em>π</em>/4 algorithm, except it samples from a quarter disk with an area equal to 1/2 removed.</p>

<ol>
  <li>Set <em>S</em> to 2.  Then set <em>c1</em> and <em>c2</em> to 0.</li>
  <li>Do the following process repeatedly, until the algorithm returns a value:
    <ol>
      <li>Set <em>c1</em> to 2*<em>c1</em> plus either 1 or 0 with equal probability.  Then, set <em>c2</em> to 2*<em>c2</em> plus either 1 or 0 with equal probability.</li>
      <li>Set <em>diamond</em> to <em>MAYBE</em> and <em>disk</em> to <em>MAYBE</em>.</li>
      <li>If ((<em>c1</em>+1) + (<em>c2</em>+1)) &lt; <em>S</em>, set <em>diamond</em> to <em>YES</em>.</li>
      <li>If ((<em>c1</em>) + (<em>c2</em>)) &gt; <em>S</em>, set <em>diamond</em> to <em>NO</em>.</li>
      <li>If ((<em>c1</em>+1)<sup>2</sup> + (<em>c2</em>+1)<sup>2</sup>) &lt; <em>S</em><sup>2</sup>, set <em>disk</em> to <em>YES</em>.</li>
      <li>If ((<em>c1</em>)<sup>2</sup> + (<em>c2</em>)<sup>2</sup>) &gt; <em>S</em><sup>2</sup>, set <em>disk</em> to <em>NO</em>.</li>
      <li>If <em>disk</em> is <em>YES</em> and <em>diamond</em> is <em>NO</em>, return 1.  Otherwise, if <em>diamond</em> is <em>YES</em> or <em>disk</em> is <em>NO</em>, return 0.</li>
      <li>Multiply <em>S</em> by 2.</li>
    </ol>
  </li>
</ol>

<p><a id="pi___minus_3_4"></a></p>

<h4 id="pi-minus-34">(<em>π</em> − 3)/4</h4>

<p>Follows the <em>π</em>/4 algorithm, except it samples from a quarter disk with enough boxes removed from it to total an area equal to 3/4.</p>

<ol>
  <li>Set <em>S</em> to 32.  Then set <em>c1</em> to a uniform random integer in the half-open interval [0, <em>S</em>) and <em>c2</em> to another uniform random integer in that interval.</li>
  <li>(Retained boxes.) If <em>c1</em> is 0 and <em>c2</em> is 0, or if <em>c1</em> is 0 and <em>c2</em> is 1, return 1.</li>
  <li>(Removed boxes.) If ((<em>c1</em>+1)<sup>2</sup> + (<em>c2</em>+1)<sup>2</sup>) &lt; 1024, return 0.</li>
  <li>Multiply <em>S</em> by 2.</li>
  <li>(Sample the modified quarter disk.) Do the following process repeatedly, until the algorithm returns a value:
    <ol>
      <li>Set <em>c1</em> to 2*<em>c1</em> plus either 1 or 0 with equal probability.  Then, set <em>c2</em> to 2*<em>c2</em> plus either 1 or 0 with equal probability.</li>
      <li>If ((<em>c1</em>+1)<sup>2</sup> + (<em>c2</em>+1)<sup>2</sup>) &lt; <em>S</em><sup>2</sup>, return 1.  (Point is inside the quarter disk, whose area is <em>π</em>/4.)</li>
      <li>If ((<em>c1</em>)<sup>2</sup> + (<em>c2</em>)<sup>2</sup>) &gt; <em>S</em><sup>2</sup>, return 0.  (Point is outside the quarter disk.)</li>
      <li>Multiply <em>S</em> by 2.</li>
    </ol>
  </li>
</ol>

<p><a id="pi___minus_3"></a></p>

<h4 id="pi-minus-3"><em>π</em> − 3</h4>

<p>Similar to the <em>π</em>/4 algorithm.  First it samples a point inside an area covering 1/4 of the unit square, then inside that area, it determines whether that point is inside another area covering (<em>π</em> − 3)/4 of the unit square.  Thus, the algorithm acts as though it samples ((<em>π</em> − 3)/4) / (1/4) = <em>π</em> − 3.</p>

<ol>
  <li>Set <em>S</em> to 2.  Then set <em>c1</em> and <em>c2</em> to 0.</li>
  <li>Do the following process repeatedly, until the algorithm aborts it or returns a value:
    <ol>
      <li>Set <em>S</em> to 32.  Then set <em>c1</em> to a uniform random integer in the half-open interval [0, <em>S</em>) and <em>c2</em> to another uniform random integer in [0, <em>S</em>).</li>
      <li>(Return 1 if in retained boxes.) If <em>c1</em> is 0 and <em>c2</em> is 0, or if <em>c1</em> is 0 and <em>c2</em> is 1, return 1.</li>
      <li>(Check if outside removed boxes.) If ((<em>c1</em>+1)<sup>2</sup> + (<em>c2</em>+1)<sup>2</sup>) &gt;= 1024, abort this process and go to step 3. (Otherwise, <em>c1</em> and <em>c2</em> are rejected and this process continues.)</li>
    </ol>
  </li>
  <li>Set <em>S</em> to 64.</li>
  <li>(Sample the modified quarter disk.) Do the following process repeatedly, until the algorithm returns a value:
    <ol>
      <li>Set <em>c1</em> to 2*<em>c1</em> plus either 1 or 0 with equal probability.  Then, set <em>c2</em> to 2*<em>c2</em> plus either 1 or 0 with equal probability.</li>
      <li>If ((<em>c1</em>+1)<sup>2</sup> + (<em>c2</em>+1)<sup>2</sup>) &lt; <em>S</em><sup>2</sup>, return 1.  (Point is inside the quarter disk, whose area is <em>π</em>/4.)</li>
      <li>If ((<em>c1</em>)<sup>2</sup> + (<em>c2</em>)<sup>2</sup>) &gt; <em>S</em><sup>2</sup>, return 0.  (Point is outside the quarter disk.)</li>
      <li>Multiply <em>S</em> by 2.</li>
    </ol>
  </li>
</ol>

<blockquote>
  <p><strong>Note:</strong> Only a limited set of (<em>c1</em>, <em>c2</em>) pairs, including (0, 0) and (0, 1), will pass step 2 of this algorithm.  Thus it may be more efficient to choose one of them uniformly at random, rather than do step 2 as shown.  If (0, 0) or (0, 1) is chosen this way, the algorithm returns 1.</p>
</blockquote>

<p><a id="4_3___pi"></a></p>

<h4 id="pi">4/(3*<em>π</em>)</h4>

<p>Given that the point (<em>x</em>, <em>y</em>) has positive coordinates and lies inside a disk of radius 1 centered at (0, 0), the mean value of <em>x</em> is 4/(3*<em>π</em>). This leads to the following algorithm to sample that probability:</p>

<ol>
  <li>Set <em>S</em> to 2.  Then set <em>c1</em> and <em>c2</em> to 0.</li>
  <li>Do the following process repeatedly, until the algorithm returns a value:
    <ol>
      <li>Set <em>c1</em> to 2*<em>c1</em> plus either 1 or 0 with equal probability.  Then, set <em>c2</em> to 2*<em>c2</em> plus either 1 or 0 with equal probability.</li>
      <li>If ((<em>c1</em>+1)<sup>2</sup> + (<em>c2</em>+1)<sup>2</sup>) &lt; <em>S</em><sup>2</sup>, do the following.  (Point is inside the quarter disk, whose area is <em>π</em>/4.  Now <em>c1</em>, the point’s <em>x</em> coordinate, is treated as a uniform random variate between <em>c1</em>/<em>S</em> and (<em>c1</em>+1)/<em>S</em>, and the following substeps return 1 with probability equal to that variate.)
        <ol>
          <li>Generate <em>z</em>, a uniform random integer in the interval [0, <em>S</em>).  If <em>z</em> is less than <em>c1</em>, return 1.  If <em>z</em> is greater than <em>c1</em>, return 0.</li>
          <li>Generate two numbers that are each 1 or 0 with equal probability.  If the two numbers are different, return the first number.  Otherwise, repeat this substep.</li>
        </ol>
      </li>
      <li>If ((<em>c1</em>)<sup>2</sup> + (<em>c2</em>)<sup>2</sup>) &gt; <em>S</em><sup>2</sup>, abort these substeps and go to step 1 (“Set <em>S</em>…”).  (Point is outside the quarter disk.)</li>
      <li>Multiply <em>S</em> by 2.</li>
    </ol>
  </li>
</ol>

<blockquote>
  <p><strong>Note:</strong> The mean value 4/(3*<em>π</em>) can be derived as follows.  The relative probability that <em>x</em> is “close” to <em>z</em>, where $0\le z \le 1$, is <em>p</em>(<em>z</em>) = sqrt(1 − <em>z</em>*<em>z</em>).  Now find the integral of <em>z</em>*<em>p</em>(<em>z</em>)/<em>c</em> (where <em>c</em>=<em>π</em>/4 is the integral of <em>p</em>(<em>z</em>) on the closed unit interval); see “<a href="#Integrals"><strong>Integrals</strong></a>”.  The result is the mean value 4/(3*<em>π</em>).  The following code in the Python programming language prints this mean value using the SymPy computer algebra library: <code>p=sqrt(1-z*z); c=integrate(p,(z,0,1)); print(integrate(z*p/c,(z,0,1)));</code>.</p>
</blockquote>

<p><a id="1___pi"></a></p>

<h4 id="pi-1">1 / <em>π</em></h4>

<p>(Flajolet et al., 2010)<sup id="fnref:1:27" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>:</p>

<ol>
  <li>Set <em>t</em> to 0.</li>
  <li>With probability 1/4, add 1 to <em>t</em> and repeat this step.  Otherwise, go to step 3.</li>
  <li>With probability 1/4, add 1 to <em>t</em> and repeat this step.  Otherwise, go to step 4.</li>
  <li>With probability 5/9, add 1 to <em>t</em>.</li>
  <li>Generate 2*<em>t</em> numbers that are each 1 or 0 with equal probability, and return 0 if there are more zeros than ones generated this way or more ones than zeros.  (In fact, this condition can be checked even before all the bits are generated this way.)  Do this step two more times.</li>
  <li>Return 1.</li>
</ol>

<p>For a sketch of how this algorithm is derived, see the appendix.</p>

<p><a id="a___b___z"></a></p>

<h4 id="absupzsup">(<em>a</em>/<em>b</em>)<sup><em>z</em></sup></h4>

<p>In the algorithm below:</p>

<ul>
  <li><em>a</em> ≥ 0 is an integer.</li>
  <li><em>b</em> &gt; 0 is an integer.</li>
  <li>z is a number (positive or not), and its absolute value (abs(<em>z</em>)) is written as a rational number (case 1), as an integer and fractional part (case 2), or as a sum of positive numbers (case 3), as described in the <a href="#ExpMinus_exp_minus__z"><strong>“ExpMinus” section</strong></a>.</li>
  <li>If <em>z</em> is known to be 0 or greater then it must be that 0 ≤ <em>a</em>/<em>b</em> ≤ 1, or</li>
  <li>If <em>z</em> is known to be less than 0, then it must be that <em>a</em>/<em>b</em> ≥ 1.</li>
</ul>

<p>The algorithm follows.</p>

<ul>
  <li>In case 1 (<em>z</em> = <em>x</em>/<em>y</em>):
    <ol>
      <li>If <em>z</em> is known to be less than 0, swap <em>a</em> and <em>b</em>, and remove the sign from <em>z</em>.  If <em>a</em>/<em>b</em> is now less than 0 or greater than 1, return an error.</li>
      <li>If <em>x</em> equals <em>y</em>, return 1 with probability <em>a</em>/<em>b</em> and 0 otherwise.</li>
      <li>If <em>x</em> is 0, return 1.  Otherwise, if <em>a</em> is 0, return 0.  Otherwise, if <em>a</em> equals <em>b</em>, return 1.</li>
      <li>If <em>x</em>/<em>y</em> is greater than 1:
        <ol>
          <li>Set <em>ipart</em> to floor(<em>x</em>/<em>y</em>) and <em>fpart</em> to rem(<em>x</em>, <em>y</em>) (equivalent to <em>x</em> - <em>y</em>*floor(<em>x</em>/<em>y</em>)).</li>
          <li>If <em>fpart</em> is greater than 0, subtract 1 from <em>ipart</em>, then call this algorithm recursively with <em>x</em> = floor(<em>fpart</em>/2) and <em>y</em> = <em>y</em>, then call this algorithm, again recursively, with <em>x</em> = <em>fpart</em> − floor(<em>fpart</em>/2) and <em>y</em> = <em>y</em>. Return 0 if either call returns 0.  (This is done rather than the more obvious approach in order to avoid calling this algorithm with fractional parts very close to 0, because the algorithm runs much more slowly than for fractional parts closer to 1.)</li>
          <li>If <em>ipart</em> is 1 or greater, generate at random a number that is 1 with probability <em>a</em><sup><em>ipart</em></sup>/<em>b</em><sup><em>ipart</em></sup> or 0 otherwise. (Or generate, at random, <em>ipart</em> many numbers that are each 1 with probability <em>a</em>/<em>b</em> or 0 otherwise, then multiply them all into one number.)  If that number is 0, return 0.</li>
          <li>Return 1.</li>
        </ol>
      </li>
      <li>(Note on steps 5 to 8: This case where 0 &lt; <em>x</em>/<em>y</em> &lt; 1 is due to recent work by Mendo (2019)<sup id="fnref:24:4" role="doc-noteref"><a href="#fn:24" class="footnote" rel="footnote">24</a></sup>.) Set <em>i</em> to 1.</li>
      <li>With probability <em>a</em>/<em>b</em>, return 1.</li>
      <li>Otherwise, with probability <em>x</em>/(<em>y</em>*<em>i</em>), return 0.</li>
      <li>Add 1 to <em>i</em> and go to step 6.</li>
    </ol>
  </li>
  <li>In case 2 (abs(<em>z</em>) = <em>m</em> + <em>ν</em>; here, 0 &lt; <em>ν</em> ≤ 1 unless <em>a</em>/<em>b</em> is not zero):
    <ol>
      <li>If <em>z</em> is known to be less than 0, swap <em>a</em> and <em>b</em>, and remove the sign from <em>z</em>.  If <em>a</em>/<em>b</em> is now less than 0 or greater than 1, return an error.</li>
      <li>If <em>a</em> is 0 and <em>m</em> is not 0, return 0.  If <em>a</em> equals <em>b</em>, return 1.</li>
      <li>If <em>m</em> is 1 or greater, generate at random a number that is 1 with probability <em>a</em><sup><em>m</em></sup>/<em>b</em><sup><em>m</em></sup> or 0 otherwise. (Or generate, at random, <em>m</em> many numbers that are each 1 with probability <em>a</em>/<em>b</em> or 0 otherwise, then multiply them all into one number.)  If that number is 0, return 0.</li>
      <li>(Note on steps 4 to 7: This case where 0 &lt; <em>z</em> &lt; 1 is due to recent work by Mendo (2019)<sup id="fnref:24:5" role="doc-noteref"><a href="#fn:24" class="footnote" rel="footnote">24</a></sup>.) Set <em>i</em> to 1.</li>
      <li>With probability <em>a</em>/<em>b</em>, return 1.</li>
      <li>Flip the <em>ν</em> input coin.  If it returns 0, return 0 with probability 1/<em>i</em>.</li>
      <li>Add 1 to <em>i</em> and go to step 6.</li>
    </ol>
  </li>
  <li>In case 3:
    <ol>
      <li>If <em>z</em> is known to be less than 0, swap <em>a</em> and <em>b</em>, and remove the sign from <em>z</em>.  If <em>a</em>/<em>b</em> is now less than 0 or greater than 1, return an error.</li>
      <li>If <em>a</em> is 0, return 0 (<em>z</em> will be positive here).  If <em>a</em> equals <em>b</em>, return 1.</li>
      <li>Rewrite the <em>z</em> parameter’s absolute value as a sum of positive numbers.  For each number, run either case 1 or case 2 (depending on how the number is written) of this algorithm with that number as the parameter.  If any of these runs returns 0, return 0; otherwise, return 1.</li>
    </ol>
  </li>
</ul>

<p><a id="1_exp_1__c__minus_2"></a></p>

<h4 id="exp1--c-minus-2">1/(exp(1) + <em>c</em> − 2)</h4>

<p>Involves the continued fraction expansion and Bernoulli Factory algorithm 3 for continued fractions.  In this algorithm, <em>c</em>≥1 is a rational number.</p>

<p>The algorithm begins with <em>pos</em> equal to 1.  Then the following steps are taken.</p>

<ul>
  <li>Do the following process repeatedly until this run of the algorithm returns a value:
    <ol>
      <li>If <em>pos</em> is divisible by 3 (that is, if rem(<em>pos</em>, 3) equals 0): Let <em>k</em> be (<em>pos</em>/3)*2.  With probability <em>k</em>/(1+<em>k</em>), return a number that is 1 with probability 1/<em>k</em> and 0 otherwise.</li>
      <li>If <em>pos</em> is 1: With probability <em>c</em>/(1+<em>c</em>), return a number that is 1 with probability 1/<em>c</em> and 0 otherwise.</li>
      <li>If <em>pos</em> is greater than 1 and not divisible by 3: Generate 1 or 0 with equal probability.  If 1 was generated this way, return 1.</li>
      <li>Do a separate run of the currently running algorithm, but with <em>pos</em> = <em>pos</em> + 1.  If the separate run returns 1, return 0.</li>
    </ol>
  </li>
</ul>

<p><a id="exp_1_minus_2"></a></p>

<h4 id="exp1-minus-2">exp(1) − 2</h4>

<p>Involves the continued fraction expansion and Bernoulli Factory algorithm 3 for continued fractions.  Run the algorithm for <strong>1/(exp(1)+<em>c</em>−2)</strong> above with <em>c</em> = 1, except the algorithm begins with <em>pos</em> equal to 2 rather than 1 (because the continued fractions are almost the same).</p>

<p><a id="zeta___3_3_4_and_Other_Zeta_Related_Constants"></a></p>

<h4 id="zeta3--3--4-and-other-zeta-related-constants"><em>ζ</em>(3) * 3 / 4 and Other Zeta-Related Constants</h4>

<p>(Flajolet et al., 2010)<sup id="fnref:1:28" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>.  It can be seen as a triple integral of the function 1/(1 + <em>a</em> * <em>b</em> * <em>c</em>), where <em>a</em>, <em>b</em>, and <em>c</em> are uniform random variates between 0 and 1.  This algorithm is given below, but using the two-coin algorithm instead of the even-parity construction<sup id="fnref:32:6" role="doc-noteref"><a href="#fn:32" class="footnote" rel="footnote">32</a></sup>.  Here, <em>ζ</em>(<em>x</em>) is the Riemann zeta function.</p>

<ol>
  <li>Generate three uniform random variates between 0 and 1.</li>
  <li>Generate 1 or 0 with equal probability.  If 1 was generated this way, return 1.</li>
  <li><a href="#Implementation_Notes"><strong>Sample from each of the three numbers</strong></a> generated in step 1.  If all three calls return 1, return 0.  Otherwise, go to step 2. (This implements a triple integral involving the uniform random variates.)</li>
</ol>

<blockquote>
  <p><strong>Note:</strong> The triple integral in section 5 of the paper is <em>ζ</em>(3) * 3 / 4, not <em>ζ</em>(3) * 7 / 8.</p>
</blockquote>

<p>This can be extended to cover any constant of the form <em>ζ</em>(<em>k</em>) * (1 − 2<sup>−(<em>k</em> − 1)</sup>) where <em>k</em> ≥ 2 is an integer, as suggested slightly by the Flajolet paper when it mentions <em>ζ</em>(5) * 31 / 32 (which should probably read <em>ζ</em>(5) * 15 / 16 instead), using the following algorithm.</p>

<ol>
  <li>Generate <em>k</em> uniform random variates between 0 and 1.</li>
  <li>Generate 1 or 0 with equal probability.  If 1 was generated this way, return 1.</li>
  <li><a href="#Implementation_Notes"><strong>Sample from each of the <em>k</em> numbers</strong></a> generated in step 1.  If all <em>k</em> calls return 1, return 0.  Otherwise, go to step 2.</li>
</ol>

<p><a id="erf__x__erf_1"></a></p>

<h4 id="erfxerf1">erf(<em>x</em>)/erf(1)</h4>

<p>In the following algorithm, <em>x</em> is a real number that is 0 or greater and 1 or less.</p>

<ol>
  <li>Generate a uniform random variate between 0 and 1, call it <em>ret</em>.</li>
  <li>Set <em>u</em> to point to the same value as <em>ret</em>, and set <em>k</em> to 1.</li>
  <li>(In this and the next step, <em>v</em> is created, which is the maximum of two uniform random variates between 0 and 1.) Generate two uniform random variates between 0 and 1, call them <em>a</em> and <em>b</em>.</li>
  <li>If <em>a</em> is less than <em>b</em>, set <em>v</em> to <em>b</em>. Otherwise, set <em>v</em> to <em>a</em>.</li>
  <li>If <em>v</em> is less than <em>u</em>, set <em>u</em> to <em>v</em>, then add 1 to <em>k</em>, then go to step 3.</li>
  <li>If <em>k</em> is odd<sup id="fnref:25:8" role="doc-noteref"><a href="#fn:25" class="footnote" rel="footnote">25</a></sup>, return 1 if <em>ret</em> is less than <em>x</em>, or 0 otherwise. (If <em>ret</em> is implemented as a uniform PSRN, this comparison should be done via the <strong>URandLessThanReal algorithm</strong>, which is described in my <a href="https://peteroupc.github.io/exporand.html"><strong>article on PSRNs</strong></a>.)</li>
  <li>Go to step 1.</li>
</ol>

<p>In fact, this algorithm takes advantage of a theorem related to the Forsythe method of random sampling (Forsythe 1972)<sup id="fnref:68" role="doc-noteref"><a href="#fn:68" class="footnote" rel="footnote">68</a></sup>.  See the section “<a href="#Probabilities_Arising_from_Certain_Permutations"><strong>Probabilities Arising from Certain Permutations</strong></a>” in the appendix for more information.</p>

<blockquote>
  <p><strong>Note:</strong> If the last step in the algorithm reads “Return 0” rather than “Go to step 1”, then the algorithm simulates the probability erf(<em>x</em>)*sqrt(π)/2 instead.</p>
</blockquote>

<p><a id="Ratio_of_Lower_Gamma_Functions_gamma__m___x__gamma__m__1"></a></p>

<h4 id="ratio-of-lower-gamma-functions-gammam-xgammam-1">Ratio of Lower Gamma Functions (γ(<em>m</em>, <em>x</em>)/γ(<em>m</em>, 1)).</h4>

<p>In this algorithm, <em>m</em> must be greater than 0, and <em>x</em> is a real number that is 0 or greater and 1 or less.</p>

<ol>
  <li>Set <em>ret</em> to a number distributed as the maximum of <em>m</em> uniform random variates between 0 and 1.  (See note 1 below.)</li>
  <li>Set <em>k</em> to 1, then set <em>u</em> to point to the same value as <em>ret</em>.</li>
  <li>Generate a uniform random variate between 0 and 1, call it <em>v</em>.</li>
  <li>If <em>v</em> is less than <em>u</em>: Set <em>u</em> to <em>v</em>, then add 1 to <em>k</em>, then go to step 3.</li>
  <li>If <em>k</em> is odd<sup id="fnref:25:9" role="doc-noteref"><a href="#fn:25" class="footnote" rel="footnote">25</a></sup>, return a number that is 1 if <em>ret</em> is less than <em>x</em> and 0 otherwise. If <em>k</em> is even<sup id="fnref:27:8" role="doc-noteref"><a href="#fn:27" class="footnote" rel="footnote">27</a></sup>, go to step 1.  (If <em>ret</em> is implemented as a uniform partially-sampled random number, this comparison should be done via the <strong>URandLessThanReal algorithm</strong>, which is described in my <a href="https://peteroupc.github.io/exporand.html"><strong>article on PSRNs</strong></a>.)</li>
</ol>

<blockquote>
  <p><strong>Notes:</strong></p>

  <ol>
    <li>In step 1 of the algorithm above, <em>ret</em> is distributed as <em>u</em>, where <em>u</em><sup>1/<em>m</em></sup> where <em>u</em> is a uniform random variate between 0 and 1.(Devroye 1986, p. 431)<sup id="fnref:30:3" role="doc-noteref"><a href="#fn:30" class="footnote" rel="footnote">30</a></sup> (This formula works for every <em>m</em> greater than 0, not just integers.)  Alternatively, <em>ret</em> can be generated using the <strong>kthsmallest</strong> algorithm with the two parameters <em>m</em> and <em>m</em> (see “<a href="https://peteroupc.github.io/exporand.html"><strong>Partially-Sampled Random Numbers”</strong></a>), but then <em>m</em> must be an integer.  Alternatively, <em>ret</em> can be generated as follows, but then <em>m</em> must be an integer:
      <ol>
        <li>Generate <em>x</em> and <em>y</em>, two uniform random variates between 0 and 1.</li>
        <li>Do the following <em>m</em> times.  If <em>x</em> is less than <em>y</em>, set <em>x</em> to point to <em>y</em>; either way, set <em>y</em> to a new uniform random variate between 0 and 1.</li>
        <li>Set <em>ret</em> to point to <em>x</em>.</li>
      </ol>
    </li>
    <li>
      <p>Derivation:  See Formula 1 in the section “<a href="https://peteroupc.github.io/bernoulli.html#Probabilities_Arising_from_Certain_Permutations"><strong>Probabilities Arising from Certain Permutations</strong></a>”, where:</p>

      <ul>
        <li><code>ECDF(x)</code>  is the probability that a uniform random variate between 0 and 1 is <em>x</em> or less, namely <em>x</em> if <em>x</em> is greater than 0 and less than 1; 0 if <em>x</em> is 0 or less; and 1 otherwise.</li>
        <li><code>DPDF(x)</code> is the probability density function for the maximum of <em>m</em> uniform random variates between 0 and 1, namely <em>m</em>*<em>x</em><sup><em>m</em>−1</sup> if <em>x</em> is greater than 0 and less than 1, and 0 otherwise.</li>
      </ul>
    </li>
  </ol>
</blockquote>

<p><a id="Euler_ndash_Mascheroni_constant___gamma"></a></p>

<h4 id="eulerndashmascheroni-constant-gamma">Euler–Mascheroni constant <em>γ</em></h4>

<p>The following algorithm to simulate the Euler–Mascheroni constant <em>γ</em> (about 0.5772) is due to Mendo (2020/2021)<sup id="fnref:36:2" role="doc-noteref"><a href="#fn:36" class="footnote" rel="footnote">36</a></sup>.  This solves an open question given in (Flajolet et al., 2010)<sup id="fnref:1:29" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>.  An algorithm for the Euler–Mascheroni constant appears here even though it is not yet known whether this constant is irrational.  Sondow (2005)<sup id="fnref:69" role="doc-noteref"><a href="#fn:69" class="footnote" rel="footnote">69</a></sup> described how the Euler–Mascheroni constant can be rewritten as an infinite sum, which is the form used in this algorithm.</p>

<ol>
  <li>Set <em>ϵ</em> to 1, then set <em>n</em>, <em>lamunq</em>, <em>lam</em>, <em>s</em>, <em>k</em>, and <em>prev</em> to 0 each.</li>
  <li>Add 1 to <em>k</em>, then add <em>s</em>/(2<sup><em>k</em></sup>) to <em>lam</em>.</li>
  <li>If <em>lamunq</em>+<em>ϵ</em> ≤ <em>lam</em> + 1/(2<sup><em>k</em></sup>), go to step 8.</li>
  <li>If <em>lamunq</em> &gt; <em>lam</em> + 1/(2<sup><em>k</em></sup>), go to step 8.</li>
  <li>If <em>lamunq</em> &gt; <em>lam</em> + 1/(2<sup><em>k</em>+1</sup>) and <em>lamunq</em>+<em>ϵ</em> &lt; 3/(2<sup><em>k</em>+1</sup>), go to step 8.</li>
  <li>(This step adds a term of the infinite sum for <em>γ</em> to <em>lamunq</em>, and sets <em>ϵ</em> to an upper bound on the error that results if the infinite sum is “cut off” after summing this and the previous terms.) If <em>n</em> is 0, add 1/2 to <em>lamunq</em> and set <em>ϵ</em> to 1/2.  Otherwise, add <em>B</em>(<em>n</em>)/(2*<em>n</em>*(2*<em>n</em>+1)*(2*<em>n</em>+2)) to <em>lamunq</em> and set <em>ϵ</em> to min(<em>prev</em>, (2+<em>B</em>(<em>n</em>)+(1/<em>n</em>))/(16*<em>n</em>*<em>n</em>)), where <em>B</em>(<em>n</em>) is the minimum number of bits needed to store <em>n</em> (or the smallest integer <em>b</em>≥1 such that <em>n</em> &lt; 2<sup><em>b</em></sup>).</li>
  <li>Add 1 to <em>n</em>, then set <em>prev</em> to <em>ϵ</em>, then go to step 3.</li>
  <li>Let <em>bound</em> be <em>lam</em>+1/(2<sup><em>k</em></sup>).  If <em>lamunq</em>+<em>ϵ</em> ≤ <em>bound</em>, set <em>s</em> to 0.  Otherwise, if <em>lamunq</em> &gt; <em>bound</em>, set <em>s</em> to 2.  Otherwise, set <em>s</em> to 1.</li>
  <li>Generate 1 or 0 with equal probability.  If 1 was generated this way, go to step 2.  Otherwise, return a number that is 0 if <em>s</em> is 0; otherwise, 1 if <em>s</em> is 2; otherwise, either 1 or 0 with equal probability.</li>
</ol>

<blockquote>
  <p><strong>Note:</strong> The following is another algorithm for this constant.  As <a href="https://stats.stackexchange.com/a/539564"><strong>I learned</strong></a>, the fractional part of 1/<em>U</em>, where <em>U</em> is a uniform random variate between 0 and 1, has a mean equal to 1 minus the Euler–Mascheroni constant <em>γ</em>, about 0.5772.<sup id="fnref:70" role="doc-noteref"><a href="#fn:70" class="footnote" rel="footnote">70</a></sup>  This leads to the following algorithm to sample a probability equal to <em>γ</em>:</p>

  <ol>
    <li>Generate a random variate of the form 1/<em>U</em> − floor(1/<em>U</em>), where <em>U</em> is a uniform random variate between 0 and 1.  This can be done by generating a uniform PSRN for <a href="https://peteroupc.github.io/exporand.html#Reciprocal_of_Uniform_Random_Variate"><strong>the reciprocal of a uniform random variate</strong></a>, then setting that PSRN’s integer part to 0.  Call the variate (or PSRN) <em>f</em>.</li>
    <li><strong>Sample from the number <em>f</em></strong> (for example, call <strong>SampleGeometricBag</strong> on <em>f</em> if <em>f</em> is implemented as a uniform PSRN).  Return 0 if the run returns 1, or 1 otherwise.</li>
  </ol>
</blockquote>

<p><a id="exp_minus__x___y___z___t"></a></p>

<h4 id="expminusxy--zt">exp(−<em>x</em>/<em>y</em>) * <em>z</em>/<em>t</em></h4>

<p>This algorithm is again based on an algorithm due to Mendo (2020/2021)<sup id="fnref:36:3" role="doc-noteref"><a href="#fn:36" class="footnote" rel="footnote">36</a></sup>.  The algorithm takes integers <em>x</em> ≥ 0, <em>y</em> &gt; 0, <em>z</em> ≥ 0, and <em>t</em> &gt; 0, such that 0 ≤ exp(−<em>x</em>/<em>y</em>) * <em>z</em>/<em>t</em> ≤ 1.</p>

<ol>
  <li>If <em>z</em> is 0, return 0.  If <em>x</em> is 0, return a number that is 1 with probability <em>z</em>/<em>t</em> and 0 otherwise.</li>
  <li>Set <em>ϵ</em> to 1, then set <em>n</em>, <em>lamunq</em>, <em>lam</em>, <em>s</em>, and <em>k</em> to 0 each.</li>
  <li>Add 1 to <em>k</em>, then add <em>s</em>/(2<sup><em>k</em></sup>) to <em>lam</em>.</li>
  <li>If <em>lamunq</em>+<em>ϵ</em> ≤ <em>lam</em> + 1/(2<sup><em>k</em></sup>), go to step 9.</li>
  <li>If <em>lamunq</em> &gt; <em>lam</em> + 1/(2<sup><em>k</em></sup>), go to step 9.</li>
  <li>If <em>lamunq</em> &gt; <em>lam</em> + 1/(2<sup><em>k</em>+1</sup>) and <em>lamunq</em>+<em>ϵ</em> &lt; 3/(2<sup><em>k</em>+1</sup>), go to step 8.</li>
  <li>(This step adds two terms of exp(−<em>x</em>/<em>y</em>)’s well-known infinite sum, multiplied by <em>z</em>/<em>t</em>, to <em>lamunq</em>, and sets <em>ϵ</em> to an upper bound on how close the current sum is to the desired probability.)  Let <em>m</em> be <em>n</em>*2.  Set <em>ϵ</em> to <em>z</em>*<em>x</em><sup><em>m</em></sup>/(<em>t</em>*(<em>m</em>!)*<em>y</em><sup><em>m</em></sup>).  If <em>m</em> is 0, add <em>z</em>*(<em>y</em>−<em>x</em>)/(<em>t</em>*<em>y</em>) to <em>lamunq</em>. Otherwise, add <em>z</em>*<em>x</em><sup><em>m</em></sup>*(<em>m</em>*<em>y</em>−<em>x</em>+<em>y</em>) / (<em>t</em>*<em>y</em><sup><em>m</em>+1</sup>*((<em>m</em>+1)!)) to <em>lamunq</em>.</li>
  <li>Add 1 to <em>n</em> and go to step 4.</li>
  <li>Let <em>bound</em> be <em>lam</em>+1/(2<sup><em>k</em></sup>).  If <em>lamunq</em>+<em>ϵ</em> ≤ <em>bound</em>, set <em>s</em> to 0.  Otherwise, if <em>lamunq</em> &gt; <em>bound</em>, set <em>s</em> to 2.  Otherwise, set <em>s</em> to 1.</li>
  <li>Generate 1 or 0 with equal probability.  If 1 was generated this way, go to step 3.  Otherwise, return a number that is 0 if <em>s</em> is 0; otherwise, 1 if <em>s</em> is 2; otherwise, either 1 or 0 with equal probability.</li>
</ol>

<p><a id="Certain_Numbers_Based_on_the_Golden_Ratio"></a></p>

<h4 id="certain-numbers-based-on-the-golden-ratio">Certain Numbers Based on the Golden Ratio</h4>

<p>The following algorithm given by Fishman and Miller (2013)<sup id="fnref:71" role="doc-noteref"><a href="#fn:71" class="footnote" rel="footnote">71</a></sup> finds the continued fraction expansion of certain numbers described as—</p>

<ul>
  <li><em>G</em>(<em>m</em>, <em>ℓ</em>) = (<em>m</em> + sqrt(<em>m</em><sup>2</sup> + 4 * <em>ℓ</em>))/2<br />    or (<em>m</em> − sqrt(<em>m</em><sup>2</sup> + 4 * <em>ℓ</em>))/2,</li>
</ul>

<p>whichever results in a real number greater than 1, where <em>m</em> is a positive integer and <em>ℓ</em> is either 1 or −1.  In this case, <em>G</em>(1, 1) is the golden ratio.</p>

<p>First, define the following operations:</p>

<ul>
  <li><strong>Get the previous and next Fibonacci-based number given <em>k</em>, <em>m</em>, and <em>ℓ</em></strong>:
    <ol>
      <li>If <em>k</em> is 0 or less, return an error.</li>
      <li>Set <em>g0</em> to 0, <em>g1</em> to 1, <em>x</em> to 0, and <em>y</em> to 0.</li>
      <li>Do the following <em>k</em> times: Set <em>y</em> to <em>m</em> * <em>g1</em> + <em>ℓ</em> * <em>g0</em>, then set <em>x</em> to <em>g0</em>, then set <em>g0</em> to <em>g1</em>, then set <em>g1</em> to <em>y</em>.</li>
      <li>Return <em>x</em> and <em>y</em>, in that order.</li>
    </ol>
  </li>
  <li><strong>Get the partial denominator given <em>pos</em>, <em>k</em>, <em>m</em>, and <em>ℓ</em></strong> (this partial denominator is part of the continued fraction expansion found by Fishman and Miller):
    <ol>
      <li><strong>Get the previous and next Fibonacci-based number given <em>k</em>, <em>m</em>, and <em>ℓ</em></strong>, call them <em>p</em> and <em>n</em>, respectively.</li>
      <li>If <em>ℓ</em> is 1 and <em>k</em> is odd<sup id="fnref:25:10" role="doc-noteref"><a href="#fn:25" class="footnote" rel="footnote">25</a></sup>, return <em>p</em> + <em>n</em>.</li>
      <li>If <em>ℓ</em> is −1 and <em>pos</em> is 0, return <em>n</em> − <em>p</em> − 1.</li>
      <li>If <em>ℓ</em> is 1 and <em>pos</em> is 0, return (<em>n</em> + <em>p</em>) − 1.</li>
      <li>If <em>ℓ</em> is −1 and <em>pos</em> is even<sup id="fnref:27:9" role="doc-noteref"><a href="#fn:27" class="footnote" rel="footnote">27</a></sup>, return <em>n</em> − <em>p</em> − 2. (The paper had an error here; the correction given here was verified by Miller via personal communication.)</li>
      <li>If <em>ℓ</em> is 1 and <em>pos</em> is even<sup id="fnref:27:10" role="doc-noteref"><a href="#fn:27" class="footnote" rel="footnote">27</a></sup>, return (<em>n</em> + <em>p</em>) − 2.</li>
      <li>Return 1.</li>
    </ol>
  </li>
</ul>

<p>An application of the continued fraction algorithm is the following algorithm that generates 1 with probability <em>G</em>(<em>m</em>, <em>ℓ</em>)<sup>−<em>k</em></sup> and 0 otherwise, where <em>k</em> is an integer that is 1 or greater (see “Continued Fractions” in my page on Bernoulli factory algorithms). The algorithm starts with <em>pos</em> = 0, then the following steps are taken:</p>

<ol>
  <li><strong>Get the partial denominator given <em>pos</em>, <em>k</em>, <em>m</em>, and <em>ℓ</em></strong>, call it <em>kp</em>.</li>
  <li>Do the following process repeatedly, until this run of the algorithm returns a value:
    <ol>
      <li>With probability <em>kp</em>/(1 + <em>kp</em>), return a number that is 1 with probability 1/<em>kp</em> and 0 otherwise.</li>
      <li>Do a separate run of the currently running algorithm, but with <em>pos</em> = <em>pos</em> + 1.  If the separate run returns 1, return 0.</li>
    </ol>
  </li>
</ol>

<p><a id="ln_1__y___z"></a></p>

<h4 id="ln1yz">ln(1+<em>y</em>/<em>z</em>)</h4>

<p>See also the algorithm given earlier for ln(1+<em>λ</em>).  In this algorithm, <em>y</em>/<em>z</em> is a rational number that is 0 or greater and 1 or less.  (Thus, the special case ln(2) results when <em>y</em>/<em>z</em> = 1/1.)</p>

<ol>
  <li>If <em>y</em> is 0, return 0.</li>
  <li>Do the following process repeatedly, until this algorithm returns a value:
    <ol>
      <li>Generate 1 or 0 with equal probability.  If 1 was generated this way, return a number that is 1 with probability <em>y</em>/<em>z</em> and 0 otherwise.</li>
      <li>Generate <em>u</em>, a uniform random variate between 0 and 1, if <em>u</em> wasn’t generated yet.</li>
      <li><a href="#Implementation_Notes"><strong>Sample from the number <em>u</em></strong></a>, then generate a number that is 1 with probability <em>y</em>/<em>z</em> and 0 otherwise.  If the call returns 1 and the number generated is 1, return 0.</li>
    </ol>
  </li>
</ol>

<p><a id="ln___pi_____pi"></a></p>

<h4 id="lnpipi">ln(<em>π</em>)/<em>π</em></h4>

<p>Special case of the algorithm for <strong>ln(<em>c</em>+<em>λ</em>)/(<em>c</em>+<em>λ</em>)</strong>.</p>

<ol>
  <li>Run the algorithm for <strong>1/<em>π</em></strong> repeatedly, until the run returns 1, then set <em>g</em> to the number of runs that returned 0 this way.</li>
  <li>If <em>g</em> is 0, return 0.  Otherwise, return a number that is 1 with probability 1/<em>g</em> or 0 otherwise.</li>
</ol>

<p><a id="Requests_and_Open_Questions"></a></p>

<h2 id="requests-and-open-questions">Requests and Open Questions</h2>

<p>See my page “<a href="https://peteroupc.github.io/bernreq.html"><strong>Open Questions on the Bernoulli Factory Problem</strong></a>” for open questions, answers to which will greatly improve my articles on Bernoulli factories.
Other questions:</p>

<ul>
  <li><a href="https://peteroupc.github.io/requestsother.html#Probabilities_arising_from_permutations"><strong>Probabilities arising from permutations</strong></a>.</li>
  <li>Is there a simpler or faster way to implement the base-2 or natural logarithm of binomial coefficients?  See the example in the section “<a href="#Certain_Converging_Series"><strong>Certain Converging Series</strong></a>”.</li>
</ul>

<p><a id="Correctness_and_Performance_Charts"></a></p>

<h2 id="correctness-and-performance-charts">Correctness and Performance Charts</h2>

<p>Charts showing the correctness and running time of some of these algorithms are found in a <a href="https://peteroupc.github.io/bernoullicorrect.html"><strong>separate page</strong></a>.</p>

<p><a id="Acknowledgments"></a></p>

<h2 id="acknowledgments">Acknowledgments</h2>

<p>I acknowledge Luis Mendo, who responded to one of my open questions, as well as C. Karney.
Due to a suggestion by Michael Shoemate who suggested it was “easy to get lost” in this and related articles, some sections that related to Bernoulli factories and were formerly in “More Algorithms for Arbitrary-Precision Sampling” were moved here.</p>

<p><a id="Notes"></a></p>

<h2 id="notes">Notes</h2>

<p><a href="https://doi.org/10.1016/j.ejc.2010.11.004"><strong>https://doi.org/10.1016/j.ejc.2010.11.004</strong></a> <a href="http://www.sciencedirect.com/science/article/pii/S0195669810001666"><strong>http://www.sciencedirect.com/science/article/pii/S0195669810001666</strong></a></p>

<p>estimation, IEEE Transactions on Information Theory 36 (1990)</p>

<p><a id="Appendix"></a></p>

<h2 id="appendix">Appendix</h2>

<p> </p>

<p><a id="Using_the_Input_Coin_Alone_for_Randomness"></a></p>

<h3 id="using-the-input-coin-alone-for-randomness">Using the Input Coin Alone for Randomness</h3>

<p>A function <em>f</em>(<em>λ</em>) is <em>strongly simulable</em> (Keane and O’Brien 1994)<sup id="fnref:24:6" role="doc-noteref"><a href="#fn:24" class="footnote" rel="footnote">24</a></sup> if there is a Bernoulli factory algorithm for that function that uses <em>only</em> the input coin as its source of randomness.</p>

<p>If a Bernoulli factory algorithm uses a fair coin, it can often generate flips of the fair coin using the input coin instead, with the help of <a href="https://peteroupc.github.io/randextract.html"><strong><em>randomness extraction</em></strong></a> techniques.</p>

<blockquote>
  <p><strong>Example:</strong> If a Bernoulli factory algorithm would generate 1 or 0 with equal probability (or flip a fair coin), instead it could flip the input coin twice until the flip returns 0 then 1 or 1 then 0 this way, then take the result as 0 or 1, respectively (von Neumann 1951)<sup id="fnref:72" role="doc-noteref"><a href="#fn:72" class="footnote" rel="footnote">72</a></sup>.  But this trick works only if the input coin’s probability of heads is neither 0 nor 1.</p>
</blockquote>

<p>When Keane and O’Brien (1994)<sup id="fnref:24:7" role="doc-noteref"><a href="#fn:24" class="footnote" rel="footnote">24</a></sup> introduced Bernoulli factories, they showed already that <em>f</em>(<em>λ</em>) is strongly simulable whenever it admits a Bernoulli factory and its domain includes neither 0 nor 1 (so the input coin doesn’t show heads every time or tails every time) — just use the von Neumann trick as in the example above.  But does <em>f</em> remain strongly simulable if its domain includes 0, 1, or both?  That’s a complexer question; see the <a href="https://peteroupc.github.io/bernsupp.html#Which_functions_don_t_require_outside_randomness_to_simulate"><strong>supplemental notes</strong></a>.</p>

<p><a id="The_Entropy_Bound"></a></p>

<h3 id="the-entropy-bound">The Entropy Bound</h3>

<p>There is a lower bound on the average number of coin flips needed to turn a coin with one probability of heads (<em>λ</em>) into a coin with another (<em>τ</em> = <em>f</em>(<em>λ</em>)).  It’s called the <em>entropy bound</em> (see, for example, (Pae 2005)<sup id="fnref:73" role="doc-noteref"><a href="#fn:73" class="footnote" rel="footnote">73</a></sup>, (Peres 1992)<sup id="fnref:74" role="doc-noteref"><a href="#fn:74" class="footnote" rel="footnote">74</a></sup>) and is calculated as—</p>

<ul>
  <li>((<em>τ</em> − 1) * ln(1 − <em>τ</em>) − <em>τ</em> * ln(<em>τ</em>)) / ((<em>λ</em> − 1) * ln(1 − <em>λ</em>) − <em>λ</em> * ln(<em>λ</em>)).</li>
</ul>

<p>For example, if <em>f</em>(<em>λ</em>) is a constant, an algorithm whose only randomness comes from the input coin will require more coin flips to simulate that constant, the more strongly that coin leans towards heads or tails.  But this formula works only for such algorithms, even if <em>f</em> isn’t a constant.</p>

<p>For certain values of <em>λ</em>, Kozen (2014)<sup id="fnref:40:1" role="doc-noteref"><a href="#fn:40" class="footnote" rel="footnote">40</a></sup> showed a tighter lower bound of this kind, but in general, this bound is not so easy to describe and assumes <em>λ</em> is known.  However, if <em>λ</em> is 1/2 (the input coin is actually a fair coin), this bound is simple: at least 2 flips of the input coin are needed on average to simulate a known constant <em>τ</em>, except when <em>τ</em> is a multiple of 1/(2<sup>n</sup>) for some integer <em>n</em>.</p>

<p><a id="Bernoulli_Factories_and_Unbiased_Estimation"></a></p>

<h3 id="bernoulli-factories-and-unbiased-estimation">Bernoulli Factories and Unbiased Estimation</h3>

<p>If an algorithm—</p>

<ul>
  <li>takes flips of a coin with an unknown probability of heads (<em>λ</em>), and</li>
  <li>produces heads with a probability that depends on <em>λ</em> (<em>f</em>(<em>λ</em>)) and tails otherwise,</li>
</ul>

<p>the algorithm acts as an <em>unbiased estimator</em> of <em>f</em>(<em>λ</em>) that produces estimates in [0, 1] with probability 1 (Łatuszyński et al. 2009/2011)<sup id="fnref:21:3" role="doc-noteref"><a href="#fn:21" class="footnote" rel="footnote">21</a></sup>. (And an estimator like this is possible only if <em>f</em> is a factory function; see Łatuszyński.) Because the algorithm is <em>unbiased</em>, its expected value (or mean or “long-run average”) is <em>f</em>(<em>λ</em>). Since the algorithm is unbiased and outputs only 0 or 1, this leads to the following: With probability 1, given an infinite sequence of independent outputs of the algorithm, the average of the first <em>n</em> outputs approaches <em>f</em>(<em>λ</em>) as <em>n</em> gets <em>large</em> (as a result of the <em>law of large numbers</em>).</p>

<p>On the other hand—</p>

<ul>
  <li>estimating <em>λ</em> as <em>λ′</em> (for example, by averaging multiple flips of a <em>λ</em>-coin), then</li>
  <li>calculating <em>f</em>(<em>λ′</em>),</li>
</ul>

<p>is not necessarily an unbiased estimator of <em>f</em>(<em>λ</em>), even if <em>λ′</em> is an unbiased estimator.</p>

<p>This page is devoted to <em>unbiased</em> estimators because “exact sampling” depends on an algorithm being an unbiased estimator. See also (Mossel and Peres 2005, section 4)<sup id="fnref:16:2" role="doc-noteref"><a href="#fn:16" class="footnote" rel="footnote">16</a></sup>.</p>

<blockquote>
  <p><strong>Note:</strong> Bias and variance are the two sources of error in a randomized estimation algorithm.  An unbiased estimator has no bias, but is not without error.  In the case at hand here, the variance of a Bernoulli factory for <em>f</em>(<em>λ</em>) equals <em>f</em>(<em>λ</em>) * (1−<em>f</em>(<em>λ</em>)) and can go as high as 1/4.  (“Variance reduction” methods are outside the scope of this document.)  An estimation algorithm’s <em>mean squared error</em> equals variance plus square of bias.</p>
</blockquote>

<p><a id="Correctness_Proof_for_the_Continued_Logarithm_Simulation_Algorithm"></a></p>

<h3 id="correctness-proof-for-the-continued-logarithm-simulation-algorithm">Correctness Proof for the Continued Logarithm Simulation Algorithm</h3>

<p><strong>Theorem.</strong> <em>If the algorithm given in “Continued Logarithms” terminates with probability 1, it returns 1 with probability exactly equal to the number represented by the continued logarithm c, and 0 otherwise.</em></p>

<p><em>Proof.</em> This proof of correctness takes advantage of Huber’s “fundamental theorem of perfect simulation” (Huber 2019)<sup id="fnref:65:1" role="doc-noteref"><a href="#fn:65" class="footnote" rel="footnote">65</a></sup>.  Using Huber’s theorem requires proving two things:</p>

<ul>
  <li>The algorithm finishes with probability 1 by assumption.</li>
  <li>Second, we show the algorithm is locally correct when the recursive call in the loop is replaced with a “black box” that simulates the correct “continued sub-logarithm”.  If step 1 reaches the last parameter, the algorithm obviously passes with the correct probability.  Otherwise, we will be simulating the probability (1 / 2<sup><em>c</em>[<em>i</em>]</sup>) / (1 + <em>x</em>), where <em>x</em> is the “continued sub-logarithm” and will be at most 1 by construction.  Step 2 defines a loop that divides the probability space into three pieces: the first piece takes up one half, the second piece (in the second substep) takes up a portion of the other half (which here is equal to <em>x</em>/2), and the last piece is the “rejection piece” that reruns the loop.  Since this loop changes no variables that affect later iterations, each iteration acts like an acceptance/rejection algorithm already proved to be a perfect simulator by Huber.  The algorithm will pass at the first substep with probability <em>p</em> = (1 / 2<sup><em>c</em>[<em>i</em>]</sup>) / 2 and fail either at the first substep of the loop with probability <em>f1</em> = (1 − 1 / 2<sup><em>c</em>[<em>i</em>]</sup>) / 2, or at the second substep with probability <em>f2</em> = <em>x</em>/2 (all these probabilities are relative to the whole iteration).  Finally, dividing the passes by the sum of passes and fails (<em>p</em> / (<em>p</em> + <em>f1</em> + <em>f2</em>)) leads to (1 / 2<sup><em>c</em>[<em>i</em>]</sup>) / (1 + <em>x</em>), which is the probability we wanted.</li>
</ul>

<p>Since both conditions of Huber’s theorem are satisfied, this completes the proof. □</p>

<p><a id="Correctness_Proof_for_Continued_Fraction_Simulation_Algorithm_3"></a></p>

<h3 id="correctness-proof-for-continued-fraction-simulation-algorithm-3">Correctness Proof for Continued Fraction Simulation Algorithm 3</h3>

<p><strong>Theorem.</strong> <em>Suppose a generalized continued fraction’s partial numerators are b[i] and all greater than 0, and its partial denominators are a[i] and all 1 or greater, and suppose further that each b[i]/a[i] is 1 or less. Then the algorithm given as Algorithm 3 in “Continued Fractions” returns 1 with probability exactly equal to the number represented by that continued fraction, and 0 otherwise.</em></p>

<p><em>Proof.</em> We use Huber’s “fundamental theorem of perfect simulation” again in the proof of correctness.</p>

<ul>
  <li>The algorithm finishes with probability 1 because with each recursion, the method does a recursive run with no greater probability than not; observe that <em>a</em>[<em>i</em>] can never be more than 1, so that <em>a</em>[<em>i</em>]/(1+<em>a</em>[<em>i</em>]), that is, the probability of finishing the run in each iteration, is always 1/2 or greater.</li>
  <li>If the recursive call in the loop is replaced with a “black box” that simulates the correct “sub-fraction”, the algorithm is locally correct.  If step 1 reaches the last element of the continued fraction, the algorithm obviously passes with the correct probability. Otherwise, we will be simulating the probability <em>b</em>[<em>i</em>] / (<em>a</em>[<em>i</em>] + <em>x</em>), where <em>x</em> is the “continued sub-fraction” and will be at most 1 by assumption.  Step 2 defines a loop that divides the probability space into three pieces: the first piece takes up a part equal to <em>h</em> = <em>a</em>[<em>i</em>]/(<em>a</em>[<em>i</em>] + 1), the second piece (in the second substep) takes up a portion of the remainder (which here is equal to <em>x</em> * (1 − <em>h</em>)), and the last piece is the “rejection piece”.  The algorithm will pass at the first substep with probability <em>p</em> = (<em>b</em>[<em>i</em>] / <em>a</em>[<em>pos</em>]) * <em>h</em> and fail either at the first substep of the loop with probability <em>f1</em> = (1 − <em>b</em>[<em>i</em>] / <em>a</em>[<em>pos</em>]) * <em>h</em>, or at the second substep with probability <em>f2</em> = <em>x</em> * (1 − <em>h</em>) (all these probabilities are relative to the whole iteration).  Finally, dividing the passes by the sum of passes and fails leads to <em>b</em>[<em>i</em>] / (<em>a</em>[<em>i</em>] + <em>x</em>), which is the desired probability wanted, so that both of Huber’s conditions are satisfied and the proof is complete.  □</li>
</ul>

<p><a id="Proof_of_the_General_Martingale_Algorithm"></a></p>

<h3 id="proof-of-the-general-martingale-algorithm">Proof of the General Martingale Algorithm</h3>

<p>This proof of the <strong>general martingale algorithm</strong> is similar to the proof for certain alternating series with only nonzero power coefficients, given in Łatuszyński et al. (2019/2011)<sup id="fnref:21:4" role="doc-noteref"><a href="#fn:21" class="footnote" rel="footnote">21</a></sup>, section 3.1.  Suppose a coin that shows heads with probability $g(\lambda)$ is flipped repeatedly and the following results are achieved: $X_1, X_2, …$, where each result is either 1 if the coin shows heads or 0 otherwise.  Then define two sequences <em>U</em> and <em>L</em> as follows:</p>

<ul>
  <li>$U_0=d_0$ and $L_0=0$.</li>
  <li>For each $n&gt;0$, $U_n$ is $L_{n-1} + \text{abs}(a_n)\times X_1\times…\times X_n$ if $a_n &gt; 0$, otherwise $U_{n-1} - \text{abs}(a_n)\times X_1\times…\times X_n$ if no nonzero power coefficients follow $a_n$ and $a_n &lt; 0$, otherwise $U_{n-1}$.</li>
  <li>For each $n&gt;0$, $L_n$ is $U_{n-1} - \text{abs}(a_n)\times X_1\times…\times X_n$ if $a_n &lt; 0$, otherwise $L_{n-1} + \text{abs}(a_n)\times X_1\times…\times X_n$ if no nonzero power coefficients follow $a_n$ and $a_n &gt; 0$, otherwise $L_{n-1}$.</li>
</ul>

<p>Then it’s clear that with probability 1, for every $n\ge 1$—</p>

<ul>
  <li>$L_n \le U_n$,</li>
  <li>$U_n$ is 0 or greater and $L_n$ is 1 or less, and</li>
  <li>$L_{n-1} \le L_n$ and $U_{n-1} \ge U_n$.</li>
</ul>

<p>Moreover, if there are infinitely many nonzero power coefficients, the <em>U</em> and <em>L</em> sequences have expected values (“long-run averages”) converging to $f(\lambda)$ with probability 1; otherwise $f(\lambda)$ is a polynomial in $g(\lambda)$, and $U_n$ and $L_n$ have expected values that approach $f(\lambda)$ as $n$ gets large.  These conditions are required for the paper’s Algorithm 3 (and thus the <strong>general martingale algorithm</strong>) to be valid.</p>

<p><a id="Algorithm_for_sin___lambda_____pi___2"></a></p>

<h3 id="algorithm-for-sinlambdapi2">Algorithm for sin(<em>λ</em>*<em>π</em>/2)</h3>

<p>The following algorithm returns 1 with probability sin(<em>λ</em>*<em>π</em>/2) and 0 otherwise, given a coin that shows heads with probability <em>λ</em>.  However, this algorithm appears in the appendix since it requires manipulating irrational numbers, particularly numbers involving <em>π</em>.</p>

<ol>
  <li>Choose at random an integer <em>n</em> (0 or greater) with probability (<em>π</em>/2)<sup>4*<em>n</em>+2</sup>/((4*<em>n</em>+2)!) − (<em>π</em>/2)<sup>4*<em>n</em>+4</sup>/((4*<em>n</em>+4)!).</li>
  <li>Let <em>v</em> = 16*(<em>n</em>+1)*(4*<em>n</em>+3).</li>
  <li>Flip the input coin 4*<em>n</em>+4 times.  Let <em>tails</em> be the number of flips that returned 0 this way. (This would be the number of heads if the probability <em>λ</em> were 1 − <em>λ</em>.)</li>
  <li>If <em>tails</em> = 4*<em>n</em>+4, return 0.</li>
  <li>If <em>tails</em> = 4*<em>n</em>+3, return a number that is 0 with probability 8*(4*<em>n</em>+3)/(<em>v</em>−<em>π</em><sup>2</sup>) and 1 otherwise.</li>
  <li>If <em>tails</em> = 4*<em>n</em>+2, return a number that is 0 with probability 8/(<em>v</em>−<em>π</em><sup>2</sup>) and 1 otherwise.</li>
  <li>Return 1.</li>
</ol>

<blockquote>
  <p><strong>Notes:</strong></p>

  <ol>
    <li>The following is a derivation of this algorithm.  Write—</li>
  </ol>
</blockquote>

<p>\(f(\lambda) = \sin(\lambda \pi/2) = 1-g(1-\lambda),\)
where—</p>

<p>\(g(\mu) = 1-\sin((1-\mu) \pi/2)\) \(= \sum_{n\ge 0} \frac{(\mu\pi/2)^{4n+2}}{(4n+2)!} - \frac{(\mu\pi/2)^{4n+4}}{(4n+4)!}\) \(= \sum_{n\ge 0} w_n(\mu) = \sum_{n\ge 0} w_n(1) \frac{w_n(\mu)}{w_n(1)}.\)  This is a <a href="#Convex_Combinations"><strong>convex combination</strong></a> of $w_n(1)$ and $\frac{w_n(\mu)}{w_n(1)}$ — to simulate $g(\mu)$, first an integer <em>n</em> is chosen with probability $w_n(1)$ and then a coin that shows heads with probability $\frac{w_n(\mu)}{w_n(1)}$ is flipped.  Finally, to simulate $f(\lambda)$, the input coin is “inverted” ($\mu = 1-\lambda$), $g(\mu)$ is simulated using the “inverted” coin, and 1 minus the simulation result is returned.<br /><br />As given above, each term $w_n(\mu)$ is a polynomial in $\mu$, and is strictly increasing and equals 1 or less everywhere on the closed unit interval, and $w_n(1)$ is a constant so that $\frac{w_n(\mu)}{w_n(1)}$ remains a polynomial.  Each polynomial $\frac{w_n(\mu)}{w_n(1)}$ can be transformed into a polynomial that has the following Bernstein coefficients: \((0, 0, ..., 0, 8/(v-\pi^2), 8(4n+3)/(v-\pi^2), 1),\)
where the polynomial is of degree $4n+4$ and so has $4n+5$ Bernstein coefficients, and $v = \frac{((4n+4)!)\times 2^{4n+4}}{((4n+2)!)\times 2^{4n+2}} = 16 (n+1) (4n+3)$.  These are the Bernstein coefficients used in steps 4 through 7 of the algorithm above.
&gt;
&gt; 2. sin(<em>λ</em>*<em>π</em>/2) = cos((1−<em>λ</em>)*<em>π</em>/2).
&gt;
&gt; 3. The problem of simulating sin(<em>λ</em>*<em>π</em>/2), it seems, was first raised by Basu (1975, p. 12)<sup id="fnref:3:1" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup>.</p>

<p><a id="Probabilities_Arising_from_Certain_Permutations"></a></p>

<h3 id="probabilities-arising-from-certain-permutations">Probabilities Arising from Certain Permutations</h3>

<p>Certain interesting probability functions can arise from permutations.</p>

<p>Inspired by the von Neumann schema, the following algorithm can be described:</p>

<p>Let a <em>permutation class</em> (defined in <a href="#Flajolet_s_Probability_Simulation_Schemes"><strong>“Flajolet’s Probability Simulation Schemes”</strong></a>) and two distributions <em>D</em> and <em>E</em>, which are both continuous with probability density functions, be given. Consider the following algorithm: Generate a sequence of independent random variates (where the first is distributed as <em>D</em> and the rest as <em>E</em>) until the sequence no longer follows the permutation class, then return <em>n</em>, which is how many numbers were generated this way minus 1.</p>

<p>Then the algorithm’s behavior is given in the tables below.</p>

<table>
  <thead>
    <tr>
      <th>Permutation Class</th>
      <th>Distributions <em>D</em> and <em>E</em></th>
      <th>The algorithm returns <em>n</em> with this probability:</th>
      <th>The probability that <em>n</em> is …</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Numbers sorted in high-to-low order</td>
      <td>Arbitrary; <em>D</em> = <em>E</em></td>
      <td><em>n</em> / ((<em>n</em> + 1)!).</td>
      <td>Odd is 1−exp(−1); even is exp(−1). See note 3.</td>
    </tr>
    <tr>
      <td>Numbers sorted in high-to-low order</td>
      <td>Each arbitrary</td>
      <td>(∫<sub>(−∞,∞)</sub> DPDF(<em>z</em>) * ((ECDF(<em>z</em>))<sup><em>n</em>−1</sup>/((<em>n</em>−1)!) − (ECDF(<em>z</em>))<sup><em>n</em></sup>/(<em>n</em>!)) <em>dz</em>), for every <em>n</em> &gt; 0 (see also proof of Theorem 2.1 of (Devroye 1986, Chapter IV)<sup id="fnref:30:4" role="doc-noteref"><a href="#fn:30" class="footnote" rel="footnote">30</a></sup>. DPDF and ECDF are defined later.</td>
      <td>Odd is denominator of formula 1 below.</td>
    </tr>
    <tr>
      <td>Alternating numbers</td>
      <td>Arbitrary; <em>D</em> = <em>E</em></td>
      <td>(<em>a</em><sub><em>n</em></sub> * (<em>n</em> + 1) − <em>a</em><sub><em>n</em> + 1</sub>) / (<em>n</em> + 1)!, where <em>a</em><sub><em>i</em></sub> is the integer at position <em>i</em> (starting at 0) of the sequence <a href="https://oeis.org/A000111"><strong>A000111</strong></a> in the <em>On-Line Encyclopedia of Integer Sequences</em>.</td>
      <td>Odd is 1−cos(1)/(sin(1)+1); even is cos(1)/(sin(1)+1).  See note 3.</td>
    </tr>
    <tr>
      <td>Any</td>
      <td>Arbitrary; <em>D</em> = <em>E</em></td>
      <td>(∫<sub>[0, 1]</sub> 1 * (<em>z</em><sup><em>n</em>−1</sup>*V(<em>n</em>)/((<em>n</em>−1)!) − <em>z</em><sup><em>n</em></sup>*V(<em>n</em>+1)/(<em>n</em>!)) <em>dz</em>), for every <em>n</em> &gt; 0.  <em>V</em>(<em>n</em>) is the number of permutations of size <em>n</em> that belong in the permutation class. For this algorithm, <em>V</em>(<em>n</em>) must be greater than 0 and less than or equal to <em>n</em> factorial; this algorithm won’t work, for example, if there are 0 permutations of odd size.</td>
      <td>Odd is 1 − 1 / EGF(1); even is 1/EGF(1).<br />Less than <em>k</em> is (<em>V</em>(0) − <em>V</em>(<em>k</em>)/(<em>k</em>!)) / <em>V</em>(0).  See note 3.</td>
    </tr>
  </tbody>
</table>

<table>
  <thead>
    <tr>
      <th>Permutation Class</th>
      <th>Distributions <em>D</em> and <em>E</em></th>
      <th>The probability that the first number in the sequence is <em>x</em> or less given that <em>n</em> is …</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Numbers sorted in high-to-low order</td>
      <td>Each arbitrary</td>
      <td>Odd is <em>ψ</em>(<em>x</em>) = (∫<sub>(−∞, <em>x</em>)</sub> exp(−ECDF(<em>z</em>)) * DPDF(<em>z</em>) <em>dz</em>) / (∫<sub>(−∞, ∞)</sub> exp(−ECDF(<em>z</em>)) * DPDF(<em>z</em>) <em>dz</em>) (Formula 1; see Theorem 2.1(iii) of (Devroye 1986, Chapter IV)<sup id="fnref:30:5" role="doc-noteref"><a href="#fn:30" class="footnote" rel="footnote">30</a></sup>; see also Forsythe 1972<sup id="fnref:68:1" role="doc-noteref"><a href="#fn:68" class="footnote" rel="footnote">68</a></sup>).  Here, DPDF is the probability density function (PDF) of <em>D</em>, and ECDF is the cumulative distribution function for <em>E</em>.<br />If <em>x</em> is a uniform random variate greater than 0 and less than 1, this probability becomes the integral of <em>ψ</em>(<em>z</em>) over the closed unit interval.</td>
    </tr>
    <tr>
      <td>Numbers sorted in high-to-low order</td>
      <td>Each arbitrary</td>
      <td>Even is (∫<sub>(−∞, <em>x</em>)</sub> (1 − exp(−ECDF(<em>z</em>))) * DPDF(<em>z</em>) <em>dz</em>) / (∫<sub>(−∞, ∞)</sub> (1 − exp(−ECDF(<em>z</em>))) * DPDF(<em>z</em>) <em>dz</em>) (Formula 2; see also Monahan 1979<sup id="fnref:75" role="doc-noteref"><a href="#fn:75" class="footnote" rel="footnote">75</a></sup>).  DPDF and ECDF are as above.</td>
    </tr>
    <tr>
      <td>Numbers sorted in high-to-low order</td>
      <td>Both uniform variates between 0 and 1</td>
      <td>Odd is ((1−exp(−<em>x</em>)))/(1−exp(−1)).  Therefore, the first number in the sequence is distributed as exponential with rate 1 and “cut off” to be not less than 0 and not greater than 1 (von Neumann 1951)<sup id="fnref:72:1" role="doc-noteref"><a href="#fn:72" class="footnote" rel="footnote">72</a></sup>.</td>
    </tr>
    <tr>
      <td>Numbers sorted in high-to-low order</td>
      <td><em>D</em> is a uniform variate between 0 and 1; <em>E</em> is max. of two uniform variates between 0 and 1.</td>
      <td>Odd is erf(<em>x</em>)/erf(1) (uses Formula 1, where DPDF(<em>z</em>) = 1 and ECDF(<em>z</em>) = <em>z</em><sup>2</sup> for 0≤<em>z</em>≤1; see also <a href="#erf__x__erf_1"><strong>erf(<em>x</em>)/erf(1)</strong></a>).</td>
    </tr>
  </tbody>
</table>

<table>
  <thead>
    <tr>
      <th>Permutation Class</th>
      <th>Distributions <em>D</em> and <em>E</em></th>
      <th>The probability that the first number in the sequence is…</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Numbers sorted in high-to-low order</td>
      <td><em>D</em> is an exponential variate with rate 1; <em>E</em> is a uniform variate between 0 and 1.</td>
      <td>1 or less given that <em>n</em> is even is 1 − 2 / (1 + exp(2)) = 1 − (1 + exp(0)) / (1 + exp(1)) = (exp(1)−1)/(exp(1)+1) (uses Formula 2, where DPDF(<em>z</em>) = exp(−<em>z</em>) and ECDF(<em>z</em>) = min(1,<em>z</em>) for <em>z</em>≥0).</td>
    </tr>
    <tr>
      <td>Numbers sorted in high-to-low order</td>
      <td><em>D</em> is an exponential variate with rate 1; <em>E</em> is a uniform variate between 0 and 1.</td>
      <td>1/2 or less given that <em>n</em> is odd is 1 − (1 + exp(1)) / (1 + exp(2)) = (exp(2) − exp(1)) / (exp(2)+1) (uses Formula 1, where DPDF(<em>z</em>) = exp(−<em>z</em>) and ECDF(<em>z</em>) = min(1,<em>z</em>) for <em>z</em>≥0).</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p><strong>Notes:</strong></p>

  <ol>
    <li>All the functions possible for formulas 1 and 2 are nowhere decreasing functions.  Both formulas express what are called <em>cumulative distribution functions</em>, namely <em>F</em><sub><em>D</em></sub>(<em>x</em> given that <em>n</em> is odd) or <em>F</em><sub><em>D</em></sub>(<em>x</em> given that <em>n</em> is even), respectively.</li>
    <li>EGF(<em>z</em>) is the <em>exponential generating function</em> (EGF) for the kind of permutation involved in the algorithm.  For example, the class of <em>alternating permutations</em> (permutations whose numbers alternate between low and high, that is, <em>X1</em> &gt; <em>X2</em> &lt; <em>X3</em> &gt; …) uses the EGF tan(<em>λ</em>)+1/cos(<em>λ</em>).  Other examples of EGFs were given in the section on the von Neumann schema.</li>
    <li>The results that point to this note have the special case that both <em>D</em> and <em>E</em> are uniform random variates between 0 and 1.  Indeed, if each variate <em>x</em> in the sequence is transformed with <em>CDF</em>(<em>x</em>), where <em>CDF</em> is <em>D</em>’s cumulative distribution function, then with probability 1, <em>x</em> becomes a uniform random variate greater than 0 and less than 1, with the same numerical order as before.  See also <a href="https://stats.stackexchange.com/questions/550847"><strong>this Stack Exchange question</strong></a>.</li>
  </ol>
</blockquote>

<p><a id="Derivation_of_an_Algorithm_for___pi___4"></a></p>

<h3 id="derivation-of-an-algorithm-for-pi--4">Derivation of an Algorithm for <em>π</em> / 4</h3>

<p>The following is a derivation of the Madhava–Gregory–Leibniz (MGL) generator for simulating the probability $\pi/4$ (Flajolet et al. 2010)<sup id="fnref:1:30" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>.  It works as follows.  Let $S$ be a set of non-negative integers.  Then:</p>

<ol>
  <li>Generate a uniform random variate between 0 and 1, call it $U$.</li>
  <li><a href="#Implementation_Notes"><strong>Sample from the number $U$</strong></a> repeatedly until the sampling “fails” (returns 0).  Set $k$ to the number of “successes”.  (Thus, this step generates $k$ with probability $g(k,U) = (1-U) U^k$.)</li>
  <li>If $k$ is in $S$, return 1; otherwise, return 0.</li>
</ol>

<p>This can be seen as running <strong>Algorithm CC</strong> with an input coin for a randomly generated probability (a uniform random variate between 0 and 1).  Given that step 1 generates $U$, the probability this algorithm returns 1 is—</p>

<p>\(\sum_{k\text{ in }S} g(k,U) = \sum_{k\text{ in }S} (1-U) U^k,\) and the overall algorithm uses the “<a href="#Integrals"><strong>integral method</strong></a>”, so that the overall algorithm returns 1 with probability—</p>

<p>\(\int_0^1\sum_{k\text{ in }S} (1-U) U^k\,dU,\) which, in the case of the MGL generator (where $S$ is the set of non-negative integers with a remainder of 0 or 1 after division by 4), equals $\int_0^1 \frac{1}{U^2+1}\,dU = \pi/4$.</p>

<p>The derivation below relies on the following fact: The probability satisfies—</p>

<p>\(\int_0^1\sum_{k\text{ in }S} g(k,U)\,dU = \sum_{k\text{ in }S}\int_0^1 g(k,U)\,dU.\) Swapping the integral and the sum is not always possible, but it is in this case because the conditions of so-called Tonelli’s theorem are met: $g(k,U)$ is continuous and non-negative whenever $k$ is in $S$ and $0\le U\le 1$; and $S$ and the closed unit interval have natural sigma-finite measures.</p>

<p>Now to show how the MGL generator produces the probability $\pi/4$.  Let $C(k)$ be the probability that this algorithm’s step 2 generates a number $k$, namely—</p>

<p>\(C(k)=\int_0^1 g(k,U)\,dU = \int_0^1 (1-U) U^k\,dU = \frac{1}{k^2+3k+2}.\)  Then the MGL series for $\pi/4$ is formed by—</p>

\[\pi/4 = (1/1-1/3)+(1/5-1/7)+...=2/3+2/35+2/99+...\]

\[=(C(0)+C(1))+(C(4)+C(5))+(C(8)+C(9))+...\]

\[=\sum_{k\ge 0} C(4k)+C(4k+1),\]

<p>where the last sum takes $C(k)$ for each $k$ in the set $S$ given for the MGL generator.</p>

<p><a id="Sketch_of_Derivation_of_the_Algorithm_for_1___pi"></a></p>

<h3 id="sketch-of-derivation-of-the-algorithm-for-1--pi">Sketch of Derivation of the Algorithm for 1 / <em>π</em></h3>

<p>The Flajolet paper presented an algorithm to simulate 1 / <em>π</em> but provided no derivation.  Here is a sketch of how this algorithm works.</p>

<p>The algorithm is an application of the <a href="#Convex_Combinations"><strong>convex combination</strong></a> technique.  Namely, 1 / <em>π</em> can be seen as a convex combination of two components:</p>

<ul>
  <li>
    <p><em>g</em>(<em>n</em>): 2<sup>6 * <em>n</em></sup> * (6 * <em>n</em> + 1) / 2<sup>8 * <em>n</em> + 2</sup> = 2<sup>−2 * <em>n</em></sup> * (6 * <em>n</em> + 1) / 4 = (6 * <em>n</em> + 1) / (2<sup>2 * <em>n</em> + 2</sup>), which is the probability that the sum of the following independent random variates equals <em>n</em>:</p>

    <ul>
      <li>Two random variates that each express the number of failures before the first success, where the chance of a success is 1−1/4 (the paper calls these two numbers <em>geometric</em>(1/4) random variates, but this terminology is avoided in this article because it has several conflicting meanings in academic works).</li>
      <li>One Bernoulli random variate with mean 5/9.</li>
    </ul>

    <p>This corresponds to step 1 of the convex combination algorithm and steps 2 through 4 of the 1 / <em>π</em> algorithm.  (This also shows that there is an error in the identity for 1 / <em>π</em> given in the Flajolet paper: the “8 <em>n</em> + 4” should read “8 <em>n</em> + 2”.)</p>
  </li>
  <li>
    <p><em>h</em><sub><em>n</em></sub>(): (choose(<em>n</em> * 2, <em>n</em>) / 2<sup>n * 2</sup>)<sup>3</sup>, which is the probability of heads of the “coin” numbered <em>n</em>.  This corresponds to step 2 of the convex combination algorithm and step 5 of the 1 / <em>π</em> algorithm.</p>
  </li>
</ul>

<blockquote>
  <p><strong>Notes:</strong></p>

  <ol>
    <li>9 * (<em>n</em> + 1) / (2<sup>2 * <em>n</em> + 4</sup>) is the probability that the sum of two independent random variates equals <em>n</em>, where each of the two variates expresses the number of failures before the first success and the chance of a success is 1−1/4.</li>
    <li><em>p</em><sup><em>m</em></sup> * (1 − <em>p</em>)<sup><em>n</em></sup> * choose(<em>n</em> + <em>m</em> − 1, <em>m</em> − 1) is the probability that the sum of <em>m</em> independent random variates equals <em>n</em> (a <em>negative binomial distribution</em>), where each of the <em>m</em> variates expresses the number of failures before the first success and the chance of a success is <em>p</em>.</li>
    <li><em>p</em> * <em>f</em>(<em>z</em> − 1) + (1 − <em>p</em>) * <em>f</em>(<em>z</em>) is the probability that the sum of two independent random variates — a Bernoulli variate with mean <em>p</em> as well as an integer that equals <em>x</em> with probability <em>f</em>(<em>x</em>) — equals <em>z</em>.</li>
  </ol>
</blockquote>

<p><a id="Preparing_Rational_Functions"></a></p>

<h3 id="preparing-rational-functions">Preparing Rational Functions</h3>

<p>This section describes how to turn a single-variable rational function (ratio of polynomials) into an array of polynomials needed to apply the <strong>“Dice Enterprise” special case</strong> described in “<a href="#Certain_Rational_Functions"><strong>Certain Rational Functions</strong></a>”.  In short, the steps to do so can be described as <em>separating</em>, <em>homogenizing</em>, and <em>augmenting</em>.</p>

<p><strong>Separating.</strong> If a rational function’s numerator (<em>D</em>) and denominator (<em>E</em>) are written—</p>

<ul>
  <li>as a sum of terms of the form <em>z</em>*<em>λ</em><sup><em>i</em></sup>*(1−<em>λ</em>)<sup><em>j</em></sup>, where <em>z</em> is a real number and <em>i</em>≥0 and <em>j</em>≥0 are integers (called <em>form 1</em> in this section),</li>
</ul>

<p>then the function can be separated into two polynomials that sum to the denominator.  (Here, <em>i</em>+<em>j</em> is the term’s <em>degree</em>, and the polynomial’s degree is the highest degree among its terms.)  To do this separation, subtract the numerator from the denominator to get a new polynomial (<em>G</em>) such that <em>G</em> = <em>E</em> − <em>D</em> (or <em>D</em> + <em>G</em> = <em>E</em>).  (Then <em>D</em> and <em>G</em> are the two polynomials that will be used.) Similarly, if we have multiple rational functions with a common denominator, namely (<em>D1</em>/<em>E</em>), …, (<em>DN</em>/<em>E</em>), where <em>D1</em>, …, <em>DN</em> and <em>E</em> are written in form 1, then they can be separated into <em>N</em> + 1 polynomials by subtracting the numerators from the denominator, so that <em>G</em> = <em>E</em> − <em>D1</em> − … − <em>DN</em>.  (Then <em>D1</em>, …, <em>DN</em> and <em>G</em> are the polynomials that will be used.) To use the polynomials in the algorithm, however, they need to be <em>homogenized</em>, then <em>augmented</em>, as described next.</p>

<blockquote>
  <p><strong>Example:</strong> Take the rational function  (4*<em>λ</em><sup>1</sup>*(1−<em>λ</em>)<sup>2</sup>) /  (7 − 5*<em>λ</em><sup>1</sup>*(1−<em>λ</em>)<sup>2</sup>).  Subtracting the numerator from the denominator leads to: 7 − 1*<em>λ</em><sup>1</sup>*(1−<em>λ</em>)<sup>2</sup>.</p>
</blockquote>

<p><strong>Homogenizing.</strong> The next step is to <em>homogenize</em> the polynomials so they have the same degree and a particular form.  For this step, choose <em>n</em> to be an integer no less than the highest degree among the polynomials.</p>

<p>Suppose a polynomial—</p>

<ul>
  <li>is 0 or greater for every <em>λ</em> 0 or greater, but not greater than 1,</li>
  <li>has degree <em>n</em> or less, and</li>
  <li>is written in form 1 as given above.</li>
</ul>

<p>Then the polynomial can be turned into a <em>homogeneous polynomial</em> of degree <em>n</em> (all its terms have degree <em>n</em>) as follows. (Homogeneous polynomials are also known as polynomials in <em>scaled Bernstein form</em> (Farouki and Rajan 1988)<sup id="fnref:18:1" role="doc-noteref"><a href="#fn:18" class="footnote" rel="footnote">18</a></sup>.)</p>

<ul>
  <li>For each integer <em>m</em> satisfying 0 ≤ <em>m</em> ≤ <em>n</em>, the new polynomial’s homogeneous coefficient at <em>m</em> is found as follows:
    <ol>
      <li>Set <em>r</em> to 0.</li>
      <li>For each term (in the old polynomial) of the form <em>z</em>*<em>λ</em><sup><em>i</em></sup>*(1−<em>λ</em>)<sup><em>j</em></sup>:
        <ul>
          <li>If <em>i</em> ≤ <em>m</em>, and (<em>n</em>−<em>m</em>) ≥ <em>j</em>, and <em>i</em> + <em>j</em> ≤ <em>n</em>, add <em>z</em>*choose(<em>n</em>−(<em>i</em>+<em>j</em>), (<em>n</em>−<em>m</em>)−<em>j</em>) to <em>r</em>.</li>
        </ul>
      </li>
      <li>Now, <em>r</em> is the new homogeneous coefficient (corresponding to the term <em>r</em>* <em>λ</em><sup><em>m</em></sup>*(1−<em>λ</em>)<sup><em>n</em>−<em>m</em></sup>).</li>
    </ol>
  </li>
</ul>

<p>If the polynomial is written in so-called “power form” as <em>c[0]</em> + <em>c[1]</em>*<em>λ</em> + <em>c[2]</em>*<em>λ</em><sup>2</sup> + … + <em>c[n]</em>*<em>λ</em><sup><em>n</em></sup>, then the method is instead as follows:</p>

<ul>
  <li>For each integer <em>m</em> satisfying 0 ≤ <em>m</em> ≤ <em>n</em>, the new polynomial’s homogeneous coefficient at <em>m</em> is found as follows:
    <ol>
      <li>Set <em>r</em> to 0.</li>
      <li>For each integer <em>i</em> satisfying 0 ≤ <em>i</em> ≤ <em>m</em>, if there is a homogeneous coefficient <em>c[i]</em>, add <em>c[i]</em>*choose(<em>n</em>−<em>i</em>, <em>n</em>−<em>m</em>) to <em>r</em>.</li>
      <li>Now, <em>r</em> is the new homogeneous coefficient (corresponding to the term <em>r</em>* <em>λ</em><sup><em>m</em></sup>*(1−<em>λ</em>)<sup><em>n</em>−<em>m</em></sup>).</li>
    </ol>
  </li>
</ul>

<blockquote>
  <p><strong>Example:</strong> Let the following polynomial be given: 3*<em>λ</em><sup>2</sup> + 10*<em>λ</em><sup>1</sup>*(1−<em>λ</em>)<sup>2</sup>.  This is a degree-3 polynomial, and we seek to turn it into a degree-5 homogeneous polynomial.  The result becomes the sum of the terms—</p>

  <ul>
    <li>0 * <em>λ</em><sup>0</sup>*(1−<em>λ</em>)<sup>5</sup>;</li>
    <li>10*choose(2, 2) * <em>λ</em><sup>1</sup>*(1−<em>λ</em>)<sup>4</sup> = 10* <em>λ</em><sup>1</sup>*(1−<em>λ</em>)<sup>4</sup>;</li>
    <li>(3*choose(3, 3) + 10*choose(2, 1)) * <em>λ</em><sup>2</sup>*(1−<em>λ</em>)<sup>3</sup> = 23* <em>λ</em><sup>2</sup>*(1−<em>λ</em>)<sup>3</sup>;</li>
    <li>(3*choose(3, 2) + 10*choose(2, 0)) * <em>λ</em><sup>3</sup>*(1−<em>λ</em>)<sup>2</sup> = 19* <em>λ</em><sup>3</sup>*(1−<em>λ</em>)<sup>2</sup>;</li>
    <li>3*choose(3, 1) * <em>λ</em><sup>4</sup>*(1−<em>λ</em>)<sup>1</sup> = 9* <em>λ</em><sup>4</sup>*(1−<em>λ</em>)<sup>1</sup>; and</li>
    <li>3*choose(3, 0) * <em>λ</em><sup>5</sup>*(1−<em>λ</em>)<sup>0</sup> = 3* <em>λ</em><sup>5</sup>*(1−<em>λ</em>)<sup>0</sup>,</li>
  </ul>

  <p>resulting in the homogeneous coefficients (0, 10, 23, 19, 9, 3) for the new homogeneous polynomial.</p>
</blockquote>

<p><strong>Augmenting.</strong> If we have an array of homogeneous single-variable polynomials of the same degree, they are ready for use in the <strong>Dice Enterprise special case</strong> if—</p>

<ul>
  <li>the polynomials have the same degree, namely <em>n</em>,</li>
  <li>their homogeneous coefficients are all 0 or greater, and</li>
  <li>the sum of <em>j</em><sup>th</sup> homogeneous coefficients is greater than 0, for each <em>j</em> starting at 0 and ending at <em>n</em>, except that the list of sums may begin with zeros, end with zeros, or both.</li>
</ul>

<p>If those conditions are not met, then each polynomial can be <em>augmented</em> as often as necessary to meet the conditions (Morina et al., 2022)<sup id="fnref:19:3" role="doc-noteref"><a href="#fn:19" class="footnote" rel="footnote">19</a></sup>.  For polynomials of the kind relevant here, augmenting a polynomial amounts to degree elevation similar to that of polynomials in Bernstein form (see also Tsai and Farouki 2001<sup id="fnref:62:1" role="doc-noteref"><a href="#fn:62" class="footnote" rel="footnote">62</a></sup>).  It is implemented as follows:</p>

<ul>
  <li>Let <em>n</em> be the polynomial’s old degree.  For each integer <em>k</em> satisfying 0 ≤ <em>k</em> ≤ <em>n</em>+1, the new polynomial’s homogeneous coefficient at <em>k</em> is found as follows:
    <ul>
      <li>Let <em>c</em>[<em>j</em>] be the old polynomial’s <em>j</em><sup>th</sup> homogeneous coefficient (starting at 0).  Calculate <em>c</em>[<em>j</em>] * choose(1, <em>k</em>−<em>j</em>) for each integer <em>j</em> satisfying max(0, <em>k</em>−1) ≤ <em>j</em> ≤ min(<em>n</em>, <em>k</em>), then add them together.  The sum is the new homogeneous coefficient.</li>
    </ul>
  </li>
</ul>

<p>According to the Morina paper, it’s enough to do <em>n</em> augmentations on each polynomial for the whole array to meet the conditions above (although fewer than <em>n</em> will often suffice).</p>

<blockquote>
  <p><strong>Note</strong>: For best results, the input polynomials’ homogeneous coefficients should be rational numbers.  If they are not, then special methods are needed to ensure exact results, such as interval arithmetic that calculates lower and upper bounds.</p>
</blockquote>

<p><a id="License"></a></p>

<h2 id="license">License</h2>

<p>Any copyright to this page is released to the Public Domain.  In case this is not possible, this page is also licensed under <a href="https://creativecommons.org/publicdomain/zero/1.0/"><strong>Creative Commons Zero</strong></a>.</p>
<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>Flajolet, P., Pelletier, M., Soria, M., “<a href="https://arxiv.org/abs/0906.5560"><strong>On Buffon machines and numbers</strong></a>”, arXiv:0906.5560  [math.PR], 2010. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:1:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a> <a href="#fnref:1:2" class="reversefootnote" role="doc-backlink">&#8617;<sup>3</sup></a> <a href="#fnref:1:3" class="reversefootnote" role="doc-backlink">&#8617;<sup>4</sup></a> <a href="#fnref:1:4" class="reversefootnote" role="doc-backlink">&#8617;<sup>5</sup></a> <a href="#fnref:1:5" class="reversefootnote" role="doc-backlink">&#8617;<sup>6</sup></a> <a href="#fnref:1:6" class="reversefootnote" role="doc-backlink">&#8617;<sup>7</sup></a> <a href="#fnref:1:7" class="reversefootnote" role="doc-backlink">&#8617;<sup>8</sup></a> <a href="#fnref:1:8" class="reversefootnote" role="doc-backlink">&#8617;<sup>9</sup></a> <a href="#fnref:1:9" class="reversefootnote" role="doc-backlink">&#8617;<sup>10</sup></a> <a href="#fnref:1:10" class="reversefootnote" role="doc-backlink">&#8617;<sup>11</sup></a> <a href="#fnref:1:11" class="reversefootnote" role="doc-backlink">&#8617;<sup>12</sup></a> <a href="#fnref:1:12" class="reversefootnote" role="doc-backlink">&#8617;<sup>13</sup></a> <a href="#fnref:1:13" class="reversefootnote" role="doc-backlink">&#8617;<sup>14</sup></a> <a href="#fnref:1:14" class="reversefootnote" role="doc-backlink">&#8617;<sup>15</sup></a> <a href="#fnref:1:15" class="reversefootnote" role="doc-backlink">&#8617;<sup>16</sup></a> <a href="#fnref:1:16" class="reversefootnote" role="doc-backlink">&#8617;<sup>17</sup></a> <a href="#fnref:1:17" class="reversefootnote" role="doc-backlink">&#8617;<sup>18</sup></a> <a href="#fnref:1:18" class="reversefootnote" role="doc-backlink">&#8617;<sup>19</sup></a> <a href="#fnref:1:19" class="reversefootnote" role="doc-backlink">&#8617;<sup>20</sup></a> <a href="#fnref:1:20" class="reversefootnote" role="doc-backlink">&#8617;<sup>21</sup></a> <a href="#fnref:1:21" class="reversefootnote" role="doc-backlink">&#8617;<sup>22</sup></a> <a href="#fnref:1:22" class="reversefootnote" role="doc-backlink">&#8617;<sup>23</sup></a> <a href="#fnref:1:23" class="reversefootnote" role="doc-backlink">&#8617;<sup>24</sup></a> <a href="#fnref:1:24" class="reversefootnote" role="doc-backlink">&#8617;<sup>25</sup></a> <a href="#fnref:1:25" class="reversefootnote" role="doc-backlink">&#8617;<sup>26</sup></a> <a href="#fnref:1:26" class="reversefootnote" role="doc-backlink">&#8617;<sup>27</sup></a> <a href="#fnref:1:27" class="reversefootnote" role="doc-backlink">&#8617;<sup>28</sup></a> <a href="#fnref:1:28" class="reversefootnote" role="doc-backlink">&#8617;<sup>29</sup></a> <a href="#fnref:1:29" class="reversefootnote" role="doc-backlink">&#8617;<sup>30</sup></a> <a href="#fnref:1:30" class="reversefootnote" role="doc-backlink">&#8617;<sup>31</sup></a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>Keane,  M.  S.,  and  O’Brien,  G.  L., “A Bernoulli factory”, <em>ACM Transactions on Modeling and Computer Simulation</em> 4(2), 1994. <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:2:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a> <a href="#fnref:2:2" class="reversefootnote" role="doc-backlink">&#8617;<sup>3</sup></a> <a href="#fnref:2:3" class="reversefootnote" role="doc-backlink">&#8617;<sup>4</sup></a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>Basu, D., “Statistical information and likelihood”, Sankhyā A 37 (1975). <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:3:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p>There is an analogue to the Bernoulli factory problem called the <em>quantum Bernoulli factory</em>, with the same goal of simulating functions of unknown probabilities, but this time with algorithms that employ quantum-mechanical operations (unlike <em>classical</em> algorithms that employ no such operations).  However, quantum-mechanical programming is far from being accessible to most programmers at the same level as classical programming, and will likely remain so for the foreseeable future.  For this reason, the <em>quantum Bernoulli factory</em> is outside the scope of this document, but it should be noted that more factory functions can be “constructed” using quantum-mechanical operations than by classical algorithms.  For example, a factory function whose domain is [0, 1] has to meet the requirements proved by Keane and O’Brien except it can touch 0, 1, or both at a finite number of points in the domain (Dale, H., Jennings, D. and Rudolph, T., 2015, “Provable quantum advantage in randomness processing”, <em>Nature communications</em> 6(1), pp. 1-4). <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:5" role="doc-endnote">
      <p>Huber, M., “<a href="https://arxiv.org/abs/1308.1562v2"><strong>Nearly optimal Bernoulli factories for linear functions</strong></a>”, arXiv:1308.1562v2  [math.PR], 2014. <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:5:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a></p>
    </li>
    <li id="fn:6" role="doc-endnote">
      <p>Yannis Manolopoulos. 2002. “Binomial coefficient computation: recursion or iteration?”, SIGCSE Bull. 34, 4 (December 2002), 65–67. DOI: <a href="https://doi.org/10.1145/820127.820168"><strong>https://doi.org/10.1145/820127.820168</strong></a>. <a href="#fnref:6" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:7" role="doc-endnote">
      <p>Goyal, V. and Sigman, K., 2012. On simulating a class of Bernstein polynomials. ACM Transactions on Modeling and Computer Simulation (TOMACS), 22(2), pp.1-5. <a href="#fnref:7" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:7:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a> <a href="#fnref:7:2" class="reversefootnote" role="doc-backlink">&#8617;<sup>3</sup></a> <a href="#fnref:7:3" class="reversefootnote" role="doc-backlink">&#8617;<sup>4</sup></a></p>
    </li>
    <li id="fn:8" role="doc-endnote">
      <p>Weikang Qian, Marc D. Riedel, Ivo Rosenberg, “Uniform approximation and Bernstein polynomials with coefficients in the unit interval”, <em>European Journal of Combinatorics</em> 32(3), 2011, <a href="#fnref:8" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:8:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a></p>
    </li>
    <li id="fn:9" role="doc-endnote">
      <p>Wästlund, J., “<a href="http://www.math.chalmers.se/~wastlund/coinFlip.pdf"><strong>Functions arising by coin flipping</strong></a>”, 1999. <a href="#fnref:9" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:9:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a> <a href="#fnref:9:2" class="reversefootnote" role="doc-backlink">&#8617;<sup>3</sup></a> <a href="#fnref:9:3" class="reversefootnote" role="doc-backlink">&#8617;<sup>4</sup></a> <a href="#fnref:9:4" class="reversefootnote" role="doc-backlink">&#8617;<sup>5</sup></a></p>
    </li>
    <li id="fn:10" role="doc-endnote">
      <p>Then <em>j</em> is a <em>binomial</em> random variate expressing the number of successes in <em>n</em> trials that each succeed with probability <em>λ</em>. <a href="#fnref:10" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:11" role="doc-endnote">
      <p>Qian, W. and Riedel, M.D., 2008, June. The synthesis of robust polynomial arithmetic with stochastic logic. In 2008 45th ACM/IEEE Design Automation Conference (pp. 648-653). IEEE. <a href="#fnref:11" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:12" role="doc-endnote">
      <p>Thomas, A.C., Blanchet, J., “<a href="https://arxiv.org/abs/1106.2508v3"><strong>A Practical Implementation of the Bernoulli Factory</strong></a>”, arXiv:1106.2508v3  [stat.AP], 2012. <a href="#fnref:12" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:12:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a> <a href="#fnref:12:2" class="reversefootnote" role="doc-backlink">&#8617;<sup>3</sup></a> <a href="#fnref:12:3" class="reversefootnote" role="doc-backlink">&#8617;<sup>4</sup></a> <a href="#fnref:12:4" class="reversefootnote" role="doc-backlink">&#8617;<sup>5</sup></a></p>
    </li>
    <li id="fn:13" role="doc-endnote">
      <p>S. Ray, P.S.V. Nataraj, “<a href="https://interval.louisiana.edu/reliable-computing-journal/volume-17/reliable-computing-17-pp-40-71.pdf"><strong>A Matrix Method for Efficient Computation of Bernstein Coefficients</strong></a>”, Reliable Computing 17(1), 2012. <a href="#fnref:13" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:13:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a></p>
    </li>
    <li id="fn:14" role="doc-endnote">
      <p>And this shows that the polynomial couldn’t be simulated if <em>c</em> were allowed to be 1, since the required degree would be infinity; in fact, the polynomial would touch 1 at the point 0.5 in this case, ruling out its simulation by any algorithm (see “About Bernoulli Factories”, earlier). <a href="#fnref:14" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:15" role="doc-endnote">
      <p>Niazadeh, R., Paes Leme, R., Schneider, J., “<a href="https://dl.acm.org/doi/10.1145/3406325.3451072"><strong>Combinatorial Bernoulli Factories: Matchings, Flows, and Polytopes</strong></a>”, in <em>Proceedings of the 53rd Annual ACM SIGACT Symposium on Theory of Computing</em>, pp. 833-846, June 2021; also at <a href="https://arxiv.org/abs/2011.03865"><strong>https://arxiv.org/abs/2011.03865.pdf</strong></a>. <a href="#fnref:15" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:16" role="doc-endnote">
      <p>Mossel, Elchanan, and Yuval Peres. New coins from old: computing with unknown bias. Combinatorica, 25(6), pp.707-724, 2005. <a href="#fnref:16" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:16:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a> <a href="#fnref:16:2" class="reversefootnote" role="doc-backlink">&#8617;<sup>3</sup></a></p>
    </li>
    <li id="fn:17" role="doc-endnote">
      <p>Nacu, Şerban, and Yuval Peres. “<a href="https://projecteuclid.org/euclid.aoap/1106922322"><strong>Fast simulation of new coins from old</strong></a>”, The Annals of Applied Probability 15, no. 1A (2005): 93-115. <a href="#fnref:17" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:17:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a> <a href="#fnref:17:2" class="reversefootnote" role="doc-backlink">&#8617;<sup>3</sup></a> <a href="#fnref:17:3" class="reversefootnote" role="doc-backlink">&#8617;<sup>4</sup></a> <a href="#fnref:17:4" class="reversefootnote" role="doc-backlink">&#8617;<sup>5</sup></a></p>
    </li>
    <li id="fn:18" role="doc-endnote">
      <p>Farouki, Rida T., and V. T. Rajan. “<a href="https://www.sciencedirect.com/science/article/pii/0167839688900167"><strong>Algorithms for polynomials in Bernstein form</strong></a>”. Computer Aided Geometric Design 5, no. 1 (1988): 1-26. <a href="#fnref:18" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:18:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a></p>
    </li>
    <li id="fn:19" role="doc-endnote">
      <p>Giulio Morina. Krzysztof Łatuszyński. Piotr Nayar. Alex Wendland. “<a href="https://doi.org/10.1214/21-AAP1679"><strong>From the Bernoulli factory to a dice enterprise via perfect sampling of Markov chains</strong></a>”, Ann. Appl. Probab. 32 (1) 327 - 359, February 2022. <a href="#fnref:19" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:19:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a> <a href="#fnref:19:2" class="reversefootnote" role="doc-backlink">&#8617;<sup>3</sup></a> <a href="#fnref:19:3" class="reversefootnote" role="doc-backlink">&#8617;<sup>4</sup></a></p>
    </li>
    <li id="fn:20" role="doc-endnote">
      <p>Propp, J.G., Wilson, D.B., “Exact sampling with coupled Markov chains and applications to statistical mechanics”, 1996. <a href="#fnref:20" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:21" role="doc-endnote">
      <p>Łatuszyński, K., Kosmidis, I.,  Papaspiliopoulos, O., Roberts, G.O., “<a href="https://arxiv.org/abs/0907.4018v2"><strong>Simulating events of unknown probabilities via reverse time martingales</strong></a>”, arXiv:0907.4018v2 [stat.CO], 2009/2011. <a href="#fnref:21" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:21:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a> <a href="#fnref:21:2" class="reversefootnote" role="doc-backlink">&#8617;<sup>3</sup></a> <a href="#fnref:21:3" class="reversefootnote" role="doc-backlink">&#8617;<sup>4</sup></a> <a href="#fnref:21:4" class="reversefootnote" role="doc-backlink">&#8617;<sup>5</sup></a></p>
    </li>
    <li id="fn:22" role="doc-endnote">
      <p>Dughmi, Shaddin, Jason Hartline, Robert D. Kleinberg, and Rad Niazadeh. “Bernoulli Factories and Black-box Reductions in Mechanism Design.” Journal of the ACM (JACM) 68, no. 2 (2021): 1-30. <a href="#fnref:22" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:23" role="doc-endnote">
      <p>Knuth, Donald E. and Andrew Chi-Chih Yao. “The complexity of nonuniform random number generation”, in <em>Algorithms and Complexity: New Directions and Recent Results</em>, 1976. <a href="#fnref:23" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:24" role="doc-endnote">
      <p>Mendo, Luis. “An asymptotically optimal Bernoulli factory for certain functions that can be expressed as power series.” Stochastic Processes and their Applications 129, no. 11 (2019): 4366-4384. <a href="#fnref:24" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:24:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a> <a href="#fnref:24:2" class="reversefootnote" role="doc-backlink">&#8617;<sup>3</sup></a> <a href="#fnref:24:3" class="reversefootnote" role="doc-backlink">&#8617;<sup>4</sup></a> <a href="#fnref:24:4" class="reversefootnote" role="doc-backlink">&#8617;<sup>5</sup></a> <a href="#fnref:24:5" class="reversefootnote" role="doc-backlink">&#8617;<sup>6</sup></a> <a href="#fnref:24:6" class="reversefootnote" role="doc-backlink">&#8617;<sup>7</sup></a> <a href="#fnref:24:7" class="reversefootnote" role="doc-backlink">&#8617;<sup>8</sup></a></p>
    </li>
    <li id="fn:25" role="doc-endnote">
      <p>“<em>x</em> is odd” means that <em>x</em> is an integer and not divisible by 2.  This is true if <em>x</em> − 2*floor(<em>x</em>/2) equals 1, or if <em>x</em> is an integer and the least significant bit of abs(<em>x</em>) is 1. <a href="#fnref:25" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:25:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a> <a href="#fnref:25:2" class="reversefootnote" role="doc-backlink">&#8617;<sup>3</sup></a> <a href="#fnref:25:3" class="reversefootnote" role="doc-backlink">&#8617;<sup>4</sup></a> <a href="#fnref:25:4" class="reversefootnote" role="doc-backlink">&#8617;<sup>5</sup></a> <a href="#fnref:25:5" class="reversefootnote" role="doc-backlink">&#8617;<sup>6</sup></a> <a href="#fnref:25:6" class="reversefootnote" role="doc-backlink">&#8617;<sup>7</sup></a> <a href="#fnref:25:7" class="reversefootnote" role="doc-backlink">&#8617;<sup>8</sup></a> <a href="#fnref:25:8" class="reversefootnote" role="doc-backlink">&#8617;<sup>9</sup></a> <a href="#fnref:25:9" class="reversefootnote" role="doc-backlink">&#8617;<sup>10</sup></a> <a href="#fnref:25:10" class="reversefootnote" role="doc-backlink">&#8617;<sup>11</sup></a></p>
    </li>
    <li id="fn:26" role="doc-endnote">
      <p><em>n</em>! = 1*2*3*…*<em>n</em> is also known as <em>n</em> factorial; in this document, (0!) = 1. <a href="#fnref:26" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:27" role="doc-endnote">
      <p>“<em>x</em> is even” means that <em>x</em> is an integer and divisible by 2.  This is true if <em>x</em> − 2*floor(<em>x</em>/2) equals 0, or if <em>x</em> is an integer and the least significant bit of abs(<em>x</em>) is 0. <a href="#fnref:27" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:27:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a> <a href="#fnref:27:2" class="reversefootnote" role="doc-backlink">&#8617;<sup>3</sup></a> <a href="#fnref:27:3" class="reversefootnote" role="doc-backlink">&#8617;<sup>4</sup></a> <a href="#fnref:27:4" class="reversefootnote" role="doc-backlink">&#8617;<sup>5</sup></a> <a href="#fnref:27:5" class="reversefootnote" role="doc-backlink">&#8617;<sup>6</sup></a> <a href="#fnref:27:6" class="reversefootnote" role="doc-backlink">&#8617;<sup>7</sup></a> <a href="#fnref:27:7" class="reversefootnote" role="doc-backlink">&#8617;<sup>8</sup></a> <a href="#fnref:27:8" class="reversefootnote" role="doc-backlink">&#8617;<sup>9</sup></a> <a href="#fnref:27:9" class="reversefootnote" role="doc-backlink">&#8617;<sup>10</sup></a> <a href="#fnref:27:10" class="reversefootnote" role="doc-backlink">&#8617;<sup>11</sup></a></p>
    </li>
    <li id="fn:28" role="doc-endnote">
      <p>Flegal, J.M., Herbei, R., “Exact sampling from intractible probability distributions via a Bernoulli factory”, <em>Electronic Journal of Statistics</em> 6, 10-37, 2012. <a href="#fnref:28" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:29" role="doc-endnote">
      <p>Brassard, G., Devroye, L., Gravel, C., “Remote Sampling with Applications to General Entanglement Simulation”, <em>Entropy</em> 2019(21)(92), <a href="https://doi.org/10.3390/e21010092"><strong>https://doi.org/10.3390/e21010092</strong></a> . <a href="#fnref:29" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:29:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a> <a href="#fnref:29:2" class="reversefootnote" role="doc-backlink">&#8617;<sup>3</sup></a></p>
    </li>
    <li id="fn:30" role="doc-endnote">
      <p>Devroye, L., <a href="http://luc.devroye.org/rnbookindex.html"><strong><em>Non-Uniform Random Variate Generation</em></strong></a>, 1986. <a href="#fnref:30" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:30:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a> <a href="#fnref:30:2" class="reversefootnote" role="doc-backlink">&#8617;<sup>3</sup></a> <a href="#fnref:30:3" class="reversefootnote" role="doc-backlink">&#8617;<sup>4</sup></a> <a href="#fnref:30:4" class="reversefootnote" role="doc-backlink">&#8617;<sup>5</sup></a> <a href="#fnref:30:5" class="reversefootnote" role="doc-backlink">&#8617;<sup>6</sup></a></p>
    </li>
    <li id="fn:31" role="doc-endnote">
      <p>Note that <code>u * BASE</code><sup>−<code>k</code></sup> is not just within <code>BASE</code><sup>−<code>k</code></sup> of its “true” result, but also not more than that result.  Hence <code>pk + 1 &lt;= u</code> rather than <code>pk + 2 &lt;= u</code>. <a href="#fnref:31" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:32" role="doc-endnote">
      <p>The “even-parity” construction (Flajolet et al. 2010) is so called because it involves flipping the input coin repeatedly until it returns zero, then counting the number of ones.  The final result is 1 if that number is even, or 0 otherwise. However, the number of flips needed by this method grows without bound as $\lambda$ (the probability the input coin returns 1) approaches 1. See also the note for <strong>Algorithm CC</strong>. <a href="#fnref:32" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:32:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a> <a href="#fnref:32:2" class="reversefootnote" role="doc-backlink">&#8617;<sup>3</sup></a> <a href="#fnref:32:3" class="reversefootnote" role="doc-backlink">&#8617;<sup>4</sup></a> <a href="#fnref:32:4" class="reversefootnote" role="doc-backlink">&#8617;<sup>5</sup></a> <a href="#fnref:32:5" class="reversefootnote" role="doc-backlink">&#8617;<sup>6</sup></a> <a href="#fnref:32:6" class="reversefootnote" role="doc-backlink">&#8617;<sup>7</sup></a></p>
    </li>
    <li id="fn:33" role="doc-endnote">
      <p>Bill Gosper, “Continued Fraction Arithmetic”, 1978. <a href="#fnref:33" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:34" role="doc-endnote">
      <p>Borwein, J. et al. “Continued Logarithms and Associated Continued Fractions.” <em>Experimental Mathematics</em> 26 (2017): 412 - 429. <a href="#fnref:34" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:35" role="doc-endnote">
      <p>Penaud, J.G., Roques, O., “Tirage à pile ou face de mots de Fibonacci”, <em>Discrete Mathematics</em> 256, 2002. <a href="#fnref:35" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:35:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a></p>
    </li>
    <li id="fn:36" role="doc-endnote">
      <p>Mendo, L., “<a href="https://arxiv.org/abs/2010.14901"><strong>Simulating a coin with irrational bias using rational arithmetic</strong></a>”, arXiv:2010.14901 [math.PR], 2020/2021. <a href="#fnref:36" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:36:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a> <a href="#fnref:36:2" class="reversefootnote" role="doc-backlink">&#8617;<sup>3</sup></a> <a href="#fnref:36:3" class="reversefootnote" role="doc-backlink">&#8617;<sup>4</sup></a></p>
    </li>
    <li id="fn:37" role="doc-endnote">
      <p>Carvalho, Luiz Max, and Guido A. Moreira. “<a href="https://arxiv.org/abs/2202.06121"><strong>Adaptive truncation of infinite sums: applications to Statistics</strong></a>”, arXiv:2202.06121 (2022). <a href="#fnref:37" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:38" role="doc-endnote">
      <p>Citterio, M., Pavani, R., “A Fast Computation of the Best k-Digit Rational Approximation to a Real Number”, Mediterranean Journal of Mathematics 13 (2016). <a href="#fnref:38" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:39" role="doc-endnote">
      <p>The error term, which follows from the so-called Lagrange remainder for Taylor series, has a numerator of 2 because 2 is higher than the maximum value at the point 1 (in cosh(1)) that <em>f</em>’s slope, slope-of-slope, etc. functions can achieve. <a href="#fnref:39" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:40" role="doc-endnote">
      <p>Kozen, D., <a href="http://www.cs.cornell.edu/~kozen/Papers/Coinflip.pdf"><strong>“Optimal Coin Flipping”</strong></a>, 2014. <a href="#fnref:40" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:40:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a></p>
    </li>
    <li id="fn:41" role="doc-endnote">
      <p>K. Bringmann, F. Kuhn, et al., “Internal DLA: Efficient Simulation of a Physical Growth Model.” In: <em>Proc. 41st International Colloquium on Automata, Languages, and Programming (ICALP’14)</em>, 2014. <a href="#fnref:41" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:42" role="doc-endnote">
      <p>Huber, M., “<a href="https://arxiv.org/abs/1507.00843v2"><strong>Optimal linear Bernoulli factories for small mean problems</strong></a>”, arXiv:1507.00843v2 [math.PR], 2016. <a href="#fnref:42" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:42:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a> <a href="#fnref:42:2" class="reversefootnote" role="doc-backlink">&#8617;<sup>3</sup></a></p>
    </li>
    <li id="fn:43" role="doc-endnote">
      <p>Dughmi, Shaddin, Jason Hartline, Robert D. Kleinberg, and Rad Niazadeh. “Bernoulli factories and black-box reductions in mechanism design.” Journal of the ACM (JACM) 68, no. 2 (2021): 1-30. <a href="#fnref:43" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:43:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a> <a href="#fnref:43:2" class="reversefootnote" role="doc-backlink">&#8617;<sup>3</sup></a></p>
    </li>
    <li id="fn:44" role="doc-endnote">
      <p>Szász, O., “Generalization of S. Bernstein’s Polynomials to the Infinite Interval”, Journal of Research of the National Bureau of Standards 45 (1950). <a href="#fnref:44" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:45" role="doc-endnote">
      <p>However, the number of flips needed by this method will then grow without bound as $\lambda$ approaches 1.  Also, this article avoids calling the value <em>X</em> produced this way a “geometric” random variate.  Indeed, there is no single way to give the probabilities of a “geometric” random variate; different academic works define the variate differently. <a href="#fnref:45" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:45:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a> <a href="#fnref:45:2" class="reversefootnote" role="doc-backlink">&#8617;<sup>3</sup></a> <a href="#fnref:45:3" class="reversefootnote" role="doc-backlink">&#8617;<sup>4</sup></a></p>
    </li>
    <li id="fn:46" role="doc-endnote">
      <p>Schmon, S.M., Doucet, A. and Deligiannidis, G., 2019, April. Bernoulli race particle filters. In The 22nd International Conference on Artificial Intelligence and Statistics (pp. 2350-2358). <a href="#fnref:46" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:47" role="doc-endnote">
      <p>Agrawal, Sanket, Dootika Vats, Krzysztof Łatuszyński, and Gareth O. Roberts. “Optimal scaling of MCMC beyond Metropolis.” Advances in Applied Probability 55, no. 2 (2023): 492-509; also in “<a href="https://arxiv.org/abs/2104.02020"><strong>Optimal Scaling of MCMC Beyond Metropolis</strong></a>”, arXiv:2104.02020 [stat.CO], 2021. <a href="#fnref:47" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:48" role="doc-endnote">
      <p>The <a href="https://peteroupc.github.io/bernsupp.html#Pushdown_Automata_and_Algebraic_Functions"><strong>appendix to the supplemental notes</strong></a> defines pushdown automata in more detail and has proofs on which algebraic functions are possible with these conceptual machines. <a href="#fnref:48" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:49" role="doc-endnote">
      <p>Flajolet, Ph., “Analytic models and ambiguity of context-free languages”, <em>Theoretical Computer Science</em> 49, pp. 283-309, 1987 <a href="#fnref:49" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:50" role="doc-endnote">
      <p>Flajolet, P. and Sedgewick, R., <em>Analytic Combinatorics</em>, 2009. <a href="#fnref:50" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:51" role="doc-endnote">
      <p>In fact, thanks to the “geometric bag” technique of Flajolet et al. (2010), the fractional part <em>ν</em> can even come from a uniform partially-sampled random number (PSRN). <a href="#fnref:51" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:52" role="doc-endnote">
      <p>Canonne, C., Kamath, G., Steinke, T., “<a href="https://arxiv.org/abs/2004.00010"><strong>The Discrete Gaussian for Differential Privacy</strong></a>”, arXiv:2004.00010 [cs.DS], 2020. <a href="#fnref:52" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:52:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a></p>
    </li>
    <li id="fn:53" role="doc-endnote">
      <p>Another algorithm for exp(−<em>λ</em>) involves the von Neumann schema, but unfortunately, it converges slowly as <em>λ</em> approaches 1. <a href="#fnref:53" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:53:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a></p>
    </li>
    <li id="fn:54" role="doc-endnote">
      <p>Peres, N., Lee, A.R. and Keich, U., 2021. Exactly computing the tail of the Poisson-Binomial Distribution. ACM Transactions on Mathematical Software (TOMS), 47(4), pp.1-19. <a href="#fnref:54" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:54:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a></p>
    </li>
    <li id="fn:55" role="doc-endnote">
      <p>Sadowsky, Bucklew, On large deviations theory and asymptotically efficient Monte Carlo <a href="#fnref:55" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:55:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a></p>
    </li>
    <li id="fn:56" role="doc-endnote">
      <p>Gonçalves, F. B., Łatuszyński, K. G., Roberts, G. O. (2017).  Exact Monte Carlo likelihood-based inference for jump-diffusion processes. <a href="#fnref:56" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:56:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a></p>
    </li>
    <li id="fn:57" role="doc-endnote">
      <p>Vats, D., Gonçalves, F. B., Łatuszyński, K. G., Roberts, G. O., “Efficient Bernoulli factory Markov chain Monte Carlo for intractable posteriors”, <em>Biometrika</em> 109(2), June 2022 (also in arXiv:2004.07471 [stat.CO]). <a href="#fnref:57" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:57:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a></p>
    </li>
    <li id="fn:58" role="doc-endnote">
      <p>There are two other algorithms for this function, but they both converge very slowly when <em>λ</em> is very close to 1.  One is the <strong>general martingale algorithm</strong> (see “More Algorithms for Arbitrary-Precision Sampling”) with $g(\lambda)=\lambda$, $d_0 = 1$, and $a_i=(-1)^i$.  The other is the so-called “even-parity” construction from Flajolet et al. 2010: “(1) Flip the input coin.  If it returns 0, return 1. (2) Flip the input coin.  If it returns 0, return 0.  Otherwise, go to step 1.” <a href="#fnref:58" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:59" role="doc-endnote">
      <p>Banerjee, P. K., &amp; Sinha, B. K. (1979). Generating an Event with Probability $p^\alpha$, $\alpha\gt 0$. Sankhyā: The Indian Journal of Statistics, Series B, 282-285. <a href="#fnref:59" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:60" role="doc-endnote">
      <p>There is another algorithm for tanh(<em>z</em>), based on Lambert’s continued fraction for tanh(.), but it works only if 0 ≤ <em>z</em> ≤ 1 and if <em>z</em> is the probability of heads of an input coin.  The algorithm begins with <em>k</em> equal to 1.  Then: (1) If <em>k</em> is 1, generate either 1 or 0 with equal probability, then if 1 was generated this way, flip the input coin and return the result; (2) If <em>k</em> is greater than 1, then with probability <em>k</em>/(1+<em>k</em>), flip the input coin twice, and if either or both flips returned 0, return 0, and if both flips returned 1, return a number that is 1 with probability 1/<em>k</em> and 0 otherwise; (3) Do a separate run of the currently running algorithm, but with <em>k</em> = <em>k</em> + 2.  If the separate run returns 1, return 0; (4) Go to step 2. <a href="#fnref:60" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:61" role="doc-endnote">
      <p>Dale, H., Jennings, D. and Rudolph, T., 2015, “Provable quantum advantage in randomness processing”, <em>Nature communications</em> 6(1), pp. 1-4. <a href="#fnref:61" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:62" role="doc-endnote">
      <p>Tsai, Yi-Feng, Farouki, R.T., “Algorithm 812: BPOLY: An Object-Oriented Library of Numerical Algorithms for Polynomials in Bernstein Form”, <em>ACM Trans. Math. Softw.</em> 27(2), 2001. <a href="#fnref:62" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:62:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a></p>
    </li>
    <li id="fn:63" role="doc-endnote">
      <p>Lee, A., Doucet, A. and Łatuszyński, K., 2014. “<a href="https://arxiv.org/abs/1407.5770v1"><strong>Perfect simulation using atomic regeneration with application to Sequential Monte Carlo</strong></a>”, arXiv:1407.5770v1  [stat.CO]. <a href="#fnref:63" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:64" role="doc-endnote">
      <p>Morina, Giulio (2021) Extending the Bernoulli Factory to a dice enterprise. PhD thesis, University of Warwick. <a href="#fnref:64" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:64:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a></p>
    </li>
    <li id="fn:65" role="doc-endnote">
      <p>Huber, M., “<a href="https://arxiv.org/abs/1907.06748v1"><strong>Designing perfect simulation algorithms using local correctness</strong></a>”, arXiv:1907.06748v1 [cs.DS], 2019. <a href="#fnref:65" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:65:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a></p>
    </li>
    <li id="fn:66" role="doc-endnote">
      <p>One of the only implementations I could find of this, if not the only, was a <a href="https://github.com/derekelkins/buffon/blob/master/Data/Distribution/Buffon.hs"><strong>Haskell implementation</strong></a>. <a href="#fnref:66" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:67" role="doc-endnote">
      <p>Another algorithm for this function uses the <strong>general martingale algorithm</strong> with $g(\lambda)=\lambda$, $d_0 = 1$ and $a_i=(-1)^{i+1}/i$ (except $a_0 = 0$), but uses more bits on average as <em>λ</em> approaches 1. <a href="#fnref:67" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:68" role="doc-endnote">
      <p>Forsythe, G.E., “Von Neumann’s Comparison Method for Random Sampling from the Normal and Other Distributions”, <em>Mathematics of Computation</em> 26(120), October 1972. <a href="#fnref:68" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:68:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a></p>
    </li>
    <li id="fn:69" role="doc-endnote">
      <p>Sondow, Jonathan. “New Vacca-Type Rational Series for Euler’s Constant and Its ‘Alternating’ Analog ln 4/<em>π</em>.”, 2005. <a href="#fnref:69" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:70" role="doc-endnote">
      <p>It can also be said that the integral (see “<a href="#Integrals"><strong>Integrals</strong></a>”) of <em>x</em> − floor(1/<em>x</em>), where <em>x</em> is greater than 0 but not greater than 1, equals 1 minus <em>γ</em>.  See, for example, Havil, J., <em>Gamma: Exploring Euler’s Constant</em>, 2003. <a href="#fnref:70" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:71" role="doc-endnote">
      <p>Fishman, D., Miller, S.J., “Closed Form Continued Fraction Expansions of Special Quadratic Irrationals”, ISRN Combinatorics Vol. 2013, Article ID 414623 (2013). <a href="#fnref:71" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:72" role="doc-endnote">
      <p>von Neumann, J., “Various techniques used in connection with random digits”, 1951. <a href="#fnref:72" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:72:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a></p>
    </li>
    <li id="fn:73" role="doc-endnote">
      <p>Pae, S., “Random number generation using a biased source”, dissertation, University of Illinois at Urbana-Champaign, 2005. <a href="#fnref:73" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:74" role="doc-endnote">
      <p>Peres, Y., “Iterating von Neumann’s procedure for extracting random bits”, Annals of Statistics 1992,20,1, p. 590-597. <a href="#fnref:74" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:75" role="doc-endnote">
      <p>Monahan, J.. “Extensions of von Neumann’s method for generating random variables.” Mathematics of Computation 33 (1979): 1065-1069. <a href="#fnref:75" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>
</div><nav id="navigation"><ul>
<li><a href="/">Back to start site.</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io">This site's repository (source code)</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io/issues">Post an issue or comment</a></ul>

<div class="noprint">
<p>
<a href="//twitter.com/intent/tweet">Share via Twitter</a>, <a href="//www.facebook.com/sharer/sharer.php" id="sharer">Share via Facebook</a>
</p>
</div>
<p style='font-size:120%;font-weight:bold'><a href='https://peteroupc.github.io/bernoulli.pdf'>Download a PDF of this page</a></p></nav></body></html>
