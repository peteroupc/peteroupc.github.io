<!DOCTYPE html><html xmlns:dc="http://purl.org/dc/terms/"><head><meta http-equiv=Content-Type content="text/html; charset=utf-8"><title>com.upokecenter.cbor.JSONOptions.ConversionMode</title><meta name="viewport" content="width=device-width"><link rel=stylesheet type="text/css" href="/style.css">
            <script type="text/x-mathjax-config"> MathJax.Hub.Config({"HTML-CSS": { availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, preferredFont: "TeX" },
                    tex2jax: { displayMath: [ ["$$","$$"], ["\\[", "\\]"] ], inlineMath: [ ["$", "$"], ["\\\\(","\\\\)"] ], processEscapes: true } });
            </script><script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"></script></head><body>  <div class="header">
<nav><p><a href="#navigation">Menu</a> - <a href="#top">Top</a> - <a href="/">Home</a></nav></div>
<div class="mainarea" id="top">
<h1>com.upokecenter.cbor.JSONOptions.ConversionMode</h1>

<h1>com.upokecenter.cbor.JSONOptions.ConversionMode</h1>

<h2>Nested Classes</h2>

<h2>Enum Constants</h2>

<ul>
<li><code>Decimal128 CBORObject.FromObject(EDecimal)</code><br>
JSON numbers are decoded to CBOR as their closest-rounded approximation to
an IEEE 854 decimal128 value, using the
round-to-nearest/ties-to-even rounding mode and the rules for the
EDecimal form of that approximation as given in the
CBORObject.FromObject(EDecimal) method.</li>
<li><code>Double</code><br>
JSON numbers are decoded to CBOR as their closest-rounded approximation as
64-bit binary floating-point numbers (using the
round-to-nearest/ties-to-even rounding mode).</li>
<li><code>Full</code><br>
JSON numbers are decoded to CBOR using the full precision given in the JSON
text.</li>
<li><code>IntOrFloat</code><br>
A JSON number is decoded to CBOR objects either as a CBOR integer (major
type 0 or 1) if the JSON number represents an integer at least
-(2^53)+1 and less than 2^53, or as their closest-rounded
approximation as 64-bit binary floating-point numbers (using the
round-to-nearest/ties-to-even rounding mode) otherwise.</li>
<li><code>IntOrFloatFromDouble</code><br>
A JSON number is decoded to CBOR objects either as a CBOR integer (major
type 0 or 1) if the number&#39;s closest-rounded approximation as a
64-bit binary floating-point number (using the
round-to-nearest/ties-to-even rounding mode) represents an
integer at least -(2^53)+1 and less than 2^53, or as that
approximation otherwise.</li>
</ul>

<h2>Methods</h2>

<ul>
<li><code>static JSONOptions.ConversionMode valueOf​(java.lang.String name)</code><br>
Returns the enum constant of this type with the specified name.</li>
<li><code>static JSONOptions.ConversionMode[] values()</code><br>
Returns an array containing the constants of this enum type, in
the order they are declared.</li>
</ul>

<h2>Enum Constant Details</h2>

<h3><a id='Full'>Full</a></h3>

<p>JSON numbers are decoded to CBOR using the full precision given in the JSON
 text. The number will be converted to a CBOR object as follows:
 If the number&#39;s exponent is 0 (after shifting the decimal point
 to the end of the number without changing its value), use the
 rules given in the <code>CBORObject.FromObject(EInteger)</code> method;
 otherwise, use the rules given in the
 <code>CBORObject.FromObject(EDecimal)</code> method. An exception in
 version 4.x involves negative zeros; if the negative zero&#39;s
 exponent is 0, it&#39;s written as a CBOR floating-point number;
 otherwise the negative zero is written as an EDecimal.</p>

<h3><a id='Double'>Double</a></h3>

<p>JSON numbers are decoded to CBOR as their closest-rounded approximation as
 64-bit binary floating-point numbers (using the
 round-to-nearest/ties-to-even rounding mode). (In some cases,
 numbers extremely close to zero may underflow to positive or
 negative zero, and numbers of extremely large absolute value may
 overflow to infinity.). It&#39;s important to note that this mode
 affects only how JSON numbers are <i>decoded</i> to a CBOR
 object; it doesn&#39;t affect how <code>EncodeToBytes</code> and other
 methods encode CBOR objects. Notably, by default,
 <code>EncodeToBytes</code> encodes CBOR floating-point values to the
  CBOR format in their 16-bit (&quot;half-float&quot;), 32-bit
  (&quot;single-precision&quot;), or 64-bit (&quot;double-precision&quot;) encoding
 form depending on the value.</p>

<h3><a id='IntOrFloat'>IntOrFloat</a></h3>

<p>A JSON number is decoded to CBOR objects either as a CBOR integer (major
 type 0 or 1) if the JSON number represents an integer at least
 -(2^53)+1 and less than 2^53, or as their closest-rounded
 approximation as 64-bit binary floating-point numbers (using the
 round-to-nearest/ties-to-even rounding mode) otherwise. For
 example, the JSON number 0.99999999999999999999999999999999999 is
 not an integer, so it&#39;s converted to its closest 64-bit binary
 floating-point approximation, namely 1.0. (In some cases, numbers
 extremely close to zero may underflow to positive or negative
 zero, and numbers of extremely large absolute value may overflow
 to infinity.). It&#39;s important to note that this mode affects only
 how JSON numbers are <i>decoded</i> to a CBOR object; it doesn&#39;t
 affect how <code>EncodeToBytes</code> and other methods encode CBOR
 objects. Notably, by default, <code>EncodeToBytes</code> encodes CBOR
 floating-point values to the CBOR format in their 16-bit
  (&quot;half-float&quot;), 32-bit (&quot;single-precision&quot;), or 64-bit
  (&quot;double-precision&quot;) encoding form depending on the value.</p>

<h3><a id='IntOrFloatFromDouble'>IntOrFloatFromDouble</a></h3>

<p>A JSON number is decoded to CBOR objects either as a CBOR integer (major
 type 0 or 1) if the number&#39;s closest-rounded approximation as a
 64-bit binary floating-point number (using the
 round-to-nearest/ties-to-even rounding mode) represents an
 integer at least -(2^53)+1 and less than 2^53, or as that
 approximation otherwise. For example, the JSON number
 0.99999999999999999999999999999999999 is the integer 1 when
 rounded to its closest 64-bit binary floating-point approximation
 (1.0), so it&#39;s converted to the CBOR integer 1 (major type 0).
 (In some cases, numbers extremely close to zero may underflow to
 zero, and numbers of extremely large absolute value may overflow
 to infinity.). It&#39;s important to note that this mode affects only
 how JSON numbers are <i>decoded</i> to a CBOR object; it doesn&#39;t
 affect how <code>EncodeToBytes</code> and other methods encode CBOR
 objects. Notably, by default, <code>EncodeToBytes</code> encodes CBOR
 floating-point values to the CBOR format in their 16-bit
  (&quot;half-float&quot;), 32-bit (&quot;single-precision&quot;), or 64-bit
  (&quot;double-precision&quot;) encoding form depending on the value.</p>

<h3><a id='Decimal128'>Decimal128</a></h3>

<p>JSON numbers are decoded to CBOR as their closest-rounded approximation to
 an IEEE 854 decimal128 value, using the
 round-to-nearest/ties-to-even rounding mode and the rules for the
 EDecimal form of that approximation as given in the
 <code>CBORObject.FromObject(EDecimal)</code> method. (In some cases,
 numbers extremely close to zero may underflow to zero, and
 numbers of extremely large absolute value may overflow to
 infinity.).</p>

<h2>Method Details</h2>

<h3><a id='values()'>values</a></h3>

<h3><a id='valueOf(java.lang.String)'>valueOf</a></h3>

<p><a href="/CBOR/">Back to CBOR start page.</a></p>
</div><nav id="navigation"><ul>
<li><a href="/">Back to start site.</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io">This site's repository (source code)</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io/issues">Post an issue or comment</a></ul>

<div class="noprint">
<p>
<a href="//twitter.com/intent/tweet">Share via Twitter</a>, <a href="//www.facebook.com/sharer/sharer.php" id="sharer">Share via Facebook</a>
</p>
</div>
</nav><script>
 document.getElementById("sharer").href="//www.facebook.com/sharer/sharer.php?u="+
    encodeURIComponent(document.location.href)
</script>
</body></html>
