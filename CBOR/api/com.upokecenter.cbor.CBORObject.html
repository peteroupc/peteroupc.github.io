<!DOCTYPE html><html xmlns:dc="http://purl.org/dc/terms/"><head><meta http-equiv=Content-Type content="text/html; charset=utf-8"><title>com.upokecenter.cbor.CBORObject</title><meta name="viewport" content="width=device-width"><link rel=stylesheet type="text/css" href="/style.css">
            <script type="text/x-mathjax-config"> MathJax.Hub.Config({"HTML-CSS": { availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, preferredFont: "TeX" },
                    tex2jax: { displayMath: [ ["$$","$$"], ["\\[", "\\]"] ], inlineMath: [ ["$", "$"], ["\\\\(","\\\\)"] ], processEscapes: true } });
            </script><script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"></script></head><body>  <div class="header">
<nav><p><a href="#navigation">Menu</a> - <a href="#top">Top</a> - <a href="/">Home</a></nav></div>
<div class="mainarea" id="top">
<h1>com.upokecenter.cbor.CBORObject</h1>

<h1>com.upokecenter.cbor.CBORObject</h1>

<h2>Fields</h2>

<ul>
<li><code>static CBORObject False</code><br>
Represents the value false.</li>
<li><code>static CBORObject NaN</code><br>
A not-a-number value.</li>
<li><code>static CBORObject NegativeInfinity</code><br>
The value negative infinity.</li>
<li><code>static CBORObject Null</code><br>
Represents the value null.</li>
<li><code>static CBORObject PositiveInfinity</code><br>
The value positive infinity.</li>
<li><code>static CBORObject True</code><br>
Represents the value true.</li>
<li><code>static CBORObject Undefined</code><br>
Represents the value undefined.</li>
<li><code>static CBORObject Zero</code><br>
Gets a CBOR object for the number zero.</li>
</ul>

<h2>Methods</h2>

<ul>
<li><code>CBORObject Abs()</code><br>
Deprecated.
Instead, convert this object to a number (with .getAsNumber()()),
and use that number&#39;s.getAbs()() method.
Instead, convert this object to a number (with .getAsNumber()()),
and use that number&#39;s.getAbs()() method.</li>
<li><code>CBORObject Add​(CBORObject obj)</code><br>
Adds a new object to the end of this array.</li>
<li><code>CBORObject Add​(java.lang.Object obj)</code><br>
Converts an object to a CBOR object and adds it to the end of this
array.</li>
<li><code>CBORObject Add​(java.lang.Object key,
java.lang.Object valueOb)</code><br>
Adds a new key and its value to this CBOR map, or adds the value if the
key doesn&#39;t exist.</li>
<li><code>static CBORObject Addition​(CBORObject first,
CBORObject second)</code><br>
Deprecated.
Instead, convert both CBOR objects to numbers (with .AsNumber()), and
use the first number&#39;s.Add() method.
Instead, convert both CBOR objects to numbers (with .AsNumber()), and
use the first number&#39;s.Add() method.</li>
<li><code>CBORObject ApplyJSONPatch​(CBORObject patch)</code><br>
Returns a copy of this object after applying the operations in a JSON patch,
in the form of a CBOR object.</li>
<li><code>boolean AsBoolean()</code><br>
Returns false if this object is a CBOR false, null, or undefined value
(whether or not the object has tags); otherwise, true.</li>
<li><code>byte AsByte()</code><br>
Deprecated.
Instead, use.getToObject()&lt;byte&gt;() in .NET or
.getToObject()(Byte.class) in Java.
Instead, use.getToObject()&lt;byte&gt;() in .NET or
.getToObject()(Byte.class) in Java.</li>
<li><code>double AsDouble()</code><br>
Converts this object to a 64-bit floating point number.</li>
<li><code>long AsDoubleBits()</code><br>
Converts this object to the bits of a 64-bit floating-point number if this
CBOR object&#39;s type is FloatingPoint.</li>
<li><code>double AsDoubleValue()</code><br>
Converts this object to a 64-bit floating-point number if this CBOR object&#39;s
type is FloatingPoint.</li>
<li><code>com.upokecenter.numbers.EDecimal AsEDecimal()</code><br>
Deprecated.
Instead, use.getToObject()&lt;PeterO.Numbers.EDecimal&gt;()
in .NET or
.getToObject()(com.upokecenter.numbers.EDecimal.class)
in Java.
Instead, use.getToObject()&lt;PeterO.Numbers.EDecimal&gt;()
in .NET or
.getToObject()(com.upokecenter.numbers.EDecimal.class)
in Java.</li>
<li><code>com.upokecenter.numbers.EFloat AsEFloat()</code><br>
Deprecated.
Instead, use.getToObject()&lt;PeterO.Numbers.EFloat&gt;() in.NET
or  .getToObject()(com.upokecenter.numbers.EFloat.class)
in Java.
Instead, use.getToObject()&lt;PeterO.Numbers.EFloat&gt;() in.NET
or  .getToObject()(com.upokecenter.numbers.EFloat.class)
in Java.</li>
<li><code>com.upokecenter.numbers.EInteger AsEInteger()</code><br>
Deprecated.
Instead, use.getToObject()&lt;PeterO.Numbers.EInteger&gt;()
in .NET or
.getToObject()(com.upokecenter.numbers.EInteger.class)
in Java.
Instead, use.getToObject()&lt;PeterO.Numbers.EInteger&gt;()
in .NET or
.getToObject()(com.upokecenter.numbers.EInteger.class)
in Java.</li>
<li><code>com.upokecenter.numbers.EInteger AsEIntegerValue()</code><br>
Converts this object to an arbitrary-precision integer if this CBOR object&#39;s
type is Integer.</li>
<li><code>com.upokecenter.numbers.ERational AsERational()</code><br>
Deprecated.
Instead, use.getToObject()&lt;PeterO.Numbers.ERational&gt;() in
.NET or.getToObject()(com.upokecenter.numbers.ERational.class)
in Java.
Instead, use.getToObject()&lt;PeterO.Numbers.ERational&gt;() in
.NET or.getToObject()(com.upokecenter.numbers.ERational.class)
in Java.</li>
<li><code>short AsInt16()</code><br>
Deprecated.
Instead, use the following: (cbor.AsNumber().ToInt16Checked()),
or .getToObject()&lt;short&gt;() in .NET.
Instead, use the following: (cbor.AsNumber().ToInt16Checked()),
or .getToObject()&lt;short&gt;() in .NET.</li>
<li><code>int AsInt32()</code><br>
Converts this object to a 32-bit signed integer.</li>
<li><code>int AsInt32Value()</code><br>
Converts this object to a 32-bit signed integer if this CBOR object&#39;s type
is Integer.</li>
<li><code>long AsInt64()</code><br>
Deprecated.
Instead, use the following: (cbor.AsNumber().ToInt64Checked()), or
.ToObject&lt;long&gt;() in.NET.
Instead, use the following: (cbor.AsNumber().ToInt64Checked()), or
.ToObject&lt;long&gt;() in.NET.</li>
<li><code>long AsInt64Value()</code><br>
Converts this object to a 64-bit signed integer if this CBOR object&#39;s type
is Integer.</li>
<li><code>CBORNumber AsNumber()</code><br>
Converts this object to a CBOR number.</li>
<li><code>float AsSingle()</code><br>
Converts this object to a 32-bit floating point number.</li>
<li><code>java.lang.String AsString()</code><br>
Gets the value of this object as a text string.</li>
<li><code>CBORObject AtJSONPointer​(java.lang.String pointer)</code><br>
Gets the CBOR object referred to by a JSON Pointer according to RFC6901.</li>
<li><code>CBORObject AtJSONPointer​(java.lang.String pointer,
CBORObject defaultValue)</code><br>
Gets the CBOR object referred to by a JSON Pointer according to RFC6901, or
a default value if the operation fails.</li>
<li><code>long CalcEncodedSize() EncodeToBytes()</code><br>
Calculates the number of bytes this CBOR object takes when serialized as a
byte array using the EncodeToBytes() method.</li>
<li><code>boolean CanFitInDouble()</code><br>
Deprecated.
Instead, use the following: (cbor.isNumber()
&amp;&amp; cbor.AsNumber().CanFitInDouble()).
Instead, use the following: (cbor.isNumber()
&amp;&amp; cbor.AsNumber().CanFitInDouble()).</li>
<li><code>boolean CanFitInInt32()</code><br>
Deprecated.
Instead, use.CanValueFitInInt32(), if the application allows only CBOR
integers, or (cbor.isNumber()
&amp;&amp;cbor.AsNumber().CanFitInInt32()),   if the application
allows any CBOR Object convertible to an integer.
Instead, use.CanValueFitInInt32(), if the application allows only CBOR
integers, or (cbor.isNumber()
&amp;&amp;cbor.AsNumber().CanFitInInt32()),   if the application
allows any CBOR Object convertible to an integer.</li>
<li><code>boolean CanFitInInt64()</code><br>
Deprecated.
Instead, use CanValueFitInInt64(), if the application allows only CBOR
integers, or (cbor.isNumber()
&amp;&amp;cbor.AsNumber().CanFitInInt64()),   if the application
allows any CBOR Object convertible to an integer.
Instead, use CanValueFitInInt64(), if the application allows only CBOR
integers, or (cbor.isNumber()
&amp;&amp;cbor.AsNumber().CanFitInInt64()),   if the application
allows any CBOR Object convertible to an integer.</li>
<li><code>boolean CanFitInSingle()</code><br>
Deprecated.
Instead, use the following: (cbor.isNumber()
&amp;&amp; cbor.AsNumber().CanFitInSingle()).
Instead, use the following: (cbor.isNumber()
&amp;&amp; cbor.AsNumber().CanFitInSingle()).</li>
<li><code>boolean CanTruncatedIntFitInInt32()</code><br>
Deprecated.
Instead, use the following: (cbor.CanValueFitInInt32() if only
integers of any tag are allowed, or (cbor.isNumber()
&amp;&amp; cbor.AsNumber().CanTruncatedIntFitInInt32()).
Instead, use the following: (cbor.CanValueFitInInt32() if only
integers of any tag are allowed, or (cbor.isNumber()
&amp;&amp; cbor.AsNumber().CanTruncatedIntFitInInt32()).</li>
<li><code>boolean CanTruncatedIntFitInInt64()</code><br>
Deprecated.
Instead, use the following: (cbor.CanValueFitInInt64() if only
integers of any tag are allowed, or (cbor.isNumber()
&amp;&amp; cbor.AsNumber().CanTruncatedIntFitInInt64()).
Instead, use the following: (cbor.CanValueFitInInt64() if only
integers of any tag are allowed, or (cbor.isNumber()
&amp;&amp; cbor.AsNumber().CanTruncatedIntFitInInt64()).</li>
<li><code>boolean CanValueFitInInt32()</code><br>
Returns whether this CBOR object stores an integer (CBORType.Integer) within
the range of a 32-bit signed integer.</li>
<li><code>boolean CanValueFitInInt64()</code><br>
Returns whether this CBOR object stores an integer (CBORType.Integer) within
the range of a 64-bit signed integer.</li>
<li><code>void Clear()</code><br>
Removes all items from this CBOR array or all keys and values from this CBOR
map.</li>
<li><code>int compareTo​(CBORObject other)</code><br>
Compares two CBOR objects.</li>
<li><code>int CompareToIgnoreTags​(CBORObject other)</code><br>
Compares this object and another CBOR object, ignoring the tags they have,
if any.</li>
<li><code>boolean ContainsKey​(CBORObject key)</code><br>
Determines whether a value of the given key exists in this object.</li>
<li><code>boolean ContainsKey​(java.lang.Object objKey)</code><br>
Determines whether a value of the given key exists in this object.</li>
<li><code>boolean ContainsKey​(java.lang.String key)</code><br>
Determines whether a value of the given key exists in this object.</li>
<li><code>static CBORObject DecodeFromBytes​(byte[] data)</code><br>
Generates a CBOR object from an array of CBOR-encoded bytes.</li>
<li><code>static CBORObject DecodeFromBytes​(byte[] data,
CBOREncodeOptions options) CBOREncodeOptions</code><br>
Generates a CBOR object from an array of CBOR-encoded bytes, using the given
CBOREncodeOptions object to control the decoding process.</li>
<li><code>static &lt;T&gt; T DecodeObjectFromBytes​(byte[] data,
CBOREncodeOptions enc,
java.lang.reflect.Type t) CBOREncodeOptions</code><br>
Generates an object of an arbitrary type from an array of CBOR-encoded
bytes, using the given CBOREncodeOptions object to control
the decoding process.</li>
<li><code>static &lt;T&gt; T DecodeObjectFromBytes​(byte[] data,
CBOREncodeOptions enc,
java.lang.reflect.Type t,
CBORTypeMapper mapper,
PODOptions pod) CBOREncodeOptions</code><br>
Generates an object of an arbitrary type from an array of CBOR-encoded
bytes, using the given CBOREncodeOptions object to control
the decoding process.</li>
<li><code>static &lt;T&gt; T DecodeObjectFromBytes​(byte[] data,
java.lang.reflect.Type t)</code><br>
Generates an object of an arbitrary type from an array of CBOR-encoded
bytes.</li>
<li><code>static &lt;T&gt; T DecodeObjectFromBytes​(byte[] data,
java.lang.reflect.Type t,
CBORTypeMapper mapper,
PODOptions pod)</code><br>
Generates an object of an arbitrary type from an array of CBOR-encoded
bytes.</li>
<li><code>static CBORObject[] DecodeSequenceFromBytes​(byte[] data)</code><br>
Generates a sequence of CBOR objects from an array of CBOR-encoded
bytes.</li>
<li><code>static CBORObject[] DecodeSequenceFromBytes​(byte[] data,
CBOREncodeOptions options)</code><br>
Generates a sequence of CBOR objects from an array of CBOR-encoded
bytes.</li>
<li><code>static CBORObject Divide​(CBORObject first,
CBORObject second)</code><br>
Deprecated.
Instead, convert both CBOR objects to numbers (with .AsNumber()), and
use the first number&#39;s.Divide() method.
Instead, convert both CBOR objects to numbers (with .AsNumber()), and
use the first number&#39;s.Divide() method.</li>
<li><code>byte[] EncodeToBytes()</code><br>
Writes the binary representation of this CBOR object and returns a byte
array of that representation.</li>
<li><code>byte[] EncodeToBytes​(CBOREncodeOptions options)</code><br>
Writes the binary representation of this CBOR object and returns a byte
array of that representation, using the specified options for
encoding the object to CBOR format.</li>
<li><code>boolean equals​(CBORObject other)</code><br>
Compares the equality of two CBOR objects.</li>
<li><code>boolean equals​(java.lang.Object obj)</code><br>
Determines whether this object and another object are equal and have the
same type.</li>
<li><code>static CBORObject FromFloatingPointBits​(long floatingBits,
int byteCount)</code><br>
Generates a CBOR object from a floating-point number represented by its
bits.</li>
<li><code>static CBORObject FromJSONBytes​(byte[] bytes)</code><br>
Generates a CBOR object from a byte array in JavaScript object Notation
(JSON) format.</li>
<li><code>static CBORObject FromJSONBytes​(byte[] bytes,
int offset,
int count)</code><br>
Generates a CBOR object from a byte array in JavaScript object Notation
(JSON) format.</li>
<li><code>static CBORObject FromJSONBytes​(byte[] bytes,
int offset,
int count,
JSONOptions jsonoptions)</code><br>
Generates a CBOR object from a byte array in JavaScript object Notation
(JSON) format, using the specified options to control the decoding
process.</li>
<li><code>static CBORObject FromJSONBytes​(byte[] bytes,
JSONOptions jsonoptions)</code><br>
Generates a CBOR object from a byte array in JavaScript object Notation
(JSON) format, using the specified options to control the decoding
process.</li>
<li><code>static CBORObject[] FromJSONSequenceBytes​(byte[] bytes)</code><br>
Generates a list of CBOR objects from an array of bytes in JavaScript object
Notation (JSON) text sequence format (RFC 7464).</li>
<li><code>static CBORObject[] FromJSONSequenceBytes​(byte[] data,
JSONOptions options)</code><br>
Generates a list of CBOR objects from an array of bytes in JavaScript object
Notation (JSON) text sequence format (RFC 7464), using the specified
options to control the decoding process.</li>
<li><code>static CBORObject FromJSONString​(java.lang.String str)</code><br>
Generates a CBOR object from a text string in JavaScript object Notation
(JSON) format.</li>
<li><code>static CBORObject FromJSONString​(java.lang.String str,
int offset,
int count)</code><br>
Generates a CBOR object from a text string in JavaScript object Notation
(JSON) format.</li>
<li><code>static CBORObject FromJSONString​(java.lang.String str,
int offset,
int count,
JSONOptions jsonoptions)</code><br>
Generates a CBOR object from a text string in JavaScript object Notation
(JSON) format, using the specified options to control the decoding
process.</li>
<li><code>static CBORObject FromJSONString​(java.lang.String str,
CBOREncodeOptions options)</code><br>
Deprecated.
Instead, use.getFromJSONString()(str,
new JSONOptions(\allowduplicatekeys = true))
or .getFromJSONString()(str,   new
JSONOptions(\allowduplicatekeys = false)), as appropriate.
Instead, use.getFromJSONString()(str,
new JSONOptions(\allowduplicatekeys = true))
or .getFromJSONString()(str,   new
JSONOptions(\allowduplicatekeys = false)), as appropriate.</li>
<li><code>static CBORObject FromJSONString​(java.lang.String str,
JSONOptions jsonoptions)</code><br>
Generates a CBOR object from a text string in JavaScript object Notation
(JSON) format, using the specified options to control the decoding
process.</li>
<li><code>static CBORObject FromObject​(boolean value)</code><br>
Returns the CBOR true value or false value, depending on &quot;value&quot;.</li>
<li><code>static CBORObject FromObject​(byte value)</code><br>
Generates a CBOR object from a byte (0 to 255).</li>
<li><code>static CBORObject FromObject​(byte[] bytes)</code><br>
Generates a CBOR object from an array of 8-bit bytes; the byte array is
copied to a new byte array in this process.</li>
<li><code>static CBORObject FromObject​(double value)</code><br>
Generates a CBOR object from a 64-bit floating-point number.</li>
<li><code>static CBORObject FromObject​(float value)</code><br>
Generates a CBOR object from a 32-bit floating-point number.</li>
<li><code>static CBORObject FromObject​(int value)</code><br>
Generates a CBOR object from a 32-bit signed integer.</li>
<li><code>static CBORObject FromObject​(int[] array)</code><br>
Generates a CBOR object from an array of 32-bit integers.</li>
<li><code>static CBORObject FromObject​(long value)</code><br>
Generates a CBOR object from a 64-bit signed integer.</li>
<li><code>static CBORObject FromObject​(long[] array)</code><br>
Generates a CBOR object from an array of 64-bit integers.</li>
<li><code>static CBORObject FromObject​(short value)</code><br>
Generates a CBOR object from a 16-bit signed integer.</li>
<li><code>static CBORObject FromObject​(CBORObject value)</code><br>
Generates a CBOR object from a CBOR object.</li>
<li><code>static CBORObject FromObject​(CBORObject[] array)</code><br>
Generates a CBOR object from an array of CBOR objects.</li>
<li><code>static CBORObject FromObject​(com.upokecenter.numbers.EDecimal bigValue)</code><br>
Generates a CBOR object from a decimal number.</li>
<li><code>static CBORObject FromObject​(com.upokecenter.numbers.EFloat bigValue)</code><br>
Generates a CBOR object from an arbitrary-precision binary floating-point
number.</li>
<li><code>static CBORObject FromObject​(com.upokecenter.numbers.EInteger bigintValue)</code><br>
Generates a CBOR object from an arbitrary-precision integer.</li>
<li><code>static CBORObject FromObject​(com.upokecenter.numbers.ERational bigValue)</code><br>
Generates a CBOR object from an arbitrary-precision rational number.</li>
<li><code>static CBORObject FromObject​(java.lang.Object obj)</code><br>
Generates a CBORObject from an arbitrary object.</li>
<li><code>static CBORObject FromObject​(java.lang.Object obj,
CBORTypeMapper mapper)</code><br>
Generates a CBORObject from an arbitrary object.</li>
<li><code>static CBORObject FromObject​(java.lang.Object obj,
CBORTypeMapper mapper,
PODOptions options)</code><br>
Generates a CBORObject from an arbitrary object, using the given options
to control how certain objects are converted to CBOR objects.</li>
<li><code>static CBORObject FromObject​(java.lang.Object obj,
PODOptions options)</code><br>
Generates a CBORObject from an arbitrary object.</li>
<li><code>static CBORObject FromObject​(java.lang.String strValue)</code><br>
Generates a CBOR object from a text string.</li>
<li><code>static CBORObject FromObjectAndTag​(java.lang.Object valueObValue,
int smallTag)</code><br>
Generates a CBOR object from an arbitrary object and gives the resulting
object a tag in addition to its existing tags (the new tag is made
the outermost tag).</li>
<li><code>static CBORObject FromObjectAndTag​(java.lang.Object valueOb,
com.upokecenter.numbers.EInteger bigintTag)</code><br>
Generates a CBOR object from an arbitrary object and gives the resulting
object a tag in addition to its existing tags (the new tag is made
the outermost tag).</li>
<li><code>static CBORObject FromSimpleValue​(int simpleValue)</code><br>
Creates a CBOR object from a simple value number.</li>
<li><code>CBORObject get​(int index)</code><br>
Gets the value of a CBOR object by integer index in this array or by integer
key in this map.</li>
<li><code>CBORObject get​(CBORObject key)</code><br>
Gets the value of a CBOR object by integer index in this array or by CBOR
object key in this map.</li>
<li><code>CBORObject get​(java.lang.String key)</code><br>
Gets the value of a CBOR object in this map, using a string as the key.</li>
<li><code>com.upokecenter.numbers.EInteger[] GetAllTags()</code><br>
Gets a list of all tags, from outermost to innermost.</li>
<li><code>byte[] GetByteString()</code><br>
Gets the backing byte array used in this CBOR object, if this object is a
byte string, without copying the data to a new byte array.</li>
<li><code>java.util.Collection&lt;java.util.Map.Entry&lt;CBORObject,​CBORObject&gt;&gt; getEntries()</code><br>
Gets a collection of the key/value pairs stored in this CBOR object, if it&#39;s
a map.</li>
<li><code>java.util.Collection&lt;CBORObject&gt; getKeys()</code><br>
Gets a collection of the keys of this CBOR object.</li>
<li><code>com.upokecenter.numbers.EInteger getMostInnerTag()</code><br>
Gets the last defined tag for this CBOR data item, or -1 if the item is
untagged.</li>
<li><code>com.upokecenter.numbers.EInteger getMostOuterTag()</code><br>
Gets the outermost tag for this CBOR data item, or -1 if the item is
untagged.</li>
<li><code>CBORObject GetOrDefault​(java.lang.Object key,
CBORObject defaultValue)</code><br>
Gets the value of a CBOR object by integer index in this array or by CBOR
object key in this map, or a default value if that value is not
found.</li>
<li><code>int getSimpleValue()</code><br>
Gets the simple value ID of this CBOR object, or -1 if the object is not a
simple value.</li>
<li><code>int getTagCount()</code><br>
Gets the number of tags this object has.</li>
<li><code>CBORType getType()</code><br>
Gets the general data type of this CBOR object.</li>
<li><code>java.util.Collection&lt;CBORObject&gt; getValues()</code><br>
Gets a collection of the values of this CBOR object, if it&#39;s a map or an
array.</li>
<li><code>int hashCode()</code><br>
Calculates the hash code of this object.</li>
<li><code>boolean HasMostInnerTag​(int tagValue)</code><br>
Returns whether this object has an innermost tag and that tag is of the
given number.</li>
<li><code>boolean HasMostInnerTag​(com.upokecenter.numbers.EInteger bigTagValue)</code><br>
Returns whether this object has an innermost tag and that tag is of the
given number, expressed as an arbitrary-precision number.</li>
<li><code>boolean HasMostOuterTag​(int tagValue)</code><br>
Returns whether this object has an outermost tag and that tag is of the
given number.</li>
<li><code>boolean HasMostOuterTag​(com.upokecenter.numbers.EInteger bigTagValue)</code><br>
Returns whether this object has an outermost tag and that tag is of the
given number.</li>
<li><code>boolean HasOneTag()</code><br>
Returns whether this object has only one tag.</li>
<li><code>boolean HasOneTag​(int tagValue)</code><br>
Returns whether this object has only one tag and that tag is the given
number.</li>
<li><code>boolean HasOneTag​(com.upokecenter.numbers.EInteger bigTagValue)</code><br>
Returns whether this object has only one tag and that tag is the given
number, expressed as an arbitrary-precision integer.</li>
<li><code>boolean HasTag​(int tagValue)</code><br>
Returns whether this object has a tag of the given number.</li>
<li><code>boolean HasTag​(com.upokecenter.numbers.EInteger bigTagValue)</code><br>
Returns whether this object has a tag of the given number.</li>
<li><code>CBORObject Insert​(int index,
java.lang.Object valueOb)</code><br>
Inserts an object at the specified position in this CBOR array.</li>
<li><code>boolean isFalse()</code><br>
Gets a value indicating whether this value is a CBOR false value, whether
tagged or not.</li>
<li><code>boolean isFinite()</code><br>
Deprecated.
Instead, use the following: (cbor.isNumber()
&amp;&amp; cbor.AsNumber().IsFinite()).
Instead, use the following: (cbor.isNumber()
&amp;&amp; cbor.AsNumber().IsFinite()).</li>
<li><code>boolean IsInfinity()</code><br>
Deprecated.
Instead, use the following: (cbor.isNumber()
&amp;&amp; cbor.AsNumber().IsInfinity()).
Instead, use the following: (cbor.isNumber()
&amp;&amp; cbor.AsNumber().IsInfinity()).</li>
<li><code>boolean isIntegral()</code><br>
Deprecated.
Instead, use the following: (cbor.isNumber()
&amp;&amp; cbor.AsNumber().IsInteger()).
Instead, use the following: (cbor.isNumber()
&amp;&amp; cbor.AsNumber().IsInteger()).</li>
<li><code>boolean IsNaN()</code><br>
Deprecated.
Instead, use the following: (cbor.isNumber()
&amp;&amp; cbor.AsNumber().IsNaN()).
Instead, use the following: (cbor.isNumber()
&amp;&amp; cbor.AsNumber().IsNaN()).</li>
<li><code>boolean isNegative()</code><br>
Deprecated.
Instead, use (cbor.IsNumber()
&amp;&amp; cbor.AsNumber().IsNegative()).
Instead, use (cbor.IsNumber()
&amp;&amp; cbor.AsNumber().IsNegative()).</li>
<li><code>boolean IsNegativeInfinity()</code><br>
Deprecated.
Instead, use the following: (cbor.isNumber()
&amp;&amp; cbor.AsNumber().IsNegativeInfinity()).
Instead, use the following: (cbor.isNumber()
&amp;&amp; cbor.AsNumber().IsNegativeInfinity()).</li>
<li><code>boolean isNull()</code><br>
Gets a value indicating whether this CBOR object is a CBOR null value,
whether tagged or not.</li>
<li><code>boolean isNumber()</code><br>
Gets a value indicating whether this CBOR object stores a number (including
infinity or a not-a-number or NaN value).</li>
<li><code>boolean IsPositiveInfinity()</code><br>
Deprecated.
Instead, use the following: (cbor.isNumber()
&amp;&amp; cbor.AsNumber().IsPositiveInfinity()).
Instead, use the following: (cbor.isNumber()
&amp;&amp; cbor.AsNumber().IsPositiveInfinity()).</li>
<li><code>boolean isTagged()</code><br>
Gets a value indicating whether this data item has at least one tag.</li>
<li><code>boolean isTrue()</code><br>
Gets a value indicating whether this value is a CBOR true value, whether
tagged or not.</li>
<li><code>boolean isUndefined()</code><br>
Gets a value indicating whether this value is a CBOR undefined value,
whether tagged or not.</li>
<li><code>boolean isZero()</code><br>
Deprecated.
Instead, use the following: (cbor.isNumber()
&amp;&amp; cbor.AsNumber().IsZero()).
Instead, use the following: (cbor.isNumber()
&amp;&amp; cbor.AsNumber().IsZero()).</li>
<li><code>static CBORObject Multiply​(CBORObject first,
CBORObject second)</code><br>
Deprecated.
Instead, convert both CBOR objects to numbers (with .AsNumber()), and
use the first number&#39;s.Multiply() method.
Instead, convert both CBOR objects to numbers (with .AsNumber()), and
use the first number&#39;s.Multiply() method.</li>
<li><code>CBORObject Negate()</code><br>
Deprecated.
Instead, convert this object to a number (with .AsNumber()), and
use that number&#39;s.Negate() method.
Instead, convert this object to a number (with .AsNumber()), and
use that number&#39;s.Negate() method.</li>
<li><code>static CBORObject NewArray()</code><br>
Creates a new empty CBOR array.</li>
<li><code>static CBORObject NewMap()</code><br>
Creates a new empty CBOR map that stores its keys in an undefined order.</li>
<li><code>static CBORObject NewOrderedMap()</code><br>
Creates a new empty CBOR map that ensures that keys are stored in the order
in which they are first inserted.</li>
<li><code>static CBORObject Read​(java.io.InputStream stream)</code><br>
Reads an object in CBOR format from a data stream.</li>
<li><code>static CBORObject Read​(java.io.InputStream stream,
CBOREncodeOptions options)</code><br>
Reads an object in CBOR format from a data stream, using the specified
options to control the decoding process.</li>
<li><code>static CBORObject ReadJSON​(java.io.InputStream stream)</code><br>
Generates a CBOR object from a data stream in JavaScript object Notation
(JSON) format.</li>
<li><code>static CBORObject ReadJSON​(java.io.InputStream stream,
CBOREncodeOptions options)</code><br>
Deprecated.
Instead, use.getReadJSON()(stream,
new JSONOptions(\allowduplicatekeys = true))
or .getReadJSON()(stream,
new JSONOptions(\allowduplicatekeys = false)),
as appropriate.
Instead, use.getReadJSON()(stream,
new JSONOptions(\allowduplicatekeys = true))
or .getReadJSON()(stream,
new JSONOptions(\allowduplicatekeys = false)),
as appropriate.</li>
<li><code>static CBORObject ReadJSON​(java.io.InputStream stream,
JSONOptions jsonoptions)</code><br>
Generates a CBOR object from a data stream in JavaScript object Notation
(JSON) format, using the specified options to control the decoding
process.</li>
<li><code>static CBORObject[] ReadJSONSequence​(java.io.InputStream stream)</code><br>
Generates a list of CBOR objects from a data stream in JavaScript object
Notation (JSON) text sequence format (RFC 7464).</li>
<li><code>static CBORObject[] ReadJSONSequence​(java.io.InputStream stream,
JSONOptions jsonoptions)</code><br>
Generates a list of CBOR objects from a data stream in JavaScript object
Notation (JSON) text sequence format (RFC 7464).</li>
<li><code>static CBORObject[] ReadSequence​(java.io.InputStream stream)</code><br>
Reads a sequence of objects in CBOR format from a data stream.</li>
<li><code>static CBORObject[] ReadSequence​(java.io.InputStream stream,
CBOREncodeOptions options)</code><br>
Reads a sequence of objects in CBOR format from a data stream.</li>
<li><code>static CBORObject Remainder​(CBORObject first,
CBORObject second)</code><br>
Deprecated.
Instead, convert both CBOR objects to numbers (with .AsNumber()), and
use the first number&#39;s.Remainder() method.
Instead, convert both CBOR objects to numbers (with .AsNumber()), and
use the first number&#39;s.Remainder() method.</li>
<li><code>boolean Remove​(CBORObject obj)</code><br>
If this object is an array, removes the first instance of the specified item
from the array.</li>
<li><code>boolean Remove​(java.lang.Object obj)</code><br>
If this object is an array, removes the first instance of the specified item
(once converted to a CBOR object) from the array.</li>
<li><code>boolean RemoveAt​(int index)</code><br>
Removes the item at the given index of this CBOR array.</li>
<li><code>void set​(int index,
CBORObject value)</code><br>
Sets the value of a CBOR object by integer index in this array or by integer
key in this map.</li>
<li><code>void set​(CBORObject key,
CBORObject value)</code><br>
Sets the value of a CBOR object by integer index in this array or by CBOR
object key in this map.</li>
<li><code>void set​(java.lang.String key,
CBORObject value)</code><br>
Sets the value of a CBOR object in this map, using a string as the key.</li>
<li><code>CBORObject Set​(java.lang.Object key,
java.lang.Object valueOb)</code><br>
Maps an object to a key in this CBOR map, or adds the value if the key
doesn&#39;t exist.</li>
<li><code>int signum()</code><br>
Deprecated.
Instead, convert this object to a number with.AsNumber(),   and use the
Sign property in.NET or the signum method in Java.
Instead, convert this object to a number with.AsNumber(),   and use the
Sign property in.NET or the signum method in Java.</li>
<li><code>int size()</code><br>
Gets the number of keys in this map, or the number of items in this array,
or 0 if this item is neither an array nor a map.</li>
<li><code>static CBORObject Subtract​(CBORObject first,
CBORObject second)</code><br>
Deprecated.
Instead, convert both CBOR objects to numbers (with .AsNumber()), and
use the first number&#39;s.Subtract() method.
Instead, convert both CBOR objects to numbers (with .AsNumber()), and
use the first number&#39;s.Subtract() method.</li>
<li><code>byte[] ToJSONBytes()</code><br>
Converts this object to a byte array in JavaScript object Notation (JSON)
format.</li>
<li><code>byte[] ToJSONBytes​(JSONOptions jsonoptions)</code><br>
Converts this object to a byte array in JavaScript object Notation (JSON)
format.</li>
<li><code>java.lang.String ToJSONString()</code><br>
Converts this object to a text string in JavaScript object Notation (JSON)
format.</li>
<li><code>java.lang.String ToJSONString​(JSONOptions options)</code><br>
Converts this object to a text string in JavaScript object Notation (JSON)
format, using the specified options to control the encoding process.</li>
<li><code>&lt;T&gt; T ToObject​(java.lang.reflect.Type t)</code><br>
Converts this CBOR object to an object of an arbitrary type.</li>
<li><code>&lt;T&gt; T ToObject​(java.lang.reflect.Type t,
CBORTypeMapper mapper)</code><br>
Converts this CBOR object to an object of an arbitrary type.</li>
<li><code>&lt;T&gt; T ToObject​(java.lang.reflect.Type t,
CBORTypeMapper mapper,
PODOptions options)</code><br>
Converts this CBOR object to an object of an arbitrary type.</li>
<li><code>&lt;T&gt; T ToObject​(java.lang.reflect.Type t,
PODOptions options)</code><br>
Converts this CBOR object to an object of an arbitrary type.</li>
<li><code>java.lang.String toString()</code><br>
Returns this CBOR object in a text form intended to be read by humans.</li>
<li><code>CBORObject Untag()</code><br>
Gets an object with the same value as this one but without the tags it has,
if any.</li>
<li><code>CBORObject UntagOne()</code><br>
Gets an object with the same value as this one but without this object&#39;s
outermost tag, if any.</li>
<li><code>CBORObject WithTag​(int smallTag)</code><br>
Generates a CBOR object from an arbitrary object and gives the resulting
object a tag in addition to its existing tags (the new tag is made
the outermost tag).</li>
<li><code>CBORObject WithTag​(com.upokecenter.numbers.EInteger bigintTag)</code><br>
Generates a CBOR object from this one, but gives the resulting object a tag
in addition to its existing tags (the new tag is made the outermost
tag).</li>
<li><code>static void Write​(boolean value,
java.io.OutputStream stream)</code><br>
Writes a Boolean value in CBOR format to a data stream.</li>
<li><code>static void Write​(byte value,
java.io.OutputStream stream)</code><br>
Writes a byte (0 to 255) in CBOR format to a data stream.</li>
<li><code>static void Write​(double value,
java.io.OutputStream stream)</code><br>
Writes a 64-bit floating-point number in CBOR format to a data stream.</li>
<li><code>static void Write​(float value,
java.io.OutputStream stream)</code><br>
Writes a 32-bit floating-point number in CBOR format to a data stream.</li>
<li><code>static void Write​(int value,
java.io.OutputStream stream)</code><br>
Writes a 32-bit signed integer in CBOR format to a data stream.</li>
<li><code>static void Write​(long value,
java.io.OutputStream stream)</code><br>
Writes a 64-bit signed integer in CBOR format to a data stream.</li>
<li><code>static void Write​(short value,
java.io.OutputStream stream)</code><br>
Writes a 16-bit signed integer in CBOR format to a data stream.</li>
<li><code>static void Write​(CBORObject value,
java.io.OutputStream stream)</code><br>
Writes a CBOR object to a CBOR data stream.</li>
<li><code>static void Write​(com.upokecenter.numbers.EDecimal bignum,
java.io.OutputStream stream)</code><br>
Writes a decimal floating-point number in CBOR format to a data stream, as
though it were converted to a CBOR object via
CBORObject.FromObject(EDecimal) and then written out.</li>
<li><code>static void Write​(com.upokecenter.numbers.EFloat bignum,
java.io.OutputStream stream)</code><br>
Writes a binary floating-point number in CBOR format to a data stream, as
though it were converted to a CBOR object via
CBORObject.FromObject(EFloat) and then written out.</li>
<li><code>static void Write​(com.upokecenter.numbers.EInteger bigint,
java.io.OutputStream stream)</code><br>
Writes a arbitrary-precision integer in CBOR format to a data stream.</li>
<li><code>static void Write​(com.upokecenter.numbers.ERational rational,
java.io.OutputStream stream)</code><br>
Writes a rational number in CBOR format to a data stream, as though it were
converted to a CBOR object via CBORObject.FromObject(ERational) and
then written out.</li>
<li><code>static void Write​(java.lang.Object objValue,
java.io.OutputStream stream)</code><br>
Writes a CBOR object to a CBOR data stream.</li>
<li><code>static void Write​(java.lang.Object objValue,
java.io.OutputStream output,
CBOREncodeOptions options)</code><br>
Writes an arbitrary object to a CBOR data stream, using the specified
options for controlling how the object is encoded to CBOR data
format.</li>
<li><code>static void Write​(java.lang.String str,
java.io.OutputStream stream)</code><br>
Writes a text string in CBOR format to a data stream.</li>
<li><code>static void Write​(java.lang.String str,
java.io.OutputStream stream,
CBOREncodeOptions options)</code><br>
Writes a text string in CBOR format to a data stream, using the given
options to control the encoding process.</li>
<li><code>static int WriteFloatingPointBits​(java.io.OutputStream outputStream,
long floatingBits,
int byteCount)</code><br>
Writes the bits of a floating-point number in CBOR format to a data stream.</li>
<li><code>static int WriteFloatingPointBits​(java.io.OutputStream outputStream,
long floatingBits,
int byteCount,
boolean shortestForm)</code><br>
Writes the bits of a floating-point number in CBOR format to a data stream.</li>
<li><code>static int WriteFloatingPointValue​(java.io.OutputStream outputStream,
double doubleVal,
int byteCount)</code><br>
Writes a 64-bit binary floating-point number in CBOR format to a data
stream, either in its 64-bit form, or its rounded 32-bit or 16-bit
equivalent.</li>
<li><code>static int WriteFloatingPointValue​(java.io.OutputStream outputStream,
float singleVal,
int byteCount)</code><br>
Writes a 32-bit binary floating-point number in CBOR format to a data
stream, either in its 64- or 32-bit form, or its rounded 16-bit
equivalent.</li>
<li><code>static void WriteJSON​(java.lang.Object obj,
java.io.OutputStream outputStream)</code><br>
Converts an arbitrary object to a text string in JavaScript object Notation
(JSON) format, as in the ToJSONString method, and writes that string
to a data stream in UTF-8.</li>
<li><code>void WriteJSONTo​(java.io.OutputStream outputStream)</code><br>
Converts this object to a text string in JavaScript object Notation (JSON)
format, as in the ToJSONString method, and writes that string to a
data stream in UTF-8.</li>
<li><code>void WriteJSONTo​(java.io.OutputStream outputStream,
JSONOptions options)</code><br>
Converts this object to a text string in JavaScript object Notation (JSON)
format, as in the ToJSONString method, and writes that string to a
data stream in UTF-8, using the given JSON options to control the
encoding process.</li>
<li><code>void WriteTo​(java.io.OutputStream stream)</code><br>
Writes this CBOR object to a data stream.</li>
<li><code>void WriteTo​(java.io.OutputStream stream,
CBOREncodeOptions options)</code><br>
Writes this CBOR object to a data stream, using the specified options for
encoding the data to CBOR format.</li>
<li><code>static int WriteValue​(java.io.OutputStream outputStream,
int majorType,
int value)</code><br>
Writes a CBOR major type number and an integer 0 or greater associated with
it to a data stream, where that integer is passed to this method as
a 32-bit signed integer.</li>
<li><code>static int WriteValue​(java.io.OutputStream outputStream,
int majorType,
long value)</code><br>
Writes a CBOR major type number and an integer 0 or greater associated with
it to a data stream, where that integer is passed to this method as
a 64-bit signed integer.</li>
<li><code>static int WriteValue​(java.io.OutputStream outputStream,
int majorType,
com.upokecenter.numbers.EInteger bigintValue)</code><br>
Writes a CBOR major type number and an integer 0 or greater associated with
it to a data stream, where that integer is passed to this method as
an arbitrary-precision integer.</li>
</ul>

<h2>Field Details</h2>

<h3><a id='False'>False</a></h3>

<p>Represents the value false.</p>

<h3><a id='NaN'>NaN</a></h3>

<p>A not-a-number value.</p>

<h3><a id='NegativeInfinity'>NegativeInfinity</a></h3>

<p>The value negative infinity.</p>

<h3><a id='Null'>Null</a></h3>

<p>Represents the value null.</p>

<h3><a id='PositiveInfinity'>PositiveInfinity</a></h3>

<p>The value positive infinity.</p>

<h3><a id='True'>True</a></h3>

<p>Represents the value true.</p>

<h3><a id='Undefined'>Undefined</a></h3>

<p>Represents the value undefined.</p>

<h3><a id='Zero'>Zero</a></h3>

<p>Gets a CBOR object for the number zero.</p>

<h2>Method Details</h2>

<h3><a id='size()'>size</a></h3>

<p>Gets the number of keys in this map, or the number of items in this array,
 or 0 if this item is neither an array nor a map.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>The number of keys in this map, or the number of items in this
array, or 0 if this item is neither an array nor a map.</li>
</ul>

<h3><a id='getMostInnerTag()'>getMostInnerTag</a></h3>

<p>Gets the last defined tag for this CBOR data item, or -1 if the item is
 untagged.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>The last defined tag for this CBOR data item, or -1 if the item is
untagged.</li>
</ul>

<h3><a id='isFalse()'>isFalse</a></h3>

<p>Gets a value indicating whether this value is a CBOR false value, whether
 tagged or not.</p>

<p><strong>Returns:</strong></p>

<ul>
<li><code>true</code> if this value is a CBOR false value; otherwise, <code>
false</code>.</li>
</ul>

<h3><a id='isFinite()'>isFinite</a></h3>

<p>Gets a value indicating whether this CBOR object represents a finite number.</p>

<p><strong>Returns:</strong></p>

<ul>
<li><code>true</code> if this CBOR object represents a finite number;
otherwise, <code>false</code>.</li>
</ul>

<h3><a id='isIntegral()'>isIntegral</a></h3>

<p>Gets a value indicating whether this object represents an integer number,
 that is, a number without a fractional part. Infinity and
 not-a-number are not considered integers.</p>

<p><strong>Returns:</strong></p>

<ul>
<li><code>true</code> if this object represents an integer number, that is, a
number without a fractional part; otherwise, <code>false</code>.</li>
</ul>

<h3><a id='isNull()'>isNull</a></h3>

<p>Gets a value indicating whether this CBOR object is a CBOR null value,
 whether tagged or not.</p>

<p><strong>Returns:</strong></p>

<ul>
<li><code>true</code> if this value is a CBOR null value; otherwise, <code>
false</code>.</li>
</ul>

<h3><a id='isTagged()'>isTagged</a></h3>

<p>Gets a value indicating whether this data item has at least one tag.</p>

<p><strong>Returns:</strong></p>

<ul>
<li><code>true</code> if this data item has at least one tag; otherwise,
<code>false</code>.</li>
</ul>

<h3><a id='isTrue()'>isTrue</a></h3>

<p>Gets a value indicating whether this value is a CBOR true value, whether
 tagged or not.</p>

<p><strong>Returns:</strong></p>

<ul>
<li><code>true</code> if this value is a CBOR true value; otherwise, <code>
false</code>.</li>
</ul>

<h3><a id='isUndefined()'>isUndefined</a></h3>

<p>Gets a value indicating whether this value is a CBOR undefined value,
 whether tagged or not.</p>

<p><strong>Returns:</strong></p>

<ul>
<li><code>true</code> if this value is a CBOR undefined value; otherwise,
<code>false</code>.</li>
</ul>

<h3><a id='isZero()'>isZero</a></h3>

<p>Gets a value indicating whether this object&#39;s value equals 0.</p>

<p><strong>Returns:</strong></p>

<ul>
<li><code>true</code> if this object&#39;s value equals 0; otherwise, <code>
false</code>.</li>
</ul>

<h3><a id='getKeys()'>getKeys</a></h3>

<p>Gets a collection of the keys of this CBOR object. In general, the order in
 which those keys occur is undefined unless this is a map created
 using the NewOrderedMap method.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>A collection of the keys of this CBOR object. To avoid potential
problems, the calling code should not modify the CBOR map or the
returned collection while iterating over the returned collection.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.IllegalStateException</code> - This object is not a map.</li>
</ul>

<h3><a id='isNegative()'>isNegative</a></h3>

<p>Gets a value indicating whether this object is a negative number.</p>

<p><strong>Returns:</strong></p>

<ul>
<li><code>true</code> if this object is a negative number; otherwise, <code>
false</code>.</li>
</ul>

<h3><a id='getMostOuterTag()'>getMostOuterTag</a></h3>

<p>Gets the outermost tag for this CBOR data item, or -1 if the item is
 untagged.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>The outermost tag for this CBOR data item, or -1 if the item is
untagged.</li>
</ul>

<h3><a id='signum()'>signum</a></h3>

<p>Gets this value&#39;s sign: -1 if negative; 1 if positive; 0 if zero. Throws an
 exception if this is a not-a-number value.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>This value&#39;s sign: -1 if negative; 1 if positive; 0 if zero.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.IllegalStateException</code> - This object does not represent a number, or
this object is a not-a-number (NaN) value.</li>
</ul>

<h3><a id='getSimpleValue()'>getSimpleValue</a></h3>

<p>Gets the simple value ID of this CBOR object, or -1 if the object is not a
 simple value. In this method, objects with a CBOR type of Boolean or
 SimpleValue are simple values, whether they are tagged or not.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>The simple value ID of this object if it&#39;s a simple value, or -1 if
this object is not a simple value.</li>
</ul>

<h3><a id='isNumber()'>isNumber</a></h3>

<p>Gets a value indicating whether this CBOR object stores a number (including
 infinity or a not-a-number or NaN value). Currently, this is true if
 this item is untagged and has a CBORType of Integer or
 FloatingPoint, or if this item has only one tag and that tag is 2,
 3, 4, 5, 30, 264, 265, 268, 269, or 270 with the right data type.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>A value indicating whether this CBOR object stores a number.</li>
</ul>

<h3><a id='getType()'>getType</a></h3>

<p>Gets the general data type of this CBOR object. This method disregards the
 tags this object has, if any.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>The general data type of this CBOR object.</li>
</ul>

<h3><a id='getEntries()'>getEntries</a></h3>

<p>Gets a collection of the key/value pairs stored in this CBOR object, if it&#39;s
 a map. Returns one entry for each key/value pair in the map. In
 general, the order in which those entries occur is undefined unless
 this is a map created using the NewOrderedMap method.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>A collection of the key/value pairs stored in this CBOR map, as a
read-only view of those pairs. To avoid potential problems, the
calling code should not modify the CBOR map while iterating over the
returned collection.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.IllegalStateException</code> - This object is not a map.</li>
</ul>

<h3><a id='getValues()'>getValues</a></h3>

<p>Gets a collection of the values of this CBOR object, if it&#39;s a map or an
 array. If this object is a map, returns one value for each key in
 the map; in general, the order in which those keys occur is
 undefined unless this is a map created using the NewOrderedMap
 method. If this is an array, returns all the values of the array in
 the order they are listed. (This method can&#39;t be used to get the
 bytes in a CBOR byte string; for that, use the GetByteString method
 instead.).</p>

<p><strong>Returns:</strong></p>

<ul>
<li>A collection of the values of this CBOR map or array. To avoid
potential problems, the calling code should not modify the CBOR map
or array or the returned collection while iterating over the
returned collection.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.IllegalStateException</code> - This object is not a map or an array.</li>
</ul>

<h3><a id='get(int)'>get</a></h3>

<p>Gets the value of a CBOR object by integer index in this array or by integer
 key in this map.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>index</code> - Index starting at 0 of the element, or the integer key to this
map. (If this is a map, the given index can be any 32-bit signed
integer, even a negative one.).</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The CBOR object referred to by index or key in this array or map. If
this is a CBOR map, returns <code>null</code> (not <code>
CBORObject.Null</code>) if an item with the given key doesn&#39;t exist (but
this behavior may change to throwing an exception in version 5.0 or
later).</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.IllegalStateException</code> - This object is not an array or map.</p></li>
<li><p><code>java.lang.IllegalArgumentException</code> - This object is an array and the index is less than
0 or at least the size of the array.</p></li>
<li><p><code>java.lang.NullPointerException</code> - The parameter &quot;value&quot; is null (as opposed to
CBORObject.Null).</p></li>
</ul>

<h3><a id='set(int,com.upokecenter.cbor.CBORObject)'>set</a></h3>

<p>Sets the value of a CBOR object by integer index in this array or by integer
 key in this map.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>index</code> - Index starting at 0 of the element, or the integer key to this
map. (If this is a map, the given index can be any 32-bit signed
integer, even a negative one.).</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.IllegalStateException</code> - This object is not an array or map.</p></li>
<li><p><code>java.lang.IllegalArgumentException</code> - This object is an array and the index is less than
0 or at least the size of the array.</p></li>
<li><p><code>java.lang.NullPointerException</code> - The parameter &quot;value&quot; is null (as opposed to
CBORObject.Null).</p></li>
</ul>

<h3><a id='GetOrDefault(java.lang.Object,com.upokecenter.cbor.CBORObject)'>GetOrDefault</a></h3>

<p>Gets the value of a CBOR object by integer index in this array or by CBOR
 object key in this map, or a default value if that value is not
 found.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>key</code> - An arbitrary object. If this is a CBOR map, this parameter is
converted to a CBOR object serving as the key to the map or index to
the array, and can be null. If this is a CBOR array, the key must be
an integer 0 or greater and less than the size of the array, and may
be any object convertible to a CBOR integer.</p></li>
<li><p><code>defaultValue</code> - A value to return if an item with the given key doesn&#39;t
exist, or if the CBOR object is an array and the key is not an
integer 0 or greater and less than the size of the array.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The CBOR object referred to by index or key in this array or map. If
this is a CBOR map, returns <code>null</code> (not <code>
CBORObject.Null</code>) if an item with the given key doesn&#39;t exist.</li>
</ul>

<h3><a id='get(com.upokecenter.cbor.CBORObject)'>get</a></h3>

<p>Gets the value of a CBOR object by integer index in this array or by CBOR
 object key in this map.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>key</code> - A CBOR object serving as the key to the map or index to the
array. If this is a CBOR array, the key must be an integer 0 or
greater and less than the size of the array.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The CBOR object referred to by index or key in this array or map. If
this is a CBOR map, returns <code>null</code> (not <code>
CBORObject.Null</code>) if an item with the given key doesn&#39;t exist.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.NullPointerException</code> - The key is null (as opposed to
CBORObject.Null); or the set method is called and the value is null.</p></li>
<li><p><code>java.lang.IllegalArgumentException</code> - This CBOR object is an array and the key is not an
integer 0 or greater and less than the size of the array.</p></li>
<li><p><code>java.lang.IllegalStateException</code> - This object is not a map or an array.</p></li>
</ul>

<h3><a id='set(com.upokecenter.cbor.CBORObject,com.upokecenter.cbor.CBORObject)'>set</a></h3>

<p>Sets the value of a CBOR object by integer index in this array or by CBOR
 object key in this map.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>key</code> - A CBOR object serving as the key to the map or index to the
array. If this is a CBOR array, the key must be an integer 0 or
greater and less than the size of the array.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.NullPointerException</code> - The key is null (as opposed to
CBORObject.Null); or the set method is called and the value is null.</p></li>
<li><p><code>java.lang.IllegalArgumentException</code> - This CBOR object is an array and the key is not an
integer 0 or greater and less than the size of the array.</p></li>
<li><p><code>java.lang.IllegalStateException</code> - This object is not a map or an array.</p></li>
</ul>

<h3><a id='get(java.lang.String)'>get</a></h3>

<p>Gets the value of a CBOR object in this map, using a string as the key.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>key</code> - A key that points to the desired value.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The CBOR object referred to by key in this map. Returns <code>null</code>
if an item with the given key doesn&#39;t exist.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.NullPointerException</code> - The key is null.</p></li>
<li><p><code>java.lang.IllegalStateException</code> - This object is not a map.</p></li>
</ul>

<h3><a id='set(java.lang.String,com.upokecenter.cbor.CBORObject)'>set</a></h3>

<p>Sets the value of a CBOR object in this map, using a string as the key.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>key</code> - A key that points to the desired value.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.NullPointerException</code> - The key is null.</p></li>
<li><p><code>java.lang.IllegalStateException</code> - This object is not a map.</p></li>
</ul>

<h3><a id='Addition(com.upokecenter.cbor.CBORObject,com.upokecenter.cbor.CBORObject)'>Addition</a></h3>

<p>Finds the sum of two CBOR numbers.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>first</code> - The parameter <code>first</code> is a CBOR object.</p></li>
<li><p><code>second</code> - The parameter <code>second</code> is a CBOR object.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A CBOR object.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.IllegalArgumentException</code> - Either or both operands are not numbers (as
opposed to Not-a-Number, NaN).</p></li>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>first</code> or <code>second</code>
is null.</p></li>
</ul>

<h3><a id='DecodeFromBytes(byte[])'>DecodeFromBytes</a></h3>

<p>Generates a CBOR object from an array of CBOR-encoded bytes.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>data</code> - A byte array in which a single CBOR object is encoded.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A CBOR object decoded from the given byte array.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>CBORException</code> - There was an error in reading or
parsing the data. This includes cases where not all of the byte
array represents a CBOR object. This exception is also thrown if the
parameter <code>data</code> is empty.</p></li>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>data</code> is null.</p></li>
</ul>

<h3><a id='DecodeSequenceFromBytes(byte[])'>DecodeSequenceFromBytes</a></h3>

<p>Generates a sequence of CBOR objects from an array of CBOR-encoded
 bytes.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>data</code> - A byte array in which any number of CBOR objects (including
zero) are encoded, one after the other. Can be empty, but cannot be
null.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An array of CBOR objects decoded from the given byte array. Returns
an empty array if <code>data</code> is empty.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>CBORException</code> - There was an error in reading or
parsing the data. This includes cases where the last CBOR object in
the data was read only partly.</p></li>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>data</code> is null.</p></li>
</ul>

<h3><a id='DecodeSequenceFromBytes(byte[],com.upokecenter.cbor.CBOREncodeOptions)'>DecodeSequenceFromBytes</a></h3>

<p>Generates a sequence of CBOR objects from an array of CBOR-encoded
 bytes.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>data</code> - A byte array in which any number of CBOR objects (including
zero) are encoded, one after the other. Can be empty, but cannot be
null.</p></li>
<li><p><code>options</code> - Specifies options to control how the CBOR object is decoded.
See <code>CBOREncodeOptions</code> for more
information. In this method, the AllowEmpty property is treated as
always set regardless of that value as specified in this parameter.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An array of CBOR objects decoded from the given byte array. Returns
an empty array if <code>data</code> is empty.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>CBORException</code> - There was an error in reading or
parsing the data. This includes cases where the last CBOR object in
the data was read only partly.</p></li>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>data</code> is null, or the
parameter <code>options</code> is null.</p></li>
</ul>

<h3><a id='FromJSONSequenceBytes(byte[])'>FromJSONSequenceBytes</a></h3>

<p>Generates a list of CBOR objects from an array of bytes in JavaScript object
 Notation (JSON) text sequence format (RFC 7464). The byte array must
 be in UTF-8 encoding and may not begin with a byte-order mark
 (U+FEFF).<p>Generally, each JSON text in a JSON text sequence is
 written as follows: Write a record separator byte (0x1e), then write
 the JSON text in UTF-8 (without a byte order mark, U+FEFF), then
 write the line feed byte (0x0a). RFC 7464, however, uses a more
 liberal syntax for parsing JSON text sequences.</p></p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>bytes</code> - A byte array in which a JSON text sequence is encoded.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A list of CBOR objects read from the JSON sequence. Objects that
could not be parsed are replaced with <code>null</code> (as opposed to
<code>CBORObject.Null</code>) in the given list.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>bytes</code> is null.</p></li>
<li><p><code>CBORException</code> - The byte array is not empty and
does not begin with a record separator byte (0x1e), or an I/O error
occurred.</p></li>
</ul>

<h3><a id='ToJSONBytes()'>ToJSONBytes</a></h3>

<p>Converts this object to a byte array in JavaScript object Notation (JSON)
 format. The JSON text will be written out in UTF-8 encoding, without
 a byte order mark, to the byte array. See the overload to
 ToJSONString taking a JSONOptions argument for further information.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>A byte array containing the converted in JSON format.</li>
</ul>

<h3><a id='ToJSONBytes(com.upokecenter.cbor.JSONOptions)'>ToJSONBytes</a></h3>

<p>Converts this object to a byte array in JavaScript object Notation (JSON)
 format. The JSON text will be written out in UTF-8 encoding, without
 a byte order mark, to the byte array. See the overload to
 ToJSONString taking a JSONOptions argument for further information.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>jsonoptions</code> - Specifies options to control writing the CBOR object to
JSON.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A byte array containing the converted object in JSON format.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.NullPointerException</code> - The parameter <code>jsonoptions</code> is null.</li>
</ul>

<h3><a id='FromJSONSequenceBytes(byte[],com.upokecenter.cbor.JSONOptions)'>FromJSONSequenceBytes</a></h3>

<p>Generates a list of CBOR objects from an array of bytes in JavaScript object
 Notation (JSON) text sequence format (RFC 7464), using the specified
 options to control the decoding process. The byte array must be in
 UTF-8 encoding and may not begin with a byte-order mark
 (U+FEFF).<p>Generally, each JSON text in a JSON text sequence is
 written as follows: Write a record separator byte (0x1e), then write
 the JSON text in UTF-8 (without a byte order mark, U+FEFF), then
 write the line feed byte (0x0a). RFC 7464, however, uses a more
 liberal syntax for parsing JSON text sequences.</p></p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>data</code> - A byte array in which a JSON text sequence is encoded.</p></li>
<li><p><code>options</code> - Specifies options to control the JSON decoding process.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A list of CBOR objects read from the JSON sequence. Objects that
could not be parsed are replaced with <code>null</code> (as opposed to
<code>CBORObject.Null</code>) in the given list.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>data</code> is null.</p></li>
<li><p><code>CBORException</code> - The byte array is not empty and
does not begin with a record separator byte (0x1e), or an I/O error
occurred.</p></li>
</ul>

<h3><a id='DecodeFromBytes(byte[],com.upokecenter.cbor.CBOREncodeOptions)'>DecodeFromBytes</a></h3>

<pre>private static string DecodeTextString(byte[] bytes) { if (bytes == null) { throw new NullPointerException(&quot;mapObj&quot;);} if (bytes.length == 0 || bytes[0]&lt;0x60 || bytes[0]&gt;0x7f) {throw new CBORException();} return CBORObject.DecodeFromBytes(bytes, CBOREncodeOptions.Default).AsString(); }
</pre>

<p>Generates a CBOR object from an array of CBOR-encoded bytes, using the given
 <code>CBOREncodeOptions</code> object to control the decoding process.<p>
 </p><p>The following example (originally written in C# for the.NET
 version) implements a method that decodes a text string from a CBOR
 byte array. It&#39;s successful only if the CBOR object contains an
  untagged text string.</p> <pre>private static string DecodeTextString(byte[] bytes) { if (bytes == null) { throw new NullPointerException(&quot;mapObj&quot;);} if (bytes.length == 0 || bytes[0]&lt;0x60 || bytes[0]&gt;0x7f) {throw new CBORException();} return CBORObject.DecodeFromBytes(bytes, CBOREncodeOptions.Default).AsString(); }</pre>.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>data</code> - A byte array in which a single CBOR object is encoded.</p></li>
<li><p><code>options</code> - Specifies options to control how the CBOR object is decoded.
See <code>CBOREncodeOptions</code> for more
information.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A CBOR object decoded from the given byte array. Returns null (as
opposed to CBORObject.Null) if <code>data</code> is empty and the
AllowEmpty property is set on the given options object.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>CBORException</code> - There was an error in reading or
parsing the data. This includes cases where not all of the byte
array represents a CBOR object. This exception is also thrown if the
parameter <code>data</code> is empty unless the AllowEmpty property is
set on the given options object.</p></li>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>data</code> is null, or the
parameter <code>options</code> is null.</p></li>
</ul>

<h3><a id='Divide(com.upokecenter.cbor.CBORObject,com.upokecenter.cbor.CBORObject)'>Divide</a></h3>

<p>Divides a CBORObject object by the value of a CBORObject object.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>first</code> - The parameter <code>first</code> is a CBOR object.</p></li>
<li><p><code>second</code> - The parameter <code>second</code> is a CBOR object.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The quotient of the two objects.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.NullPointerException</code> - The parameter <code>first</code> or <code>second</code>
is null.</li>
</ul>

<h3><a id='FromJSONString(java.lang.String,int,int)'>FromJSONString</a></h3>

<p>Generates a CBOR object from a text string in JavaScript object Notation
 (JSON) format.</p> <p>If a JSON object has duplicate keys, a
 CBORException is thrown. This is a change in version 4.0.</p>

<p><p>Note that if a CBOR object is converted to JSON with
 <code>ToJSONString</code>, then the JSON is converted back to CBOR with
 this method, the new CBOR object will not necessarily be the same as
 the old CBOR object, especially if the old CBOR object uses data
 types not supported in JSON, such as integers in map keys.</p></p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>str</code> - A text string in JSON format. The entire string must contain a
single JSON object and not multiple objects. The string may not
begin with a byte-order mark (U+FEFF).</p></li>
<li><p><code>offset</code> - An index, starting at 0, showing where the desired portion of
<code>str</code> begins.</p></li>
<li><p><code>count</code> - The length, in code units, of the desired portion of <code>
str</code> (but not more than <code>str</code> &#39;s length).</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A CBOR object.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>str</code> is null.</p></li>
<li><p><code>CBORException</code> - The string is not in JSON format.</p></li>
<li><p><code>java.lang.IllegalArgumentException</code> - Either <code>offset</code> or <code>count</code> is less
than 0 or greater than <code>str</code> &#39;s length, or <code>str</code> &#39;s
length minus <code>offset</code> is less than <code>count</code>.</p></li>
</ul>

<h3><a id='FromJSONString(java.lang.String,com.upokecenter.cbor.JSONOptions)'>FromJSONString</a></h3>

<p>Generates a CBOR object from a text string in JavaScript object Notation
 (JSON) format, using the specified options to control the decoding
 process. <p>Note that if a CBOR object is converted to JSON with
 <code>ToJSONString</code>, then the JSON is converted back to CBOR with
 this method, the new CBOR object will not necessarily be the same as
 the old CBOR object, especially if the old CBOR object uses data
 types not supported in JSON, such as integers in map keys.</p></p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>str</code> - A text string in JSON format. The entire string must contain a
single JSON object and not multiple objects. The string may not
begin with a byte-order mark (U+FEFF).</p></li>
<li><p><code>jsonoptions</code> - Specifies options to control the JSON decoding process.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A CBOR object containing the JSON data decoded.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>str</code> or <code>
jsonoptions</code> is null.</p></li>
<li><p><code>CBORException</code> - The string is not in JSON format.</p></li>
</ul>

<h3><a id='FromJSONString(java.lang.String)'>FromJSONString</a></h3>

<p>Generates a CBOR object from a text string in JavaScript object Notation
 (JSON) format.</p> <p>If a JSON object has duplicate keys, a
 CBORException is thrown. This is a change in version 4.0.</p>

<p><p>Note that if a CBOR object is converted to JSON with
 <code>ToJSONString</code>, then the JSON is converted back to CBOR with
 this method, the new CBOR object will not necessarily be the same as
 the old CBOR object, especially if the old CBOR object uses data
 types not supported in JSON, such as integers in map keys.</p></p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>str</code> - A text string in JSON format. The entire string must contain a
single JSON object and not multiple objects. The string may not
begin with a byte-order mark (U+FEFF).</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A CBOR object.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>str</code> is null.</p></li>
<li><p><code>CBORException</code> - The string is not in JSON format.</p></li>
</ul>

<h3><a id='FromJSONString(java.lang.String,com.upokecenter.cbor.CBOREncodeOptions)'>FromJSONString</a></h3>

<p>Generates a CBOR object from a text string in JavaScript object Notation
 (JSON) format, using the specified options to control the decoding
 process. <p>Note that if a CBOR object is converted to JSON with
 <code>ToJSONString</code>, then the JSON is converted back to CBOR with
 this method, the new CBOR object will not necessarily be the same as
 the old CBOR object, especially if the old CBOR object uses data
 types not supported in JSON, such as integers in map keys.</p></p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>str</code> - A text string in JSON format. The entire string must contain a
single JSON object and not multiple objects. The string may not
begin with a byte-order mark (U+FEFF).</p></li>
<li><p><code>options</code> - Specifies options to control the decoding process. This
method uses only the AllowDuplicateKeys property of this object.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A CBOR object containing the JSON data decoded.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>str</code> or <code>options</code>
is null.</p></li>
<li><p><code>CBORException</code> - The string is not in JSON format.</p></li>
</ul>

<h3><a id='FromJSONString(java.lang.String,int,int,com.upokecenter.cbor.JSONOptions)'>FromJSONString</a></h3>

<p>Generates a CBOR object from a text string in JavaScript object Notation
 (JSON) format, using the specified options to control the decoding
 process. <p>Note that if a CBOR object is converted to JSON with
 <code>ToJSONString</code>, then the JSON is converted back to CBOR with
 this method, the new CBOR object will not necessarily be the same as
 the old CBOR object, especially if the old CBOR object uses data
 types not supported in JSON, such as integers in map keys.</p></p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>str</code> - The parameter <code>str</code> is a text string.</p></li>
<li><p><code>offset</code> - An index, starting at 0, showing where the desired portion of
<code>str</code> begins.</p></li>
<li><p><code>count</code> - The length, in code units, of the desired portion of <code>
str</code> (but not more than <code>str</code> &#39;s length).</p></li>
<li><p><code>jsonoptions</code> - The parameter <code>jsonoptions</code> is a Cbor.JSONOptions
object.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A CBOR object containing the JSON data decoded.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>str</code> or <code>
jsonoptions</code> is null.</p></li>
<li><p><code>CBORException</code> - The string is not in JSON format.</p></li>
<li><p><code>java.lang.IllegalArgumentException</code> - Either <code>offset</code> or <code>count</code> is less
than 0 or greater than <code>str</code> &#39;s length, or <code>str</code> &#39;s
length minus <code>offset</code> is less than <code>count</code>.</p></li>
</ul>

<h3><a id='ToObject(java.lang.reflect.Type)'>ToObject</a></h3>

<pre>Type arrayListString = new ParameterizedType() { public Type[] getActualTypeArguments() { /* Contains one type parameter, string*/ return new Type[] { string.class }; } public Type getRawType() { /* Raw type is ArrayList */ return ArrayList.class; } public Type getOwnerType() { return null; } }; ArrayList&lt;string&gt; array = (ArrayList&lt;string&gt;) cborArray.ToObject(arrayListString);
</pre>

<p>Converts this CBOR object to an object of an arbitrary type. See the
 documentation for the overload of this method taking a
 CBORTypeMapper parameter for more information. This method doesn&#39;t
 use a CBORTypeMapper parameter to restrict which data types are
 eligible for Plain-Old-Data serialization.<p> </p><p>Java offers no easy
 way to express a generic type, at least none as easy as C#&#39;s
 <code>typeof</code> operator. The following example, written in Java, is a
 way to specify that the return value will be an ArrayList of string
 objects.</p> <pre>Type arrayListString = new ParameterizedType() { public Type[] getActualTypeArguments() { /* Contains one type parameter, string<em>/ return new Type[] { string.class }; } public Type getRawType() { /</em> Raw type is ArrayList */ return ArrayList.class; } public Type getOwnerType() { return null; } }; ArrayList&lt;string&gt; array = (ArrayList&lt;string&gt;) cborArray.ToObject(arrayListString);</pre> <p>By comparison, the C#
 version is much shorter.</p> <pre>List&lt;string&gt; array = (List&lt;string&gt;)cborArray.ToObject(typeof(List&lt;string&gt;));</pre>.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>t</code> - The type, class, or interface that this method&#39;s return value will
belong to. To express a generic type in Java, see the example.
<b>Note:</b> For security reasons, an application should not base
this parameter on user input or other externally supplied data.
Whenever possible, this parameter should be either a type specially
handled by this method (such as <code>int</code> or <code>string</code>) or a
plain-old-data type (POCO or POJO type) within the control of the
application. If the plain-old-data type references other data types,
those types should likewise meet either criterion above.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The converted object.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>CBORException</code> - The given type <code>t</code> , or
this object&#39;s CBOR type, is not supported, or the given object&#39;s
nesting is too deep, or another error occurred when serializing the
object.</p></li>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>t</code> is null.</p></li>
</ul>

<h3><a id='ToObject(java.lang.reflect.Type,com.upokecenter.cbor.CBORTypeMapper)'>ToObject</a></h3>

<p>Converts this CBOR object to an object of an arbitrary type. See the
 documentation for the overload of this method taking a
 CBORTypeMapper and PODOptions parameters parameters for more
 information.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>t</code> - The type, class, or interface that this method&#39;s return value will
belong to. To express a generic type in Java, see the example.
<b>Note:</b> For security reasons, an application should not base
this parameter on user input or other externally supplied data.
Whenever possible, this parameter should be either a type specially
handled by this method (such as <code>int</code> or <code>string</code>) or a
plain-old-data type (POCO or POJO type) within the control of the
application. If the plain-old-data type references other data types,
those types should likewise meet either criterion above.</p></li>
<li><p><code>mapper</code> - This parameter controls which data types are eligible for
Plain-Old-Data deserialization and includes custom converters from
CBOR objects to certain data types.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The converted object.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>CBORException</code> - The given type <code>t</code>, or this
object&#39;s CBOR type, is not supported, or the given object&#39;s nesting
is too deep, or another error occurred when serializing the object.</p></li>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>t</code> is null.</p></li>
</ul>

<h3><a id='ToObject(java.lang.reflect.Type,com.upokecenter.cbor.PODOptions)'>ToObject</a></h3>

<p>Converts this CBOR object to an object of an arbitrary type. See the
 documentation for the overload of this method taking a
 CBORTypeMapper and PODOptions parameters for more information. This
 method (without a CBORTypeMapper parameter) allows all data types
 not otherwise handled to be eligible for Plain-Old-Data
 serialization.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>t</code> - The type, class, or interface that this method&#39;s return value will
belong to. To express a generic type in Java, see the example.
<b>Note:</b> For security reasons, an application should not base
this parameter on user input or other externally supplied data.
Whenever possible, this parameter should be either a type specially
handled by this method (such as <code>int</code> or <code>string</code>) or a
plain-old-data type (POCO or POJO type) within the control of the
application. If the plain-old-data type references other data types,
those types should likewise meet either criterion above.</p></li>
<li><p><code>options</code> - Specifies options for controlling deserialization of CBOR
objects.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The converted object.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.UnsupportedOperationException</code> - The given type <code>t</code>, or this object&#39;s
CBOR type, is not supported.</p></li>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>t</code> is null.</p></li>
<li><p><code>CBORException</code> - The given object&#39;s nesting is too
deep, or another error occurred when serializing the object.</p></li>
</ul>

<h3><a id='ToObject(java.lang.reflect.Type,com.upokecenter.cbor.CBORTypeMapper,com.upokecenter.cbor.PODOptions)'>ToObject</a></h3>

<pre>CBORTypeMapper conv = new CBORTypeMapper().AddConverter(java.util.Date.class, CBORDateConverter.UntaggedNumber); var obj = CBORObject.FromObject().getToObject()&lt;java.util.Date&gt;(conv);
</pre>

<p>Converts this CBOR object to an object of an arbitrary type. The
 following cases are checked in the logical order given (rather than
 the strict order in which they are implemented by this library):</p>

<p><ul><li>If the type is <code>CBORObject</code> , return this object.</li>
 <li>If the given object is <code>CBORObject.Null</code> (with or without
 tags), returns <code>null</code> .</li> <li>If the object is of a type
 corresponding to a type converter mentioned in the <paramref name='mapper'/> parameter, that converter will be used to convert
 the CBOR object to an object of the given type. Type converters can
 be used to override the default conversion behavior of almost any
 object.</li> <li>If the type is <code>object</code> , return this
 object.</li> <li>If the type is <code>char</code> , converts
 single-character CBOR text strings and CBOR integers from 0 through
 65535 to a <code>char</code> object and returns that <code>char</code>
 object.</li> <li>If the type is <code>boolean</code> (<code>boolean</code> in
 Java), returns the result of AsBoolean.</li> <li>If the type is
 <code>short</code> , returns this number as a 16-bit signed integer after
 converting its value to an integer by discarding its fractional
 part, and throws an exception if this object&#39;s value is infinity or
 a not-a-number value, or does not represent a number (currently
 IllegalStateException, but may change in the next major version), or
 if the value, once converted to an integer by discarding its
 fractional part, is less than -32768 or greater than 32767
 (currently ArithmeticException, but may change in the next major
 version).</li> <li>If the type is <code>long</code> , returns this number
 as a 64-bit signed integer after converting its value to an integer
 by discarding its fractional part, and throws an exception if this
 object&#39;s value is infinity or a not-a-number value, or does not
 represent a number (currently IllegalStateException, but may change
 in the next major version), or if the value, once converted to an
 integer by discarding its fractional part, is less than -2^63 or
 greater than 2^63-1 (currently ArithmeticException, but may change in
 the next major version).</li> <li>If the type is <code>short</code> , the
 same rules as for <code>long</code> are used, but the range is from -32768
 through 32767 and the return type is <code>short</code> .</li> <li>If the
 type is <code>byte</code> , the same rules as for <code>long</code> are used,
 but the range is from 0 through 255 and the return type is
 <code>byte</code> .</li> <li>If the type is <code>sbyte</code> , the same rules
 as for <code>long</code> are used, but the range is from -128 through 127
 and the return type is <code>sbyte</code> .</li> <li>If the type is
 <code>ushort</code> , the same rules as for <code>long</code> are used, but the
 range is from 0 through 65535 and the return type is <code>ushort</code>
.</li> <li>If the type is <code>uint</code> , the same rules as for
 <code>long</code> are used, but the range is from 0 through 2^31-1 and the
 return type is <code>uint</code> .</li> <li>If the type is <code>ulong</code> ,
 the same rules as for <code>long</code> are used, but the range is from 0
 through 2^63-1 and the return type is <code>ulong</code> .</li> <li>If the
 type is <code>int</code> or a primitive floating-point type (<code>float</code>
 , <code>double</code> , as well as <code>decimal</code> in.NET), returns the
 result of the corresponding As* method.</li> <li>If the type is
 <code>string</code> , returns the result of AsString.</li> <li>If the type
 is <code>EFloat</code> , <code>EDecimal</code> , <code>EInteger</code> , or
 <code>ERational</code> in the <code>PeterO.Numbers</code>
  library (in .NET) or the <code>com.github.peteroupc/numbers</code>
  artifact (in Java), or if the type is <code>BigInteger</code> or
 <code>BigDecimal</code> in the Java version, converts the given object to
 a number of the corresponding type and throws an exception
 (currently IllegalStateException) if the object does not represent a
 number (for this purpose, infinity and not-a-number values, but not
 <code>CBORObject.Null</code> , are considered numbers). Currently, this is
 equivalent to the result of <code>AsEFloat()</code> , <code>AsEDecimal()</code>
 , <code>AsEInteger</code> , or <code>AsERational()</code> , respectively, but
 may change slightly in the next major version. Note that in the case
 of <code>EFloat</code> , if this object represents a decimal number with a
 fractional part, the conversion may lose information depending on
 the number, and if the object is a rational number with a
 nonterminating binary expansion, the number returned is a binary
 floating-point number rounded to a high but limited precision. In
 the case of <code>EDecimal</code> , if this object expresses a rational
 number with a nonterminating decimal expansion, returns a decimal
 number rounded to 34 digits of precision. In the case of
 <code>EInteger</code> , if this CBOR object expresses a floating-point
 number, it is converted to an integer by discarding its fractional
 part, and if this CBOR object expresses a rational number, it is
 converted to an integer by dividing the numerator by the denominator
 and discarding the fractional part of the result, and this method
 throws an exception (currently ArithmeticException, but may change in
 the next major version) if this object expresses infinity or a
 not-a-number value.</li> <li>In the.NET version, if the type is a
 nullable (e.g., <code>Nullable&lt;int&gt;</code> or <code>int?</code> , returns
 <code>null</code> if this CBOR object is null, or this object&#39;s value
 converted to the nullable&#39;s underlying type, e.g., <code>int</code> .</li>
 <li>If the type is an enumeration (<code>Enum</code>) type and this CBOR
 object is a text string or an integer, returns the appropriate
 enumerated constant. (For example, if <code>MyEnum</code> includes an
 entry for <code>MyValue</code> , this method will return
  <code>MyEnum.MyValue</code> if the CBOR object represents <code>&quot;MyValue&quot;</code>
 or the underlying value for <code>MyEnum.MyValue</code> .) <b>Note:</b> If
 an integer is converted to a.NET Enum constant, and that integer is
 shared by more than one constant of the same type, it is undefined
 which constant from among them is returned. (For example, if
 <code>MyEnum.Zero = 0</code> and <code>MyEnum.Null = 0</code> , converting 0 to
 <code>MyEnum</code> may return either <code>MyEnum.Zero</code> or
 <code>MyEnum.Null</code> .) As a result, .NET Enum types with constants
 that share an underlying value should not be passed to this
 method.</li> <li>If the type is <code>byte[]</code> (a one-dimensional
 byte array) and this CBOR object is a byte string, returns a byte
 array which this CBOR byte string&#39;s data will be copied to. (This
 method can&#39;t be used to encode CBOR data to a byte array; for that,
 use the EncodeToBytes method instead.)</li> <li>If the type is a
 one-dimensional or multidimensional array type and this CBOR object
 is an array, returns an array containing the items in this CBOR
 object.</li> <li>If the type is List, ReadOnlyCollection or the
 generic or non-generic List, ICollection, Iterable,
 IReadOnlyCollection, or IReadOnlyList (or ArrayList, List,
 Collection, or Iterable in Java), and if this CBOR object is an
 array, returns an object conforming to the type, class, or interface
 passed to this method, where the object will contain all items in
 this CBOR array.</li> <li>If the type is Dictionary,
 ReadOnlyDictionary or the generic or non-generic Map or
 IReadOnlyDictionary (or HashMap or Map in Java), and if this CBOR
 object is a map, returns an object conforming to the type, class, or
 interface passed to this method, where the object will contain all
 keys and values in this CBOR map.</li> <li>If the type is an
  enumeration constant (&quot;enum&quot;), and this CBOR object is an integer or
 text string, returns the enumeration constant with the given number
 or name, respectively. (Enumeration constants made up of multiple
 enumeration constants, as allowed by .NET, can only be matched by
 number this way.)</li> <li>If the type is <code>java.util.Date</code> (or
 <code>Date</code> in Java) , returns a date/time object if the CBOR
 object&#39;s outermost tag is 0 or 1. For tag 1, this method treats the
 CBOR object as a number of seconds since the start of 1970, which is
  based on the POSIX definition of &quot;seconds since the Epoch&quot;, a
 definition that does not count leap seconds. In this method, this
 number of seconds assumes the use of a proleptic Gregorian calendar,
 in which the rules regarding the number of days in each month and
 which years are leap years are the same for all years as they were
 in 1970 (including without regard to time zone differences or
 transitions from other calendars to the Gregorian). The string
 format used in tag 0 supports only years up to 4 decimal digits
 long. For tag 1, CBOR objects that express infinity or not-a-number
 (NaN) are treated as invalid by this method. This default behavior
 for <code>java.util.Date</code> and <code>Date</code> can be changed by passing a
 suitable CBORTypeMapper to this method, such as a CBORTypeMapper
 that registers a CBORDateConverter for <code>java.util.Date</code> or
 <code>Date</code> objects. See the examples.</li> <li>If the type is
 <code>java.net.URI</code> (or <code>URI</code> in Java), returns a URI object if
 possible.</li> <li>If the type is <code>java.util.UUID</code> (or <code>UUID</code> in
 Java), returns a UUID object if possible.</li> <li>Plain-Old-Data
 deserialization: If the object is a type not specially handled
 above, the type includes a zero-parameter constructor (default or
  not), this CBOR object is a CBOR map, and the &quot;mapper&quot; parameter (if
 any) allows this type to be eligible for Plain-Old-Data
 deserialization, then this method checks the given type for eligible
 setters as follows:</li> <li>(<em>) In the .NET version, eligible
 setters are the public, nonstatic setters of properties with a
 public, nonstatic getter. Eligible setters also include public,
 nonstatic, non- <code>static final</code> , non- <code>readonly</code> fields. If a
  class has two properties and/or fields of the form &quot;X&quot; and &quot;IsX&quot;,
  where &quot;X&quot; is any name, or has multiple properties and/or fields with
 the same name, those properties and fields are ignored.</li> <li>(</em>)
 In the Java version, eligible setters are public, nonstatic methods
  starting with &quot;set&quot; followed by a character other than a basic digit
  or lower-case letter, that is, other than &quot;a&quot; to &quot;z&quot; or &quot;0&quot; to &quot;9&quot;,
 that take one parameter. The class containing an eligible setter
 must have a public, nonstatic method with the same name, but
  starting with &quot;get&quot; or &quot;is&quot; rather than &quot;set&quot;, that takes no
 parameters and does not return void. (For example, if a class has
  &quot;public setValue(string)&quot; and &quot;public getValue()&quot;, &quot;setValue&quot; is an
  eligible setter. However, &quot;setValue()&quot; and &quot;setValue(string, int)&quot;
 are not eligible setters.) In addition, public, nonstatic, nonfinal
 fields are also eligible setters. If a class has two or more
 otherwise eligible setters (methods and/or fields) with the same
 name, but different parameter type, they are not eligible
 setters.</li> <li>Then, the method creates an object of the given
 type and invokes each eligible setter with the corresponding value
 in the CBOR map, if any. Key names in the map are matched to
 eligible setters according to the rules described in the <code>PODOptions</code> documentation. Note that for
 security reasons, certain types are not supported even if they
 contain eligible setters. For the Java version, the object creation
 may fail in the case of a nested nonstatic class.</li> </ul><p>
 </p><p>The following example (originally written in C# for the DotNet
 version) uses a CBORTypeMapper to change how CBOR objects are
 converted to java.util.Date objects. In this case, the ToObject method
 assumes the CBOR object is an untagged number giving the number of
 seconds since the start of 1970.</p> <pre>CBORTypeMapper conv = new CBORTypeMapper().AddConverter(java.util.Date.class, CBORDateConverter.UntaggedNumber); var obj = CBORObject.FromObject().getToObject()&lt;java.util.Date&gt;(conv);</pre>
 <p>Java offers no easy way to express a generic type, at least none
 as easy as C#&#39;s <code>typeof</code> operator. The following example,
 written in Java, is a way to specify that the return value will be
 an ArrayList of string objects.</p> <pre>Type arrayListString = new ParameterizedType() { public Type[] getActualTypeArguments() { /* Contains one type parameter, string<em>/ return new Type[] { string.class }; } public Type getRawType() { /</em> Raw type is ArrayList */ return ArrayList.class; } public Type getOwnerType() { return null; } }; ArrayList&lt;string&gt; array = (ArrayList&lt;string&gt;) cborArray.ToObject(arrayListString);</pre>
 <p>By comparison, the C# version is much shorter.</p>
 <pre>List&lt;string&gt; array = (List&lt;string&gt;)cborArray.ToObject(typeof(List&lt;string&gt;));</pre> .</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>t</code> - The type, class, or interface that this method&#39;s return value will
belong to. To express a generic type in Java, see the example.
<b>Note:</b> For security reasons, an application should not base
this parameter on user input or other externally supplied data.
Whenever possible, this parameter should be either a type specially
handled by this method, such as <code>int</code> or <code>string</code> , or a
plain-old-data type (POCO or POJO type) within the control of the
application. If the plain-old-data type references other data types,
those types should likewise meet either criterion above.</p></li>
<li><p><code>mapper</code> - This parameter controls which data types are eligible for
Plain-Old-Data deserialization and includes custom converters from
CBOR objects to certain data types. Can be null.</p></li>
<li><p><code>options</code> - Specifies options for controlling deserialization of CBOR
objects.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The converted object.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>CBORException</code> - The given type <code>t</code> , or
this object&#39;s CBOR type, is not supported, or the given object&#39;s
nesting is too deep, or another error occurred when serializing the
object.</p></li>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>t</code> or <code>options</code> is
null.</p></li>
</ul>

<h3><a id='DecodeObjectFromBytes(byte[],com.upokecenter.cbor.CBOREncodeOptions,java.lang.reflect.Type,com.upokecenter.cbor.CBORTypeMapper,com.upokecenter.cbor.PODOptions)'>DecodeObjectFromBytes</a></h3>

<p>Generates an object of an arbitrary type from an array of CBOR-encoded
 bytes, using the given <code>CBOREncodeOptions</code> object to control
 the decoding process. It is equivalent to DecodeFromBytes followed
 by ToObject. See the documentation for those methods for more
 information.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>data</code> - A byte array in which a single CBOR object is encoded.</p></li>
<li><p><code>enc</code> - Specifies options to control how the CBOR object is decoded. See
<code>CBOREncodeOptions</code> for more information.</p></li>
<li><p><code>t</code> - The type, class, or interface that this method&#39;s return value will
belong to. To express a generic type in Java, see the example.
<b>Note:</b> For security reasons, an application should not base
this parameter on user input or other externally supplied data.
Whenever possible, this parameter should be either a type specially
handled by this method, such as <code>int</code> or <code>string</code>, or a
plain-old-data type (POCO or POJO type) within the control of the
application. If the plain-old-data type references other data types,
those types should likewise meet either criterion above.</p></li>
<li><p><code>mapper</code> - This parameter controls which data types are eligible for
Plain-Old-Data deserialization and includes custom converters from
CBOR objects to certain data types. Can be null.</p></li>
<li><p><code>pod</code> - Specifies options for controlling deserialization of CBOR
objects.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An object of the given type decoded from the given byte array.
Returns null (as opposed to CBORObject.Null) if <code>data</code> is
empty and the AllowEmpty property is set on the given
CBOREncodeOptions object.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>CBORException</code> - There was an error in reading or
parsing the data. This includes cases where not all of the byte
array represents a CBOR object. This exception is also thrown if the
parameter <code>data</code> is empty unless the AllowEmpty property is
set on the given options object. Also thrown if the given type
<code>t</code>, or this object&#39;s CBOR type, is not supported, or the
given object&#39;s nesting is too deep, or another error occurred when
serializing the object.</p></li>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>data</code> is null, or the
parameter <code>enc</code> is null, or the parameter <code>t</code> or <code>
pod</code> is null.</p></li>
</ul>

<h3><a id='DecodeObjectFromBytes(byte[],com.upokecenter.cbor.CBOREncodeOptions,java.lang.reflect.Type)'>DecodeObjectFromBytes</a></h3>

<p>Generates an object of an arbitrary type from an array of CBOR-encoded
 bytes, using the given <code>CBOREncodeOptions</code> object to control
 the decoding process. It is equivalent to DecodeFromBytes followed
 by ToObject. See the documentation for those methods for more
 information.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>data</code> - A byte array in which a single CBOR object is encoded.</p></li>
<li><p><code>enc</code> - Specifies options to control how the CBOR object is decoded. See
<code>CBOREncodeOptions</code> for more information.</p></li>
<li><p><code>t</code> - The type, class, or interface that this method&#39;s return value will
belong to. To express a generic type in Java, see the example.
<b>Note:</b> For security reasons, an application should not base
this parameter on user input or other externally supplied data.
Whenever possible, this parameter should be either a type specially
handled by this method, such as <code>int</code> or <code>string</code>, or a
plain-old-data type (POCO or POJO type) within the control of the
application. If the plain-old-data type references other data types,
those types should likewise meet either criterion above.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An object of the given type decoded from the given byte array.
Returns null (as opposed to CBORObject.Null) if <code>data</code> is
empty and the AllowEmpty property is set on the given
CBOREncodeOptions object.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>CBORException</code> - There was an error in reading or
parsing the data. This includes cases where not all of the byte
array represents a CBOR object. This exception is also thrown if the
parameter <code>data</code> is empty unless the AllowEmpty property is
set on the given options object. Also thrown if the given type
<code>t</code>, or this object&#39;s CBOR type, is not supported, or the
given object&#39;s nesting is too deep, or another error occurred when
serializing the object.</p></li>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>data</code> is null, or the
parameter <code>enc</code> is null, or the parameter <code>t</code> is null.</p></li>
</ul>

<h3><a id='DecodeObjectFromBytes(byte[],java.lang.reflect.Type,com.upokecenter.cbor.CBORTypeMapper,com.upokecenter.cbor.PODOptions)'>DecodeObjectFromBytes</a></h3>

<p>Generates an object of an arbitrary type from an array of CBOR-encoded
 bytes. It is equivalent to DecodeFromBytes followed by ToObject. See
 the documentation for those methods for more information.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>data</code> - A byte array in which a single CBOR object is encoded.</p></li>
<li><p><code>t</code> - The type, class, or interface that this method&#39;s return value will
belong to. To express a generic type in Java, see the example.
<b>Note:</b> For security reasons, an application should not base
this parameter on user input or other externally supplied data.
Whenever possible, this parameter should be either a type specially
handled by this method, such as <code>int</code> or <code>string</code>, or a
plain-old-data type (POCO or POJO type) within the control of the
application. If the plain-old-data type references other data types,
those types should likewise meet either criterion above.</p></li>
<li><p><code>mapper</code> - This parameter controls which data types are eligible for
Plain-Old-Data deserialization and includes custom converters from
CBOR objects to certain data types. Can be null.</p></li>
<li><p><code>pod</code> - Specifies options for controlling deserialization of CBOR
objects.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An object of the given type decoded from the given byte array.
Returns null (as opposed to CBORObject.Null) if <code>data</code> is
empty and the AllowEmpty property is set on the given
CBOREncodeOptions object.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>CBORException</code> - There was an error in reading or
parsing the data. This includes cases where not all of the byte
array represents a CBOR object. This exception is also thrown if the
parameter <code>data</code> is empty unless the AllowEmpty property is
set on the given options object. Also thrown if the given type
<code>t</code>, or this object&#39;s CBOR type, is not supported, or the
given object&#39;s nesting is too deep, or another error occurred when
serializing the object.</p></li>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>data</code> is null, or the
parameter <code>t</code> or <code>pod</code> is null.</p></li>
</ul>

<h3><a id='DecodeObjectFromBytes(byte[],java.lang.reflect.Type)'>DecodeObjectFromBytes</a></h3>

<p>Generates an object of an arbitrary type from an array of CBOR-encoded
 bytes. It is equivalent to DecodeFromBytes followed by ToObject. See
 the documentation for those methods for more information.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>data</code> - A byte array in which a single CBOR object is encoded.</p></li>
<li><p><code>t</code> - The type, class, or interface that this method&#39;s return value will
belong to. To express a generic type in Java, see the example.
<b>Note:</b> For security reasons, an application should not base
this parameter on user input or other externally supplied data.
Whenever possible, this parameter should be either a type specially
handled by this method, such as <code>int</code> or <code>string</code>, or a
plain-old-data type (POCO or POJO type) within the control of the
application. If the plain-old-data type references other data types,
those types should likewise meet either criterion above.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An object of the given type decoded from the given byte array.
Returns null (as opposed to CBORObject.Null) if <code>data</code> is
empty and the AllowEmpty property is set on the given
CBOREncodeOptions object.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>CBORException</code> - There was an error in reading or
parsing the data. This includes cases where not all of the byte
array represents a CBOR object. This exception is also thrown if the
parameter <code>data</code> is empty unless the AllowEmpty property is
set on the given options object. Also thrown if the given type
<code>t</code>, or this object&#39;s CBOR type, is not supported, or the
given object&#39;s nesting is too deep, or another error occurred when
serializing the object.</p></li>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>data</code> is null, or the
parameter <code>t</code> is null.</p></li>
</ul>

<h3><a id='FromObject(long)'>FromObject</a></h3>

<p>Generates a CBOR object from a 64-bit signed integer.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>value</code> - The parameter <code>value</code> is a 64-bit signed integer.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A CBOR object.</li>
</ul>

<h3><a id='FromObject(com.upokecenter.cbor.CBORObject)'>FromObject</a></h3>

<p>Generates a CBOR object from a CBOR object.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>value</code> - The parameter <code>value</code> is a CBOR object.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>Same as <code>value</code>, or &quot;CBORObject.Null&quot; is <code>value</code> is
null.</li>
</ul>

<h3><a id='CalcEncodedSize()'>CalcEncodedSize</a></h3>

<p>Calculates the number of bytes this CBOR object takes when serialized as a
 byte array using the <code>EncodeToBytes()</code> method. This calculation
 assumes that integers, lengths of maps and arrays, lengths of text
 and byte strings, and tag numbers are encoded in their shortest
 form; that floating-point numbers are encoded in their shortest
 value-preserving form; and that no indefinite-length encodings are
 used.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>The number of bytes this CBOR object takes when serialized as a byte
array using the <code>EncodeToBytes()</code> method.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>CBORException</code> - The CBOR object has an extremely
deep level of nesting, including if the CBOR object is or has an
array or map that includes itself.</li>
</ul>

<h3><a id='FromObject(com.upokecenter.numbers.EInteger)'>FromObject</a></h3>

<p>Generates a CBOR object from an arbitrary-precision integer. The CBOR object
 is generated as follows: <ul> <li>If the number is null, returns
 CBORObject.Null.</li> <li>Otherwise, if the number is greater than
 or equal to -(2^64) and less than 2^64, the CBOR object will have
 the object type Integer and the appropriate value.</li>
 <li>Otherwise, the CBOR object will have tag 2 (zero or positive) or
 3 (negative) and the appropriate value.</li></ul></p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>bigintValue</code> - An arbitrary-precision integer. Can be null.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The given number encoded as a CBOR object. Returns CBORObject.Null
if <code>bigintValue</code> is null.</li>
</ul>

<h3><a id='FromObject(com.upokecenter.numbers.EFloat)'>FromObject</a></h3>

<p>Generates a CBOR object from an arbitrary-precision binary floating-point
 number. The CBOR object is generated as follows (this is a change in
 version 4.0): <ul> <li>If the number is null, returns
 CBORObject.Null.</li> <li>Otherwise, if the number expresses
 infinity, not-a-number, or negative zero, the CBOR object will have
 tag 269 and the appropriate format.</li> <li>Otherwise, if the
 number&#39;s exponent is at least 2^64 or less than -(2^64), the CBOR
 object will have tag 265 and the appropriate format.</li>
 <li>Otherwise, the CBOR object will have tag 5 and the appropriate
 format.</li></ul></p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>bigValue</code> - An arbitrary-precision binary floating-point number. Can be
null.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The given number encoded as a CBOR object. Returns CBORObject.Null
if <code>bigValue</code> is null.</li>
</ul>

<h3><a id='FromObject(com.upokecenter.numbers.ERational)'>FromObject</a></h3>

<p>Generates a CBOR object from an arbitrary-precision rational number. The
 CBOR object is generated as follows (this is a change in version
 4.0): <ul> <li>If the number is null, returns CBORObject.Null.</li>
 <li>Otherwise, if the number expresses infinity, not-a-number, or
 negative zero, the CBOR object will have tag 270 and the appropriate
 format.</li> <li>Otherwise, the CBOR object will have tag 30 and the
 appropriate format.</li></ul></p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>bigValue</code> - An arbitrary-precision rational number. Can be null.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The given number encoded as a CBOR object. Returns CBORObject.Null
if <code>bigValue</code> is null.</li>
</ul>

<h3><a id='FromObject(com.upokecenter.numbers.EDecimal)'>FromObject</a></h3>

<p>Generates a CBOR object from a decimal number. The CBOR object is generated
 as follows (this is a change in version 4.0): <ul> <li>If the number
 is null, returns CBORObject.Null.</li> <li>Otherwise, if the number
 expresses infinity, not-a-number, or negative zero, the CBOR object
 will have tag 268 and the appropriate format.</li> <li>If the
 number&#39;s exponent is at least 2^64 or less than -(2^64), the CBOR
 object will have tag 264 and the appropriate format.</li>
 <li>Otherwise, the CBOR object will have tag 4 and the appropriate
 format.</li></ul></p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>bigValue</code> - An arbitrary-precision decimal number. Can be null.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The given number encoded as a CBOR object. Returns CBORObject.Null
if <code>bigValue</code> is null.</li>
</ul>

<h3><a id='FromObject(java.lang.String)'>FromObject</a></h3>

<p>Generates a CBOR object from a text string.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>strValue</code> - A text string value. Can be null.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A CBOR object representing the string, or CBORObject.Null if
stringValue is null.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.IllegalArgumentException</code> - The string contains an unpaired surrogate code
point.</li>
</ul>

<h3><a id='FromObject(int)'>FromObject</a></h3>

<p>Generates a CBOR object from a 32-bit signed integer.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>value</code> - The parameter <code>value</code> is a 32-bit signed integer.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A CBOR object.</li>
</ul>

<h3><a id='FromObject(short)'>FromObject</a></h3>

<p>Generates a CBOR object from a 16-bit signed integer.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>value</code> - The parameter <code>value</code> is a 16-bit signed integer.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A CBOR object generated from the given integer.</li>
</ul>

<h3><a id='FromObject(boolean)'>FromObject</a></h3>

<p>Returns the CBOR true value or false value, depending on &quot;value&quot;.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>value</code> - Either <code>true</code> or <code>false</code>.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>CBORObject.True if value is true; otherwise CBORObject.False.</li>
</ul>

<h3><a id='FromObject(byte)'>FromObject</a></h3>

<p>Generates a CBOR object from a byte (0 to 255).</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>value</code> - The parameter <code>value</code> is a byte (from 0 to 255).</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A CBOR object generated from the given integer.</li>
</ul>

<h3><a id='FromObject(float)'>FromObject</a></h3>

<p>Generates a CBOR object from a 32-bit floating-point number. The input value
 can be a not-a-number (NaN) value (such as <code>Float.NaN</code> in
 DotNet or Float.NaN in Java); however, NaN values have multiple
 forms that are equivalent for many applications&#39; purposes, and
 <code>Float.NaN</code> / <code>Float.NaN</code> is only one of these equivalent
 forms. In fact, <code>CBORObject.FromObject(Float.NaN)</code> or
 <code>CBORObject.FromObject(Float.NaN)</code> could produce a CBOR-encoded
 object that differs between DotNet and Java, because
 <code>Float.NaN</code> / <code>Float.NaN</code> may have a different form in
 DotNet and Java (for example, the NaN value&#39;s sign may be negative
 in DotNet, but positive in Java).</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>value</code> - The parameter <code>value</code> is a 32-bit floating-point number.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A CBOR object generated from the given number.</li>
</ul>

<h3><a id='FromObject(double)'>FromObject</a></h3>

<p>Generates a CBOR object from a 64-bit floating-point number. The input value
 can be a not-a-number (NaN) value (such as <code>Double.NaN</code>);
 however, NaN values have multiple forms that are equivalent for many
 applications&#39; purposes, and <code>Double.NaN</code> is only one of these
 equivalent forms. In fact, <code>CBORObject.FromObject(Double.NaN)</code>
 could produce a CBOR-encoded object that differs between DotNet and
 Java, because <code>Double.NaN</code> may have a different form in DotNet
 and Java (for example, the NaN value&#39;s sign may be negative in
 DotNet, but positive in Java).</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>value</code> - The parameter <code>value</code> is a 64-bit floating-point number.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A CBOR object generated from the given number.</li>
</ul>

<h3><a id='FromObject(byte[])'>FromObject</a></h3>

<p>Generates a CBOR object from an array of 8-bit bytes; the byte array is
 copied to a new byte array in this process. (This method can&#39;t be
 used to decode CBOR data from a byte array; for that, use the
 <b>DecodeFromBytes</b> method instead.).</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>bytes</code> - An array of 8-bit bytes; can be null.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A CBOR object where each element of the given byte array is copied
to a new array, or CBORObject.Null if the value is null.</li>
</ul>

<h3><a id='FromObject(com.upokecenter.cbor.CBORObject[])'>FromObject</a></h3>

<p>Generates a CBOR object from an array of CBOR objects.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>array</code> - An array of CBOR objects.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A CBOR object where each element of the given array is copied to a
new array, or CBORObject.Null if the value is null.</li>
</ul>

<h3><a id='FromObject(int[])'>FromObject</a></h3>

<p>Generates a CBOR object from an array of 32-bit integers.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>array</code> - An array of 32-bit integers.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A CBOR array object where each element of the given array is copied
to a new array, or CBORObject.Null if the value is null.</li>
</ul>

<h3><a id='FromObject(long[])'>FromObject</a></h3>

<p>Generates a CBOR object from an array of 64-bit integers.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>array</code> - An array of 64-bit integers.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A CBOR array object where each element of the given array is copied
to a new array, or CBORObject.Null if the value is null.</li>
</ul>

<h3><a id='FromObject(java.lang.Object)'>FromObject</a></h3>

<p>Generates a CBORObject from an arbitrary object. See the overload of this
 method that takes CBORTypeMapper and PODOptions arguments.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>obj</code> - The parameter <code>obj</code> is an arbitrary object, which can be
null. <p><b>NOTE:</b> For security reasons, whenever possible, an
application should not base this parameter on user input or other
externally supplied data, and whenever possible, the application
should limit this parameter&#39;s inputs to types specially handled by
this method (such as <code>int</code> or <code>string</code>) and/or to
plain-old-data types (POCO or POJO types) within the control of the
application. If the plain-old-data type references other data types,
those types should likewise meet either criterion above.</p>.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A CBOR object corresponding to the given object. Returns
CBORObject.Null if the object is null.</li>
</ul>

<h3><a id='FromObject(java.lang.Object,com.upokecenter.cbor.PODOptions)'>FromObject</a></h3>

<p>Generates a CBORObject from an arbitrary object. See the overload of this
 method that takes CBORTypeMapper and PODOptions arguments.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>obj</code> - The parameter <code>obj</code> is an arbitrary object. <p><b>NOTE:</b>
For security reasons, whenever possible, an application should not
base this parameter on user input or other externally supplied data,
and whenever possible, the application should limit this parameter&#39;s
inputs to types specially handled by this method (such as <code>
int</code> or <code>string</code>) and/or to plain-old-data types (POCO or
POJO types) within the control of the application. If the
plain-old-data type references other data types, those types should
likewise meet either criterion above.</p>.</p></li>
<li><p><code>options</code> - An object containing options to control how certain objects
are converted to CBOR objects.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A CBOR object corresponding to the given object. Returns
CBORObject.Null if the object is null.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.NullPointerException</code> - The parameter <code>options</code> is null.</li>
</ul>

<h3><a id='FromObject(java.lang.Object,com.upokecenter.cbor.CBORTypeMapper)'>FromObject</a></h3>

<p>Generates a CBORObject from an arbitrary object. See the overload of this
 method that takes CBORTypeMapper and PODOptions arguments.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>obj</code> - The parameter <code>obj</code> is an arbitrary object. <p><b>NOTE:</b>
For security reasons, whenever possible, an application should not
base this parameter on user input or other externally supplied data,
and whenever possible, the application should limit this parameter&#39;s
inputs to types specially handled by this method (such as <code>
int</code> or <code>string</code>) and/or to plain-old-data types (POCO or
POJO types) within the control of the application. If the
plain-old-data type references other data types, those types should
likewise meet either criterion above.</p>.</p></li>
<li><p><code>mapper</code> - An object containing optional converters to convert objects of
certain types to CBOR objects.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A CBOR object corresponding to the given object. Returns
CBORObject.Null if the object is null.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.NullPointerException</code> - The parameter <code>mapper</code> is null.</li>
</ul>

<h3><a id='FromObject(java.lang.Object,com.upokecenter.cbor.CBORTypeMapper,com.upokecenter.cbor.PODOptions)'>FromObject</a></h3>

<pre>CBORTypeMapper conv = new CBORTypeMapper().AddConverter(java.util.Date.class, CBORDateConverter.TaggedNumber); CBORObject obj = CBORObject.FromObject(java.util.Date.Now, conv);
</pre>

<p>Generates a CBORObject from an arbitrary object, using the given options
 to control how certain objects are converted to CBOR objects. The
 following cases are checked in the logical order given (rather than
 the strict order in which they are implemented by this library):</p>

<p><ul><li><code>null</code> is converted to <code>CBORObject.Null</code> .</li>
 <li>A <code>CBORObject</code> is returned as itself.</li> <li>If the
 object is of a type corresponding to a type converter mentioned in
 the <paramref name='mapper'/> parameter, that converter will be used
 to convert the object to a CBOR object. Type converters can be used
 to override the default conversion behavior of almost any
 object.</li> <li>A <code>char</code> is converted to an integer (from 0
 through 65535), and returns a CBOR object of that integer. (This is
 a change in version 4.0 from previous versions, which converted
 <code>char</code> , except surrogate code points from 0xd800 through
 0xdfff, into single-character text strings.)</li> <li>A
 <code>boolean</code> (<code>boolean</code> in Java) is converted to
 <code>CBORObject.True</code> or <code>CBORObject.False</code> .</li> <li>A
 <code>byte</code> is converted to a CBOR integer from 0 through 255.</li>
 <li>A primitive integer type (<code>int</code> , <code>short</code> ,
 <code>long</code> , as well as <code>sbyte</code> , <code>ushort</code> , <code>uint</code>
 , and <code>ulong</code> in.NET) is converted to the corresponding CBOR
 integer.</li> <li>A primitive floating-point type (<code>float</code> ,
 <code>double</code> , as well as <code>decimal</code> in.NET) is converted to
 the corresponding CBOR number.</li> <li>A <code>string</code> is converted
 to a CBOR text string. To create a CBOR byte string object from
 <code>string</code> , see the example given in <see cref='PeterO.Cbor.CBORObject.FromObject(System.Byte[])'/>.</li>
 <li>In the.NET version, a nullable is converted to
 <code>CBORObject.Null</code> if the nullable&#39;s value is <code>null</code> , or
 converted according to the nullable&#39;s underlying type, if that type
 is supported by this method.</li> <li>In the Java version, a number
 of type <code>BigInteger</code> or <code>BigDecimal</code> is converted to the
 corresponding CBOR number.</li> <li>A number of type <code>EDecimal</code>
 , <code>EFloat</code> , <code>EInteger</code> , and <code>ERational</code> in the <code>PeterO.Numbers</code>
  library (in .NET) or the <code>com.github.peteroupc/numbers</code>
  artifact (in Java) is converted to the corresponding CBOR
 number.</li> <li>An array other than <code>byte[]</code> is converted to a
 CBOR array. In the.NET version, a multidimensional array is
 converted to an array of arrays.</li> <li>A <code>byte[]</code>
 (1-dimensional byte array) is converted to a CBOR byte string; the
 byte array is copied to a new byte array in this process. (This
 method can&#39;t be used to decode CBOR data from a byte array; for
 that, use the <b>DecodeFromBytes</b> method instead.)</li> <li>An
 object implementing Map (Map in Java) is converted to a CBOR map
 containing the keys and values enumerated.</li> <li>An object
 implementing Iterable (Iterable in Java) is converted to a CBOR
 array containing the items enumerated.</li> <li>An enumeration(
 <code>Enum</code>) object is converted to its <i>underlying value</i> in
 the.NET version, or the result of its <code>ordinal()</code> method in the
 Java version.</li> <li>An object of type <code>java.util.Date</code> ,
 <code>java.net.URI</code> , or <code>java.util.UUID</code> (<code>Date</code> , <code>URI</code> , or
 <code>UUID</code> , respectively, in Java) will be converted to a tagged
 CBOR object of the appropriate kind. By default, <code>java.util.Date</code> /
 <code>Date</code> will be converted to a tag-0 string following the date
 format used in the Atom syndication format, but this behavior can be
 changed by passing a suitable CBORTypeMapper to this method, such as
 a CBORTypeMapper that registers a CBORDateConverter for
 <code>java.util.Date</code> or <code>Date</code> objects. See the examples.</li>
 <li>If the object is a type not specially handled above, this method
 checks the <paramref name='obj'/> parameter for eligible getters as
 follows:</li> <li>(<em>) In the .NET version, eligible getters are the
 public, nonstatic getters of read/write properties (and also those
 of read-only properties in the case of a compiler-generated type or
 an F# type). Eligible getters also include public, nonstatic, non-
 <code>static final</code> , non- <code>readonly</code> fields. If a class has two
  properties and/or fields of the form &quot;X&quot; and &quot;IsX&quot;, where &quot;X&quot; is any
 name, or has multiple properties and/or fields with the same name,
 those properties and fields are ignored.</li> <li>(</em>) In the Java
 version, eligible getters are public, nonstatic methods starting
  with &quot;get&quot; or &quot;is&quot; (either word followed by a character other than a
  basic digit or lower-case letter, that is, other than &quot;a&quot; to &quot;z&quot; or
  &quot;0&quot; to &quot;9&quot;), that take no parameters and do not return void, except
  that methods named &quot;getClass&quot; are not eligible getters. In addition,
 public, nonstatic, nonfinal fields are also eligible getters. If a
 class has two otherwise eligible getters (methods and/or fields) of
  the form &quot;isX&quot; and &quot;getX&quot;, where &quot;X&quot; is the same in both, or two
 such getters with the same name but different return type, they are
 not eligible getters.</li> <li>Then, the method returns a CBOR map
 with each eligible getter&#39;s name or property name as each key, and
 with the corresponding value returned by that getter as that key&#39;s
 value. Before adding a key-value pair to the map, the key&#39;s name is
 adjusted according to the rules described in the <code>PODOptions</code> documentation. Note that for
 security reasons, certain types are not supported even if they
 contain eligible getters.</li> </ul> <p><b>REMARK:</b> .NET
 enumeration (<code>Enum</code>) constants could also have been converted
 to text strings with <code>toString()</code> , but that method will return
 multiple names if the given Enum object is a combination of Enum
 objects (e.g. if the object is <code>FileAccess.Read |
 FileAccess.Write</code>). More generally, if Enums are converted to
 text strings, constants from Enum types with the <code>Flags</code>
 attribute, and constants from the same Enum type that share an
 underlying value, should not be passed to this method.</p><p> </p><p>The
 following example (originally written in C# for the DotNet version)
 uses a CBORTypeMapper to change how java.util.Date objects are converted
 to CBOR. In this case, such objects are converted to CBOR objects
 with tag 1 that store numbers giving the number of seconds since the
 start of 1970.</p> <pre>CBORTypeMapper conv = new CBORTypeMapper().AddConverter(java.util.Date.class, CBORDateConverter.TaggedNumber); CBORObject obj = CBORObject.FromObject(java.util.Date.Now, conv);</pre> <p>The following
 example generates a CBOR object from a 64-bit signed integer that is
 treated as a 64-bit unsigned integer (such as DotNet&#39;s UInt64, which
 has no direct equivalent in the Java language), in the sense that
 the value is treated as 2^64 plus the original value if it&#39;s
 negative.</p> <pre>long x = -40L; /* Example 64-bit value treated as 2^64-40.<em>/ CBORObject obj = CBORObject.FromObject(v &lt; 0 ? EInteger.FromInt32(1).ShiftLeft(64).Add(v) : EInteger.FromInt64(v));</pre> <p>In the Java version, which has
 java.math.getBigInteger(), the following can be used instead:</p>
 <pre>long x = -40L; /</em> Example 64-bit value treated as 2^64-40.*/ CBORObject obj = CBORObject.FromObject(v &lt; 0 ? BigInteger.valueOf(1).shiftLeft(64).add(BigInteger.valueOf(v)) : BigInteger.valueOf(v));</pre></p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>obj</code> - An arbitrary object to convert to a CBOR object. <p><b>NOTE:</b>
For security reasons, whenever possible, an application should not
base this parameter on user input or other externally supplied data,
and whenever possible, the application should limit this parameter&#39;s
inputs to types specially handled by this method (such as <code>
int</code> or <code>string</code>) and/or to plain-old-data types (POCO or
POJO types) within the control of the application. If the
plain-old-data type references other data types, those types should
likewise meet either criterion above.</p>.</p></li>
<li><p><code>mapper</code> - An object containing optional converters to convert objects of
certain types to CBOR objects. Can be null.</p></li>
<li><p><code>options</code> - An object containing options to control how certain objects
are converted to CBOR objects.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A CBOR object corresponding to the given object. Returns
CBORObject.Null if the object is null.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>options</code> is null.</p></li>
<li><p><code>CBORException</code> - An error occurred while
converting the given object to a CBOR object.</p></li>
</ul>

<h3><a id='WithTag(com.upokecenter.numbers.EInteger)'>WithTag</a></h3>

<p>Generates a CBOR object from this one, but gives the resulting object a tag
 in addition to its existing tags (the new tag is made the outermost
 tag).</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>bigintTag</code> - Tag number. The tag number 55799 can be used to mark a
&quot;self-described CBOR&quot; object. This document does not attempt to list
all CBOR tags and their meanings. An up-to-date list can be found at
the CBOR Tags registry maintained by the Internet Assigned Numbers
Authority(<i>iana.org/assignments/cbor-tags</i>).</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A CBOR object with the same value as this one but given the tag
<code>bigintTag</code> in addition to its existing tags (the new tag is
made the outermost tag).</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.IllegalArgumentException</code> - The parameter <code>bigintTag</code> is less than 0 or
greater than 2^64-1.</p></li>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>bigintTag</code> is null.</p></li>
</ul>

<h3><a id='FromObjectAndTag(java.lang.Object,com.upokecenter.numbers.EInteger)'>FromObjectAndTag</a></h3>

<p>Generates a CBOR object from an arbitrary object and gives the resulting
 object a tag in addition to its existing tags (the new tag is made
 the outermost tag).</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>valueOb</code> - The parameter <code>valueOb</code> is an arbitrary object, which
can be null. <p><b>NOTE:</b> For security reasons, whenever
possible, an application should not base this parameter on user
input or other externally supplied data, and whenever possible, the
application should limit this parameter&#39;s inputs to types specially
handled by this method (such as <code>int</code> or <code>string</code>)
and/or to plain-old-data types (POCO or POJO types) within the
control of the application. If the plain-old-data type references
other data types, those types should likewise meet either criterion
above.</p>.</p></li>
<li><p><code>bigintTag</code> - Tag number. The tag number 55799 can be used to mark a
&quot;self-described CBOR&quot; object. This document does not attempt to list
all CBOR tags and their meanings. An up-to-date list can be found at
the CBOR Tags registry maintained by the Internet Assigned Numbers
Authority(<i>iana.org/assignments/cbor-tags</i>).</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A CBOR object where the object <code>valueOb</code> is converted to a
CBOR object and given the tag <code>bigintTag</code>. If <code>valueOb</code>
is null, returns a version of CBORObject.Null with the given tag.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.IllegalArgumentException</code> - The parameter <code>bigintTag</code> is less than 0 or
greater than 2^64-1.</p></li>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>bigintTag</code> is null.</p></li>
</ul>

<h3><a id='WithTag(int)'>WithTag</a></h3>

<p>Generates a CBOR object from an arbitrary object and gives the resulting
 object a tag in addition to its existing tags (the new tag is made
 the outermost tag).</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>smallTag</code> - A 32-bit integer that specifies a tag number. The tag number
55799 can be used to mark a &quot;self-described CBOR&quot; object. This
document does not attempt to list all CBOR tags and their meanings.
An up-to-date list can be found at the CBOR Tags registry maintained
by the Internet Assigned Numbers Authority(
<i>iana.org/assignments/cbor-tags</i>).</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A CBOR object with the same value as this one but given the tag
<code>smallTag</code> in addition to its existing tags (the new tag is
made the outermost tag).</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.IllegalArgumentException</code> - The parameter <code>smallTag</code> is less than 0.</li>
</ul>

<h3><a id='FromObjectAndTag(java.lang.Object,int)'>FromObjectAndTag</a></h3>

<p>Generates a CBOR object from an arbitrary object and gives the resulting
 object a tag in addition to its existing tags (the new tag is made
 the outermost tag).</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>valueObValue</code> - The parameter <code>valueObValue</code> is an arbitrary
object, which can be null. <p><b>NOTE:</b> For security reasons,
whenever possible, an application should not base this parameter on
user input or other externally supplied data, and whenever possible,
the application should limit this parameter&#39;s inputs to types
specially handled by this method (such as <code>int</code> or <code>
string</code>) and/or to plain-old-data types (POCO or POJO types) within
the control of the application. If the plain-old-data type
references other data types, those types should likewise meet either
criterion above.</p>.</p></li>
<li><p><code>smallTag</code> - A 32-bit integer that specifies a tag number. The tag number
55799 can be used to mark a &quot;self-described CBOR&quot; object. This
document does not attempt to list all CBOR tags and their meanings.
An up-to-date list can be found at the CBOR Tags registry maintained
by the Internet Assigned Numbers Authority(
<i>iana.org/assignments/cbor-tags</i>).</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A CBOR object where the object <code>valueObValue</code> is converted to
a CBOR object and given the tag <code>smallTag</code>. If &quot;valueOb&quot; is
null, returns a version of CBORObject.Null with the given tag.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.IllegalArgumentException</code> - The parameter <code>smallTag</code> is less than 0.</li>
</ul>

<h3><a id='FromSimpleValue(int)'>FromSimpleValue</a></h3>

<p>Creates a CBOR object from a simple value number.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>simpleValue</code> - The parameter <code>simpleValue</code> is a 32-bit signed
integer.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A CBOR object.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.IllegalArgumentException</code> - The parameter <code>simpleValue</code> is less than 0,
greater than 255, or from 24 through 31.</li>
</ul>

<h3><a id='Multiply(com.upokecenter.cbor.CBORObject,com.upokecenter.cbor.CBORObject)'>Multiply</a></h3>

<p>Multiplies two CBOR numbers.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>first</code> - The parameter <code>first</code> is a CBOR object.</p></li>
<li><p><code>second</code> - The parameter <code>second</code> is a CBOR object.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The product of the two numbers.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.IllegalArgumentException</code> - Either or both operands are not numbers (as
opposed to Not-a-Number, NaN).</p></li>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>first</code> or <code>second</code>
is null.</p></li>
</ul>

<h3><a id='NewArray()'>NewArray</a></h3>

<p>Creates a new empty CBOR array.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>A new CBOR array.</li>
</ul>

<h3><a id='NewMap()'>NewMap</a></h3>

<p>Creates a new empty CBOR map that stores its keys in an undefined order.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>A new CBOR map.</li>
</ul>

<h3><a id='NewOrderedMap()'>NewOrderedMap</a></h3>

<p>Creates a new empty CBOR map that ensures that keys are stored in the order
 in which they are first inserted.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>A new CBOR map.</li>
</ul>

<h3><a id='ReadSequence(java.io.InputStream)'>ReadSequence</a></h3>

<p>Reads a sequence of objects in CBOR format from a data stream. This
 method will read CBOR objects from the stream until the end of the
 stream is reached or an error occurs, whichever happens first.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>stream</code> - A readable data stream.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An array containing the CBOR objects that were read from the data
stream. Returns an empty array if there is no unread data in the
stream.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>stream</code> is null, or the
parameter &quot;options&quot; is null.</p></li>
<li><p><code>CBORException</code> - There was an error in reading or
parsing the data, including if the last CBOR object was read only
partially.</p></li>
<li><p><code>java.io.IOException</code></p></li>
</ul>

<h3><a id='ReadSequence(java.io.InputStream,com.upokecenter.cbor.CBOREncodeOptions)'>ReadSequence</a></h3>

<p>Reads a sequence of objects in CBOR format from a data stream. This
 method will read CBOR objects from the stream until the end of the
 stream is reached or an error occurs, whichever happens first.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>stream</code> - A readable data stream.</p></li>
<li><p><code>options</code> - Specifies the options to use when decoding the CBOR data
stream. See CBOREncodeOptions for more information. In this method,
the AllowEmpty property is treated as set regardless of the value of
that property specified in this parameter.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An array containing the CBOR objects that were read from the data
stream. Returns an empty array if there is no unread data in the
stream.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>stream</code> is null, or the
parameter <code>options</code> is null.</p></li>
<li><p><code>CBORException</code> - There was an error in reading or
parsing the data, including if the last CBOR object was read only
partially.</p></li>
<li><p><code>java.io.IOException</code></p></li>
</ul>

<h3><a id='Read(java.io.InputStream)'>Read</a></h3>

<p>Reads an object in CBOR format from a data stream. This method will read
 from the stream until the end of the CBOR object is reached or an
 error occurs, whichever happens first.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>stream</code> - A readable data stream.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A CBOR object that was read.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>stream</code> is null.</p></li>
<li><p><code>CBORException</code> - There was an error in reading or
parsing the data.</p></li>
</ul>

<h3><a id='Read(java.io.InputStream,com.upokecenter.cbor.CBOREncodeOptions)'>Read</a></h3>

<p>Reads an object in CBOR format from a data stream, using the specified
 options to control the decoding process. This method will read from
 the stream until the end of the CBOR object is reached or an error
 occurs, whichever happens first.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>stream</code> - A readable data stream.</p></li>
<li><p><code>options</code> - Specifies the options to use when decoding the CBOR data
stream. See CBOREncodeOptions for more information.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A CBOR object that was read.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>stream</code> is null.</p></li>
<li><p><code>CBORException</code> - There was an error in reading or
parsing the data.</p></li>
</ul>

<h3><a id='ReadJSON(java.io.InputStream)'>ReadJSON</a></h3>

<p>Generates a CBOR object from a data stream in JavaScript object Notation
 (JSON) format. The JSON stream may begin with a byte-order mark
 (U+FEFF). Since version 2.0, the JSON stream can be in UTF-8,
 UTF-16, or UTF-32 encoding; the encoding is detected by assuming
 that the first character read must be a byte-order mark or a nonzero
 basic character (U+0001 to U+007F). (In previous versions, only
 UTF-8 was allowed.). (This behavior may change to supporting only
 UTF-8, with or without a byte order mark, in version 5.0 or later,
 perhaps with an option to restore the previous behavior of also
 supporting UTF-16 and UTF-32.).</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>stream</code> - A readable data stream. The sequence of bytes read from the
data stream must contain a single JSON object and not multiple
objects.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A CBOR object.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>stream</code> is null.</p></li>
<li><p><code>java.io.IOException</code> - An I/O error occurred.</p></li>
<li><p><code>CBORException</code> - The data stream contains invalid
encoding or is not in JSON format.</p></li>
</ul>

<h3><a id='ReadJSONSequence(java.io.InputStream)'>ReadJSONSequence</a></h3>

<p>Generates a list of CBOR objects from a data stream in JavaScript object
 Notation (JSON) text sequence format (RFC 7464). The data stream
 must be in UTF-8 encoding and may not begin with a byte-order mark
 (U+FEFF).<p>Generally, each JSON text in a JSON text sequence is
 written as follows: Write a record separator byte (0x1e), then write
 the JSON text in UTF-8 (without a byte order mark, U+FEFF), then
 write the line feed byte (0x0a). RFC 7464, however, uses a more
 liberal syntax for parsing JSON text sequences.</p></p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>stream</code> - A readable data stream. The sequence of bytes read from the
data stream must either be empty or begin with a record separator
byte (0x1e).</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A list of CBOR objects read from the JSON sequence. Objects that
could not be parsed are replaced with <code>null</code> (as opposed to
<code>CBORObject.Null</code>) in the given list.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>stream</code> is null.</p></li>
<li><p><code>java.io.IOException</code> - An I/O error occurred.</p></li>
<li><p><code>CBORException</code> - The data stream is not empty and
does not begin with a record separator byte (0x1e).</p></li>
</ul>

<h3><a id='ReadJSON(java.io.InputStream,com.upokecenter.cbor.CBOREncodeOptions)'>ReadJSON</a></h3>

<p>Generates a CBOR object from a data stream in JavaScript object Notation
 (JSON) format, using the specified options to control the decoding
 process. The JSON stream may begin with a byte-order mark (U+FEFF).
 Since version 2.0, the JSON stream can be in UTF-8, UTF-16, or
 UTF-32 encoding; the encoding is detected by assuming that the first
 character read must be a byte-order mark or a nonzero basic
 character (U+0001 to U+007F). (In previous versions, only UTF-8 was
 allowed.).</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>stream</code> - A readable data stream. The sequence of bytes read from the
data stream must contain a single JSON object and not multiple
objects.</p></li>
<li><p><code>options</code> - Contains options to control the JSON decoding process. This
method uses only the AllowDuplicateKeys property of this object.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A CBOR object containing the JSON data decoded.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>stream</code> is null.</p></li>
<li><p><code>java.io.IOException</code> - An I/O error occurred.</p></li>
<li><p><code>CBORException</code> - The data stream contains invalid
encoding or is not in JSON format.</p></li>
</ul>

<h3><a id='ReadJSONSequence(java.io.InputStream,com.upokecenter.cbor.JSONOptions)'>ReadJSONSequence</a></h3>

<p>Generates a list of CBOR objects from a data stream in JavaScript object
 Notation (JSON) text sequence format (RFC 7464). The data stream
 must be in UTF-8 encoding and may not begin with a byte-order mark
 (U+FEFF).<p>Generally, each JSON text in a JSON text sequence is
 written as follows: Write a record separator byte (0x1e), then write
 the JSON text in UTF-8 (without a byte order mark, U+FEFF), then
 write the line feed byte (0x0a). RFC 7464, however, uses a more
 liberal syntax for parsing JSON text sequences.</p></p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>stream</code> - A readable data stream. The sequence of bytes read from the
data stream must either be empty or begin with a record separator
byte (0x1e).</p></li>
<li><p><code>jsonoptions</code> - Specifies options to control how JSON texts in the stream
are decoded to CBOR. See the JSONOptions class.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A list of CBOR objects read from the JSON sequence. Objects that
could not be parsed are replaced with <code>null</code> (as opposed to
<code>CBORObject.Null</code>) in the given list.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>stream</code> is null.</p></li>
<li><p><code>java.io.IOException</code> - An I/O error occurred.</p></li>
<li><p><code>CBORException</code> - The data stream is not empty and
does not begin with a record separator byte (0x1e).</p></li>
</ul>

<h3><a id='ReadJSON(java.io.InputStream,com.upokecenter.cbor.JSONOptions)'>ReadJSON</a></h3>

<p>Generates a CBOR object from a data stream in JavaScript object Notation
 (JSON) format, using the specified options to control the decoding
 process. The JSON stream may begin with a byte-order mark (U+FEFF).
 Since version 2.0, the JSON stream can be in UTF-8, UTF-16, or
 UTF-32 encoding; the encoding is detected by assuming that the first
 character read must be a byte-order mark or a nonzero basic
 character (U+0001 to U+007F). (In previous versions, only UTF-8 was
 allowed.). (This behavior may change to supporting only UTF-8, with
 or without a byte order mark, in version 5.0 or later, perhaps with
 an option to restore the previous behavior of also supporting UTF-16
 and UTF-32.).</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>stream</code> - A readable data stream. The sequence of bytes read from the
data stream must contain a single JSON object and not multiple
objects.</p></li>
<li><p><code>jsonoptions</code> - Specifies options to control how the JSON stream is
decoded to CBOR. See the JSONOptions class.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A CBOR object containing the JSON data decoded.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>stream</code> is null.</p></li>
<li><p><code>java.io.IOException</code> - An I/O error occurred.</p></li>
<li><p><code>CBORException</code> - The data stream contains invalid
encoding or is not in JSON format.</p></li>
</ul>

<h3><a id='FromJSONBytes(byte[])'>FromJSONBytes</a></h3>

<p>Generates a CBOR object from a byte array in JavaScript object Notation
 (JSON) format.</p> <p>If a JSON object has duplicate keys, a
 CBORException is thrown.</p> <p>Note that if a CBOR object is
 converted to JSON with <code>ToJSONBytes</code>, then the JSON is
 converted back to CBOR with this method, the new CBOR object will
 not necessarily be the same as the old CBOR object, especially if
 the old CBOR object uses data types not supported in JSON, such as
 integers in map keys.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>bytes</code> - A byte array in JSON format. The entire byte array must contain
a single JSON object and not multiple objects. The byte array may
begin with a byte-order mark (U+FEFF). The byte array can be in
UTF-8, UTF-16, or UTF-32 encoding; the encoding is detected by
assuming that the first character read must be a byte-order mark or
a nonzero basic character (U+0001 to U+007F). (This behavior may
change to supporting only UTF-8, with or without a byte order mark,
in version 5.0 or later, perhaps with an option to restore the
previous behavior of also supporting UTF-16 and UTF-32.).</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A CBOR object containing the JSON data decoded.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>bytes</code> is null.</p></li>
<li><p><code>CBORException</code> - The byte array contains invalid
encoding or is not in JSON format.</p></li>
</ul>

<h3><a id='FromJSONBytes(byte[],com.upokecenter.cbor.JSONOptions)'>FromJSONBytes</a></h3>

<p>Generates a CBOR object from a byte array in JavaScript object Notation
 (JSON) format, using the specified options to control the decoding
 process. <p>Note that if a CBOR object is converted to JSON with
 <code>ToJSONBytes</code>, then the JSON is converted back to CBOR with
 this method, the new CBOR object will not necessarily be the same as
 the old CBOR object, especially if the old CBOR object uses data
 types not supported in JSON, such as integers in map keys.</p></p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>bytes</code> - A byte array in JSON format. The entire byte array must contain
a single JSON object and not multiple objects. The byte array may
begin with a byte-order mark (U+FEFF). The byte array can be in
UTF-8, UTF-16, or UTF-32 encoding; the encoding is detected by
assuming that the first character read must be a byte-order mark or
a nonzero basic character (U+0001 to U+007F). (This behavior may
change to supporting only UTF-8, with or without a byte order mark,
in version 5.0 or later, perhaps with an option to restore the
previous behavior of also supporting UTF-16 and UTF-32.).</p></li>
<li><p><code>jsonoptions</code> - Specifies options to control how the JSON data is decoded
to CBOR. See the JSONOptions class.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A CBOR object containing the JSON data decoded.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>bytes</code> or <code>
jsonoptions</code> is null.</p></li>
<li><p><code>CBORException</code> - The byte array contains invalid
encoding or is not in JSON format.</p></li>
</ul>

<h3><a id='FromJSONBytes(byte[],int,int)'>FromJSONBytes</a></h3>

<p>Generates a CBOR object from a byte array in JavaScript object Notation
 (JSON) format.</p> <p>If a JSON object has duplicate keys, a
 CBORException is thrown.</p> <p>Note that if a CBOR object is
 converted to JSON with <code>ToJSONBytes</code>, then the JSON is
 converted back to CBOR with this method, the new CBOR object will
 not necessarily be the same as the old CBOR object, especially if
 the old CBOR object uses data types not supported in JSON, such as
 integers in map keys.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>bytes</code> - A byte array, the specified portion of which is in JSON format.
The specified portion of the byte array must contain a single JSON
object and not multiple objects. The portion may begin with a
byte-order mark (U+FEFF). The portion can be in UTF-8, UTF-16, or
UTF-32 encoding; the encoding is detected by assuming that the first
character read must be a byte-order mark or a nonzero basic
character (U+0001 to U+007F). (This behavior may change to
supporting only UTF-8, with or without a byte order mark, in version
5.0 or later, perhaps with an option to restore the previous
behavior of also supporting UTF-16 and UTF-32.).</p></li>
<li><p><code>offset</code> - An index, starting at 0, showing where the desired portion of
<code>bytes</code> begins.</p></li>
<li><p><code>count</code> - The length, in bytes, of the desired portion of <code>bytes</code>
(but not more than <code>bytes</code> &#39;s length).</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A CBOR object containing the JSON data decoded.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>bytes</code> is null.</p></li>
<li><p><code>CBORException</code> - The byte array contains invalid
encoding or is not in JSON format.</p></li>
<li><p><code>java.lang.IllegalArgumentException</code> - Either <code>offset</code> or <code>count</code> is less
than 0 or greater than <code>bytes</code> &#39;s length, or <code>bytes</code> &#39;s
length minus <code>offset</code> is less than <code>count</code>.</p></li>
</ul>

<h3><a id='FromJSONBytes(byte[],int,int,com.upokecenter.cbor.JSONOptions)'>FromJSONBytes</a></h3>

<p>Generates a CBOR object from a byte array in JavaScript object Notation
 (JSON) format, using the specified options to control the decoding
 process. <p>Note that if a CBOR object is converted to JSON with
 <code>ToJSONBytes</code>, then the JSON is converted back to CBOR with
 this method, the new CBOR object will not necessarily be the same as
 the old CBOR object, especially if the old CBOR object uses data
 types not supported in JSON, such as integers in map keys.</p></p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>bytes</code> - A byte array, the specified portion of which is in JSON format.
The specified portion of the byte array must contain a single JSON
object and not multiple objects. The portion may begin with a
byte-order mark (U+FEFF). The portion can be in UTF-8, UTF-16, or
UTF-32 encoding; the encoding is detected by assuming that the first
character read must be a byte-order mark or a nonzero basic
character (U+0001 to U+007F). (This behavior may change to
supporting only UTF-8, with or without a byte order mark, in version
5.0 or later, perhaps with an option to restore the previous
behavior of also supporting UTF-16 and UTF-32.).</p></li>
<li><p><code>offset</code> - An index, starting at 0, showing where the desired portion of
<code>bytes</code> begins.</p></li>
<li><p><code>count</code> - The length, in bytes, of the desired portion of <code>bytes</code>
(but not more than <code>bytes</code> &#39;s length).</p></li>
<li><p><code>jsonoptions</code> - Specifies options to control how the JSON data is decoded
to CBOR. See the JSONOptions class.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A CBOR object containing the JSON data decoded.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>bytes</code> or <code>
jsonoptions</code> is null.</p></li>
<li><p><code>CBORException</code> - The byte array contains invalid
encoding or is not in JSON format.</p></li>
<li><p><code>java.lang.IllegalArgumentException</code> - Either <code>offset</code> or <code>count</code> is less
than 0 or greater than <code>bytes</code> &#39;s length, or <code>bytes</code> &#39;s
length minus <code>offset</code> is less than <code>count</code>.</p></li>
</ul>

<h3><a id='Remainder(com.upokecenter.cbor.CBORObject,com.upokecenter.cbor.CBORObject)'>Remainder</a></h3>

<p>Finds the remainder that results when a CBORObject object is divided by the
 value of a CBOR object.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>first</code> - The parameter <code>first</code> is a CBOR object.</p></li>
<li><p><code>second</code> - The parameter <code>second</code> is a CBOR object.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The remainder of the two numbers.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.NullPointerException</code> - The parameter <code>first</code> or <code>second</code>
is null.</li>
</ul>

<h3><a id='Subtract(com.upokecenter.cbor.CBORObject,com.upokecenter.cbor.CBORObject)'>Subtract</a></h3>

<p>Finds the difference between two CBOR number objects.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>first</code> - The parameter <code>first</code> is a CBOR object.</p></li>
<li><p><code>second</code> - The parameter <code>second</code> is a CBOR object.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The difference of the two objects.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.IllegalArgumentException</code> - Either or both operands are not numbers (as
opposed to Not-a-Number, NaN).</p></li>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>first</code> or <code>second</code>
is null.</p></li>
</ul>

<h3><a id='Write(java.lang.String,java.io.OutputStream)'>Write</a></h3>

<p>Writes a text string in CBOR format to a data stream. The string will be
 encoded using definite-length encoding regardless of its length.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>str</code> - The string to write. Can be null.</p></li>
<li><p><code>stream</code> - A writable data stream.</p></li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>stream</code> is null.</p></li>
<li><p><code>java.io.IOException</code> - An I/O error occurred.</p></li>
</ul>

<h3><a id='Write(java.lang.String,java.io.OutputStream,com.upokecenter.cbor.CBOREncodeOptions)'>Write</a></h3>

<p>Writes a text string in CBOR format to a data stream, using the given
 options to control the encoding process.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>str</code> - The string to write. Can be null.</p></li>
<li><p><code>stream</code> - A writable data stream.</p></li>
<li><p><code>options</code> - Options for encoding the data to CBOR.</p></li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>stream</code> is null.</p></li>
<li><p><code>java.io.IOException</code> - An I/O error occurred.</p></li>
</ul>

<h3><a id='Write(com.upokecenter.numbers.EFloat,java.io.OutputStream)'>Write</a></h3>

<p>Writes a binary floating-point number in CBOR format to a data stream, as
 though it were converted to a CBOR object via
 CBORObject.FromObject(EFloat) and then written out.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>bignum</code> - An arbitrary-precision binary floating-point number. Can be
null.</p></li>
<li><p><code>stream</code> - A writable data stream.</p></li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>stream</code> is null.</p></li>
<li><p><code>java.io.IOException</code> - An I/O error occurred.</p></li>
</ul>

<h3><a id='Write(com.upokecenter.numbers.ERational,java.io.OutputStream)'>Write</a></h3>

<p>Writes a rational number in CBOR format to a data stream, as though it were
 converted to a CBOR object via CBORObject.FromObject(ERational) and
 then written out.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>rational</code> - An arbitrary-precision rational number. Can be null.</p></li>
<li><p><code>stream</code> - A writable data stream.</p></li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>stream</code> is null.</p></li>
<li><p><code>java.io.IOException</code> - An I/O error occurred.</p></li>
</ul>

<h3><a id='Write(com.upokecenter.numbers.EDecimal,java.io.OutputStream)'>Write</a></h3>

<p>Writes a decimal floating-point number in CBOR format to a data stream, as
 though it were converted to a CBOR object via
 CBORObject.FromObject(EDecimal) and then written out.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>bignum</code> - The arbitrary-precision decimal number to write. Can be null.</p></li>
<li><p><code>stream</code> - InputStream to write to.</p></li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>stream</code> is null.</p></li>
<li><p><code>java.io.IOException</code> - An I/O error occurred.</p></li>
</ul>

<h3><a id='Write(com.upokecenter.numbers.EInteger,java.io.OutputStream)'>Write</a></h3>

<p>Writes a arbitrary-precision integer in CBOR format to a data stream.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>bigint</code> - Arbitrary-precision integer to write. Can be null.</p></li>
<li><p><code>stream</code> - A writable data stream.</p></li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>stream</code> is null.</p></li>
<li><p><code>java.io.IOException</code> - An I/O error occurred.</p></li>
</ul>

<h3><a id='Write(long,java.io.OutputStream)'>Write</a></h3>

<p>Writes a 64-bit signed integer in CBOR format to a data stream.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>value</code> - The value to write.</p></li>
<li><p><code>stream</code> - A writable data stream.</p></li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>stream</code> is null.</p></li>
<li><p><code>java.io.IOException</code> - An I/O error occurred.</p></li>
</ul>

<h3><a id='Write(int,java.io.OutputStream)'>Write</a></h3>

<p>Writes a 32-bit signed integer in CBOR format to a data stream.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>value</code> - The value to write.</p></li>
<li><p><code>stream</code> - A writable data stream.</p></li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>stream</code> is null.</p></li>
<li><p><code>java.io.IOException</code> - An I/O error occurred.</p></li>
</ul>

<h3><a id='Write(short,java.io.OutputStream)'>Write</a></h3>

<p>Writes a 16-bit signed integer in CBOR format to a data stream.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>value</code> - The value to write.</p></li>
<li><p><code>stream</code> - A writable data stream.</p></li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>stream</code> is null.</p></li>
<li><p><code>java.io.IOException</code> - An I/O error occurred.</p></li>
</ul>

<h3><a id='Write(boolean,java.io.OutputStream)'>Write</a></h3>

<p>Writes a Boolean value in CBOR format to a data stream.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>value</code> - The value to write.</p></li>
<li><p><code>stream</code> - A writable data stream.</p></li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>stream</code> is null.</p></li>
<li><p><code>java.io.IOException</code> - An I/O error occurred.</p></li>
</ul>

<h3><a id='Write(byte,java.io.OutputStream)'>Write</a></h3>

<p>Writes a byte (0 to 255) in CBOR format to a data stream. If the value is
 less than 24, writes that byte. If the value is 25 to 255, writes
 the byte 24, then this byte&#39;s value.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>value</code> - The value to write.</p></li>
<li><p><code>stream</code> - A writable data stream.</p></li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>stream</code> is null.</p></li>
<li><p><code>java.io.IOException</code> - An I/O error occurred.</p></li>
</ul>

<h3><a id='Write(float,java.io.OutputStream)'>Write</a></h3>

<p>Writes a 32-bit floating-point number in CBOR format to a data stream. The
 number is written using the shortest floating-point encoding
 possible; this is a change from previous versions.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>value</code> - The value to write.</p></li>
<li><p><code>stream</code> - A writable data stream.</p></li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>stream</code> is null.</p></li>
<li><p><code>java.io.IOException</code> - An I/O error occurred.</p></li>
</ul>

<h3><a id='Write(double,java.io.OutputStream)'>Write</a></h3>

<p>Writes a 64-bit floating-point number in CBOR format to a data stream. The
 number is written using the shortest floating-point encoding
 possible; this is a change from previous versions.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>value</code> - The value to write.</p></li>
<li><p><code>stream</code> - A writable data stream.</p></li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>stream</code> is null.</p></li>
<li><p><code>java.io.IOException</code> - An I/O error occurred.</p></li>
</ul>

<h3><a id='Write(com.upokecenter.cbor.CBORObject,java.io.OutputStream)'>Write</a></h3>

<p>Writes a CBOR object to a CBOR data stream.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>value</code> - The value to write. Can be null.</p></li>
<li><p><code>stream</code> - A writable data stream.</p></li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>stream</code> is null.</p></li>
<li><p><code>java.io.IOException</code></p></li>
</ul>

<h3><a id='Write(java.lang.Object,java.io.OutputStream)'>Write</a></h3>

<p>Writes a CBOR object to a CBOR data stream. See the three-parameter Write
 method that takes a CBOREncodeOptions.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>objValue</code> - The arbitrary object to be serialized. Can be null.</p></li>
<li><p><code>stream</code> - A writable data stream.</p></li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.io.IOException</code></li>
</ul>

<h3><a id='Write(java.lang.Object,java.io.OutputStream,com.upokecenter.cbor.CBOREncodeOptions)'>Write</a></h3>

<p>Writes an arbitrary object to a CBOR data stream, using the specified
 options for controlling how the object is encoded to CBOR data
 format. If the object is convertible to a CBOR map or a CBOR object
 that contains CBOR maps, the order in which the keys to those maps
 are written out to the data stream is undefined unless the map was
 created using the NewOrderedMap method. The example code given in
 <see cref='PeterO.Cbor.CBORObject.WriteTo(System.IO.InputStream)'/> can
 be used to write out certain keys of a CBOR map in a given order.
 Currently, the following objects are supported: <ul> <li>Lists of
 CBORObject.</li> <li>Maps of CBORObject. The order in which the keys
 to the map are written out to the data stream is undefined unless
 the map was created using the NewOrderedMap method.</li>
 <li>Null.</li> <li>Byte arrays, which will always be written as
 definite-length byte strings.</li> <li>string objects. The strings
 will be encoded using definite-length encoding regardless of their
 length.</li> <li>Any object accepted by the FromObject static
 methods.</li></ul></p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>objValue</code> - The arbitrary object to be serialized. Can be null.
<p><b>NOTE:</b> For security reasons, whenever possible, an
application should not base this parameter on user input or other
externally supplied data, and whenever possible, the application
should limit this parameter&#39;s inputs to types specially handled by
this method (such as <code>int</code> or <code>string</code>) and/or to
plain-old-data types (POCO or POJO types) within the control of the
application. If the plain-old-data type references other data types,
those types should likewise meet either criterion above.</p>.</p></li>
<li><p><code>output</code> - A writable data stream.</p></li>
<li><p><code>options</code> - CBOR options for encoding the CBOR object to bytes.</p></li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.IllegalArgumentException</code> - The object&#39;s type is not supported.</p></li>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>options</code> or <code>
output</code> is null.</p></li>
<li><p><code>java.io.IOException</code></p></li>
</ul>

<h3><a id='WriteJSON(java.lang.Object,java.io.OutputStream)'>WriteJSON</a></h3>

<p>Converts an arbitrary object to a text string in JavaScript object Notation
 (JSON) format, as in the ToJSONString method, and writes that string
 to a data stream in UTF-8. If the object is convertible to a CBOR
 map, or to a CBOR object that contains CBOR maps, the order in which
 the keys to those maps are written out to the JSON string is
 undefined unless the map was created using the NewOrderedMap method.
 The example code given in
 <b>PeterO.Cbor.CBORObject.ToJSONString(PeterO.Cbor.JSONOptions)</b>
 can be used to write out certain keys of a CBOR map in a given order
 to a JSON string.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>obj</code> - The parameter <code>obj</code> is an arbitrary object. Can be null.
<p><b>NOTE:</b> For security reasons, whenever possible, an
application should not base this parameter on user input or other
externally supplied data, and whenever possible, the application
should limit this parameter&#39;s inputs to types specially handled by
this method (such as <code>int</code> or <code>string</code>) and/or to
plain-old-data types (POCO or POJO types) within the control of the
application. If the plain-old-data type references other data types,
those types should likewise meet either criterion above.</p>.</p></li>
<li><p><code>outputStream</code> - A writable data stream.</p></li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>outputStream</code> is null.</p></li>
<li><p><code>java.io.IOException</code></p></li>
</ul>

<h3><a id='Abs()'>Abs</a></h3>

<p>Gets this object&#39;s absolute value.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>This object&#39;s absolute without its negative sign.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.IllegalStateException</code> - This object does not represent a number (for
this purpose, infinities and not-a-number or NaN values, but not
CBORObject.Null, are considered numbers).</li>
</ul>

<h3><a id='Add(java.lang.Object,java.lang.Object)'>Add</a></h3>

<p>Adds a new key and its value to this CBOR map, or adds the value if the
 key doesn't exist.</p> <p>NOTE: This method can't be used to add a
 tag to an existing CBOR object. To create a CBOR object with a given
 tag, call the <code>CBORObject.FromObjectAndTag</code> method and pass the
 CBOR object and the desired tag number to that method.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>key</code> - An object representing the key, which will be converted to a
CBORObject. Can be null, in which case this value is converted to
CBORObject.Null.</p></li>
<li><p><code>valueOb</code> - An object representing the value, which will be converted to
a CBORObject. Can be null, in which case this value is converted to
CBORObject.Null.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>This instance.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.IllegalArgumentException</code> - The parameter <code>key</code> already exists in this
map.</p></li>
<li><p><code>java.lang.IllegalStateException</code> - This object is not a map.</p></li>
<li><p><code>java.lang.IllegalArgumentException</code> - The parameter <code>key</code> or <code>valueOb</code> has
an unsupported type.</p></li>
</ul>

<h3><a id='Add(com.upokecenter.cbor.CBORObject)'>Add</a></h3>

<pre>CBORObject obj = CBORObject.NewArray() .Add(CBORObject.False) .Add(CBORObject.FromObject(5)) .Add(CBORObject.FromObject(&quot;text string&quot;)) .Add(CBORObject.FromObjectAndTag(9999, 1));
</pre>

<p>Adds a new object to the end of this array. (Used to throw
 NullPointerException on a null reference, but now converts the null
 reference to CBORObject.Null, for convenience with the object
 overload of this method).</p> <p>NOTE: This method can't be used to
 add a tag to an existing CBOR object. To create a CBOR object with a
 given tag, call the <code>CBORObject.FromObjectAndTag</code> method and
 pass the CBOR object and the desired tag number to that
 method.</p><p> </p><p>The following example creates a CBOR array and
 adds several CBOR objects, one of which has a custom CBOR tag, to
 that array. Note the chaining behavior made possible by this
  method.</p> <pre>CBORObject obj = CBORObject.NewArray() .Add(CBORObject.False) .Add(CBORObject.FromObject(5)) .Add(CBORObject.FromObject("text string")) .Add(CBORObject.FromObjectAndTag(9999, 1));</pre> .

**Parameters:**

* <code>obj</code> - The parameter <code>obj</code> is a CBOR object.

**Returns:**

* This instance.

**Throws:**

* <code>java.lang.IllegalStateException</code> - This object is not an array.

### <a id='Add(java.lang.Object)'>Add</a>
    CBORObject obj = CBORObject.NewArray() .Add(CBORObject.False) .Add(5) .Add("text string") .Add(CBORObject.FromObjectAndTag(9999, 1));
<p>Converts an object to a CBOR object and adds it to the end of this
 array.</p> <p>NOTE: This method can't be used to add a tag to an
 existing CBOR object. To create a CBOR object with a given tag, call
 the <code>CBORObject.FromObjectAndTag</code> method and pass the CBOR
 object and the desired tag number to that method.</p><p> </p><p>The
 following example creates a CBOR array and adds several CBOR
 objects, one of which has a custom CBOR tag, to that array. Note the
  chaining behavior made possible by this method.</p> <pre>CBORObject obj = CBORObject.NewArray() .Add(CBORObject.False) .Add(5) .Add("text string") .Add(CBORObject.FromObjectAndTag(9999, 1));</pre> .

**Parameters:**

* <code>obj</code> - A CBOR object (or an object convertible to a CBOR object) to add
 to this CBOR array.

**Returns:**

* This instance.

**Throws:**

* <code>java.lang.IllegalStateException</code> - This instance is not an array.

* <code>java.lang.IllegalArgumentException</code> - The type of <code>obj</code> is not supported.

### <a id='AsEInteger()'>AsEInteger</a>

Converts this object to an arbitrary-precision integer. See the ToObject
 overload taking a type for more information.

**Returns:**

* The closest arbitrary-precision integer to this object.

**Throws:**

* <code>java.lang.IllegalStateException</code> - This object does not represent a number (for
 the purposes of this method, infinity and not-a-number values, but
 not <code>CBORObject.Null</code>, are considered numbers).

* <code>java.lang.ArithmeticException</code> - This object's value is infinity or not-a-number
 (NaN).

### <a id='AsBoolean()'>AsBoolean</a>

Returns false if this object is a CBOR false, null, or undefined value
 (whether or not the object has tags); otherwise, true.

**Returns:**

* False if this object is a CBOR false, null, or undefined value;
 otherwise, true.

### <a id='AsByte()'>AsByte</a>

Converts this object to a byte (0 to 255). Floating point values are
 converted to integers by discarding their fractional parts.

**Returns:**

* The closest byte-sized integer to this object.

**Throws:**

* <code>java.lang.IllegalStateException</code> - This object does not represent a number (for
 this purpose, infinities and not-a-number or NaN values, but not
 CBORObject.Null, are considered numbers).

* <code>java.lang.ArithmeticException</code> - This object's value exceeds the range of a byte
 (would be less than 0 or greater than 255 when converted to an
 integer by discarding its fractional part).

### <a id='AsDouble()'>AsDouble</a>

Converts this object to a 64-bit floating point number.

**Returns:**

* The closest 64-bit floating point number to this object. The return
 value can be positive infinity or negative infinity if this value
 exceeds the range of a 64-bit floating point number.

**Throws:**

* <code>java.lang.IllegalStateException</code> - This object does not represent a number (for
 this purpose, infinities and not-a-number or NaN values, but not
 CBORObject.Null, are considered numbers).

### <a id='AsEDecimal()'>AsEDecimal</a>

Converts this object to a decimal number.

**Returns:**

* A decimal number for this object's value.

**Throws:**

* <code>java.lang.IllegalStateException</code> - This object does not represent a number (for
 the purposes of this method, infinity and not-a-number values, but
 not <code>CBORObject.Null</code>, are considered numbers).

### <a id='AsEFloat()'>AsEFloat</a>

Converts this object to an arbitrary-precision binary floating point number.
 See the ToObject overload taking a type for more information.

**Returns:**

* An arbitrary-precision binary floating-point number for this
 object's value.

**Throws:**

* <code>java.lang.IllegalStateException</code> - This object does not represent a number (for
 the purposes of this method, infinity and not-a-number values, but
 not <code>CBORObject.Null</code>, are considered numbers).

### <a id='AsERational()'>AsERational</a>

Converts this object to a rational number. See the ToObject overload taking
 a type for more information.

**Returns:**

* A rational number for this object's value.

**Throws:**

* <code>java.lang.IllegalStateException</code> - This object does not represent a number (for
 the purposes of this method, infinity and not-a-number values, but
 not <code>CBORObject.Null</code>, are considered numbers).

### <a id='AsInt16()'>AsInt16</a>

Converts this object to a 16-bit signed integer. Floating point values are
 converted to integers by discarding their fractional parts.

**Returns:**

* The closest 16-bit signed integer to this object.

**Throws:**

* <code>java.lang.IllegalStateException</code> - This object does not represent a number (for
 this purpose, infinities and not-a-number or NaN values, but not
 CBORObject.Null, are considered numbers).

* <code>java.lang.ArithmeticException</code> - This object's value exceeds the range of a 16-bit
 signed integer.

### <a id='AsInt32Value()'>AsInt32Value</a>
    CBORObject obj = CBORObject.FromInt32(99999); if (obj.CanValueFitInInt32()) { /* Not an Int32; handle the error */ System.out.println("Not a 32-bit integer."); } else { System.out.println("The value is " + obj.AsInt32Value()); }
Converts this object to a 32-bit signed integer if this CBOR object's type
 is Integer. This method disregards the tags this object has, if
 any.<p> </p><p>The following example code (originally written in C# for
 the.NET Framework) shows a way to check whether a given CBOR object
 stores a 32-bit signed integer before getting its value.</p>

<p><pre>CBORObject obj = CBORObject.FromInt32(99999); if (obj.CanValueFitInInt32()) { /* Not an Int32; handle the error */ System.out.println(&quot;Not a 32-bit integer.&quot;); } else { System.out.println(&quot;The value is &quot; + obj.AsInt32Value()); }</pre> .</p>

<p><strong>Returns:</strong></p>

<ul>
<li>The 32-bit signed integer stored by this object.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.IllegalStateException</code> - This object&#39;s type is not <code>
CBORType.Integer</code>.</p></li>
<li><p><code>java.lang.ArithmeticException</code> - This object&#39;s value exceeds the range of a 32-bit
signed integer.</p></li>
</ul>

<h3><a id='AsInt64Value()'>AsInt64Value</a></h3>

<pre>CBORObject obj = CBORObject.FromInt64(99999); if (obj.CanValueFitInInt64()) { /* Not an Int64; handle the error*/ System.out.println(&quot;Not a 64-bit integer.&quot;); } else { System.out.println(&quot;The value is &quot; + obj.AsInt64Value()); }
</pre>

<p>Converts this object to a 64-bit signed integer if this CBOR object&#39;s type
 is Integer. This method disregards the tags this object has, if
 any.<p> </p><p>The following example code (originally written in C# for
 the.NET Framework) shows a way to check whether a given CBOR object
 stores a 64-bit signed integer before getting its value.</p>
  <pre>CBORObject obj = CBORObject.FromInt64(99999); if (obj.CanValueFitInInt64()) { /* Not an Int64; handle the error*/ System.out.println(&quot;Not a 64-bit integer.&quot;); } else { System.out.println(&quot;The value is &quot; + obj.AsInt64Value()); }</pre> .</p>

<p><strong>Returns:</strong></p>

<ul>
<li>The 64-bit signed integer stored by this object.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.IllegalStateException</code> - This object&#39;s type is not <code>
CBORType.Integer</code>.</p></li>
<li><p><code>java.lang.ArithmeticException</code> - This object&#39;s value exceeds the range of a 64-bit
signed integer.</p></li>
</ul>

<h3><a id='CanValueFitInInt64()'>CanValueFitInInt64</a></h3>

<p>Returns whether this CBOR object stores an integer (CBORType.Integer) within
 the range of a 64-bit signed integer. This method disregards the
 tags this object has, if any.</p>

<p><strong>Returns:</strong></p>

<ul>
<li><code>true</code> if this CBOR object stores an integer
(CBORType.Integer) whose value is at least -(2^63) and less than
2^63; otherwise, <code>false</code>.</li>
</ul>

<h3><a id='CanValueFitInInt32()'>CanValueFitInInt32</a></h3>

<p>Returns whether this CBOR object stores an integer (CBORType.Integer) within
 the range of a 32-bit signed integer. This method disregards the
 tags this object has, if any.</p>

<p><strong>Returns:</strong></p>

<ul>
<li><code>true</code> if this CBOR object stores an integer
(CBORType.Integer) whose value is at least -(2^31) and less than
2^31; otherwise, <code>false</code>.</li>
</ul>

<h3><a id='AsEIntegerValue()'>AsEIntegerValue</a></h3>

<p>Converts this object to an arbitrary-precision integer if this CBOR object&#39;s
 type is Integer. This method disregards the tags this object has, if
 any. (Note that CBOR stores untagged integers at least -(2^64) and
 less than 2^64.).</p>

<p><strong>Returns:</strong></p>

<ul>
<li>The integer stored by this object.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.IllegalStateException</code> - This object&#39;s type is not <code>
CBORType.Integer</code>.</li>
</ul>

<h3><a id='AsDoubleBits()'>AsDoubleBits</a></h3>

<p>Converts this object to the bits of a 64-bit floating-point number if this
 CBOR object&#39;s type is FloatingPoint. This method disregards the tags
 this object has, if any.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>The bits of a 64-bit floating-point number stored by this object.
The most significant bit is the sign (set means negative, clear
means nonnegative); the next most significant 11 bits are the
exponent area; and the remaining bits are the significand area. If
all the bits of the exponent area are set and the significand area
is 0, this indicates infinity. If all the bits of the exponent area
are set and the significand area is other than 0, this indicates
not-a-number (NaN).</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.IllegalStateException</code> - This object&#39;s type is not <code>
CBORType.FloatingPoint</code>.</li>
</ul>

<h3><a id='AsDoubleValue()'>AsDoubleValue</a></h3>

<p>Converts this object to a 64-bit floating-point number if this CBOR object&#39;s
 type is FloatingPoint. This method disregards the tags this object
 has, if any.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>The 64-bit floating-point number stored by this object.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.IllegalStateException</code> - This object&#39;s type is not <code>
CBORType.FloatingPoint</code>.</li>
</ul>

<h3><a id='AsNumber()'>AsNumber</a></h3>

<p>Converts this object to a CBOR number. (NOTE: To determine whether this
 method call can succeed, call the <b>IsNumber</b> property
 (isNumber() method in Java) before calling this method.).</p>

<p><strong>Returns:</strong></p>

<ul>
<li>The number represented by this object.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.IllegalStateException</code> - This object does not represent a number (for
this purpose, infinities and not-a-number or NaN values, but not
CBORObject.Null, are considered numbers).</li>
</ul>

<h3><a id='AsInt32()'>AsInt32</a></h3>

<pre>CBORObject obj = CBORObject.FromInt32(99999); if (obj.AsNumber().CanTruncatedIntFitInInt32()) { /* Not an Int32; handle the error */ System.out.println(&quot;Not a 32-bit integer.&quot;); } else { System.out.println(&quot;The value is &quot; + obj.AsInt32()); }
</pre>

<p>Converts this object to a 32-bit signed integer. Non-integer number values
 are converted to integers by discarding their fractional parts.
 (NOTE: To determine whether this method call can succeed, call
 <b>AsNumber().getCanTruncatedIntFitInInt32()</b> before calling this
 method. See the example.).<p> </p><p>The following example code
 (originally written in C# for the.NET Framework) shows a way to
 check whether a given CBOR object stores a 32-bit signed integer
  before getting its value.</p> <pre>CBORObject obj = CBORObject.FromInt32(99999); if (obj.AsNumber().CanTruncatedIntFitInInt32()) { /* Not an Int32; handle the error */ System.out.println(&quot;Not a 32-bit integer.&quot;); } else { System.out.println(&quot;The value is &quot; + obj.AsInt32()); }</pre> .</p>

<p><strong>Returns:</strong></p>

<ul>
<li>The closest 32-bit signed integer to this object.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.IllegalStateException</code> - This object does not represent a number (for
this purpose, infinities and not-a-number or NaN values, but not
CBORObject.Null, are considered numbers).</p></li>
<li><p><code>java.lang.ArithmeticException</code> - This object&#39;s value exceeds the range of a 32-bit
signed integer.</p></li>
</ul>

<h3><a id='AsInt64()'>AsInt64</a></h3>

<pre>CBORObject obj = CBORObject.FromInt64(99999); if (obj.isIntegral() &amp;&amp; obj.AsNumber().CanFitInInt64()) { /* Not an Int64; handle the error */ System.out.println(&quot;Not a 64-bit integer.&quot;); } else { System.out.println(&quot;The value is &quot; + obj.AsInt64()); }
</pre>

<p>Converts this object to a 64-bit signed integer. Non-integer numbers are
 converted to integers by discarding their fractional parts. (NOTE:
 To determine whether this method call can succeed, call
 <b>AsNumber().getCanTruncatedIntFitInInt64()</b> before calling this
 method. See the example.).<p> </p><p>The following example code
 (originally written in C# for the.NET Framework) shows a way to
 check whether a given CBOR object stores a 64-bit signed integer
  before getting its value.</p> <pre>CBORObject obj = CBORObject.FromInt64(99999); if (obj.isIntegral() &amp;&amp; obj.AsNumber().CanFitInInt64()) { /* Not an Int64; handle the error */ System.out.println(&quot;Not a 64-bit integer.&quot;); } else { System.out.println(&quot;The value is &quot; + obj.AsInt64()); }</pre> .</p>

<p><strong>Returns:</strong></p>

<ul>
<li>The closest 64-bit signed integer to this object.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.IllegalStateException</code> - This object does not represent a number (for
this purpose, infinities and not-a-number or NaN values, but not
CBORObject.Null, are considered numbers).</p></li>
<li><p><code>java.lang.ArithmeticException</code> - This object&#39;s value exceeds the range of a 64-bit
signed integer.</p></li>
</ul>

<h3><a id='AsSingle()'>AsSingle</a></h3>

<p>Converts this object to a 32-bit floating point number.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>The closest 32-bit floating point number to this object. The return
value can be positive infinity or negative infinity if this object&#39;s
value exceeds the range of a 32-bit floating point number.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.IllegalStateException</code> - This object does not represent a number (for
this purpose, infinities and not-a-number or NaN values, but not
CBORObject.Null, are considered numbers).</li>
</ul>

<h3><a id='AsString()'>AsString</a></h3>

<p>Gets the value of this object as a text string.<p>This method is not the
  &quot;reverse&quot; of the <code>FromObject</code> method in the sense that
 FromObject can take either a text string or <code>null</code>, but this
 method can accept only text strings. The <code>ToObject</code> method is
  closer to a &quot;reverse&quot; version to <code>FromObject</code> than the
 <code>AsString</code> method: <code>ToObject&lt;string&gt;(cbor)</code> in
 DotNet, or <code>ToObject(string.class)</code> in Java, will convert a
 CBOR object to a DotNet or Java string if it represents a text
 string, or to <code>null</code> if <code>IsNull</code> returns <code>true</code> for
 the CBOR object, and will fail in other cases.</p></p>

<p><strong>Returns:</strong></p>

<ul>
<li>Gets this object&#39;s string.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.IllegalStateException</code> - This object&#39;s type is not a text string (for
the purposes of this method, infinity and not-a-number values, but
not <code>CBORObject.Null</code>, are considered numbers). To check the
CBOR object for null before conversion, use the following idiom
(originally written in C# for the.NET version): <code>(cbor == null
|| cbor.isNull()) ? null : cbor.AsString()</code>.</li>
</ul>

<h3><a id='CanFitInDouble()'>CanFitInDouble</a></h3>

<p>Returns whether this object&#39;s value can be converted to a 64-bit floating
 point number without its value being rounded to another numerical
 value.</p>

<p><strong>Returns:</strong></p>

<ul>
<li><code>true</code> if this object&#39;s value can be converted to a 64-bit
floating point number without its value being rounded to another
numerical value, or if this is a not-a-number value, even if the
value&#39;s diagnostic information can&#39;t fit in a 64-bit floating point
number; otherwise, <code>false</code>.</li>
</ul>

<h3><a id='CanFitInInt32()'>CanFitInInt32</a></h3>

<p>Returns whether this object&#39;s numerical value is an integer, is -(2^31) or
 greater, and is less than 2^31.</p>

<p><strong>Returns:</strong></p>

<ul>
<li><code>true</code> if this object&#39;s numerical value is an integer, is
-(2^31) or greater, and is less than 2^31; otherwise, <code>false</code>.</li>
</ul>

<h3><a id='CanFitInInt64()'>CanFitInInt64</a></h3>

<p>Returns whether this object&#39;s numerical value is an integer, is -(2^63) or
 greater, and is less than 2^63.</p>

<p><strong>Returns:</strong></p>

<ul>
<li><code>true</code> if this object&#39;s numerical value is an integer, is
-(2^63) or greater, and is less than 2^63; otherwise, <code>false</code>.</li>
</ul>

<h3><a id='CanFitInSingle()'>CanFitInSingle</a></h3>

<p>Returns whether this object&#39;s value can be converted to a 32-bit floating
 point number without its value being rounded to another numerical
 value.</p>

<p><strong>Returns:</strong></p>

<ul>
<li><code>true</code> if this object&#39;s value can be converted to a 32-bit
floating point number without its value being rounded to another
numerical value, or if this is a not-a-number value, even if the
value&#39;s diagnostic information can&#39; t fit in a 32-bit floating point
number; otherwise, <code>false</code>.</li>
</ul>

<h3><a id='CanTruncatedIntFitInInt32()'>CanTruncatedIntFitInInt32</a></h3>

<p>Returns whether this object&#39;s value, converted to an integer by discarding
 its fractional part, would be -(2^31) or greater, and less than
 2^31.</p>

<p><strong>Returns:</strong></p>

<ul>
<li><code>true</code> if this object&#39;s value, converted to an integer by
discarding its fractional part, would be -(2^31) or greater, and
less than 2^31; otherwise, <code>false</code>.</li>
</ul>

<h3><a id='CanTruncatedIntFitInInt64()'>CanTruncatedIntFitInInt64</a></h3>

<p>Returns whether this object&#39;s value, converted to an integer by discarding
 its fractional part, would be -(2^63) or greater, and less than
 2^63.</p>

<p><strong>Returns:</strong></p>

<ul>
<li><code>true</code> if this object&#39;s value, converted to an integer by
discarding its fractional part, would be -(2^63) or greater, and
less than 2^63; otherwise, <code>false</code>.</li>
</ul>

<h3><a id='compareTo(com.upokecenter.cbor.CBORObject)'>compareTo</a></h3>

<p>Compares two CBOR objects. This implementation was changed in version 4.0.
 <p>In this implementation:</p> <ul> <li>The null pointer (null
 reference) is considered less than any other object.</li> <li>If the
 two objects are both integers (CBORType.Integer) both floating-point
 values, both byte strings, both simple values (including True and
 False), or both text strings, their CBOR encodings (as though
 EncodeToBytes were called on each integer) are compared as though by
 a byte-by-byte comparison. (This means, for example, that positive
 integers sort before negative integers).</li> <li>If both objects
 have a tag, they are compared first by the tag&#39;s value then by the
 associated item (which itself can have a tag).</li> <li>If both
 objects are arrays, they are compared item by item. In this case, if
 the arrays have different numbers of items, the array with more
 items is treated as greater than the other array.</li> <li>If both
 objects are maps, their key-value pairs, sorted by key in accordance
 with this method, are compared, where each pair is compared first by
 key and then by value. In this case, if the maps have different
 numbers of key-value pairs, the map with more pairs is treated as
 greater than the other map.</li> <li>If the two objects have
 different types, the object whose type comes first in the order of
 untagged integers, untagged byte strings, untagged text strings,
 untagged arrays, untagged maps, tagged objects, untagged simple
 values (including True and False) and untagged floating point values
 sorts before the other object.</li></ul> <p>This method is
 consistent with the Equals method.</p></p>

<p><strong>Specified by:</strong></p>

<ul>
<li><code>compareTo</code> in interface <code>java.lang.Comparable&lt;CBORObject&gt;</code></li>
</ul>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>other</code> - A value to compare with.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A negative number, if this value is less than the other object; or
0, if both values are equal; or a positive number, if this value is
less than the other object or if the other object is null. This
implementation returns a positive number if.</li>
</ul>

<h3><a id='CompareToIgnoreTags(com.upokecenter.cbor.CBORObject)'>CompareToIgnoreTags</a></h3>

<p>Compares this object and another CBOR object, ignoring the tags they have,
 if any. See the compareTo method for more information on the
 comparison function.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>other</code> - A value to compare with.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>Less than 0, if this value is less than the other object; or 0, if
both values are equal; or greater than 0, if this value is less than
the other object or if the other object is null.</li>
</ul>

<h3><a id='ContainsKey(java.lang.Object)'>ContainsKey</a></h3>

<p>Determines whether a value of the given key exists in this object.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>objKey</code> - The parameter <code>objKey</code> is an arbitrary object.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li><code>true</code> if the given key is found, or <code>false</code> if the
given key is not found or this object is not a map.</li>
</ul>

<h3><a id='ContainsKey(com.upokecenter.cbor.CBORObject)'>ContainsKey</a></h3>

<p>Determines whether a value of the given key exists in this object.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>key</code> - An object that serves as the key. If this is <code>null</code>, checks
for <code>CBORObject.Null</code>.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li><code>true</code> if the given key is found, or <code>false</code> if the
given key is not found or this object is not a map.</li>
</ul>

<h3><a id='ContainsKey(java.lang.String)'>ContainsKey</a></h3>

<p>Determines whether a value of the given key exists in this object.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>key</code> - A text string that serves as the key. If this is <code>null</code>,
checks for <code>CBORObject.Null</code>.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li><code>true</code> if the given key (as a CBOR object) is found, or <code>
false</code> if the given key is not found or this object is not a map.</li>
</ul>

<h3><a id='EncodeToBytes()'>EncodeToBytes</a></h3>

<p>Writes the binary representation of this CBOR object and returns a byte
 array of that representation. If the CBOR object contains CBOR maps,
 or is a CBOR map itself, the order in which the keys to the map are
 written out to the byte array is undefined unless the map was
 created using the NewOrderedMap method. The example code given in
 <see cref='PeterO.Cbor.CBORObject.WriteTo(System.IO.InputStream)'/> can
 be used to write out certain keys of a CBOR map in a given order.
 For the CTAP2 (FIDO Client-to-Authenticator Protocol 2) canonical
 ordering, which is useful for implementing Web Authentication, call
  <code>EncodeToBytes(new CBOREncodeOptions("ctap2canonical=true"))</code>
 rather than this method.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>A byte array in CBOR format.</li>
</ul>

<h3><a id='EncodeToBytes(com.upokecenter.cbor.CBOREncodeOptions)'>EncodeToBytes</a></h3>

<p>Writes the binary representation of this CBOR object and returns a byte
 array of that representation, using the specified options for
 encoding the object to CBOR format. For the CTAP2 (FIDO
 Client-to-Authenticator Protocol 2) canonical ordering, which is
 useful for implementing Web Authentication, call this method as
 follows: <code>EncodeToBytes(new
  CBOREncodeOptions(&quot;ctap2canonical=true&quot;))</code>.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>options</code> - Options for encoding the data to CBOR.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A byte array in CBOR format.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.NullPointerException</code> - The parameter <code>options</code> is null.</li>
</ul>

<h3><a id='AtJSONPointer(java.lang.String)'>AtJSONPointer</a></h3>

<p>Gets the CBOR object referred to by a JSON Pointer according to RFC6901. For
 more information, see the overload taking a default value parameter.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>pointer</code> - A JSON pointer according to RFC 6901.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An object within this CBOR object. Returns this object if pointer is
the empty string (even if this object has a CBOR type other than
array or map).</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>CBORException</code> - Thrown if the pointer is null, or
if the pointer is invalid, or if there is no object at the given
pointer, or the special key &quot;-&quot; appears in the pointer in the
context of an array (not a map), or if the pointer is non-empty and
this object has a CBOR type other than array or map.</li>
</ul>

<h3><a id='AtJSONPointer(java.lang.String,com.upokecenter.cbor.CBORObject)'>AtJSONPointer</a></h3>

<pre>&#39;/&#39; KEY &#39;/&#39; KEY.get(...)
</pre>

<p>Gets the CBOR object referred to by a JSON Pointer according to RFC6901, or
 a default value if the operation fails. The syntax for a JSON
 Pointer is: <pre>&#39;/&#39; KEY &#39;/&#39; KEY.get(...)</pre> where KEY represents
 a key into the JSON object or its sub-objects in the hierarchy. For
 example, <pre>/foo/2/bar</pre> means the same as
  <pre>obj.get(&#39;foo&#39;)[2][&#39;bar&#39;]</pre> in JavaScript. If &quot;~&quot; and/or &quot;/&quot;
  occurs in a key, it must be escaped with &quot;~0&quot; or &quot;~1&quot;, respectively,
  in a JSON pointer. JSON pointers also support the special key &quot;-&quot;
  (as in &quot;/foo/-&quot;) to indicate the end of an array, but this method
 treats this key as an error since it refers to a nonexistent item.
 Indices to arrays (such as 2 in the example) must contain only basic
 digits 0 to 9 and no leading zeros. (Note that RFC 6901 was
 published before JSON was extended to support top-level values other
 than arrays and key-value dictionaries.).</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>pointer</code> - A JSON pointer according to RFC 6901.</p></li>
<li><p><code>defaultValue</code> - The parameter <code>defaultValue</code> is a Cbor.CBORObject
object.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>An object within the specified JSON object. Returns this object if
pointer is the empty string (even if this object has a CBOR type
other than array or map). Returns <code>defaultValue</code> if the
pointer is null, or if the pointer is invalid, or if there is no
object at the given pointer, or the special key &quot;-&quot; appears in the
pointer in the context of an array (not a map), or if the pointer is
non-empty and this object has a CBOR type other than array or map.</li>
</ul>

<h3><a id='ApplyJSONPatch(com.upokecenter.cbor.CBORObject)'>ApplyJSONPatch</a></h3>

<p>Returns a copy of this object after applying the operations in a JSON patch,
 in the form of a CBOR object. JSON patches are specified in RFC 6902
 and their format is summarized in the remarks below.<p><b>Remarks:</b>
 A JSON patch is an array with one or more maps. Each map has the
  following keys: </p><ul> <li>&quot;op&quot; - Required. This key&#39;s value is the
  patch operation and must be &quot;add&quot;, &quot;remove&quot;, &quot;move&quot;, &quot;copy&quot;, &quot;test&quot;,
  or &quot;replace&quot;, in basic lower case letters and no other case
  combination.</li> <li>&quot;value&quot; - Required if the operation is &quot;add&quot;,
  &quot;replace&quot;, or &quot;test&quot; and specifies the item to add (insert), or that
 will replace the existing item, or to check an existing item for
  equality, respectively. (For &quot;test&quot;, the operation fails if the
  existing item doesn&#39;t match the specified value.)</li> <li>&quot;path&quot; -
 Required for all operations. A JSON Pointer (RFC 6901) specifying the
 destination path in the CBOR object for the operation. For more
 information, see RFC 6901 or the documentation for
  AtJSONPointer(pointer, defaultValue).</li> <li>&quot;from&quot; - Required if
  the operation is &quot;move&quot; or &quot;copy&quot;. A JSON Pointer (RFC 6901)
 specifying the path in the CBOR object where the source value is
 located.</li></ul></p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>patch</code> - A JSON patch in the form of a CBOR object; it has the form
summarized in the remarks.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The result of the patch operation.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>CBORException</code> - The parameter <code>patch</code> is
null or the patch operation failed.</li>
</ul>

<h3><a id='equals(java.lang.Object)'>equals</a></h3>

<p>Determines whether this object and another object are equal and have the
 same type. Not-a-number values can be considered equal by this
 method.</p>

<p><strong>Overrides:</strong></p>

<ul>
<li><code>equals</code> in class <code>java.lang.Object</code></li>
</ul>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>obj</code> - The parameter <code>obj</code> is an arbitrary object.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li><code>true</code> if the objects are equal; otherwise, <code>false</code>. In
this method, two objects are not equal if they don&#39;t have the same
type or if one is null and the other isn&#39;t.</li>
</ul>

<h3><a id='equals(com.upokecenter.cbor.CBORObject)'>equals</a></h3>

<p>Compares the equality of two CBOR objects. Not-a-number values can be
 considered equal by this method.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>other</code> - The object to compare.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li><code>true</code> if the objects are equal; otherwise, <code>false</code>. In
this method, two objects are not equal if they don&#39;t have the same
type or if one is null and the other isn&#39;t.</li>
</ul>

<h3><a id='GetByteString()'>GetByteString</a></h3>

<p>Gets the backing byte array used in this CBOR object, if this object is a
 byte string, without copying the data to a new byte array. Any
 changes in the returned array&#39;s contents will be reflected in this
 CBOR object. Note, though, that the array&#39;s length can&#39;t be changed.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>The byte array held by this CBOR object.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.IllegalStateException</code> - This object is not a byte string.</li>
</ul>

<h3><a id='hashCode()'>hashCode</a></h3>

<p>Calculates the hash code of this object. The hash code for a given instance
 of this class is not guaranteed to be the same across versions of
 this class, and no application or process IDs are used in the hash
 code calculation.</p>

<p><strong>Overrides:</strong></p>

<ul>
<li><code>hashCode</code> in class <code>java.lang.Object</code></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A 32-bit hash code.</li>
</ul>

<h3><a id='GetAllTags()'>GetAllTags</a></h3>

<p>Gets a list of all tags, from outermost to innermost.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>An array of tags, or the empty string if this object is untagged.</li>
</ul>

<h3><a id='HasOneTag()'>HasOneTag</a></h3>

<p>Returns whether this object has only one tag.</p>

<p><strong>Returns:</strong></p>

<ul>
<li><code>true</code> if this object has only one tag; otherwise, <code>
false</code>.</li>
</ul>

<h3><a id='HasOneTag(int)'>HasOneTag</a></h3>

<p>Returns whether this object has only one tag and that tag is the given
 number.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>tagValue</code> - The tag number.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li><code>true</code> if this object has only one tag and that tag is the
given number; otherwise, <code>false</code>.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.IllegalArgumentException</code> - The parameter <code>tagValue</code> is less than 0.</li>
</ul>

<h3><a id='HasOneTag(com.upokecenter.numbers.EInteger)'>HasOneTag</a></h3>

<p>Returns whether this object has only one tag and that tag is the given
 number, expressed as an arbitrary-precision integer.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>bigTagValue</code> - An arbitrary-precision integer.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li><code>true</code> if this object has only one tag and that tag is the
given number; otherwise, <code>false</code>.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>bigTagValue</code> is null.</p></li>
<li><p><code>java.lang.IllegalArgumentException</code> - The parameter <code>bigTagValue</code> is less than 0.</p></li>
</ul>

<h3><a id='getTagCount()'>getTagCount</a></h3>

<p>Gets the number of tags this object has.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>The number of tags this object has.</li>
</ul>

<h3><a id='HasMostInnerTag(int)'>HasMostInnerTag</a></h3>

<p>Returns whether this object has an innermost tag and that tag is of the
 given number.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>tagValue</code> - The tag number.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li><code>true</code> if this object has an innermost tag and that tag is of
the given number; otherwise, <code>false</code>.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.IllegalArgumentException</code> - The parameter <code>tagValue</code> is less than 0.</li>
</ul>

<h3><a id='HasMostInnerTag(com.upokecenter.numbers.EInteger)'>HasMostInnerTag</a></h3>

<p>Returns whether this object has an innermost tag and that tag is of the
 given number, expressed as an arbitrary-precision number.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>bigTagValue</code> - The tag number.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li><code>true</code> if this object has an innermost tag and that tag is of
the given number; otherwise, <code>false</code>.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>bigTagValue</code> is null.</p></li>
<li><p><code>java.lang.IllegalArgumentException</code> - The parameter <code>bigTagValue</code> is less than 0.</p></li>
</ul>

<h3><a id='HasMostOuterTag(int)'>HasMostOuterTag</a></h3>

<p>Returns whether this object has an outermost tag and that tag is of the
 given number.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>tagValue</code> - The tag number.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li><code>true</code> if this object has an outermost tag and that tag is of
the given number; otherwise, <code>false</code>.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.IllegalArgumentException</code> - The parameter <code>tagValue</code> is less than 0.</li>
</ul>

<h3><a id='HasMostOuterTag(com.upokecenter.numbers.EInteger)'>HasMostOuterTag</a></h3>

<p>Returns whether this object has an outermost tag and that tag is of the
 given number.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>bigTagValue</code> - The tag number.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li><code>true</code> if this object has an outermost tag and that tag is of
the given number; otherwise, <code>false</code>.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>bigTagValue</code> is null.</p></li>
<li><p><code>java.lang.IllegalArgumentException</code> - The parameter <code>bigTagValue</code> is less than 0.</p></li>
</ul>

<h3><a id='HasTag(int)'>HasTag</a></h3>

<p>Returns whether this object has a tag of the given number.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>tagValue</code> - The tag value to search for.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li><code>true</code> if this object has a tag of the given number;
otherwise, <code>false</code>.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.IllegalArgumentException</code> - The parameter <code>tagValue</code> is less than 0.</p></li>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>tagValue</code> is null.</p></li>
</ul>

<h3><a id='HasTag(com.upokecenter.numbers.EInteger)'>HasTag</a></h3>

<p>Returns whether this object has a tag of the given number.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>bigTagValue</code> - The tag value to search for.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li><code>true</code> if this object has a tag of the given number;
otherwise, <code>false</code>.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>bigTagValue</code> is null.</p></li>
<li><p><code>java.lang.IllegalArgumentException</code> - The parameter <code>bigTagValue</code> is less than 0.</p></li>
</ul>

<h3><a id='Insert(int,java.lang.Object)'>Insert</a></h3>

<p>Inserts an object at the specified position in this CBOR array.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>index</code> - Index starting at 0 to insert at.</p></li>
<li><p><code>valueOb</code> - An object representing the value, which will be converted to
a CBORObject. Can be null, in which case this value is converted to
CBORObject.Null.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>This instance.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.IllegalStateException</code> - This object is not an array.</p></li>
<li><p><code>java.lang.IllegalArgumentException</code> - The parameter <code>valueOb</code> has an unsupported
type; or <code>index</code> is not a valid index into this array.</p></li>
</ul>

<h3><a id='IsInfinity()'>IsInfinity</a></h3>

<p>Gets a value indicating whether this CBOR object represents infinity.</p>

<p><strong>Returns:</strong></p>

<ul>
<li><code>true</code> if this CBOR object represents infinity; otherwise,
<code>false</code>.</li>
</ul>

<h3><a id='IsNaN()'>IsNaN</a></h3>

<p>Gets a value indicating whether this CBOR object represents a not-a-number
 value (as opposed to whether this object does not express a number).</p>

<p><strong>Returns:</strong></p>

<ul>
<li><code>true</code> if this CBOR object represents a not-a-number value (as
opposed to whether this object does not represent a number as
defined by the IsNumber property or <code>isNumber()</code> method in
Java); otherwise, <code>false</code>.</li>
</ul>

<h3><a id='IsNegativeInfinity()'>IsNegativeInfinity</a></h3>

<p>Gets a value indicating whether this CBOR object represents negative
 infinity.</p>

<p><strong>Returns:</strong></p>

<ul>
<li><code>true</code> if this CBOR object represents negative infinity;
otherwise, <code>false</code>.</li>
</ul>

<h3><a id='IsPositiveInfinity()'>IsPositiveInfinity</a></h3>

<p>Gets a value indicating whether this CBOR object represents positive
 infinity.</p>

<p><strong>Returns:</strong></p>

<ul>
<li><code>true</code> if this CBOR object represents positive infinity;
otherwise, <code>false</code>.</li>
</ul>

<h3><a id='Negate()'>Negate</a></h3>

<p>Gets this object&#39;s value with the sign reversed.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>The reversed-sign form of this number.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.IllegalStateException</code> - This object does not represent a number (for
this purpose, infinities and not-a-number or NaN values, but not
CBORObject.Null, are considered numbers).</li>
</ul>

<h3><a id='Clear()'>Clear</a></h3>

<p>Removes all items from this CBOR array or all keys and values from this CBOR
 map.</p>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.IllegalStateException</code> - This object is not a CBOR array or CBOR map.</li>
</ul>

<h3><a id='Remove(java.lang.Object)'>Remove</a></h3>

<p>If this object is an array, removes the first instance of the specified item
 (once converted to a CBOR object) from the array. If this object is
 a map, removes the item with the given key (once converted to a CBOR
 object) from the map.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>obj</code> - The item or key (once converted to a CBOR object) to remove.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li><code>true</code> if the item was removed; otherwise, <code>false</code>.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>obj</code> is null (as opposed
to CBORObject.Null).</p></li>
<li><p><code>java.lang.IllegalStateException</code> - The object is not an array or map.</p></li>
</ul>

<h3><a id='RemoveAt(int)'>RemoveAt</a></h3>

<p>Removes the item at the given index of this CBOR array.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>index</code> - The index, starting at 0, of the item to remove.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>Returns &quot;true&quot; if the object was removed. Returns &quot;false&quot; if the
given index is less than 0, or is at least as high as the number of
items in the array.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.IllegalStateException</code> - This object is not a CBOR array.</li>
</ul>

<h3><a id='Remove(com.upokecenter.cbor.CBORObject)'>Remove</a></h3>

<p>If this object is an array, removes the first instance of the specified item
 from the array. If this object is a map, removes the item with the
 given key from the map.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>obj</code> - The item or key to remove.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li><code>true</code> if the item was removed; otherwise, <code>false</code>.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>obj</code> is null (as opposed
to CBORObject.Null).</p></li>
<li><p><code>java.lang.IllegalStateException</code> - The object is not an array or map.</p></li>
</ul>

<h3><a id='Set(java.lang.Object,java.lang.Object)'>Set</a></h3>

<p>Maps an object to a key in this CBOR map, or adds the value if the key
 doesn&#39;t exist. If this is a CBOR array, instead sets the value at
 the given index to the given value.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>key</code> - If this instance is a CBOR map, this parameter is an object
representing the key, which will be converted to a CBORObject; in
this case, this parameter can be null, in which case this value is
converted to CBORObject.Null. If this instance is a CBOR array, this
parameter must be a 32-bit signed integer(<code>int</code>) identifying
the index (starting from 0) of the item to set in the array.</p></li>
<li><p><code>valueOb</code> - An object representing the value, which will be converted to
a CBORObject. Can be null, in which case this value is converted to
CBORObject.Null.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>This instance.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.IllegalStateException</code> - This object is not a map or an array.</p></li>
<li><p><code>java.lang.IllegalArgumentException</code> - The parameter <code>key</code> or <code>valueOb</code> has
an unsupported type, or this instance is a CBOR array and <code>
key</code> is less than 0, is the size of this array or greater, or is not
a 32-bit signed integer (<code>int</code>).</p></li>
</ul>

<h3><a id='ToJSONString()'>ToJSONString</a></h3>

<p>Converts this object to a text string in JavaScript object Notation (JSON)
 format. See the overload to ToJSONString taking a JSONOptions
 argument for further information. <p>If the CBOR object contains
 CBOR maps, or is a CBOR map itself, the order in which the keys to
 the map are written out to the JSON string is undefined unless the
 map was created using the NewOrderedMap method. Map keys other than
 untagged text strings are converted to JSON strings before writing
  them out (for example, <code>22(&quot;Test&quot;)</code> is converted to
  <code>&quot;Test&quot;</code> and <code>true</code> is converted to <code>&quot;true&quot;</code>). After
 such conversion, if two or more keys for the same map are identical,
 this method throws a CBORException. The example code given in
 <b>PeterO.Cbor.CBORObject.ToJSONString(PeterO.Cbor.JSONOptions)</b>
 can be used to write out certain keys of a CBOR map in a given order
 to a JSON string, or to write out a CBOR object as part of a JSON
 text sequence.</p> <p><b>Warning:</b> In general, if this CBOR
 object contains integer map keys or uses other features not
 supported in JSON, and the application converts this CBOR object to
 JSON and back to CBOR, the application <i>should not</i> expect the
 new CBOR object to be exactly the same as the original. This is
 because the conversion in many cases may have to convert unsupported
 features in JSON to supported features which correspond to a
 different feature in CBOR (such as converting integer map keys,
 which are supported in CBOR but not JSON, to text strings, which are
 supported in both).</p></p>

<p><strong>Returns:</strong></p>

<ul>
<li>A text string containing the converted object in JSON format.</li>
</ul>

<h3><a id='ToJSONString(com.upokecenter.cbor.JSONOptions)'>ToJSONString</a></h3>

<pre>/* Generates a JSON string of &#39;mapObj&#39; whose keys are in the order given in &#39;keys&#39; . Only keys found in &#39;keys&#39; will be written if they exist in &#39;mapObj&#39;. */ private static string KeysToJSONMap(CBORObject mapObj, List&lt;CBORObject&gt; keys) { if (mapObj == null) { throw new NullPointerException)&quot;mapObj&quot;);} if (keys == null) { throw new NullPointerException)&quot;keys&quot;);} if (obj.getType() != CBORType.Map) { throw new IllegalArgumentException(&quot;&#39;obj&#39; is not a map.&quot;); } StringBuilder builder = new StringBuilder(); boolean first = true; builder.append(&quot;{&quot;); for (CBORObject key in keys) { if (mapObj.ContainsKey(key)) { if (!first) {builder.append(&quot;, &quot;);} var keyString=(key.getCBORType() == CBORType.string) ? key.AsString() : key.ToJSONString(); builder.append(CBORObject.FromObject(keyString) .ToJSONString()) .append(&quot;:&quot;).append(mapObj.get(key).ToJSONString()); first=false; } } return builder.append(&quot;}&quot;).toString(); }
</pre>

<p>Converts this object to a text string in JavaScript object Notation (JSON)
 format, using the specified options to control the encoding process.
 This function works not only with arrays and maps, but also
 integers, strings, byte arrays, and other JSON data types. Notes:
 <ul><li>If this object contains maps with non-string keys, the keys
 are converted to JSON strings before writing the map as a JSON
 string.</li> <li>If this object represents a number (the IsNumber
 property, or isNumber() method in Java, returns true), then it is
 written out as a number.</li> <li>If the CBOR object contains CBOR
 maps, or is a CBOR map itself, the order in which the keys to the
 map are written out to the JSON string is undefined unless the map
 was created using the NewOrderedMap method. Map keys other than
 untagged text strings are converted to JSON strings before writing
  them out (for example, <code>22(&quot;Test&quot;)</code> is converted to
  <code>&quot;Test&quot;</code> and <code>true</code> is converted to <code>&quot;true&quot;</code>). After
 such conversion, if two or more keys for the same map are identical,
 this method throws a CBORException.</li> <li>If a number in the form
 of an arbitrary-precision binary floating-point number has a very
 high binary exponent, it will be converted to a double before being
 converted to a JSON string. (The resulting double could overflow to
 infinity, in which case the arbitrary-precision binary
 floating-point number is converted to null.)</li> <li>The string
 will not begin with a byte-order mark (U+FEFF); RFC 8259 (the JSON
 specification) forbids placing a byte-order mark at the beginning of
 a JSON string.</li> <li>Byte strings are converted to Base64 URL
 without whitespace or padding by default (see section 3.4.5.3 of RFC
 8949). A byte string will instead be converted to traditional base64
 without whitespace and with padding if it has tag 22, or base16 for
 tag 23. (To create a CBOR object with a given tag, call the
 <code>CBORObject.FromObjectAndTag</code> method and pass the CBOR object
 and the desired tag number to that method.)</li> <li>Rational
 numbers will be converted to their exact form, if possible,
 otherwise to a high-precision approximation. (The resulting
 approximation could overflow to infinity, in which case the rational
 number is converted to null.)</li> <li>Simple values other than true
 and false will be converted to null. (This doesn&#39;t include
 floating-point numbers.)</li> <li>Infinity and not-a-number will be
 converted to null.</li> </ul> <p><b>Warning:</b> In general, if this
 CBOR object contains integer map keys or uses other features not
 supported in JSON, and the application converts this CBOR object to
 JSON and back to CBOR, the application <i>should not</i> expect the
 new CBOR object to be exactly the same as the original. This is
 because the conversion in many cases may have to convert unsupported
 features in JSON to supported features which correspond to a
 different feature in CBOR (such as converting integer map keys,
 which are supported in CBOR but not JSON, to text strings, which are
 supported in both).</p> <p>The example code given below (originally
 written in C# for the.NET version) can be used to write out certain
  keys of a CBOR map in a given order to a JSON string.</p> <pre>/* Generates a JSON string of &#39;mapObj&#39; whose keys are in the order given in &#39;keys&#39; . Only keys found in &#39;keys&#39; will be written if they exist in &#39;mapObj&#39;. */ private static string KeysToJSONMap(CBORObject mapObj, List&lt;CBORObject&gt; keys) { if (mapObj == null) { throw new NullPointerException)&quot;mapObj&quot;);} if (keys == null) { throw new NullPointerException)&quot;keys&quot;);} if (obj.getType() != CBORType.Map) { throw new IllegalArgumentException(&quot;&#39;obj&#39; is not a map.&quot;); } StringBuilder builder = new StringBuilder(); boolean first = true; builder.append(&quot;{&quot;); for (CBORObject key in keys) { if (mapObj.ContainsKey(key)) { if (!first) {builder.append(&quot;, &quot;);} var keyString=(key.getCBORType() == CBORType.string) ? key.AsString() : key.ToJSONString(); builder.append(CBORObject.FromObject(keyString) .ToJSONString()) .append(&quot;:&quot;).append(mapObj.get(key).ToJSONString()); first=false; } } return builder.append(&quot;}&quot;).toString(); }</pre> .</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>options</code> - Specifies options to control writing the CBOR object to JSON.</li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A text string containing the converted object in JSON format.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.NullPointerException</code> - The parameter <code>options</code> is null.</li>
</ul>

<h3><a id='toString()'>toString</a></h3>

<p>Returns this CBOR object in a text form intended to be read by humans. The
 value returned by this method is not intended to be parsed by
 computer programs, and the exact text of the value may change at any
 time between versions of this library. <p>The returned string is not
 necessarily in JavaScript object Notation (JSON); to convert CBOR
 objects to JSON strings, use the
 <b>PeterO.Cbor.CBORObject.ToJSONString(PeterO.Cbor.JSONOptions)</b>
 method instead.</p></p>

<p><strong>Overrides:</strong></p>

<ul>
<li><code>toString</code> in class <code>java.lang.Object</code></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A text representation of this object.</li>
</ul>

<h3><a id='Untag()'>Untag</a></h3>

<p>Gets an object with the same value as this one but without the tags it has,
 if any. If this object is an array, map, or byte string, the data
 will not be copied to the returned object, so changes to the
 returned object will be reflected in this one.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>A CBOR object.</li>
</ul>

<h3><a id='UntagOne()'>UntagOne</a></h3>

<p>Gets an object with the same value as this one but without this object&#39;s
 outermost tag, if any. If this object is an array, map, or byte
 string, the data will not be copied to the returned object, so
 changes to the returned object will be reflected in this one.</p>

<p><strong>Returns:</strong></p>

<ul>
<li>A CBOR object.</li>
</ul>

<h3><a id='WriteJSONTo(java.io.OutputStream)'>WriteJSONTo</a></h3>

<pre>stream.write(0x1e); /* RS */ cborObject.WriteJSONTo(stream); /* JSON */ stream.write(0x0a); /* LF */
</pre>

<p>Converts this object to a text string in JavaScript object Notation (JSON)
 format, as in the ToJSONString method, and writes that string to a
 data stream in UTF-8. If the CBOR object contains CBOR maps, or is a
 CBOR map, the order in which the keys to the map are written out to
 the JSON string is undefined unless the map was created using the
 NewOrderedMap method. The example code given in
 <b>PeterO.Cbor.CBORObject.ToJSONString(PeterO.Cbor.JSONOptions)</b>
 can be used to write out certain keys of a CBOR map in a given order
 to a JSON string.<p> </p><p>The following example (originally written in
 C# for the.NET version) writes out a CBOR object as part of a JSON
 text sequence (RFC 7464).</p> <pre> stream.write(0x1e); /* RS <em>/ cborObject.WriteJSONTo(stream); /</em> JSON <em>/ stream.write(0x0a); /</em> LF <em>/ </pre> <p>The following example (originally written
 in C# for the.NET version) shows how to use the
 <code>LimitedMemoryStream</code> class (implemented in
 <i>LimitedMemoryStream.cs</i> in the peteroupc/CBOR open-source
 repository) to limit the size of supported JSON serializations of
 CBOR objects.</p> <pre> /</em> maximum supported JSON size in bytes<em>/ int maxSize = 20000; {
LimitedMemoryStream ms = null;
try {
ms = new LimitedMemoryStream(maxSize);
 cborObject.WriteJSONTo(ms); var bytes = ms.toByteArray();
}
finally {
try { if (ms != null) { ms.close(); } } catch (java.io.IOException ex) {}
}
} </pre> <p>The following example (written
 in Java for the Java version) shows how to use a subclassed
 <code>OutputStream</code> together with a <code>ByteArrayOutputStream</code> to
 limit the size of supported JSON serializations of CBOR objects.</p>
 <pre> /</em> maximum supported JSON size in bytes<em>/ final int maxSize = 20000; ByteArrayOutputStream ba = new ByteArrayOutputStream(); /</em> throws UnsupportedOperationException if too big<em>/ cborObject.WriteJSONTo(new FilterOutputStream(ba) { private int size = 0; public void write(byte[] b, int off, int len) { if (len&gt;(maxSize-size)) { throw new UnsupportedOperationException(); } size+=len; out.write(b, off, len); } public void write(byte b) { if (size &gt;= maxSize) { throw new UnsupportedOperationException(); } size++; out.write(b); } }); byte[] bytes = ba.toByteArray(); </pre>
 <p>The following example (originally written in C# for the.NET
 version) shows how to use a.NET MemoryStream to limit the size of
 supported JSON serializations of CBOR objects. The disadvantage is
 that the extra memory needed to do so can be wasteful, especially if
 the average serialized object is much smaller than the maximum size
 given (for example, if the maximum size is 20000 bytes, but the
 average serialized object has a size of 50 bytes).</p> <pre> byte[] backing = new byte[20000]; /</em> maximum supported JSON size in bytes<em>/ byte[] bytes1, bytes2; {
java.io.ByteArrayOutputStream ms = null;
try {
ms = new java.io.ByteArrayOutputStream(backing);
 /</em> throws UnsupportedOperationException if too big<em>/ cborObject.WriteJSONTo(ms); bytes1 = new byte[ms.size()]; /</em> Copy serialized data if successful<em>/ System.ArrayCopy(backing, 0, bytes1, 0, (int)ms.size()); /</em> Reset memory stream<em>/ ms.size() = 0; cborObject2.WriteJSONTo(ms); bytes2 = new byte[ms.size()]; /</em> Copy serialized data if successful*/ System.ArrayCopy(backing, 0, bytes2, 0, (int)ms.size());
}
finally {
try { if (ms != null) { ms.close(); } } catch (java.io.IOException ex) {}
}
} </pre></p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>outputStream</code> - A writable data stream.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.io.IOException</code> - An I/O error occurred.</p></li>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>outputStream</code> is null.</p></li>
</ul>

<h3><a id='WriteJSONTo(java.io.OutputStream,com.upokecenter.cbor.JSONOptions)'>WriteJSONTo</a></h3>

<p>Converts this object to a text string in JavaScript object Notation (JSON)
 format, as in the ToJSONString method, and writes that string to a
 data stream in UTF-8, using the given JSON options to control the
 encoding process. If the CBOR object contains CBOR maps, or is a
 CBOR map, the order in which the keys to the map are written out to
 the JSON string is undefined unless the map was created using the
 NewOrderedMap method. The example code given in
 <b>PeterO.Cbor.CBORObject.ToJSONString(PeterO.Cbor.JSONOptions)</b>
 can be used to write out certain keys of a CBOR map in a given order
 to a JSON string.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>outputStream</code> - A writable data stream.</p></li>
<li><p><code>options</code> - An object containing the options to control writing the CBOR
object to JSON.</p></li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.io.IOException</code> - An I/O error occurred.</p></li>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>outputStream</code> is null.</p></li>
</ul>

<h3><a id='FromFloatingPointBits(long,int)'>FromFloatingPointBits</a></h3>

<p>Generates a CBOR object from a floating-point number represented by its
 bits.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>floatingBits</code> - The bits of a floating-point number number to write.</p></li>
<li><p><code>byteCount</code> - The number of bytes of the stored floating-point number;
this also specifies the format of the &quot;floatingBits&quot; parameter. This
value can be 2 if &quot;floatingBits&quot;&#39;s lowest (least significant) 16
bits identify the floating-point number in IEEE 754r binary16
format; or 4 if &quot;floatingBits&quot;&#39;s lowest (least significant) 32 bits
identify the floating-point number in IEEE 754r binary32 format; or
8 if &quot;floatingBits&quot; identifies the floating point number in IEEE
754r binary64 format. Any other values for this parameter are
invalid.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>A CBOR object storing the given floating-point number.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><code>java.lang.IllegalArgumentException</code> - The parameter <code>byteCount</code> is other than 2,
4, or 8.</li>
</ul>

<h3><a id='WriteFloatingPointBits(java.io.OutputStream,long,int)'>WriteFloatingPointBits</a></h3>

<p>Writes the bits of a floating-point number in CBOR format to a data stream.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>outputStream</code> - A writable data stream.</p></li>
<li><p><code>floatingBits</code> - The bits of a floating-point number number to write.</p></li>
<li><p><code>byteCount</code> - The number of bytes of the stored floating-point number;
this also specifies the format of the &quot;floatingBits&quot; parameter. This
value can be 2 if &quot;floatingBits&quot;&#39;s lowest (least significant) 16
bits identify the floating-point number in IEEE 754r binary16
format; or 4 if &quot;floatingBits&quot;&#39;s lowest (least significant) 32 bits
identify the floating-point number in IEEE 754r binary32 format; or
8 if &quot;floatingBits&quot; identifies the floating point number in IEEE
754r binary64 format. Any other values for this parameter are
invalid. This method will write one plus this many bytes to the data
stream.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The number of 8-bit bytes ordered to be written to the data stream.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.IllegalArgumentException</code> - The parameter <code>byteCount</code> is other than 2,
4, or 8.</p></li>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>outputStream</code> is null.</p></li>
<li><p><code>java.io.IOException</code></p></li>
</ul>

<h3><a id='WriteFloatingPointBits(java.io.OutputStream,long,int,boolean)'>WriteFloatingPointBits</a></h3>

<p>Writes the bits of a floating-point number in CBOR format to a data stream.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>outputStream</code> - A writable data stream.</p></li>
<li><p><code>floatingBits</code> - The bits of a floating-point number number to write.</p></li>
<li><p><code>byteCount</code> - The number of bytes of the stored floating-point number;
this also specifies the format of the &quot;floatingBits&quot; parameter. This
value can be 2 if &quot;floatingBits&quot;&#39;s lowest (least significant) 16
bits identify the floating-point number in IEEE 754r binary16
format; or 4 if &quot;floatingBits&quot;&#39;s lowest (least significant) 32 bits
identify the floating-point number in IEEE 754r binary32 format; or
8 if &quot;floatingBits&quot; identifies the floating point number in IEEE
754r binary64 format. Any other values for this parameter are
invalid.</p></li>
<li><p><code>shortestForm</code> - If true, writes the shortest form of the floating-point
number that preserves its value. If false, this method will write
the number in the form given by &#39;floatingBits&#39; by writing one plus
the number of bytes given by &#39;byteCount&#39; to the data stream.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The number of 8-bit bytes ordered to be written to the data stream.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.IllegalArgumentException</code> - The parameter <code>byteCount</code> is other than 2,
4, or 8.</p></li>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>outputStream</code> is null.</p></li>
<li><p><code>java.io.IOException</code></p></li>
</ul>

<h3><a id='WriteFloatingPointValue(java.io.OutputStream,double,int)'>WriteFloatingPointValue</a></h3>

<p>Writes a 64-bit binary floating-point number in CBOR format to a data
 stream, either in its 64-bit form, or its rounded 32-bit or 16-bit
 equivalent.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>outputStream</code> - A writable data stream.</p></li>
<li><p><code>doubleVal</code> - The double-precision floating-point number to write.</p></li>
<li><p><code>byteCount</code> - The number of 8-bit bytes of the stored number. This value
can be 2 to store the number in IEEE 754r binary16, rounded to
nearest, ties to even; or 4 to store the number in IEEE 754r
binary32, rounded to nearest, ties to even; or 8 to store the number
in IEEE 754r binary64. Any other values for this parameter are
invalid.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The number of 8-bit bytes ordered to be written to the data stream.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.IllegalArgumentException</code> - The parameter <code>byteCount</code> is other than 2,
4, or 8.</p></li>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>outputStream</code> is null.</p></li>
<li><p><code>java.io.IOException</code></p></li>
</ul>

<h3><a id='WriteFloatingPointValue(java.io.OutputStream,float,int)'>WriteFloatingPointValue</a></h3>

<p>Writes a 32-bit binary floating-point number in CBOR format to a data
 stream, either in its 64- or 32-bit form, or its rounded 16-bit
 equivalent.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>outputStream</code> - A writable data stream.</p></li>
<li><p><code>singleVal</code> - The single-precision floating-point number to write.</p></li>
<li><p><code>byteCount</code> - The number of 8-bit bytes of the stored number. This value
can be 2 to store the number in IEEE 754r binary16, rounded to
nearest, ties to even; or 4 to store the number in IEEE 754r
binary32; or 8 to store the number in IEEE 754r binary64. Any other
values for this parameter are invalid.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The number of 8-bit bytes ordered to be written to the data stream.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.IllegalArgumentException</code> - The parameter <code>byteCount</code> is other than 2,
4, or 8.</p></li>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>outputStream</code> is null.</p></li>
<li><p><code>java.io.IOException</code></p></li>
</ul>

<h3><a id='WriteValue(java.io.OutputStream,int,long)'>WriteValue</a></h3>

<p>Writes a CBOR major type number and an integer 0 or greater associated with
 it to a data stream, where that integer is passed to this method as
 a 64-bit signed integer. This is a low-level method that is useful
 for implementing custom CBOR encoding methodologies. This method
 encodes the given major type and value in the shortest form allowed
 for the major type.<p>There are other useful things to note when
 encoding CBOR that are not covered by this WriteValue method. To
 mark the start of an indefinite-length array, write the 8-bit byte
 0x9f to the output stream. To mark the start of an indefinite-length
 map, write the 8-bit byte 0xbf to the output stream. To mark the end
 of an indefinite-length array or map, write the 8-bit byte 0xff to
 the output stream. For examples, see the WriteValue(InputStream, int,
 int) overload.</p></p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>outputStream</code> - A writable data stream.</p></li>
<li><p><code>majorType</code> - The CBOR major type to write. This is a number from 0
through 7 as follows. 0: integer 0 or greater; 1: negative integer;
2: byte string; 3: UTF-8 text string; 4: array; 5: map; 6: tag; 7:
simple value. See RFC 8949 for details on these major types.</p></li>
<li><p><code>value</code> - An integer 0 or greater associated with the major type, as
follows. 0: integer 0 or greater; 1: the negative integer&#39;s absolute
value is 1 plus this number; 2: length in bytes of the byte string;
3: length in bytes of the UTF-8 text string; 4: number of items in
the array; 5: number of key-value pairs in the map; 6: tag number;
7: simple value number, which must be in the interval [0, 23] or
[32, 255].</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The number of bytes ordered to be written to the data stream.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.IllegalArgumentException</code> - Value is from 24 to 31 and major type is 7.</p></li>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>outputStream</code> is null.</p></li>
<li><p><code>java.io.IOException</code></p></li>
</ul>

<h3><a id='WriteValue(java.io.OutputStream,int,int)'>WriteValue</a></h3>

<pre>/* array, length 3*/ CBORObject.WriteValue(stream, 4, 3); /* item 1 */ CBORObject.Write(&quot;hello world&quot;, stream); CBORObject.Write(25, stream); /* item 2*/ CBORObject.Write(false, stream); /* item 3*/
</pre>

<p>Writes a CBOR major type number and an integer 0 or greater associated with
 it to a data stream, where that integer is passed to this method as
 a 32-bit signed integer. This is a low-level method that is useful
 for implementing custom CBOR encoding methodologies. This method
 encodes the given major type and value in the shortest form allowed
 for the major type.<p>There are other useful things to note when
 encoding CBOR that are not covered by this WriteValue method. To
 mark the start of an indefinite-length array, write the 8-bit byte
 0x9f to the output stream. To mark the start of an indefinite-length
 map, write the 8-bit byte 0xbf to the output stream. To mark the end
 of an indefinite-length array or map, write the 8-bit byte 0xff to
 the output stream.</p><p> </p><p>In the following example, an array of
 three objects is written as CBOR to a data stream.</p>
  <pre>/* array, length 3<em>/ CBORObject.WriteValue(stream, 4, 3); /</em> item 1 <em>/ CBORObject.Write(&quot;hello world&quot;, stream); CBORObject.Write(25, stream); /</em> item 2<em>/ CBORObject.Write(false, stream); /</em> item 3<em>/</pre> <p>In the following
 example, a map consisting of two key-value pairs is written as CBOR
  to a data stream.</p> <pre>CBORObject.WriteValue(stream, 5, 2); /</em> map, 2 pairs<em>/ CBORObject.Write(&quot;number&quot;, stream); /</em> key 1 <em>/ CBORObject.Write(25, stream); /</em> value 1 <em>/ CBORObject.Write(&quot;string&quot;, stream); /</em> key 2<em>/ CBORObject.Write(&quot;hello&quot;, stream); /</em> value 2*/</pre> <p>In the following example
 (originally written in C# for the.NET Framework version), a text
  string is written as CBOR to a data stream.</p> <pre>string str = &quot;hello world&quot;; byte[] bytes = DataUtilities.GetUtf8Bytes(str, true); CBORObject.WriteValue(stream, 4, bytes.length); stream.write(bytes, 0, bytes.length);</pre> .</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>outputStream</code> - A writable data stream.</p></li>
<li><p><code>majorType</code> - The CBOR major type to write. This is a number from 0
through 7 as follows. 0: integer 0 or greater; 1: negative integer;
2: byte string; 3: UTF-8 text string; 4: array; 5: map; 6: tag; 7:
simple value. See RFC 8949 for details on these major types.</p></li>
<li><p><code>value</code> - An integer 0 or greater associated with the major type, as
follows. 0: integer 0 or greater; 1: the negative integer&#39;s absolute
value is 1 plus this number; 2: length in bytes of the byte string;
3: length in bytes of the UTF-8 text string; 4: number of items in
the array; 5: number of key-value pairs in the map; 6: tag number;
7: simple value number, which must be in the interval [0, 23] or
[32, 255].</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The number of bytes ordered to be written to the data stream.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.IllegalArgumentException</code> - Value is from 24 to 31 and major type is 7.</p></li>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>outputStream</code> is null.</p></li>
<li><p><code>java.io.IOException</code></p></li>
</ul>

<h3><a id='WriteValue(java.io.OutputStream,int,com.upokecenter.numbers.EInteger)'>WriteValue</a></h3>

<p>Writes a CBOR major type number and an integer 0 or greater associated with
 it to a data stream, where that integer is passed to this method as
 an arbitrary-precision integer. This is a low-level method that is
 useful for implementing custom CBOR encoding methodologies. This
 method encodes the given major type and value in the shortest form
 allowed for the major type.<p>There are other useful things to note
 when encoding CBOR that are not covered by this WriteValue method.
 To mark the start of an indefinite-length array, write the 8-bit
 byte 0x9f to the output stream. To mark the start of an
 indefinite-length map, write the 8-bit byte 0xbf to the output
 stream. To mark the end of an indefinite-length array or map, write
 the 8-bit byte 0xff to the output stream.</p></p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>outputStream</code> - A writable data stream.</p></li>
<li><p><code>majorType</code> - The CBOR major type to write. This is a number from 0
through 7 as follows. 0: integer 0 or greater; 1: negative integer;
2: byte string; 3: UTF-8 text string; 4: array; 5: map; 6: tag; 7:
simple value. See RFC 8949 for details on these major types.</p></li>
<li><p><code>bigintValue</code> - An integer 0 or greater associated with the major type,
as follows. 0: integer 0 or greater; 1: the negative integer&#39;s
absolute value is 1 plus this number; 2: length in bytes of the byte
string; 3: length in bytes of the UTF-8 text string; 4: number of
items in the array; 5: number of key-value pairs in the map; 6: tag
number; 7: simple value number, which must be in the interval [0,
23] or [32, 255]. For major types 0 to 6, this number may not be
greater than 2^64 - 1.</p></li>
</ul>

<p><strong>Returns:</strong></p>

<ul>
<li>The number of bytes ordered to be written to the data stream.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.IllegalArgumentException</code> - The parameter <code>majorType</code> is 7 and value is
greater than 255.</p></li>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>outputStream</code> or <code>
bigintValue</code> is null.</p></li>
<li><p><code>java.io.IOException</code></p></li>
</ul>

<h3><a id='WriteTo(java.io.OutputStream)'>WriteTo</a></h3>

<pre>private static void WriteKeysToMap(CBORObject mapObj, List&lt;CBORObject&gt; keys, OutputStream outputStream) throws java.io.IOException { if (mapObj == null) { throw new NullPointerException(&quot;mapObj&quot;);} if (keys == null) {throw new NullPointerException(&quot;keys&quot;);} if (outputStream == null) {throw new NullPointerException(&quot;outputStream&quot;);} if (obj.getType()!=CBORType.Map) { throw new IllegalArgumentException(&quot;&#39;obj&#39; is not a map.&quot;); } int keyCount = 0; for (CBORObject key in keys) { if (mapObj.ContainsKey(key)) { keyCount++; } } CBORObject.WriteValue(outputStream, 5, keyCount); for (CBORObject key in keys) { if (mapObj.ContainsKey(key)) { key.WriteTo(outputStream); mapObj.get(key).WriteTo(outputStream); } } }
</pre>

<p>Writes this CBOR object to a data stream. If the CBOR object contains
 CBOR maps, or is a CBOR map, the order in which the keys to the map
 are written out to the data stream is undefined unless the map was
 created using the NewOrderedMap method. See the examples (originally
 written in C# for the.NET version) for ways to write out certain
 keys of a CBOR map in a given order. In the case of CBOR objects of
 type FloatingPoint, the number is written using the shortest
 floating-point encoding possible; this is a change from previous
 versions.</p><p> </p><p>The following example shows a method that writes
 each key of 'mapObj' to 'outputStream', in the order given in
 'keys', where 'mapObj' is written out in the form of a CBOR
 <b>definite-length map</b> . Only keys found in 'keys' will be
  written if they exist in 'mapObj'.</p> <pre>private static void WriteKeysToMap(CBORObject mapObj, List&lt;CBORObject&gt; keys, OutputStream outputStream) throws java.io.IOException { if (mapObj == null) { throw new NullPointerException("mapObj");} if (keys == null) {throw new NullPointerException("keys");} if (outputStream == null) {throw new NullPointerException("outputStream");} if (obj.getType()!=CBORType.Map) { throw new IllegalArgumentException("'obj' is not a map."); } int keyCount = 0; for (CBORObject key in keys) { if (mapObj.ContainsKey(key)) { keyCount++; } } CBORObject.WriteValue(outputStream, 5, keyCount); for (CBORObject key in keys) { if (mapObj.ContainsKey(key)) { key.WriteTo(outputStream); mapObj.get(key).WriteTo(outputStream); } } }</pre> <p>The following example shows a method that writes each
 key of 'mapObj' to 'outputStream', in the order given in 'keys',
 where 'mapObj' is written out in the form of a CBOR
 <b>indefinite-length map</b> . Only keys found in 'keys' will be
  written if they exist in 'mapObj'.</p> <pre>private static void WriteKeysToIndefMap(CBORObject mapObj, List&lt;CBORObject&gt; keys, OutputStream outputStream) throws java.io.IOException { if (mapObj == null) { throw new NullPointerException("mapObj");} if (keys == null) {throw new NullPointerException("keys");} if (outputStream == null) {throw new NullPointerException("outputStream");} if (obj.getType()!=CBORType.Map) { throw new IllegalArgumentException("'obj' is not a map."); } outputStream.write((byte)0xBF); for (CBORObject key in keys) { if (mapObj.ContainsKey(key)) { key.WriteTo(outputStream); mapObj.get(key).WriteTo(outputStream); } } outputStream.write((byte)0xff); }</pre> <p>The following example
 shows a method that writes out a list of objects to 'outputStream'
  as an <b>indefinite-length CBOR array</b> .</p> <pre>private static void WriteToIndefArray(List&lt;object&gt; list, OutputStream outputStream) throws java.io.IOException { if (list == null) { throw new NullPointerException("list");} if (outputStream == null) {throw new NullPointerException("outputStream");} outputStream.write((byte)0x9f); for (object item in list) { new CBORObject(item).WriteTo(outputStream); } outputStream.write((byte)0xff); }</pre> <p>The following example
 (originally written in C# for the.NET version) shows how to use the
 <code>LimitedMemoryStream</code> class (implemented in
 <i>LimitedMemoryStream.cs</i> in the peteroupc/CBOR open-source
 repository) to limit the size of supported CBOR serializations.</p>

<p><pre> /* maximum supported CBOR size in bytes<em>/ int maxSize = 20000; {
LimitedMemoryStream ms = null;
try {
ms = new LimitedMemoryStream(maxSize);
 cborObject.WriteTo(ms); var bytes = ms.toByteArray();
}
finally {
try { if (ms != null) { ms.close(); } } catch (java.io.IOException ex) {}
}
} </pre> <p>The following example (written in Java for
 the Java version) shows how to use a subclassed <code>OutputStream</code>
 together with a <code>ByteArrayOutputStream</code> to limit the size of
 supported CBOR serializations.</p> <pre> /</em> maximum supported CBOR size in bytes<em>/ final int maxSize = 20000; ByteArrayOutputStream ba = new ByteArrayOutputStream(); /</em> throws UnsupportedOperationException if too big<em>/ cborObject.WriteTo(new FilterOutputStream(ba) { private int size = 0; public void write(byte[] b, int off, int len) { if (len&gt;(maxSize-size)) { throw new UnsupportedOperationException(); } size+=len; out.write(b, off, len); } public void write(byte b) { if (size &gt;= maxSize) { throw new UnsupportedOperationException(); } size++; out.write(b); } }); byte[] bytes = ba.toByteArray(); </pre>
 <p>The following example (originally written in C# for the.NET
 version) shows how to use a.NET MemoryStream to limit the size of
 supported CBOR serializations. The disadvantage is that the extra
 memory needed to do so can be wasteful, especially if the average
 serialized object is much smaller than the maximum size given (for
 example, if the maximum size is 20000 bytes, but the average
 serialized object has a size of 50 bytes).</p> <pre> byte[] backing = new byte[20000]; /</em> maximum supported CBOR size in bytes<em>/ byte[] bytes1, bytes2; {
java.io.ByteArrayOutputStream ms = null;
try {
ms = new java.io.ByteArrayOutputStream(backing);
 /</em> throws UnsupportedOperationException if too big<em>/ cborObject.WriteTo(ms); bytes1 = new byte[ms.size()]; /</em> Copy serialized data if successful<em>/ System.ArrayCopy(backing, 0, bytes1, 0, (int)ms.size()); /</em> Reset memory stream<em>/ ms.size() = 0; cborObject2.WriteTo(ms); bytes2 = new byte[ms.size()]; /</em> Copy serialized data if successful*/ System.ArrayCopy(backing, 0, bytes2, 0, (int)ms.size());
}
finally {
try { if (ms != null) { ms.close(); } } catch (java.io.IOException ex) {}
}
} </pre></p>

<p><strong>Parameters:</strong></p>

<ul>
<li><code>stream</code> - A writable data stream.</li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>stream</code> is null.</p></li>
<li><p><code>java.io.IOException</code> - An I/O error occurred.</p></li>
</ul>

<h3><a id='WriteTo(java.io.OutputStream,com.upokecenter.cbor.CBOREncodeOptions)'>WriteTo</a></h3>

<p>Writes this CBOR object to a data stream, using the specified options for
 encoding the data to CBOR format. If the CBOR object contains CBOR
 maps, or is a CBOR map, the order in which the keys to the map are
 written out to the data stream is undefined unless the map was
 created using the NewOrderedMap method. The example code given in
 <see cref='PeterO.Cbor.CBORObject.WriteTo(System.IO.InputStream)'/> can
 be used to write out certain keys of a CBOR map in a given order. In
 the case of CBOR objects of type FloatingPoint, the number is
 written using the shortest floating-point encoding possible; this is
 a change from previous versions.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><p><code>stream</code> - A writable data stream.</p></li>
<li><p><code>options</code> - Options for encoding the data to CBOR.</p></li>
</ul>

<p><strong>Throws:</strong></p>

<ul>
<li><p><code>java.lang.NullPointerException</code> - The parameter <code>stream</code> is null.</p></li>
<li><p><code>java.io.IOException</code> - An I/O error occurred.</p></li>
<li><p><code>java.lang.IllegalArgumentException</code> - Unexpected data type&quot;.</p></li>
</ul>

<p><a href="/CBOR/">Back to CBOR start page.</a></p>
</div><nav id="navigation"><ul>
<li><a href="/">Back to start site.</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io">This site's repository (source code)</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io/issues">Post an issue or comment</a></ul>

<div class="noprint">
<p>
<a href="//twitter.com/intent/tweet">Share via Twitter</a>, <a href="//www.facebook.com/sharer/sharer.php" id="sharer">Share via Facebook</a>
</p>
</div>
</nav></body></html>
