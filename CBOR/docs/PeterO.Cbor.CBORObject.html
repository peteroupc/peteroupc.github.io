<!DOCTYPE html><html xmlns:dc="http://purl.org/dc/terms/"><head><meta http-equiv=Content-Type content="text/html; charset=utf-8"><title>PeterO.Cbor.CBORObject</title><meta name="viewport" content="width=device-width"><link rel=stylesheet type="text/css" href="/style.css">
            <script type="text/x-mathjax-config"> MathJax.Hub.Config({"HTML-CSS": { availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, preferredFont: "TeX" },
                    tex2jax: { displayMath: [ ["$$","$$"], ["\\[", "\\]"] ], inlineMath: [ ["$", "$"], ["\\\\(","\\\\)"] ], processEscapes: true } });
            </script><script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"></script></head><body>  <div class="header">
<nav><p><a href="#navigation">Menu</a> - <a href="#top">Top</a> - <a href="/">Home</a></nav></div>
<div class="mainarea" id="top">
<h1>PeterO.Cbor.CBORObject</h1>
<p>## PeterO.Cbor.CBORObject</p>

<pre>public sealed class CBORObject :
    System.IComparable,
    System.IEquatable
</pre>

<p>Represents an object in Concise Binary Object Representation (CBOR) and contains methods for reading and writing CBOR data. CBOR is an Internet Standard and defined in RFC 8949.</p>

<p><b>Converting CBOR objects</b></p>

<p>There are many ways to get a CBOR object, including from bytes, objects, streams and JSON, as described below.</p>

<p><b>To and from byte arrays:</b> The CBORObject.DecodeFromBytes method converts a byte array in CBOR format to a CBOR object. The EncodeToBytes method converts a CBOR object to its corresponding byte array in CBOR format.</p>

<p><b>To and from data streams:</b> The CBORObject.Write methods write many kinds of objects to a data stream, including numbers, CBOR objects, strings, and arrays of numbers and strings. The CBORObject.Read method reads a CBOR object from a data stream.</p>

<p><b>To and from other objects:</b> The  <code>CBORObject.From[Type]</code>  method converts many kinds of objects to a CBOR object, including numbers, strings, and arrays and maps of numbers and strings. Methods like AsNumber and AsString convert a CBOR object to different types of object. The  <code>CBORObject.ToObject</code>  method converts a CBOR object to an object of a given type; for example, a CBOR array to a native  <code>List</code>  (or  <code>ArrayList</code>  in Java), or a CBOR integer to an  <code>int</code>  or  <code>long</code> . Of these methods, the.NET versions of the methods  <code>CBORObject.FromObject</code>  and  <code>CBORObject.ToObject</code>  are not compatible with any context that disallows reflection, such as ahead-of-time compilation or self-contained app deployment.</p>

<p><b>To and from JSON:</b> This class also doubles as a reader and writer of JavaScript Object Notation (JSON). The CBORObject.FromJSONString method converts JSON in text string form to a CBOR object, and the ToJSONString method converts a CBOR object to a JSON string. (Note that the conversion from CBOR to JSON is not always without loss and may make it impossible to recover the original object when converting the JSON back to CBOR. See the ToJSONString documentation.) Likewise, ToJSONBytes and FromJSONBytes work with JSON in the form of byte arrays rather than text strings.</p>

<p>In addition, the CBORObject.WriteJSON method writes many kinds of objects as JSON to a data stream, including numbers, CBOR objects, strings, and arrays of numbers and strings. The CBORObject.Read method reads a CBOR object from a JSON data stream.</p>

<p><b>Comparison Considerations:</b></p>

<p>Instances of CBORObject should not be compared for equality using the “==” operator; it’s possible to create two CBOR objects with the same value but not the same reference. (The “==” operator might only check if each side of the operator is the same instance.)</p>

<p>This class’s natural ordering (under the CompareTo method) is consistent with the Equals method, meaning that two values that compare as equal under the CompareTo method are also equal under the Equals method; this is a change in version 4.0. Two otherwise equal objects with different tags are not treated as equal by both CompareTo and Equals. To strip the tags from a CBOR object before comparing, use the  <code>Untag</code>  method.</p>

<p><b>Thread Safety:</b></p>

<p>Certain CBOR objects are immutable (their values can’t be changed), so they are inherently safe for use by multiple threads.</p>

<p>CBOR objects that are arrays, maps, and byte strings (whether or not they are tagged) are mutable, but this class doesn’t attempt to synchronize reads and writes to those objects by multiple threads, so those objects are not thread safe without such synchronization.</p>

<p>One kind of CBOR object is called a map, or a list of key-value pairs. Keys can be any kind of CBOR object, including numbers, strings, arrays, and maps. However, untagged text strings (which means GetTags returns an empty array and the Type property, or “getType()” in Java, returns TextString) are the most suitable to use as keys; other kinds of CBOR object are much better used as map values instead, keeping in mind that some of them are not thread safe without synchronizing reads and writes to them.</p>

<p>To find the type of a CBOR object, call its Type property (or “getType()” in Java). The return value can be Integer, FloatingPoint, Boolean, SimpleValue, or TextString for immutable CBOR objects, and Array, Map, or ByteString for mutable CBOR objects.</p>

<p><b>Nesting Depth:</b></p>

<p>The DecodeFromBytes and Read methods can only read objects with a limited maximum depth of arrays and maps nested within other arrays and maps. The code sets this maximum depth to 500 (allowing more than enough nesting for most purposes), but it’s possible that stack overflows in some runtimes might lower the effective maximum nesting depth. When the nesting depth goes above 500, the DecodeFromBytes and Read methods throw a CBORException.</p>

<p>The ReadJSON and FromJSONString methods currently have nesting depths of 1000.</p>

<h3 id="member-summary">Member Summary</h3>
<ul>
  <li><code>[Add(object)](#Add_object)</code> -</li>
  <li><code>[Add(object, object)](#Add_object_object)</code> -</li>
  <li><code>[Add(PeterO.Cbor.CBORObject)](#Add_PeterO_Cbor_CBORObject)</code> -</li>
  <li><code>[ApplyJSONPatch(PeterO.Cbor.CBORObject)](#ApplyJSONPatch_PeterO_Cbor_CBORObject)</code> -</li>
  <li><code>[AsBoolean()](#AsBoolean)</code> - Returns false if this object is a CBOR false, null, or undefined value (whether or not the object has tags); otherwise, true.</li>
  <li><code>[AsDouble()](#AsDouble)</code> - Converts this object to a 64-bit floating point number.</li>
  <li><code>[AsDoubleBits()](#AsDoubleBits)</code> - Converts this object to the bits of a 64-bit floating-point number if this CBOR object’s type is FloatingPoint.</li>
  <li><code>[AsDoubleValue()](#AsDoubleValue)</code> - Converts this object to a 64-bit floating-point number if this CBOR object’s type is FloatingPoint.</li>
  <li><code>[AsEIntegerValue()](#AsEIntegerValue)</code> - Converts this object to an arbitrary-precision integer if this CBOR object’s type is Integer.</li>
  <li><code>[AsGuid()](#AsGuid)</code> - Converts this object to a Guid.</li>
  <li><code>[AsInt32()](#AsInt32)</code> - Converts this object to a 32-bit signed integer.</li>
  <li><code>[AsInt32Value()](#AsInt32Value)</code> - Converts this object to a 32-bit signed integer if this CBOR object’s type is Integer.</li>
  <li><code>[AsInt64Value()](#AsInt64Value)</code> - Converts this object to a 64-bit signed integer if this CBOR object’s type is Integer.</li>
  <li><code>[AsNumber()](#AsNumber)</code> - Converts this object to a CBOR number.</li>
  <li><code>[AsSingle()](#AsSingle)</code> - Converts this object to a 32-bit floating point number.</li>
  <li><code>[AsString()](#AsString)</code> - Gets the value of this object as a text string.</li>
  <li><code>[AtJSONPointer(string)](#AtJSONPointer_string)</code> -</li>
  <li><code>[AtJSONPointer(string, PeterO.Cbor.CBORObject)](#AtJSONPointer_string_PeterO_Cbor_CBORObject)</code> -</li>
  <li><code>[CalcEncodedSize()](#CalcEncodedSize)</code> - Calculates the number of bytes this CBOR object takes when serialized as a byte array using the EncodeToBytes() method.</li>
  <li><code>[CanValueFitInInt32()](#CanValueFitInInt32)</code> - Returns whether this CBOR object stores an integer (CBORType.</li>
  <li><code>[CanValueFitInInt64()](#CanValueFitInInt64)</code> - Returns whether this CBOR object stores an integer (CBORType.</li>
  <li><code>[Clear()](#Clear)</code> - Removes all items from this CBOR array or all keys and values from this CBOR map.</li>
  <li><code>[CompareTo(PeterO.Cbor.CBORObject)](#CompareTo_PeterO_Cbor_CBORObject)</code> -</li>
  <li><code>[CompareToIgnoreTags(PeterO.Cbor.CBORObject)](#CompareToIgnoreTags_PeterO_Cbor_CBORObject)</code> -</li>
  <li><code>[ContainsKey(object)](#ContainsKey_object)</code> -</li>
  <li><code>[ContainsKey(PeterO.Cbor.CBORObject)](#ContainsKey_PeterO_Cbor_CBORObject)</code> -</li>
  <li><code>[ContainsKey(string)](#ContainsKey_string)</code> -</li>
  <li><code>[Count](#Count)</code> - Gets the number of keys in this map, or the number of items in this array, or 0 if this item is neither an array nor a map.</li>
  <li><code>[DecodeFromBytes(byte[])](#DecodeFromBytes_byte)</code> -</li>
  <li><code>[DecodeFromBytes(byte[], PeterO.Cbor.CBOREncodeOptions)](#DecodeFromBytes_byte_PeterO_Cbor_CBOREncodeOptions)</code> -</li>
  <li><code>[DecodeObjectFromBytes(byte[], PeterO.Cbor.CBOREncodeOptions, System.Type)](#DecodeObjectFromBytes_byte_PeterO_Cbor_CBOREncodeOptions_System_Type)</code> -</li>
  <li><code>[DecodeObjectFromBytes(byte[], PeterO.Cbor.CBOREncodeOptions, System.Type, PeterO.Cbor.CBORTypeMapper, PeterO.Cbor.PODOptions)](#DecodeObjectFromBytes_byte_PeterO_Cbor_CBOREncodeOptions_System_Type_PeterO_Cbor_CBORTypeMapper_PeterO_Cbor_PODOptions)</code> -</li>
  <li><code>[DecodeObjectFromBytes(byte[], System.Type)](#DecodeObjectFromBytes_byte_System_Type)</code> -</li>
  <li><code>[DecodeObjectFromBytes(byte[], System.Type, PeterO.Cbor.CBORTypeMapper, PeterO.Cbor.PODOptions)](#DecodeObjectFromBytes_byte_System_Type_PeterO_Cbor_CBORTypeMapper_PeterO_Cbor_PODOptions)</code> -</li>
  <li><code>[DecodeObjectFromBytes&lt;T&gt;(byte[])](#DecodeObjectFromBytes_T_byte)</code> -</li>
  <li><code>[DecodeObjectFromBytes&lt;T&gt;(byte[], PeterO.Cbor.CBOREncodeOptions)](#DecodeObjectFromBytes_T_byte_PeterO_Cbor_CBOREncodeOptions)</code> -</li>
  <li><code>[DecodeObjectFromBytes&lt;T&gt;(byte[], PeterO.Cbor.CBOREncodeOptions, PeterO.Cbor.CBORTypeMapper, PeterO.Cbor.PODOptions)](#DecodeObjectFromBytes_T_byte_PeterO_Cbor_CBOREncodeOptions_PeterO_Cbor_CBORTypeMapper_PeterO_Cbor_PODOptions)</code> -</li>
  <li><code>[DecodeObjectFromBytes&lt;T&gt;(byte[], PeterO.Cbor.CBORTypeMapper, PeterO.Cbor.PODOptions)](#DecodeObjectFromBytes_T_byte_PeterO_Cbor_CBORTypeMapper_PeterO_Cbor_PODOptions)</code> -</li>
  <li><code>[DecodeSequenceFromBytes(byte[])](#DecodeSequenceFromBytes_byte)</code> -</li>
  <li><code>[DecodeSequenceFromBytes(byte[], PeterO.Cbor.CBOREncodeOptions)](#DecodeSequenceFromBytes_byte_PeterO_Cbor_CBOREncodeOptions)</code> -</li>
  <li><code>[EncodeToBytes()](#EncodeToBytes)</code> - Writes the binary representation of this CBOR object and returns a byte array of that representation.</li>
  <li><code>[EncodeToBytes(PeterO.Cbor.CBOREncodeOptions)](#EncodeToBytes_PeterO_Cbor_CBOREncodeOptions)</code> -</li>
  <li><code>[Entries](#Entries)</code> - Gets a collection of the key/value pairs stored in this CBOR object, if it’s a map.</li>
  <li><code>[Equals(object)](#Equals_object)</code> -</li>
  <li><code>[Equals(PeterO.Cbor.CBORObject)](#Equals_PeterO_Cbor_CBORObject)</code> -</li>
  <li><code>[public static readonly PeterO.Cbor.CBORObject False;](#False)</code> - Represents the value false.</li>
  <li><code>[FromBool(bool)](#FromBool_bool)</code> -</li>
  <li><code>[FromByte(byte)](#FromByte_byte)</code> -</li>
  <li><code>[FromByteArray(byte[])](#FromByteArray_byte)</code> -</li>
  <li><code>[FromCBORArray(PeterO.Cbor.CBORObject[])](#FromCBORArray_PeterO_Cbor_CBORObject)</code> -</li>
  <li><code>[FromCBORObjectAndTag(PeterO.Cbor.CBORObject, int)](#FromCBORObjectAndTag_PeterO_Cbor_CBORObject_int)</code> -</li>
  <li><code>[FromCBORObjectAndTag(PeterO.Cbor.CBORObject, PeterO.Numbers.EInteger)](#FromCBORObjectAndTag_PeterO_Cbor_CBORObject_PeterO_Numbers_EInteger)</code> -</li>
  <li><code>[FromCBORObjectAndTag(PeterO.Cbor.CBORObject, ulong)](#FromCBORObjectAndTag_PeterO_Cbor_CBORObject_ulong)</code> -</li>
  <li><code>[FromDecimal(decimal)](#FromDecimal_decimal)</code> -</li>
  <li><code>[FromDouble(double)](#FromDouble_double)</code> -</li>
  <li><code>[FromEDecimal(PeterO.Numbers.EDecimal)](#FromEDecimal_PeterO_Numbers_EDecimal)</code> -</li>
  <li><code>[FromEFloat(PeterO.Numbers.EFloat)](#FromEFloat_PeterO_Numbers_EFloat)</code> -</li>
  <li><code>[FromEInteger(PeterO.Numbers.EInteger)](#FromEInteger_PeterO_Numbers_EInteger)</code> -</li>
  <li><code>[FromERational(PeterO.Numbers.ERational)](#FromERational_PeterO_Numbers_ERational)</code> -</li>
  <li><code>[FromFloatingPointBits(long, int)](#FromFloatingPointBits_long_int)</code> -</li>
  <li><code>[FromGuid(System.Guid)](#FromGuid_System_Guid)</code> -</li>
  <li><code>[FromInt16(short)](#FromInt16_short)</code> -</li>
  <li><code>[FromInt32(int)](#FromInt32_int)</code> -</li>
  <li><code>[FromInt64(long)](#FromInt64_long)</code> -</li>
  <li><code>[FromJSONBytes(byte[])](#FromJSONBytes_byte)</code> -</li>
  <li><code>[FromJSONBytes(byte[], int, int)](#FromJSONBytes_byte_int_int)</code> -</li>
  <li><code>[FromJSONBytes(byte[], int, int, PeterO.Cbor.JSONOptions)](#FromJSONBytes_byte_int_int_PeterO_Cbor_JSONOptions)</code> -</li>
  <li><code>[FromJSONBytes(byte[], PeterO.Cbor.JSONOptions)](#FromJSONBytes_byte_PeterO_Cbor_JSONOptions)</code> -</li>
  <li><code>[FromJSONSequenceBytes(byte[])](#FromJSONSequenceBytes_byte)</code> -</li>
  <li><code>[FromJSONSequenceBytes(byte[], PeterO.Cbor.JSONOptions)](#FromJSONSequenceBytes_byte_PeterO_Cbor_JSONOptions)</code> -</li>
  <li><code>[FromJSONString(string)](#FromJSONString_string)</code> -</li>
  <li><code>[FromJSONString(string, int, int)](#FromJSONString_string_int_int)</code> -</li>
  <li><code>[FromJSONString(string, int, int, PeterO.Cbor.JSONOptions)](#FromJSONString_string_int_int_PeterO_Cbor_JSONOptions)</code> -</li>
  <li><code>[FromJSONString(string, PeterO.Cbor.JSONOptions)](#FromJSONString_string_PeterO_Cbor_JSONOptions)</code> -</li>
  <li><code>[FromMap(System.Collections.Generic.IEnumerable)](#FromMap_System_Collections_Generic_IEnumerable)</code> -</li>
  <li><code>[FromObject(bool)](#FromObject_bool)</code> - <b>Deprecated:</b> Use FromBool instead.</li>
  <li><code>[FromObject(byte[])](#FromObject_byte)</code> - <b>Deprecated:</b> Use FromByte instead. <b>Deprecated:</b> Use FromByteArray instead.</li>
  <li><code>[FromObject(decimal)](#FromObject_decimal)</code> - <b>Deprecated:</b> Use FromDecimal instead</li>
  <li><code>[FromObject(double)](#FromObject_double)</code> - <b>Deprecated:</b> Use FromDouble instead.</li>
  <li><code>[FromObject(float)](#FromObject_float)</code> - <b>Deprecated:</b> Use FromFloat instead.</li>
  <li><code>[FromObject(int[])](#FromObject_int)</code> - <b>Deprecated:</b> Use FromInt instead.</li>
  <li><code>[FromObject(long[])](#FromObject_long)</code> - <b>Deprecated:</b> Use FromInt64 instead.</li>
  <li><code>[FromObject(object)](#FromObject_object)</code> -</li>
  <li><code>[FromObject(object, PeterO.Cbor.CBORTypeMapper)](#FromObject_object_PeterO_Cbor_CBORTypeMapper)</code> -</li>
  <li><code>[FromObject(object, PeterO.Cbor.CBORTypeMapper, PeterO.Cbor.PODOptions)](#FromObject_object_PeterO_Cbor_CBORTypeMapper_PeterO_Cbor_PODOptions)</code> -</li>
  <li><code>[FromObject(object, PeterO.Cbor.PODOptions)](#FromObject_object_PeterO_Cbor_PODOptions)</code> -</li>
  <li><code>[FromObject(PeterO.Cbor.CBORObject[])](#FromObject_PeterO_Cbor_CBORObject)</code> - <b>Deprecated:</b> Don’t use a function and use Nullable Reference Types to guard against nulls. <b>Deprecated:</b> Use FromCBORArray instead.</li>
  <li><code>[FromObject(PeterO.Numbers.EDecimal)](#FromObject_PeterO_Numbers_EDecimal)</code> - <b>Deprecated:</b> Use FromEDecimal instead.</li>
  <li><code>[FromObject(PeterO.Numbers.EFloat)](#FromObject_PeterO_Numbers_EFloat)</code> - <b>Deprecated:</b> Use FromEFloat instead.</li>
  <li><code>[FromObject(PeterO.Numbers.EInteger)](#FromObject_PeterO_Numbers_EInteger)</code> - <b>Deprecated:</b> Use FromEInteger instead.</li>
  <li><code>[FromObject(PeterO.Numbers.ERational)](#FromObject_PeterO_Numbers_ERational)</code> - <b>Deprecated:</b> Use FromERational instead.</li>
  <li><code>[FromObject(sbyte)](#FromObject_sbyte)</code> - <b>Deprecated:</b> Use FromSbyte instead</li>
  <li><code>[FromObject(short)](#FromObject_short)</code> - <b>Deprecated:</b> Use FromInt16 instead.</li>
  <li><code>[FromObject(string)](#FromObject_string)</code> - <b>Deprecated:</b> Use FromString instead.</li>
  <li><code>[FromObject(uint)](#FromObject_uint)</code> - <b>Deprecated:</b> Use FromUInt instead</li>
  <li><code>[FromObject(ulong)](#FromObject_ulong)</code> - <b>Deprecated:</b> Use FromUInt64 instead</li>
  <li><code>[FromObject(ushort)](#FromObject_ushort)</code> - <b>Deprecated:</b> Use FromUShort instead</li>
  <li><code>[FromObjectAndTag(object, int)](#FromObjectAndTag_object_int)</code> - <b>Deprecated:</b> Use FromCBORObjectAndTag instead.</li>
  <li><code>[FromObjectAndTag(object, PeterO.Numbers.EInteger)](#FromObjectAndTag_object_PeterO_Numbers_EInteger)</code> - <b>Deprecated:</b> Use FromCBORObjectAndTag instead.</li>
  <li><code>[FromOrderedMap(System.Collections.Generic.IEnumerable)](#FromOrderedMap_System_Collections_Generic_IEnumerable)</code> -</li>
  <li><code>[FromSbyte(sbyte)](#FromSbyte_sbyte)</code> -</li>
  <li><code>[FromSimpleValue(int)](#FromSimpleValue_int)</code> -</li>
  <li><code>[FromSingle(float)](#FromSingle_float)</code> -</li>
  <li><code>[FromString(string)](#FromString_string)</code> -</li>
  <li><code>[FromUInt(uint)](#FromUInt_uint)</code> -</li>
  <li><code>[FromUInt64(ulong)](#FromUInt64_ulong)</code> -</li>
  <li><code>[FromUShort(ushort)](#FromUShort_ushort)</code> -</li>
  <li><code>[GetAllTags()](#GetAllTags)</code> - Gets a list of all tags, from outermost to innermost.</li>
  <li><code>[GetByteString()](#GetByteString)</code> - Gets the backing byte array used in this CBOR object, if this object is a byte string, without copying the data to a new byte array.</li>
  <li><code>[GetHashCode()](#GetHashCode)</code> - Calculates the hash code of this object.</li>
  <li><code>[GetOrDefault(int, PeterO.Cbor.CBORObject)](#GetOrDefault_int_PeterO_Cbor_CBORObject)</code> -</li>
  <li><code>[GetOrDefault(PeterO.Cbor.CBORObject, PeterO.Cbor.CBORObject)](#GetOrDefault_PeterO_Cbor_CBORObject_PeterO_Cbor_CBORObject)</code> -</li>
  <li><code>[GetOrDefault(string, PeterO.Cbor.CBORObject)](#GetOrDefault_string_PeterO_Cbor_CBORObject)</code> -</li>
  <li><code>[HasMostInnerTag(int)](#HasMostInnerTag_int)</code> -</li>
  <li><code>[HasMostInnerTag(PeterO.Numbers.EInteger)](#HasMostInnerTag_PeterO_Numbers_EInteger)</code> -</li>
  <li><code>[HasMostOuterTag(int)](#HasMostOuterTag_int)</code> -</li>
  <li><code>[HasMostOuterTag(PeterO.Numbers.EInteger)](#HasMostOuterTag_PeterO_Numbers_EInteger)</code> -</li>
  <li><code>[HasOneTag()](#HasOneTag)</code> - Returns whether this object has only one tag.</li>
  <li><code>[HasOneTag(int)](#HasOneTag_int)</code> -</li>
  <li><code>[HasOneTag(PeterO.Numbers.EInteger)](#HasOneTag_PeterO_Numbers_EInteger)</code> -</li>
  <li><code>[HasTag(int)](#HasTag_int)</code> -</li>
  <li><code>[HasTag(PeterO.Numbers.EInteger)](#HasTag_PeterO_Numbers_EInteger)</code> -</li>
  <li><code>[Insert(int, object)](#Insert_int_object)</code> - <b>Deprecated:</b> Use the CBORObject overload instead.</li>
  <li><code>[Insert(int, PeterO.Cbor.CBORObject)](#Insert_int_PeterO_Cbor_CBORObject)</code> -</li>
  <li><code>[IsFalse](#IsFalse)</code> - Gets a value indicating whether this value is a CBOR false value, whether tagged or not.</li>
  <li><code>[IsNull](#IsNull)</code> - Gets a value indicating whether this CBOR object is a CBOR null value, whether tagged or not.</li>
  <li><code>[IsNumber](#IsNumber)</code> - Gets a value indicating whether this CBOR object stores a number (including infinity or a not-a-number or NaN value).</li>
  <li><code>[IsTagged](#IsTagged)</code> - Gets a value indicating whether this data item has at least one tag.</li>
  <li><code>[IsTrue](#IsTrue)</code> - Gets a value indicating whether this value is a CBOR true value, whether tagged or not.</li>
  <li><code>[IsUndefined](#IsUndefined)</code> - Gets a value indicating whether this value is a CBOR undefined value, whether tagged or not.</li>
  <li><code>[Keys](#Keys)</code> - Gets a collection of the keys of this CBOR object.</li>
  <li><code>[MostInnerTag](#MostInnerTag)</code> - Gets the last defined tag for this CBOR data item, or -1 if the item is untagged.</li>
  <li><code>[MostOuterTag](#MostOuterTag)</code> - Gets the outermost tag for this CBOR data item, or -1 if the item is untagged.</li>
  <li><code>[public static readonly PeterO.Cbor.CBORObject NaN;](#NaN)</code> - A not-a-number value.</li>
  <li><code>[public static readonly PeterO.Cbor.CBORObject NegativeInfinity;](#NegativeInfinity)</code> - The value negative infinity.</li>
  <li><code>[NewArray()](#NewArray)</code> - Creates a new empty CBOR array.</li>
  <li><code>[NewMap()](#NewMap)</code> - Creates a new empty CBOR map that stores its keys in an undefined order.</li>
  <li><code>[NewOrderedMap()](#NewOrderedMap)</code> - Creates a new empty CBOR map that ensures that keys are stored in the order in which they are first inserted.</li>
  <li><code>[public static readonly PeterO.Cbor.CBORObject Null;](#Null)</code> - Represents the value null.</li>
  <li><code>[bool operator &gt;(PeterO.Cbor.CBORObject, PeterO.Cbor.CBORObject)](#op_GreaterThan)</code> -</li>
  <li><code>[bool operator &gt;=(PeterO.Cbor.CBORObject, PeterO.Cbor.CBORObject)](#op_GreaterThanOrEqual)</code> -</li>
  <li><code>[bool operator &lt;(PeterO.Cbor.CBORObject, PeterO.Cbor.CBORObject)](#op_LessThan)</code> -</li>
  <li><code>[bool operator &lt;=(PeterO.Cbor.CBORObject, PeterO.Cbor.CBORObject)](#op_LessThanOrEqual)</code> -</li>
  <li><code>[public static readonly PeterO.Cbor.CBORObject PositiveInfinity;](#PositiveInfinity)</code> - The value positive infinity.</li>
  <li><code>[Read(System.IO.Stream)](#Read_System_IO_Stream)</code> -</li>
  <li><code>[Read(System.IO.Stream, PeterO.Cbor.CBOREncodeOptions)](#Read_System_IO_Stream_PeterO_Cbor_CBOREncodeOptions)</code> -</li>
  <li><code>[ReadJSON(System.IO.Stream)](#ReadJSON_System_IO_Stream)</code> -</li>
  <li><code>[ReadJSON(System.IO.Stream, PeterO.Cbor.JSONOptions)](#ReadJSON_System_IO_Stream_PeterO_Cbor_JSONOptions)</code> -</li>
  <li><code>[ReadJSONSequence(System.IO.Stream)](#ReadJSONSequence_System_IO_Stream)</code> -</li>
  <li><code>[ReadJSONSequence(System.IO.Stream, PeterO.Cbor.JSONOptions)](#ReadJSONSequence_System_IO_Stream_PeterO_Cbor_JSONOptions)</code> -</li>
  <li><code>[ReadSequence(System.IO.Stream)](#ReadSequence_System_IO_Stream)</code> -</li>
  <li><code>[ReadSequence(System.IO.Stream, PeterO.Cbor.CBOREncodeOptions)](#ReadSequence_System_IO_Stream_PeterO_Cbor_CBOREncodeOptions)</code> -</li>
  <li><code>[Remove(object)](#Remove_object)</code> -</li>
  <li><code>[Remove(PeterO.Cbor.CBORObject)](#Remove_PeterO_Cbor_CBORObject)</code> -</li>
  <li><code>[RemoveAt(int)](#RemoveAt_int)</code> -</li>
  <li><code>[Set(int, PeterO.Cbor.CBORObject)](#Set_int_PeterO_Cbor_CBORObject)</code> -</li>
  <li><code>[Set(object, object)](#Set_object_object)</code> - <b>Deprecated:</b> Use the CBORObject overload instead.</li>
  <li><code>[Set(PeterO.Cbor.CBORObject, PeterO.Cbor.CBORObject)](#Set_PeterO_Cbor_CBORObject_PeterO_Cbor_CBORObject)</code> -</li>
  <li><code>[SimpleValue](#SimpleValue)</code> - Gets the simple value ID of this CBOR object, or -1 if the object is not a simple value.</li>
  <li><code>[TagCount](#TagCount)</code> - Gets the number of tags this object has.</li>
  <li><code>[this[int]](#this_int)</code> - Gets the value of a CBOR object by integer index in this array or by integer key in this map.</li>
  <li><code>[this[PeterO.Cbor.CBORObject]](#this_PeterO_Cbor_CBORObject)</code> - Gets the value of a CBOR object by integer index in this array or by CBOR object key in this map.</li>
  <li><code>[this[string]](#this_string)</code> - Gets the value of a CBOR object in this map, using a string as the key.</li>
  <li><code>[ToJSONBytes()](#ToJSONBytes)</code> - Converts this object to a byte array in JavaScript Object Notation (JSON) format.</li>
  <li><code>[ToJSONBytes(PeterO.Cbor.JSONOptions)](#ToJSONBytes_PeterO_Cbor_JSONOptions)</code> -</li>
  <li><code>[ToJSONString()](#ToJSONString)</code> - Converts this object to a text string in JavaScript Object Notation (JSON) format.</li>
  <li><code>[ToJSONString(PeterO.Cbor.JSONOptions)](#ToJSONString_PeterO_Cbor_JSONOptions)</code> -</li>
  <li><code>[ToObject(System.Type)](#ToObject_System_Type)</code> -</li>
  <li><code>[ToObject(System.Type, PeterO.Cbor.CBORTypeMapper)](#ToObject_System_Type_PeterO_Cbor_CBORTypeMapper)</code> -</li>
  <li><code>[ToObject(System.Type, PeterO.Cbor.CBORTypeMapper, PeterO.Cbor.PODOptions)](#ToObject_System_Type_PeterO_Cbor_CBORTypeMapper_PeterO_Cbor_PODOptions)</code> -</li>
  <li><code>[ToObject(System.Type, PeterO.Cbor.PODOptions)](#ToObject_System_Type_PeterO_Cbor_PODOptions)</code> -</li>
  <li><code>[ToObject&lt;T&gt;()](#ToObject_T)</code> - Converts this CBOR object to an object of an arbitrary type.</li>
  <li><code>[ToObject&lt;T&gt;(PeterO.Cbor.CBORTypeMapper)](#ToObject_T_PeterO_Cbor_CBORTypeMapper)</code> -</li>
  <li><code>[ToObject&lt;T&gt;(PeterO.Cbor.CBORTypeMapper, PeterO.Cbor.PODOptions)](#ToObject_T_PeterO_Cbor_CBORTypeMapper_PeterO_Cbor_PODOptions)</code> -</li>
  <li><code>[ToObject&lt;T&gt;(PeterO.Cbor.PODOptions)](#ToObject_T_PeterO_Cbor_PODOptions)</code> -</li>
  <li><code>[ToString()](#ToString)</code> - Returns this CBOR object in a text form intended to be read by humans.</li>
  <li><code>[public static readonly PeterO.Cbor.CBORObject True;](#True)</code> - Represents the value true.</li>
  <li><code>[Type](#Type)</code> - Gets the general data type of this CBOR object.</li>
  <li><code>[public static readonly PeterO.Cbor.CBORObject Undefined;](#Undefined)</code> - Represents the value undefined.</li>
  <li><code>[Untag()](#Untag)</code> - Gets an object with the same value as this one but without the tags it has, if any.</li>
  <li><code>[UntagOne()](#UntagOne)</code> - Gets an object with the same value as this one but without this object’s outermost tag, if any.</li>
  <li><code>[Values](#Values)</code> - Gets a collection of the values of this CBOR object, if it’s a map or an array.</li>
  <li><code>[WithTag(int)](#WithTag_int)</code> -</li>
  <li><code>[WithTag(PeterO.Numbers.EInteger)](#WithTag_PeterO_Numbers_EInteger)</code> -</li>
  <li><code>[WithTag(ulong)](#WithTag_ulong)</code> -</li>
  <li><code>[Write(bool, System.IO.Stream)](#Write_bool_System_IO_Stream)</code> -</li>
  <li><code>[Write(byte, System.IO.Stream)](#Write_byte_System_IO_Stream)</code> -</li>
  <li><code>[Write(double, System.IO.Stream)](#Write_double_System_IO_Stream)</code> -</li>
  <li><code>[Write(float, System.IO.Stream)](#Write_float_System_IO_Stream)</code> -</li>
  <li><code>[Write(int, System.IO.Stream)](#Write_int_System_IO_Stream)</code> -</li>
  <li><code>[Write(long, System.IO.Stream)](#Write_long_System_IO_Stream)</code> -</li>
  <li><code>[Write(object, System.IO.Stream)](#Write_object_System_IO_Stream)</code> -</li>
  <li><code>[Write(object, System.IO.Stream, PeterO.Cbor.CBOREncodeOptions)](#Write_object_System_IO_Stream_PeterO_Cbor_CBOREncodeOptions)</code> -</li>
  <li><code>[Write(PeterO.Cbor.CBORObject, System.IO.Stream)](#Write_PeterO_Cbor_CBORObject_System_IO_Stream)</code> -</li>
  <li><code>[Write(PeterO.Numbers.EDecimal, System.IO.Stream)](#Write_PeterO_Numbers_EDecimal_System_IO_Stream)</code> -</li>
  <li><code>[Write(PeterO.Numbers.EFloat, System.IO.Stream)](#Write_PeterO_Numbers_EFloat_System_IO_Stream)</code> -</li>
  <li><code>[Write(PeterO.Numbers.EInteger, System.IO.Stream)](#Write_PeterO_Numbers_EInteger_System_IO_Stream)</code> -</li>
  <li><code>[Write(PeterO.Numbers.ERational, System.IO.Stream)](#Write_PeterO_Numbers_ERational_System_IO_Stream)</code> -</li>
  <li><code>[Write(sbyte, System.IO.Stream)](#Write_sbyte_System_IO_Stream)</code> -</li>
  <li><code>[Write(short, System.IO.Stream)](#Write_short_System_IO_Stream)</code> -</li>
  <li><code>[Write(string, System.IO.Stream)](#Write_string_System_IO_Stream)</code> -</li>
  <li><code>[Write(string, System.IO.Stream, PeterO.Cbor.CBOREncodeOptions)](#Write_string_System_IO_Stream_PeterO_Cbor_CBOREncodeOptions)</code> -</li>
  <li><code>[Write(uint, System.IO.Stream)](#Write_uint_System_IO_Stream)</code> -</li>
  <li><code>[Write(ulong, System.IO.Stream)](#Write_ulong_System_IO_Stream)</code> -</li>
  <li><code>[Write(ushort, System.IO.Stream)](#Write_ushort_System_IO_Stream)</code> -</li>
  <li><code>[WriteFloatingPointBits(System.IO.Stream, long, int)](#WriteFloatingPointBits_System_IO_Stream_long_int)</code> -</li>
  <li><code>[WriteFloatingPointBits(System.IO.Stream, long, int, bool)](#WriteFloatingPointBits_System_IO_Stream_long_int_bool)</code> -</li>
  <li><code>[WriteFloatingPointValue(System.IO.Stream, double, int)](#WriteFloatingPointValue_System_IO_Stream_double_int)</code> -</li>
  <li><code>[WriteFloatingPointValue(System.IO.Stream, float, int)](#WriteFloatingPointValue_System_IO_Stream_float_int)</code> -</li>
  <li><code>[WriteJSON(object, System.IO.Stream)](#WriteJSON_object_System_IO_Stream)</code> -</li>
  <li><code>[WriteJSONTo(System.IO.Stream)](#WriteJSONTo_System_IO_Stream)</code> -</li>
  <li><code>[WriteJSONTo(System.IO.Stream, PeterO.Cbor.JSONOptions)](#WriteJSONTo_System_IO_Stream_PeterO_Cbor_JSONOptions)</code> -</li>
  <li><code>[WriteTo(System.IO.Stream)](#WriteTo_System_IO_Stream)</code> -</li>
  <li><code>[WriteTo(System.IO.Stream, PeterO.Cbor.CBOREncodeOptions)](#WriteTo_System_IO_Stream_PeterO_Cbor_CBOREncodeOptions)</code> -</li>
  <li><code>[WriteValue(System.IO.Stream, int, int)](#WriteValue_System_IO_Stream_int_int)</code> -</li>
  <li><code>[WriteValue(System.IO.Stream, int, long)](#WriteValue_System_IO_Stream_int_long)</code> -</li>
  <li><code>[WriteValue(System.IO.Stream, int, PeterO.Numbers.EInteger)](#WriteValue_System_IO_Stream_int_PeterO_Numbers_EInteger)</code> -</li>
  <li><code>[WriteValue(System.IO.Stream, int, uint)](#WriteValue_System_IO_Stream_int_uint)</code> -</li>
  <li><code>[WriteValue(System.IO.Stream, int, ulong)](#WriteValue_System_IO_Stream_int_ulong)</code> -</li>
  <li><code>[public static readonly PeterO.Cbor.CBORObject Zero;](#Zero)</code> - Gets a CBOR object for the number zero.</li>
</ul>

<p><a id="False"></a>
### False</p>

<pre>public static readonly PeterO.Cbor.CBORObject False;
</pre>

<p>Represents the value false.</p>

<p><a id="NaN"></a>
### NaN</p>

<pre>public static readonly PeterO.Cbor.CBORObject NaN;
</pre>

<p>A not-a-number value.</p>

<p><a id="NegativeInfinity"></a>
### NegativeInfinity</p>

<pre>public static readonly PeterO.Cbor.CBORObject NegativeInfinity;
</pre>

<p>The value negative infinity.</p>

<p><a id="Null"></a>
### Null</p>

<pre>public static readonly PeterO.Cbor.CBORObject Null;
</pre>

<p>Represents the value null.</p>

<p><a id="PositiveInfinity"></a>
### PositiveInfinity</p>

<pre>public static readonly PeterO.Cbor.CBORObject PositiveInfinity;
</pre>

<p>The value positive infinity.</p>

<p><a id="True"></a>
### True</p>

<pre>public static readonly PeterO.Cbor.CBORObject True;
</pre>

<p>Represents the value true.</p>

<p><a id="Undefined"></a>
### Undefined</p>

<pre>public static readonly PeterO.Cbor.CBORObject Undefined;
</pre>

<p>Represents the value undefined.</p>

<p><a id="Zero"></a>
### Zero</p>

<pre>public static readonly PeterO.Cbor.CBORObject Zero;
</pre>

<p>Gets a CBOR object for the number zero.</p>

<p><a id="Count"></a>
### Count</p>

<pre>public int Count { get; }
</pre>

<p>Gets the number of keys in this map, or the number of items in this array, or 0 if this item is neither an array nor a map.</p>

<p><b>Returns:</b></p>

<p>The number of keys in this map, or the number of items in this array, or 0 if this item is neither an array nor a map.</p>

<p><a id="Entries"></a>
### Entries</p>

<pre>public System.Collections.Generic.ICollection Entries { get; }
</pre>

<p>Gets a collection of the key/value pairs stored in this CBOR object, if it’s a map. Returns one entry for each key/value pair in the map. In general, the order in which those entries occur is undefined unless this is a map created using the NewOrderedMap method.</p>

<p><b>Returns:</b></p>

<p>A collection of the key/value pairs stored in this CBOR map, as a read-only view of those pairs. To avoid potential problems, the calling code should not modify the CBOR map while iterating over the returned collection.</p>

<p><b>Exceptions:</b></p>

<ul>
  <li>System.InvalidOperationException:
This object is not a map.</li>
</ul>

<p><a id="IsFalse"></a>
### IsFalse</p>

<pre>public bool IsFalse { get; }
</pre>

<p>Gets a value indicating whether this value is a CBOR false value, whether tagged or not.</p>

<p><b>Returns:</b></p>

<p><code>true</code>  if this value is a CBOR false value; otherwise,  <code>false</code> .</p>

<p><a id="IsNull"></a>
### IsNull</p>

<pre>public bool IsNull { get; }
</pre>

<p>Gets a value indicating whether this CBOR object is a CBOR null value, whether tagged or not.</p>

<p><b>Returns:</b></p>

<p><code>true</code>  if this value is a CBOR null value; otherwise,  <code>false</code> .</p>

<p><a id="IsNumber"></a>
### IsNumber</p>

<pre>public bool IsNumber { get; }
</pre>

<p>Gets a value indicating whether this CBOR object stores a number (including infinity or a not-a-number or NaN value). Currently, this is true if this item is untagged and has a CBORType of Integer or FloatingPoint, or if this item has only one tag and that tag is 2, 3, 4, 5, 30, 264, 265, 268, 269, or 270 with the right data type.</p>

<p><b>Returns:</b></p>

<p>A value indicating whether this CBOR object stores a number.</p>

<p><a id="IsTagged"></a>
### IsTagged</p>

<pre>public bool IsTagged { get; }
</pre>

<p>Gets a value indicating whether this data item has at least one tag.</p>

<p><b>Returns:</b></p>

<p><code>true</code>  if this data item has at least one tag; otherwise,  <code>false</code> .</p>

<p><a id="IsTrue"></a>
### IsTrue</p>

<pre>public bool IsTrue { get; }
</pre>

<p>Gets a value indicating whether this value is a CBOR true value, whether tagged or not.</p>

<p><b>Returns:</b></p>

<p><code>true</code>  if this value is a CBOR true value; otherwise,  <code>false</code> .</p>

<p><a id="IsUndefined"></a>
### IsUndefined</p>

<pre>public bool IsUndefined { get; }
</pre>

<p>Gets a value indicating whether this value is a CBOR undefined value, whether tagged or not.</p>

<p><b>Returns:</b></p>

<p><code>true</code>  if this value is a CBOR undefined value; otherwise,  <code>false</code> .</p>

<p><a id="this_string"></a>
### Item</p>

<pre>public PeterO.Cbor.CBORObject this[string key] { get; set; }
</pre>

<p>Gets the value of a CBOR object in this map, using a string as the key.</p>

<p><b>Parameters:</b></p>

<ul>
  <li><i>key</i>: A key that points to the desired value.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The CBOR object referred to by key in this map. Returns  <code>null</code>  if an item with the given key doesn’t exist.</p>

<p><b>Exceptions:</b></p>

<ul>
  <li>
    <p>System.ArgumentNullException:
The key is null.</p>
  </li>
  <li>
    <p>System.InvalidOperationException:
This object is not a map.</p>
  </li>
</ul>

<p><a id="Keys"></a>
### Keys</p>

<pre>public System.Collections.Generic.ICollection Keys { get; }
</pre>

<p>Gets a collection of the keys of this CBOR object. In general, the order in which those keys occur is undefined unless this is a map created using the NewOrderedMap method.</p>

<p><b>Returns:</b></p>

<p>A read-only collection of the keys of this CBOR object. To avoid potential problems, the calling code should not modify the CBOR map while iterating over the returned collection.</p>

<p><b>Exceptions:</b></p>

<ul>
  <li>System.InvalidOperationException:
This object is not a map.</li>
</ul>

<p><a id="MostInnerTag"></a>
### MostInnerTag</p>

<pre>public PeterO.Numbers.EInteger MostInnerTag { get; }
</pre>

<p>Gets the last defined tag for this CBOR data item, or -1 if the item is untagged.</p>

<p><b>Returns:</b></p>

<p>The last defined tag for this CBOR data item, or -1 if the item is untagged.</p>

<p><a id="MostOuterTag"></a>
### MostOuterTag</p>

<pre>public PeterO.Numbers.EInteger MostOuterTag { get; }
</pre>

<p>Gets the outermost tag for this CBOR data item, or -1 if the item is untagged.</p>

<p><b>Returns:</b></p>

<p>The outermost tag for this CBOR data item, or -1 if the item is untagged.</p>

<p><a id="SimpleValue"></a>
### SimpleValue</p>

<pre>public int SimpleValue { get; }
</pre>

<p>Gets the simple value ID of this CBOR object, or -1 if the object is not a simple value. In this method, objects with a CBOR type of Boolean or SimpleValue are simple values, whether they are tagged or not.</p>

<p><b>Returns:</b></p>

<p>The simple value ID of this object if it’s a simple value, or -1 if this object is not a simple value.</p>

<p><a id="TagCount"></a>
### TagCount</p>

<pre>public int TagCount { get; }
</pre>

<p>Gets the number of tags this object has.</p>

<p><b>Returns:</b></p>

<p>The number of tags this object has.</p>

<p><a id="Type"></a>
### Type</p>

<pre>public PeterO.Cbor.CBORType Type { get; }
</pre>

<p>Gets the general data type of this CBOR object. This method disregards the tags this object has, if any.</p>

<p><b>Returns:</b></p>

<p>The general data type of this CBOR object.</p>

<p><a id="Values"></a>
### Values</p>

<pre>public System.Collections.Generic.ICollection Values { get; }
</pre>

<p>Gets a collection of the values of this CBOR object, if it’s a map or an array. If this object is a map, returns one value for each key in the map; in general, the order in which those keys occur is undefined unless this is a map created using the NewOrderedMap method. If this is an array, returns all the values of the array in the order they are listed. (This method can’t be used to get the bytes in a CBOR byte string; for that, use the GetByteString method instead.).</p>

<p><b>Returns:</b></p>

<p>A read-only collection of the values of this CBOR map or array. To avoid potential problems, the calling code should not modify the CBOR map or array while iterating over the returned collection.</p>

<p><b>Exceptions:</b></p>

<ul>
  <li>System.InvalidOperationException:
This object is not a map or an array.</li>
</ul>

<p><a id="AsBoolean"></a>
### AsBoolean</p>

<pre>public bool AsBoolean();
</pre>

<p>Returns false if this object is a CBOR false, null, or undefined value (whether or not the object has tags); otherwise, true.</p>

<p><b>Return Value:</b></p>

<p>False if this object is a CBOR false, null, or undefined value; otherwise, true.</p>

<p><a id="AsDouble"></a>
### AsDouble</p>

<pre>public double AsDouble();
</pre>

<p>Converts this object to a 64-bit floating point number.</p>

<p><b>Return Value:</b></p>

<p>The closest 64-bit floating point number to this object. The return value can be positive infinity or negative infinity if this value exceeds the range of a 64-bit floating point number.</p>

<p><b>Exceptions:</b></p>

<ul>
  <li>System.InvalidOperationException:
This object does not represent a number (for this purpose, infinities and not-a-number or NaN values, but not CBORObject.Null, are considered numbers).</li>
</ul>

<p><a id="AsDoubleBits"></a>
### AsDoubleBits</p>

<pre>public long AsDoubleBits();
</pre>

<p>Converts this object to the bits of a 64-bit floating-point number if this CBOR object’s type is FloatingPoint. This method disregards the tags this object has, if any.</p>

<p><b>Return Value:</b></p>

<p>The bits of a 64-bit floating-point number stored by this object. The most significant bit is the sign (set means negative, clear means nonnegative); the next most significant 11 bits are the exponent area; and the remaining bits are the significand area. If all the bits of the exponent area are set and the significand area is 0, this indicates infinity. If all the bits of the exponent area are set and the significand area is other than 0, this indicates not-a-number (NaN).</p>

<p><b>Exceptions:</b></p>

<ul>
  <li>System.InvalidOperationException:
This object’s type is not  <code>CBORType.FloatingPoint</code> .</li>
</ul>

<p><a id="AsDoubleValue"></a>
### AsDoubleValue</p>

<pre>public double AsDoubleValue();
</pre>

<p>Converts this object to a 64-bit floating-point number if this CBOR object’s type is FloatingPoint. This method disregards the tags this object has, if any.</p>

<p><b>Return Value:</b></p>

<p>The 64-bit floating-point number stored by this object.</p>

<p><b>Exceptions:</b></p>

<ul>
  <li>System.InvalidOperationException:
This object’s type is not  <code>CBORType.FloatingPoint</code> .</li>
</ul>

<p><a id="AsEIntegerValue"></a>
### AsEIntegerValue</p>

<pre>public PeterO.Numbers.EInteger AsEIntegerValue();
</pre>

<p>Converts this object to an arbitrary-precision integer if this CBOR object’s type is Integer. This method disregards the tags this object has, if any. (Note that CBOR stores untagged integers at least -(2^64) and less than 2^64.).</p>

<p><b>Return Value:</b></p>

<p>The integer stored by this object.</p>

<p><b>Exceptions:</b></p>

<ul>
  <li>System.InvalidOperationException:
This object’s type is not  <code>CBORType.Integer</code> .</li>
</ul>

<p><a id="AsGuid"></a>
### AsGuid</p>

<pre>public System.Guid AsGuid();
</pre>

<p>Converts this object to a Guid.</p>

<p><b>Return Value:</b></p>

<p>A Guid.</p>

<p><b>Exceptions:</b></p>

<ul>
  <li>
    <p>System.InvalidOperationException:
This object does not represent a Guid.</p>
  </li>
  <li>
    <p>PeterO.Cbor.CBORException:
This object does not have the expected tag.</p>
  </li>
</ul>

<p><a id="AsInt32"></a>
### AsInt32</p>

<pre>public int AsInt32();
</pre>

<p>Converts this object to a 32-bit signed integer. Noninteger number values are converted to integers by discarding their fractional parts. (NOTE: To determine whether this method call can succeed, call <b>AsNumber().CanTruncatedIntFitInInt32</b> before calling this method. See the example.).</p>

<p>The following example code (originally written in C# for the.NET Framework) shows a way to check whether a given CBOR object stores a 32-bit signed integer before getting its value.</p>

<pre>CBORObject obj = CBORObject.FromInt32(99999);
            if (obj.AsNumber().CanTruncatedIntFitInInt32()) {
            /* Not an Int32; handle the error */
            Console.WriteLine("Not a 32-bit integer."); } else {
            Console.WriteLine("The value is " + obj.AsInt32()); }
</pre>

<p>.</p>

<p><b>Return Value:</b></p>

<p>The closest 32-bit signed integer to this object.</p>

<p><b>Exceptions:</b></p>

<ul>
  <li>
    <p>System.InvalidOperationException:
This object does not represent a number (for this purpose, infinities and not-a-number or NaN values, but not CBORObject.Null, are considered numbers).</p>
  </li>
  <li>
    <p>System.OverflowException:
This object’s value exceeds the range of a 32-bit signed integer.</p>
  </li>
</ul>

<p><a id="AsInt32Value"></a>
### AsInt32Value</p>

<pre>public int AsInt32Value();
</pre>

<p>Converts this object to a 32-bit signed integer if this CBOR object’s type is Integer. This method disregards the tags this object has, if any.</p>

<p>The following example code (originally written in C# for the.NET Framework) shows a way to check whether a given CBOR object stores a 32-bit signed integer before getting its value.</p>

<pre>CBORObject obj = CBORObject.FromInt32(99999);
            if (obj.CanValueFitInInt32()) { /* Not an Int32;
            handle the error */ Console.WriteLine("Not a 32-bit integer."); } else {
            Console.WriteLine("The value is " + obj.AsInt32Value()); }
</pre>

<p>.</p>

<p><b>Return Value:</b></p>

<p>The 32-bit signed integer stored by this object.</p>

<p><b>Exceptions:</b></p>

<ul>
  <li>
    <p>System.InvalidOperationException:
This object’s type is not  <code>CBORType.Integer</code>  .</p>
  </li>
  <li>
    <p>System.OverflowException:
This object’s value exceeds the range of a 32-bit signed integer.</p>
  </li>
</ul>

<p><a id="AsInt64Value"></a>
### AsInt64Value</p>

<pre>public long AsInt64Value();
</pre>

<p>Converts this object to a 64-bit signed integer if this CBOR object’s type is Integer. This method disregards the tags this object has, if any.</p>

<p>The following example code (originally written in C# for the.NET Framework) shows a way to check whether a given CBOR object stores a 64-bit signed integer before getting its value.</p>

<pre>CBORObject obj = CBORObject.FromInt64(99999);
            if (obj.CanValueFitInInt64()) {
            /* Not an Int64; handle the error*/
            Console.WriteLine("Not a 64-bit integer."); } else {
            Console.WriteLine("The value is " + obj.AsInt64Value()); }
</pre>

<p>.</p>

<p><b>Return Value:</b></p>

<p>The 64-bit signed integer stored by this object.</p>

<p><b>Exceptions:</b></p>

<ul>
  <li>
    <p>System.InvalidOperationException:
This object’s type is not  <code>CBORType.Integer</code>  .</p>
  </li>
  <li>
    <p>System.OverflowException:
This object’s value exceeds the range of a 64-bit signed integer.</p>
  </li>
</ul>

<p><a id="AsNumber"></a>
### AsNumber</p>

<pre>public PeterO.Cbor.CBORNumber AsNumber();
</pre>

<p>Converts this object to a CBOR number. (NOTE: To determine whether this method call can succeed, call the <b>IsNumber</b> property (isNumber() method in Java) before calling this method.).</p>

<p><b>Return Value:</b></p>

<p>The number represented by this object.</p>

<p><b>Exceptions:</b></p>

<ul>
  <li>System.InvalidOperationException:
This object does not represent a number (for this purpose, infinities and not-a-number or NaN values, but not CBORObject.Null, are considered numbers).</li>
</ul>

<p><a id="AsSingle"></a>
### AsSingle</p>

<pre>public float AsSingle();
</pre>

<p>Converts this object to a 32-bit floating point number.</p>

<p><b>Return Value:</b></p>

<p>The closest 32-bit floating point number to this object. The return value can be positive infinity or negative infinity if this object’s value exceeds the range of a 32-bit floating point number.</p>

<p><b>Exceptions:</b></p>

<ul>
  <li>System.InvalidOperationException:
This object does not represent a number (for this purpose, infinities and not-a-number or NaN values, but not CBORObject.Null, are considered numbers).</li>
</ul>

<p><a id="AsString"></a>
### AsString</p>

<pre>public string AsString();
</pre>

<p>Gets the value of this object as a text string.</p>

<p>This method is not the “reverse” of the  <code>FromString</code>  method in the sense that FromString can take either a text string or  <code>null</code> , but this method can accept only text strings. The  <code>ToObject</code>  method is closer to a “reverse” version to  <code>FromString</code>  than the  <code>AsString</code>  method:  <code>ToObject&lt;String&gt;(cbor)</code>  in DotNet, or  <code>ToObject(String.class)</code>  in Java, will convert a CBOR object to a DotNet or Java String if it represents a text string, or to  <code>null</code>  if  <code>IsNull</code>  returns  <code>true</code>  for the CBOR object, and will fail in other cases.</p>

<p><b>Return Value:</b></p>

<p>Gets this object’s string.</p>

<p><b>Exceptions:</b></p>

<ul>
  <li>System.InvalidOperationException:
This object’s type is not a text string (for the purposes of this method, infinity and not-a-number values, but not  <code>CBORObject.Null</code> , are considered numbers). To check the CBOR object for null before conversion, use the following idiom (originally written in C# for the.NET version):  <code>(cbor == null || cbor.IsNull) ? null :
         cbor.AsString()</code> .</li>
</ul>

<p><a id="CalcEncodedSize"></a>
### CalcEncodedSize</p>

<pre>public long CalcEncodedSize();
</pre>

<p>Calculates the number of bytes this CBOR object takes when serialized as a byte array using the  <code>EncodeToBytes()</code>  method. This calculation assumes that integers, lengths of maps and arrays, lengths of text and byte strings, and tag numbers are encoded in their shortest form; that floating-point numbers are encoded in their shortest value-preserving form; and that no indefinite-length encodings are used.</p>

<p><b>Return Value:</b></p>

<p>The number of bytes this CBOR object takes when serialized as a byte array using the  <code>EncodeToBytes()</code>  method.</p>

<p><b>Exceptions:</b></p>

<ul>
  <li>PeterO.Cbor.CBORException:
The CBOR object has an extremely deep level of nesting, including if the CBOR object is or has an array or map that includes itself.</li>
</ul>

<p><a id="CanValueFitInInt32"></a>
### CanValueFitInInt32</p>

<pre>public bool CanValueFitInInt32();
</pre>

<p>Returns whether this CBOR object stores an integer (CBORType.Integer) within the range of a 32-bit signed integer. This method disregards the tags this object has, if any.</p>

<p><b>Return Value:</b></p>

<p><code>true</code>  if this CBOR object stores an integer (CBORType.Integer) whose value is at least -(2^31) and less than 2^31; otherwise,  <code>false</code> .</p>

<p><a id="CanValueFitInInt64"></a>
### CanValueFitInInt64</p>

<pre>public bool CanValueFitInInt64();
</pre>

<p>Returns whether this CBOR object stores an integer (CBORType.Integer) within the range of a 64-bit signed integer. This method disregards the tags this object has, if any.</p>

<p><b>Return Value:</b></p>

<p><code>true</code>  if this CBOR object stores an integer (CBORType.Integer) whose value is at least -(2^63) and less than 2^63; otherwise,  <code>false</code> .</p>

<p><a id="Clear"></a>
### Clear</p>

<pre>public void Clear();
</pre>

<p>Removes all items from this CBOR array or all keys and values from this CBOR map.</p>

<p><b>Exceptions:</b></p>

<ul>
  <li>System.InvalidOperationException:
This object is not a CBOR array or CBOR map.</li>
</ul>

<p><a id="EncodeToBytes"></a>
### EncodeToBytes</p>

<pre>public byte[] EncodeToBytes();
</pre>

<p>Writes the binary representation of this CBOR object and returns a byte array of that representation. If the CBOR object contains CBOR maps, or is a CBOR map itself, the order in which the keys to the map are written out to the byte array is undefined unless the map was created using the NewOrderedMap method. The example code given in <strong>M:PeterO.Cbor.CBORObject.WriteTo(System.IO.Stream)</strong> can be used to write out certain keys of a CBOR map in a given order. For the CTAP2 (FIDO Client-to-Authenticator Protocol 2) canonical ordering, which is useful for implementing Web Authentication, call  <code>EncodeToBytes(new CBOREncodeOptions("ctap2canonical=true"))</code>  rather than this method.</p>

<p><b>Return Value:</b></p>

<p>A byte array in CBOR format.</p>

<p><a id="GetAllTags"></a>
### GetAllTags</p>

<pre>public PeterO.Numbers.EInteger[] GetAllTags();
</pre>

<p>Gets a list of all tags, from outermost to innermost.</p>

<p><b>Return Value:</b></p>

<p>An array of tags, or the empty string if this object is untagged.</p>

<p><a id="GetByteString"></a>
### GetByteString</p>

<pre>public byte[] GetByteString();
</pre>

<p>Gets the backing byte array used in this CBOR object, if this object is a byte string, without copying the data to a new byte array. Any changes in the returned array’s contents will be reflected in this CBOR object. Note, though, that the array’s length can’t be changed.</p>

<p><b>Return Value:</b></p>

<p>The byte array held by this CBOR object.</p>

<p><b>Exceptions:</b></p>

<ul>
  <li>System.InvalidOperationException:
This object is not a byte string.</li>
</ul>

<p><a id="GetHashCode"></a>
### GetHashCode</p>

<pre>public override int GetHashCode();
</pre>

<p>Calculates the hash code of this object. The hash code for a given instance of this class is not guaranteed to be the same across versions of this class, and no application or process IDs are used in the hash code calculation.</p>

<p><b>Return Value:</b></p>

<p>A 32-bit hash code.</p>

<p><a id="HasOneTag"></a>
### HasOneTag</p>

<pre>public bool HasOneTag();
</pre>

<p>Returns whether this object has only one tag.</p>

<p><b>Return Value:</b></p>

<p><code>true</code>  if this object has only one tag; otherwise,  <code>false</code> .</p>

<p><a id="NewArray"></a>
### NewArray</p>

<pre>public static PeterO.Cbor.CBORObject NewArray();
</pre>

<p>Creates a new empty CBOR array.</p>

<p><b>Return Value:</b></p>

<p>A new CBOR array.</p>

<p><a id="NewMap"></a>
### NewMap</p>

<pre>public static PeterO.Cbor.CBORObject NewMap();
</pre>

<p>Creates a new empty CBOR map that stores its keys in an undefined order.</p>

<p><b>Return Value:</b></p>

<p>A new CBOR map.</p>

<p><a id="NewOrderedMap"></a>
### NewOrderedMap</p>

<pre>public static PeterO.Cbor.CBORObject NewOrderedMap();
</pre>

<p>Creates a new empty CBOR map that ensures that keys are stored in the order in which they are first inserted.</p>

<p><b>Return Value:</b></p>

<p>A new CBOR map.</p>

<p><a id="ToJSONBytes"></a>
### ToJSONBytes</p>

<pre>public byte[] ToJSONBytes();
</pre>

<p>Converts this object to a byte array in JavaScript Object Notation (JSON) format. The JSON text will be written out in UTF-8 encoding, without a byte order mark, to the byte array. See the overload to ToJSONString taking a JSONOptions argument for further information.</p>

<p><b>Return Value:</b></p>

<p>A byte array containing the converted in JSON format.</p>

<p><a id="ToJSONString"></a>
### ToJSONString</p>

<pre>public string ToJSONString();
</pre>

<p>Converts this object to a text string in JavaScript Object Notation (JSON) format. See the overload to ToJSONString taking a JSONOptions argument for further information. If the CBOR object contains CBOR maps, or is a CBOR map itself, the order in which the keys to the map are written out to the JSON string is undefined unless the map was created using the NewOrderedMap method. Map keys other than untagged text strings are converted to JSON strings before writing them out (for example,  <code>22("Test")</code>  is converted to  <code>"Test"</code>  and  <code>true</code>  is converted to  <code>"true"</code>  ). After such conversion, if two or more keys for the same map are identical, this method throws a CBORException. The example code given in <b>PeterO.Cbor.CBORObject.ToJSONString(PeterO.Cbor.JSONOptions)</b> can be used to write out certain keys of a CBOR map in a given order to a JSON string, or to write out a CBOR object as part of a JSON text sequence.</p>

<p><b>Warning:</b> In general, if this CBOR object contains integer map keys or uses other features not supported in JSON, and the application converts this CBOR object to JSON and back to CBOR, the application <i>should not</i> expect the new CBOR object to be exactly the same as the original. This is because the conversion in many cases may have to convert unsupported features in JSON to supported features which correspond to a different feature in CBOR (such as converting integer map keys, which are supported in CBOR but not JSON, to text strings, which are supported in both).</p>

<p><b>Return Value:</b></p>

<p>A text string containing the converted object in JSON format.</p>

<p><a id="ToObject_T"></a>
### ToObject</p>

<pre>public T ToObject&lt;T&gt;();
</pre>

<p>Converts this CBOR object to an object of an arbitrary type. See <strong>M:PeterO.Cbor.CBORObject.ToObject(System.Type)</strong> for further information.</p>

<p><b>Parameters:</b></p>

<ul>
  <li>&lt;T&gt;: The type, class, or interface that this method’s return value will belong to. <b>Note:</b> For security reasons, an application should not base this parameter on user input or other externally supplied data. Whenever possible, this parameter should be either a type specially handled by this method (such as  <code>int</code>  or  <code>String</code>  ) or a plain-old-data type (POCO or POJO type) within the control of the application. If the plain-old-data type references other data types, those types should likewise meet either criterion given earlier.</li>
</ul>

<p><b>Return Value:</b></p>

<p>The converted object.</p>

<p><b>Exceptions:</b></p>

<ul>
  <li>System.NotSupportedException:
The given type “T”, or this object’s CBOR type, is not supported.</li>
</ul>

<p><a id="ToString"></a>
### ToString</p>

<pre>public override string ToString();
</pre>

<p>Returns this CBOR object in a text form intended to be read by humans. The value returned by this method is not intended to be parsed by computer programs, and the exact text of the value may change at any time between versions of this library. The returned string is not necessarily in JavaScript Object Notation (JSON); to convert CBOR objects to JSON strings, use the <b>PeterO.Cbor.CBORObject.ToJSONString(PeterO.Cbor.JSONOptions)</b> method instead.</p>

<p><b>Return Value:</b></p>

<p>A text representation of this object.</p>

<p><a id="Untag"></a>
### Untag</p>

<pre>public PeterO.Cbor.CBORObject Untag();
</pre>

<p>Gets an object with the same value as this one but without the tags it has, if any. If this object is an array, map, or byte string, the data will not be copied to the returned object, so changes to the returned object will be reflected in this one.</p>

<p><b>Return Value:</b></p>

<p>A CBOR object.</p>

<p><a id="UntagOne"></a>
### UntagOne</p>

<pre>public PeterO.Cbor.CBORObject UntagOne();
</pre>

<p>Gets an object with the same value as this one but without this object’s outermost tag, if any. If this object is an array, map, or byte string, the data will not be copied to the returned object, so changes to the returned object will be reflected in this one.</p>

<p><b>Return Value:</b></p>

<p>A CBOR object.</p>

<p><a href="/CBOR/">Back to CBOR start page.</a></p>
</div><nav id="navigation"><ul>
<li><a href="/">Back to start site.</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io">This site's repository (source code)</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io/issues">Post an issue or comment</a></ul>

<div class="noprint">
<p>
<a href="//twitter.com/intent/tweet">Share via Twitter</a>, <a href="//www.facebook.com/sharer/sharer.php" id="sharer">Share via Facebook</a>
</p>
</div>
</nav></body></html>
