<!DOCTYPE html>
<html lang="en">
<head><meta charset="utf-8"><title>JSDoc: Source: extras/text.js</title>
<meta name="viewport" content="width=device-width">
<script src="mathml.js"></script>
<link rel=stylesheet type="text/css" href="/style.css">
</head>
<body style="margin-top:0px">
<div class="header">
<p><a href="#navigation">Menu</a> - <a href="/">Home</a> -
<a href="http://peteroupc.github.io/">Donate to Me</a></p></div>
<div class="mainarea" id="top">
    <h1>Source: extras/text.js</h1>

    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*
Written by Peter O. in 2016.

Any copyright is dedicated to the Public Domain.
http://creativecommons.org/publicdomain/zero/1.0/
If you like this, you should donate to Peter O.
at: http://peteroupc.github.io/
*/
/* global H3DU, H3DU.Mesh, Promise */
if((typeof H3DU === "undefined" || (H3DU === null || typeof H3DU === "undefined"))){ H3DU={}; }
/**
* Represents a bitmap font.  This class supports
* traditional bitmap fonts and signed distance field fonts.&lt;p>
* Bitmap fonts consist of a font definition file and one
* or more textures containing the shape of each font glyph.  The glyphs
* are packed so that the glyphs don't
* overlap each other.&lt;p>
* In a signed distance field font, each pixel's alpha value depends on the
* distance from that location to the edge of the glyph.  A pixel alpha less
* than 0.5 (127 in most image formats) means the pixel is outside the
* glyph, greater than 0.5 means the pixel is inside the glyph, and 0 (for
* outside the glyph) and 1 (for inside the glyph) means the pixel is
* outside a buffer zone formed by the glyph's outline.  Each glyph is usually
* given extra space to accommodate the signed distance field information.&lt;p>
* The font definition file formats supported are text (".fnt"),
* JSON (".json"), binary (".fnt" or ".bin"), and XML (".xml").
* The text and binary file formats are specified at
* &lt;a href="http://www.angelcode.com/products/bmfont/doc/file_format.html">this
* page&lt;/a>.  The XML format is very similar to the text file format.
* The JSON format is described at
* &lt;a href="https://github.com/Jam3/load-bmfont/blob/master/json-spec.md">this
* page&lt;/a>.
* &lt;p>
* See &lt;a href="https://github.com/mattdesl/text-modules#bitmap-text">this page&lt;/a>
* for a list of bitmap font generation tools. (No one tool is recommended over any
* other, and the mention of this link is not an endorsement or sponsorship
* of any particular tool.)&lt;p>
* NOTE: The constructor should not be called directly by applications.
* Use the {@link H3DU.TextFont.load} method to get an H3DU.TextFont object.  This
* constructor's parameters are undocumented and are subject to change.
* &lt;p>This class is considered a supplementary class to the
* Public Domain HTML 3D Library and is not considered part of that
* library. &lt;p>
* To use this class, you must include the script "extras/text.js"; the
 * class is not included in the "h3du_min.js" file which makes up
 * the HTML 3D Library.  Example:&lt;pre>
 * &amp;lt;script type="text/javascript" src="extras/text.js">&amp;lt;/script>&lt;/pre>
* @class
* @alias H3DU.TextFont
*/
H3DU.TextFont=function(fontinfo,chars,pages,kernings,common,fileUrl){
 this.info=fontinfo
 this.common=common
 if(this.info){
  this.info.padding=H3DU.TextFont._toArray(this.info.padding,4)
  this.info.spacing=H3DU.TextFont._toArray(this.info.spacing,2)
 }
 this.textShader=H3DU.TextFont._textShader();
 this.fileUrl=fileUrl;
 this.chars=chars
 this.pages=pages
 this.kern=[];
 for(var i=0;i&lt;kernings.length;i++){
  var k=kernings[i]
  if(!this.kern[k.first])this.kern[k.first]=[]
  this.kern[k.first][k.second]=k
 }
}
/** @private */
H3DU.TextFont._toArray=function(str,minLength){
 var spl;
 if(typeof str==="string"){
  spl=str.split(",")
  for(var i=0;i&lt;spl.length;i++){
   spl[i]=parseInt(spl[i],10)
  }
 } else if(str!=null &amp;&amp;
   str.constructor==Array &amp;&amp; str.length>=minLength){
  return str;
 } else {
  spl=[]
 }
 for(var i=spl.length;i&lt;minLength;i++){
  spl.push(0)
 }
 return spl
}

/**
 * Calculates the width and height of a text string when
 * drawn using this font.
* @param {String} string The text string to measure.  Line breaks
* ("\n", "\r", "\r\n") are recognized by this method.
* @param {Object} params An object described in {@link H3DU.TextFont.makeTextMeshes}.
 * @returns {Array&lt;Number>} An array of two numbers;
 * the first is the width of the string, and the second is the
 * height of the string (taking into account line feed characters,
 * U+000A, that break lines).
 * @memberof! H3DU.TextFont#
*/
H3DU.TextFont.prototype.measure=function(str,params){
 var height=((typeof params.lineHeight !== "undefined" &amp;&amp; params.lineHeight !== null)) ? params.lineHeight :
   this.common.lineHeight;
 if(height&lt;0)throw new Error();
 var width=((typeof params.width !== "undefined" &amp;&amp; params.width !== null)) ? params.width : -1;
 var scale=height/this.common.lineHeight;
 var linebreaks=this._findLineBreaks(str,scale,width);
 var size=0;
 var yPos=0;
 for(var i=0;i&lt;linebreaks.length;i+=3){
  size=Math.max(size,linebreaks[i+2]);
  yPos+=height;
 }
 return [size,yPos];
}
/** @private */
H3DU.TextFont.prototype._measureWord=function(
  str,startIndex,endIndex,lastChar,scale,info){
 var xPos=0;
 var xSize=0;
 for(var i=startIndex;i&lt;endIndex;i++){
  var c=str.charCodeAt(i);
  if(c>=0xd800 &amp;&amp; c&lt;0xdc00 &amp;&amp; i+1&lt;endIndex){
   c = 0x10000 + ((c - 0xd800) &lt;&lt; 10) + (str.charCodeAt(i+1) -
          0xdc00);
   i++;
  } else if(c>=0xd800 &amp;&amp; c&lt;0xe000){
   c=0xfffd
  }
  if(c === 0x0d || c === 0x0a){
   // don't measure line break characters; mandatory line
   // breaks should have been classified as such already
   lastChar=c;
   continue;
  }
  var ch=this.chars[c]||this.chars[0]||null
  if(ch){
   xSize=Math.max(xSize,xPos+ch.width*scale);
   if(lastChar!=-1){
    if(this.kern[lastChar] &amp;&amp; this.kern[lastChar][c]){
     xPos+=this.kern[lastChar][c].amount*scale;
    }
   }
   xPos+=ch.xadvance*scale;
  }
  lastChar=c;
 }
 info[0]=xPos; // x-advance of the word
 info[1]=xSize; // width of the word
 info[2]=lastChar; // last character of the word
}
/** @private */
H3DU.TextFont.prototype._findLineBreaks=function(str,scale,maxWidth){
 if(str.length === 0){
  return [];
 }
 var breaks=[];
 var classes=[];
 var linePositions=[];
 var currentClass=-1;
 // Find the runs of non-whitespace/whitespace in the text
 for(var i=0;i&lt;str.length;i++){
  var c=str.charCodeAt(i);
  if(c>=0xd800 &amp;&amp; c&lt;0xdc00 &amp;&amp; i+1&lt;str.length){
   c = 0x10000 + ((c - 0xd800) &lt;&lt; 10) + (str.charCodeAt(i+1) -
          0xdc00);
   i++;
  } else if(c>=0xd800 &amp;&amp; c&lt;0xe000){
   c=0xfffd
  }
  if(c === 0x0d || c === 0x0a){
   classes.push(2); // line break
   breaks.push(i);
   if(c === 0x0d &amp;&amp; i+1&lt;str.length &amp;&amp; str.charCodeAt(i+1) === 0x0a){
    i++;
   }
   currentClass=-1;
   continue;
  } else if(c === 0x0c || c === 0x09 || c === 0x20){
   // non-linebreak whitespace
   if(currentClass!=1){
    classes.push(1); // whitespace
    breaks.push(i);
   }
   currentClass=1;
   xPos=0;
  } else {
   // non-whitespace
   if(currentClass!=0){
    classes.push(0); // non-whitespace
    breaks.push(i);
   }
   currentClass=0;
  }
 }
 breaks.push(str.length);
 var wordInfo=[]
 var lastChar=-1;
 var xPos=0;
 var xSize=0;
 var lineStart=0;
 var possibleLineEnd=0;
 for(var i=0;i&lt;classes.length;i++){
   if(classes[i] === 2){
    // mandatory line break
    linePositions.push(lineStart,breaks[i],xSize);
    xPos=0;
    xSize=0;
    lineStart=breaks[i+1];
    possibleLineEnd=lineStart
   } else {
    this._measureWord(str,breaks[i],
     breaks[i+1],lastChar,scale,wordInfo);
    var size=xPos+wordInfo[1];
    lastChar=wordInfo[2];
    if(maxWidth>=0 &amp;&amp; size>maxWidth){
     linePositions.push(lineStart,possibleLineEnd,xSize);
     if(classes[i] === 1){
      // Spaces that overshoot the max width;
      // don't include the spaces
      xPos=0;
      xSize=0;
      lineStart=breaks[i+1];
      possibleLineEnd=lineStart
     } else {
      xPos=wordInfo[0];
      xSize=Math.max(0,wordInfo[1]);
      lineStart=breaks[i];
      possibleLineEnd=breaks[i+1]
     }
    } else {
     if(classes[i] === 0){
      possibleLineEnd=breaks[i+1]
      xSize=Math.max(0,xPos+wordInfo[1]);
     }
     xPos+=wordInfo[0];
    }
   }
 }
 if(lineStart!=str.length){
  linePositions.push(lineStart,possibleLineEnd,xSize);
 }
 return linePositions
}

/**
* Creates a shape containing the primitives needed to
* draw text in the given position, size, and color.
* For the text to show upright, the coordinate system should have the
* X-axis pointing right and the Y-axis pointing down (for example, an
* orthographic projection where the left and top coordinates are less
* than the right and bottom coordinates, respectively).
* @param {H3DU.TextFont} font The bitmap font to use when drawing the text.
* @param {String} string The text to draw.  Line breaks ("\n", "\r", "\r\n") are recognized
* by this method.
* @param {Object} params An object described in {@link H3DU.TextFont.makeTextMeshes}.
* Can also contain the following keys:&lt;ul>
* &lt;li>&lt;code>color&lt;/code> - A [color vector or string]{@link H3DU.toGLColor} giving
* the color to draw the text with.
* If this value is given, the bitmap font is assumed to be a signed distance field
* font.
* &lt;li>&lt;code>texture&lt;/code> - An array of textures ({@link H3DU.Texture}) to use with this font,
* or a single {@link H3DU.Texture} if only one texture page is used.
* If null or omitted, uses the default filenames for texture pages defined in this font.
* &lt;/ul>
* @memberof! H3DU.TextFont#
*/
H3DU.TextFont.prototype.textShape=function(str, params){
 var group=new H3DU.ShapeGroup();
 var color=((typeof params.color !== "undefined" &amp;&amp; params.color !== null)) ? params.color : null;
 var textures=((typeof params.textures !== "undefined" &amp;&amp; params.textures !== null)) ?
   params.textures : null;
 if(textures &amp;&amp; textures instanceof H3DU.Texture){
  textures=[textures]
 }
 var hasColor=(color!=null);
 color=(hasColor) ? color : [0,0,0,0];
 var meshesForPage=this.makeTextMeshes(str,params);
 for(var i=0;i&lt;meshesForPage.length;i++){
  var mfp=meshesForPage[i];
  if(!mfp)continue;
  var sh=new H3DU.Shape(mfp);
  var material=new H3DU.Material(color,color).setParams({
   "texture":textures ? textures[i] : this.pages[i],
   "basic":true,
   "shader": hasColor ? H3DU.TextFont._textShaderInfo : null
  });
  sh.setMaterial(material);
  group.addShape(sh);
 }
 return group;
}
/** @private */
H3DU.TextFont.prototype._makeTextMeshesInner=function(str,startPos,endPos,xPos,yPos,params,extra,meshesForPage){
 var height=((typeof params.lineHeight !== "undefined" &amp;&amp; params.lineHeight !== null)) ? params.lineHeight : this.common.lineHeight;
 var startXPos=xPos;
 var lastChar=-1;
 for(var i=startPos;i&lt;endPos;i++){
  var c=str.charCodeAt(i);
  if(c>=0xd800 &amp;&amp; c&lt;0xdc00 &amp;&amp; i+1&lt;endPos){
   c = 0x10000 + ((c - 0xd800) &lt;&lt; 10) + (str.charCodeAt(i+1) -
          0xdc00);
   i++;
  } else if(c>=0xd800 &amp;&amp; c&lt;0xe000){
   c=0xfffd
  }
  if(c === 0x0a || c === 0x0d){
   // NOTE: Should not occur at this point
   lastChar=c;
   continue;
  }
  var ch=this.chars[c]||this.chars[0]||null
  if(ch){
   var sx=ch.x*extra.recipPageWidth;
   var sy=ch.y*extra.recipPageHeight;
   var sx2=(ch.x+ch.width)*extra.recipPageWidth;
   var sy2=(ch.y+ch.height)*extra.recipPageHeight;
   var xo=ch.xoffset*extra.scale;
   var yo=ch.yoffset*extra.scale;
   var vx=xPos+xo;
   var vy=yPos+yo;
   var vx2=vx+ch.width*extra.scale;
   var vy2=vy+ch.height*extra.scale;
   if(ch.width>0 &amp;&amp; ch.height>0) {
    var chMesh=meshesForPage[ch.page];
    if(!chMesh){
     chMesh=new H3DU.Mesh();
     meshesForPage[ch.page]=chMesh;
    }
    chMesh.mode(H3DU.Mesh.TRIANGLE_STRIP)
     .texCoord2(sx,1-sy)
     .vertex2(vx,vy)
     .texCoord2(sx,1-sy2)
     .vertex2(vx,vy2)
     .texCoord2(sx2,1-sy)
     .vertex2(vx2,vy)
     .texCoord2(sx2,1-sy2)
     .vertex2(vx2,vy2);
   }
   if(lastChar!=-1){
    if(this.kern[lastChar] &amp;&amp; this.kern[lastChar][c]){
     xPos+=this.kern[lastChar][c].amount*extra.scale;
    }
   }
   xPos+=ch.xadvance*extra.scale;
  }
  lastChar=c;
 }
}

/**
 * Creates an array of meshes containing the primitives
 * needed to draw text with this font.
* @param {String} string The text to draw. Line breaks ("\n", "\r", "\r\n") are recognized
* by this method.
* @param {Object} params An object whose keys have
* the possibilities given below, and whose values are those
* allowed for each key.&lt;ul>
* &lt;li>&lt;code>x&lt;/code> - X-coordinate of the top left corner of the text.
* If null or omitted, uses 0.
* For the text to show upright, the coordinate system should have the
* X-axis pointing right and the Y-axis pointing down (for example, an
* orthographic projection where the left and top coordinates are less
* than the right and bottom coordinates, respectively).
* &lt;li>&lt;code>y&lt;/code> - Y-coordinate of the top left corner of the text.
* If null or omitted, uses 0.
* &lt;li>&lt;code>lineHeight&lt;/code> - Height of each line of the text in units.
* If null or omitted, uses the line height given in the font.
* &lt;li>&lt;code>width&lt;/code> - Maximum width of each line.  Lines
* that exceed this width will be wrapped.
* &lt;li>&lt;code>align&lt;/code> - Horizontal text alignment.  Can be "left",
* "center", or "right" (all strings).
* &lt;/ul>
* @returns {Array&lt;Mesh>} An array of meshes representing the text.
* There is one mesh for each texture page of the font.  If none of the
* text uses a given page, the corresponding mesh will be null.
 * @memberof! H3DU.TextFont#
*/
H3DU.TextFont.prototype.makeTextMeshes=function(str,params){
 var meshesForPage=[];
 var xPos=((typeof params.x !== "undefined" &amp;&amp; params.x !== null)) ? params.x : 0;
 var yPos=((typeof params.y !== "undefined" &amp;&amp; params.y !== null)) ? params.y : 0;
 var height=((typeof params.lineHeight !== "undefined" &amp;&amp; params.lineHeight !== null)) ? params.lineHeight :
   this.common.lineHeight;
 if(height&lt;0)throw new Error();
 var width=((typeof params.width !== "undefined" &amp;&amp; params.width !== null)) ? params.width : -1;
 var align=((typeof params.align !== "undefined" &amp;&amp; params.align !== null)) ? params.align : 0;
 if(align=="right")align=2;
 else if(align=="center")align=1;
 else align=0;
 var extra={
  recipPageWidth:1.0/this.common.scaleW,
  recipPageHeight:1.0/this.common.scaleH,
  scale:height/this.common.lineHeight
 };
 var meshesForPage=[];
 for(var i=0;i&lt;this.pages.length;i++){
  meshesForPage[i]=null;
 }
 var linebreaks=this._findLineBreaks(str,extra.scale,width);
 if(linebreaks.length === 0){
  return meshesForPage;
 }
 if(width&lt;0){
  // Calculate max width if no explicit width was given
  for(var i=0;i&lt;linebreaks.length;i+=3){
   width=(i === 0) ? linebreaks[i+2] : Math.max(width,linebreaks[i+2])
  }
 }
 for(var i=0;i&lt;linebreaks.length;i+=3){
  var x=xPos
  if(align === 1)x=x+(width-linebreaks[i+2])*0.5
  else if(align === 2)x=x+width-linebreaks[i+2]
  this._makeTextMeshesInner(str,linebreaks[i],
    linebreaks[i+1],x,yPos,params,extra,meshesForPage);
  yPos+=height;
 }
 return meshesForPage;
}
/** @private */
H3DU.TextFont._resolvePath=function(path,name){
 // Relatively dumb for a relative path
 // resolver, but sufficient for H3DU.TextFont's purposes
 "use strict";
var ret=path;
 var lastSlash=ret.lastIndexOf("/");
 if(lastSlash>=0){
  ret=ret.substr(0,lastSlash+1)+name.replace(/\\/g,"/");
 } else {
  ret=name.replace(/\\/g,"/");
 }
 return ret;
};
/** @private */
H3DU.TextFont._elementToObject=function(element){
 var attrs=element.getAttributeNames();
 var x={};
 for(var i=0;i&lt;attrs.length;i++){
  var n=attrs[i];
  if(n=="face" || n=="charset" || n=="file" || n=="padding" ||
     n=="spacing"){
    x[n]=element.getAttribute(n)
   } else {
    x[n]=parseInt(element.getAttribute(n),10)
    if(isNaN(x[n]))x[n]=0;
   }
 }
 return x;
}
/** @private */
H3DU.TextFont._loadJsonFontInner=function(data){
 var xchars=[]
 var xpages=[]
 var xkernings=[]
 var json=data.data
 if(!json.pages || !json.chars || !json.info ||
   !json.common){
   return null;
 }
  for(var i=0;i&lt;json.chars.length;i++){
   xchars[json.chars[i].id]=json.chars[i]
  }
  for(var i=0;i&lt;json.pages.length;i++){
   var p=json.pages[i]
   xpages[i]=H3DU.TextFont._resolvePath(data.url,p);
  }
 if(json.kernings){
   xkernings=json.kernings
 }
 return new H3DU.TextFont(json.info,xchars,xpages,xkernings,
   json.common,data.url)
}
/** @private */
H3DU.TextFont._loadXmlFontInner=function(data){
 var doc=data.data
 var commons=doc.getElementsByTagName("common")
 if(commons.length === 0)return null;
 var infos=doc.getElementsByTagName("info")
 if(infos.length === 0)return null;
 var pages=doc.getElementsByTagName("page")
 if(pages.length === 0)return null;
 var chars=doc.getElementsByTagName("char")
 var kernings=doc.getElementsByTagName("kerning")
 var xchars=[]
 var xpages=[]
 var xkernings=[]
 var xcommons=H3DU.TextFont._elementToObject(commons[0])
 var xinfos=H3DU.TextFont._elementToObject(infos[0])
 for(var i=0;i&lt;pages.length;i++){
  var p=H3DU.TextFont._elementToObject(pages[i])
  xpages[p.id]=H3DU.TextFont._resolvePath(data.url,p.file);
 }
 for(var i=0;i&lt;chars.length;i++){
  var p=H3DU.TextFont._elementToObject(chars[i])
  xchars[p.id]=p
 }
 for(var i=0;i&lt;kernings.length;i++){
  var p=H3DU.TextFont._elementToObject(kernings[i])
  xkernings.push(p)
 }
 return new H3DU.TextFont(xinfos,xchars,xpages,xkernings,xcommons,data.url)
}
/** @private */
H3DU.TextFont._decodeUtf8=function(data,offset,endOffset){
var ret=[];
var cp,bytesSeen;
var bytesNeeded=0;
var lower=0x80;
var upper=0xbf;
 if(offset>endOffset)throw new Error();
 while (true) {
          if (offset >= endOffset) {
            if (bytesNeeded != 0) {
              return null;
            }
            return ret.join("");
          }
          var b = data.getUint8(offset++);
          if (bytesNeeded === 0) {
            if ((b &amp; 0x7f) == b) {
              ret.push(String.fromCharCode(b));
              continue;
            } else if (b >= 0xc2 &amp;&amp; b &lt;= 0xdf) {
              bytesNeeded = 1;
              cp = (b - 0xc0) &lt;&lt; 6;
            } else if (b >= 0xe0 &amp;&amp; b &lt;= 0xef) {
              lower = (b === 0xe0) ? 0xa0 : 0x80;
              upper = (b === 0xed) ? 0x9f : 0xbf;
              bytesNeeded = 2;
              cp = (b - 0xe0) &lt;&lt; 12;
            } else if (b >= 0xf0 &amp;&amp; b &lt;= 0xf4) {
              lower = (b === 0xf0) ? 0x90 : 0x80;
              upper = (b === 0xf4) ? 0x8f : 0xbf;
              bytesNeeded = 3;
              cp = (b - 0xf0) &lt;&lt; 18;
            } else {
              return null;
            }
            continue;
          }
          if (b &lt; lower || b > upper) {
            return null;
          } else {
            lower = 0x80;
            upper = 0xbf;
            ++bytesSeen;
            cp += (b - 0x80) &lt;&lt; (6 * (bytesNeeded - bytesSeen));
            if (bytesSeen != bytesNeeded) {
              continue;
            }
            var cpRet = cp;
            cp = 0;
            bytesSeen = 0;
            bytesNeeded = 0;
            if(cpRet>=0x10000){
              ret.push(String.fromCharCode(((cpRet - 0x10000) >> 10) + 0xd800));
              ret.push(String.fromCharCode(((cpRet - 0x10000) &amp; 0x3ff) + 0xdc00));
            } else {
              ret.push(String.fromCharCode(cpRet));
            }
          }
        }
}
/** @private */
H3DU.TextFont._loadBinaryFontInner=function(data){
 var view=new DataView(data.data)
 var offset=4;
 if(view.getUint8(0)!=66||
  view.getUint8(1)!=77||
  view.getUint8(2)!=70||
  view.getUint8(3)!=3){
  throw new Error()
   return null;
 }
 var info={}
 var chars=[]
 var pages=[]
 var kernings=[]
 var commons={}
 var havetype=[false,false,false,false,false,false]
 function utf8stringsize(view,startIndex,endIndex){
   for(var i=startIndex;i&lt;endIndex;i++){
     if(view.getUint8(i) === 0){
      return (i-startIndex)
     }
   }
   return -1
 }
 function utf8string(view,startIndex,endIndex){
   for(var i=startIndex;i&lt;endIndex;i++){
     if(view.getUint8(i) === 0){
      return H3DU.TextFont._decodeUtf8(view,startIndex,i);
     }
   }
   return null
 }
 while (offset&lt;view.byteLength) {
  var type=view.getUint8(offset)
  var size=view.getUint32(offset+1,true)
  if(type==null || type&lt;1 || type>5){return null;}
  if(havetype[type]){return null;}
  var newOffset=offset+5+size;
  havetype[type]=true
  offset+=5
  switch(type){
   case 1:
    if(size&lt;14){return null;}
    info.fontSize=view.getInt16(offset,true);
    info.bitField=view.getUint8(offset+2);
    var cs=view.getUint8(offset+3);
    // return null if charset is unsupported
    if(cs!=0){return null;}
    info.charSet=""; // ignore charSet field, not used
    info.stretchH=view.getUint16(offset+4,true)
    info.aa=view.getUint8(offset+6)
    info.padding=[
      view.getUint8(offset+7),
      view.getUint8(offset+8),
      view.getUint8(offset+9),
      view.getUint8(offset+10)],
    info.spacing=[
      view.getUint8(offset+11),
      view.getUint8(offset+12)]
    info.outline=view.getUint8(offset+13)
    info.fontName=utf8string(view,offset+14,offset+size)
    if(info.fontName==null){return null;}
    break;
   case 2:
    commons.lineHeight=view.getUint16(offset,true)
    commons.base=view.getUint16(offset+2,true)
    commons.scaleW=view.getUint16(offset+4,true)
    commons.scaleH=view.getUint16(offset+6,true)
    commons.pages=view.getUint16(offset+8,true)
    commons.bitField=view.getUint8(offset+10)
    commons.alphaChnl=view.getUint8(offset+11)
    commons.redChnl=view.getUint8(offset+12)
    commons.greenChnl=view.getUint8(offset+13)
    commons.blueChnl=view.getUint8(offset+14)
    break;
   case 3:
    var ss=utf8stringsize(view,offset,offset+size)
    if(ss&lt;0){return null}
    for(var x=0;x&lt;size;x+=ss+1){
     var name=utf8string(view,offset,offset+ss+1)
     if(name==null){return null}
     pages.push(H3DU.TextFont._resolvePath(data.url,name))
     offset+=ss+1
    }
    break;
   case 4:
    for(var x=0;x&lt;size;x+=20){
     var ch={}
     ch.id=view.getUint32(offset,true)
     ch.x=view.getUint16(offset+4,true)
     ch.y=view.getUint16(offset+6,true)
     ch.width=view.getUint16(offset+8,true)
     ch.height=view.getUint16(offset+10,true)
     ch.xoffset=view.getInt16(offset+12,true)
     ch.yoffset=view.getInt16(offset+14,true)
     ch.xadvance=view.getInt16(offset+16,true)
     ch.page=view.getUint8(offset+18)
     ch.chnl=view.getUint8(offset+19)
     offset+=20
     chars[ch.id]=ch
    }
    break;
   case 5:
    for(var x=0;x&lt;size;x+=10){
     var ch={}
     ch.first=view.getUint32(offset,true)
     ch.second=view.getUint32(offset+4,true)
     ch.amount=view.getInt16(offset+8,true)
     kernings.push(ch)
    }
    break;
  }
  offset=newOffset;
 }
if(!havetype[1] || !havetype[2] || !havetype[3]){
  return null;}
 return new H3DU.TextFont(info,chars,pages,kernings,commons,data.url)
}
/** @private */
H3DU.TextFont._loadTextFontInner=function(data){
  var text=data.data
  var lines=text.split(/\r?\n/)
  var pages=[]
  var chars=[]
  var kernings=[]
  var common=null;
  var fontinfo=null;
  var firstline=true;
  for(var i=0;i&lt;lines.length;i++){
   var e=(/^(\w+)\s+(.*)/).exec(lines[i]);
   if(!e)continue;
   var word=e[1];
   var rest=e[2];
   var hash={};
   while(true){
     e=(/^((\w+)\=(\"[^\"]+\"|\S+(?:\s+(?![^\s\=]+\=)[^\s\=]+)*)\s*)/).exec(rest)
     if(!e)break;
     var key=e[2];
     var value=e[3];
     if(value.charAt(0)=='"'){
      value=value.substring(1,value.length-1);
     } else if(value.match(/^-?\d+$/)){
      value=parseInt(value,10)|0;
     }
     hash[key]=value;
     rest=rest.substr(e[1].length);
   }
   if(word=="page"){
    pages[hash.id|0]=H3DU.TextFont._resolvePath(data.url,hash.file);
   }
   if(word=="char" &amp;&amp; hash.id!=null){
    chars[hash.id|0]=hash;
   }
   if(word=="common"){
    if(common)return null;
    common=hash
   }
   if(word=="kerning" &amp;&amp; hash.first!=null){
    kernings.push(hash)
   }
   if(word=="info" &amp;&amp; hash.face!=null){
    if(fontinfo)return null;
    fontinfo=hash
   }
  }
  if(!fontinfo || !common || pages.length === 0){
   return null;
  }
  return new H3DU.TextFont(fontinfo,chars,pages,kernings,common,data.url)
}
/**
* Loads a bitmap font definition from a file along with the textures
* used by that font.
* @param {String} fontFileName The URL of the font data file
* to load.  The following file extensions are read as the following formats:&lt;ul>
* &lt;li>".xml": XML&lt;/li>
* &lt;li>".json": JSON&lt;/li>
* &lt;li>".bin": Binary&lt;/li>
* &lt;li>".fnt": Text or binary&lt;/li>
* &lt;li>All others: Text&lt;/li>&lt;/ul>
 * @param {H3DU.TextureLoader} [textureLoader]
* @returns {Promise} A promise that is resolved
* when the font data and textures are loaded successfully,
* and is rejected when an error occurs.
* If the promise is resolved, the result will be an object with the
* following keys:&lt;ul>
&lt;li>&lt;code>url&lt;/code> - The URL of the font data file.
&lt;li>&lt;code>font&lt;/code> - The font data in the form of an {@link H3DU.TextFont} object.
&lt;li>&lt;code>textures&lt;/code> - An array of {@link H3DU.Texture} objects used by the font,
in the order in which they are declared in the font data file.
&lt;/ul>
*/
H3DU.TextFont.loadWithTextures=function(fontFileName,textureLoader){
 if(!textureLoader){
  throw new Error();
 }
 return H3DU.TextFont.load(fontFileName).then(function(font){
  return font.loadTextures(textureLoader).then(function(r){
     return Promise.resolve({"url":font.fileUrl,"font":font,"textures":r});
  },function(r){
     return Promise.reject({"url":font.fileUrl,"results":r});
  });
 });
}
/**
 * Not documented yet.
 * @param {*} textureLoader
 * @memberof! H3DU.TextFont#
*/
H3DU.TextFont.prototype.loadTextures=function(textureLoader){
  var textures=[]
  for(var i=0;i&lt;this.pages.length;i++){
   if(!this.pages[i])throw new Error();
   textures.push(this.pages[i])
  }
  return textureLoader.loadTexturesAll(textures);
}

/**
* Loads a bitmap font definition from a file.
* Note that this method only loads the font data and not the bitmaps
* used to represent the font.
* @param {String} fontFileName The URL of the font data file
* to load.  The following file extensions are read as the following formats:&lt;ul>
* &lt;li>".xml": XML&lt;/li>
* &lt;li>".json": JSON&lt;/li>
* &lt;li>".bin": Binary&lt;/li>
* &lt;li>".fnt": Text or binary&lt;/li>
* &lt;li>All others: Text&lt;/li>&lt;/ul>
* @returns {Promise&lt;H3DU.TextFont>} A promise that is resolved
* when the font data is loaded successfully (the result will be
* an H3DU.TextFont object), and is rejected when an error occurs.
*/
H3DU.TextFont.load=function(fontFileName){
 if((/\.xml$/i.exec(fontFileName))){
  return H3DU.loadFileFromUrl(fontFileName,"xml").then(
   function(data){
    var ret=H3DU.TextFont._loadXmlFontInner(data)
    return ret ? Promise.resolve(ret) : Promise.reject({"url":data.url})
   })
 } else if((/\.bin$/i.exec(fontFileName))){
  return H3DU.loadFileFromUrl(fontFileName,"arraybuffer").then(
   function(data){
    var ret=H3DU.TextFont._loadBinaryFontInner(data)
    return ret ? Promise.resolve(ret) : Promise.reject({"url":data.url})
   },function(e){
    console.log(e)
   })
 } else if((/\.fnt$/i.exec(fontFileName))){
  return H3DU.loadFileFromUrl(fontFileName,"arraybuffer").then(
   function(data){
    var view=new DataView(data.data)
    var ret=null;
    if(view.getUint8(0) === 66 &amp;&amp; view.getUint8(1) === 77 &amp;&amp; view.getUint8(2) === 70) {
     ret=H3DU.TextFont._loadBinaryFontInner(data)
    } else {
     var view=new DataView(data.data)
     ret=H3DU.TextFont._loadTextFontInner({
       "url":data.url,"data":H3DU.TextFont._decodeUtf8(view,0,view.byteLength)})
    }
    return ret ? Promise.resolve(ret) : Promise.reject({"url":data.url})
   })
 } else if((/\.json$/i.exec(fontFileName))){
  return H3DU.loadFileFromUrl(fontFileName,"json").then(
   function(data){
    var ret=H3DU.TextFont._loadJsonFontInner(data)
    return ret ? Promise.resolve(ret) : Promise.reject({"url":data.url})
   })
 } else {
  return H3DU.loadFileFromUrl(fontFileName).then(
   function(data){
    var ret=H3DU.TextFont._loadTextFontInner(data)
    return ret ? Promise.resolve(ret) : Promise.reject({"url":data.url})
   })
 }
}
/** @private */
H3DU.TextFont._textShader=function(){
"use strict";
var i;
var shader=""
shader+="#ifdef GL_OES_standard_derivatives\n"
shader+="#extension GL_OES_standard_derivatives : enable\n"
shader+="#endif\n"
shader+=H3DU.ShaderProgram.fragmentShaderHeader() +
"uniform vec4 md;\n" +
"uniform sampler2D sampler;\n" +
"varying vec2 uvVar;\n"+
"varying vec3 colorAttrVar;\n" +
"void main(){\n" +
" float d=texture2D(sampler, uvVar).a;\n"
shader+="#ifdef GL_OES_standard_derivatives\n"
shader+=" float dsmooth=length(vec2(dFdx(d),dFdy(d)))*0.75;\n";
shader+="#else\n"
shader+=" float dsmooth=0.06;\n";
shader+="#endif\n"
shader+=" gl_FragColor=vec4(md.rgb,md.a*smoothstep(0.5-dsmooth,0.5+dsmooth,d));\n" +
"}";
return shader;
};
H3DU.TextFont._textShaderInfo=new H3DU.ShaderInfo(null,H3DU.TextFont._textShader());
</code></pre>
        </article>
    </section>

</div>
<nav id="navigation">
<p>
If you like this software, you should consider donating to me, Peter O., at the link below:</p>
<p class="printonly"><b>upokecenter.dreamhosters.com/articles/donate-now-2</b></p>
<div class=noprint>
<form action="https://www.paypal.com/cgi-bin/webscr" method="post" target="_top">
<input type="hidden" name="cmd" value="_s-xclick">
<input type="hidden" name="encrypted" value="-----BEGIN PKCS7-----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-----END PKCS7-----">
<input type="image" src="https://www.paypalobjects.com/en_US/i/btn/btn_donateCC_LG.gif"
name="submit" border="2" alt="PayPal - The safer, easier way to pay online!">
<img alt="" src="https://www.paypalobjects.com/en_US/i/scr/pixel.gif" width="1" height="1">
</form>
<p>
<a href="https://twitter.com/share" class="twitter-share-button" data-count="horizontal" data-lang="en">Share via Twitter</a>
<script type="text/javascript" charset="UTF-8" src="https://platform.twitter.com/widgets.js"></script>
<span><g:plusone size="medium"></g:plusone></span><br/>
<span><fb:like send="true" width="300" show_faces="true"></fb:like></span>
</p>
</div>
<h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-glutil.html">glutil</a></li></ul><h3>Classes</h3><ul><li><a href="Camera.html">Camera</a></li><li><a href="global.html#CurveTube">CurveTube</a></li><li><a href="Epitrochoid.html">Epitrochoid</a></li><li><a href="GraphicsPath.html">GraphicsPath</a></li><li><a href="H3DU.Batch3D.html">Batch3D</a></li><li><a href="H3DU.BezierCurve.html">BezierCurve</a></li><li><a href="H3DU.BezierSurface.html">BezierSurface</a></li><li><a href="H3DU.BSplineCurve.html">BSplineCurve</a></li><li><a href="H3DU.BSplineSurface.html">BSplineSurface</a></li><li><a href="H3DU.BufferedMesh.html">BufferedMesh</a></li><li><a href="H3DU.CurveEval.html">CurveEval</a></li><li><a href="H3DU.FrameBuffer.html">FrameBuffer</a></li><li><a href="H3DU.Lights.html">Lights</a></li><li><a href="H3DU.LightSource.html">LightSource</a></li><li><a href="H3DU.Material.html">Material</a></li><li><a href="H3DU.Math.html">Math</a></li><li><a href="H3DU.Mesh.html">Mesh</a></li><li><a href="H3DU.MeshBuffer.html">MeshBuffer</a></li><li><a href="H3DU.Meshes.html">Meshes</a></li><li><a href="H3DU.RenderPass3D.html">RenderPass3D</a></li><li><a href="H3DU.Scene3D.html">Scene3D</a></li><li><a href="H3DU.ShaderInfo.html">ShaderInfo</a></li><li><a href="H3DU.ShaderProgram.html">ShaderProgram</a></li><li><a href="H3DU.Shape.html">Shape</a></li><li><a href="H3DU.ShapeGroup.html">ShapeGroup</a></li><li><a href="H3DU.SurfaceEval.html">SurfaceEval</a></li><li><a href="H3DU.TextFont.html">TextFont</a></li><li><a href="H3DU.TextureLoader.html">TextureLoader</a></li><li><a href="H3DU.Transform.html">Transform</a></li><li><a href="Hypotrochoid.html">Hypotrochoid</a></li><li><a href="MeshJSON.html">MeshJSON</a></li><li><a href="ObjData.html">ObjData</a></li><li><a href="Promise.html">Promise</a></li><li><a href="SurfaceOfRevolution.html">SurfaceOfRevolution</a></li><li><a href="Trochoid.html">Trochoid</a></li></ul><h3>Namespaces</h3><ul><li><a href="H3DU.html">H3DU</a></li></ul><h3>Tutorials</h3><ul><li><a href="tutorial-camera_.html">The "Camera" and the Projection and View Transforms</a></li><li><a href="tutorial-filters.html">Graphics Filters</a></li><li><a href="tutorial-glmath.html">GLMath Math Library</a></li><li><a href="tutorial-history.html">Older Version History</a></li><li><a href="tutorial-matrixdetails.html">Matrix Details</a></li><li><a href="tutorial-meshexamples.html">Examples of Creating Meshes on the Fly</a></li><li><a href="tutorial-overview.html">Library Overview</a></li><li><a href="tutorial-paths.html">2-Dimensional Graphics Paths</a></li><li><a href="tutorial-shapes.html">Creating Shapes</a></li><li><a href="tutorial-surfaces.html">Parametric Curves and Parametric Surfaces</a></li><li><a href="tutorial-textures.html">Texture Examples</a></li></ul><h3><a href="global.html">Global</a></h3>
</nav>
<script>
if(document.location.href.indexOf("file://")!=0){
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = '//apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/all.js#xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
}
</script>
</body>
</html>
