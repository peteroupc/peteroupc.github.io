<!DOCTYPE html><html xmlns:dc="http://purl.org/dc/terms/"><head><meta http-equiv=Content-Type content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width"><link rel=stylesheet type="text/css" href="/style.css">
            <script type="text/x-mathjax-config"> MathJax.Hub.Config({"HTML-CSS": { availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, preferredFont: "TeX" },
                    tex2jax: { displayMath: [ ["$$","$$"], ["\\[", "\\]"] ], inlineMath: [ ["$", "$"], ["\\\\(","\\\\)"] ], processEscapes: true } });
            </script><script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"></script></head><body>  <div class="header">
<nav><p><a href="#navigation">Menu</a> - <a href="#top">Top</a> - <a href="/">Home</a></nav></div>
<div class="mainarea" id="top">
<h1 id="meshbuffer">MeshBuffer</h1>

<p><a href="index.html">Back to documentation index.</a></p>

<p><a name="MeshBuffer"></a>
### new MeshBuffer()</p>

<p><strong>Deprecated: It is planned to render this class obsolete and rely on three.js’s BufferGeometry.</strong></p>

<p>A geometric mesh in the form of buffer objects.
A mesh buffer is made up of one or more <a href="BufferAccessor.html">vertex attribute objects</a>,
and an optional array of vertex indices. Each vertex attribute object contains
the values of one attribute of the mesh, such as positions,
vertex normals, and texture coordinates. A mesh buffer
can store vertices that make up triangles, line segments, or points.</p>

<p>This constructor creates an empty mesh buffer and sets the array
of vertex indices to null and the primitive type to <a href="MeshBuffer.html#MeshBuffer.TRIANGLES">MeshBuffer.TRIANGLES</a>.</p>

<p>The <code>MeshBuffer</code> class contains four methods (<code>fromPositions</code>,
<code>fromPositionsNormals</code>, <code>fromPositionsUV</code>, and <code>fromPositionsNormalsUV</code>) that let you define a mesh buffer from a predefined array of vertex data. See the documentation for those methods for more information.</p>

<p>The <a href="Meshes.html"><code>Meshes</code></a> class includes several handy methods for creating built-in shapes; those methods return a <code>MeshBuffer</code> object that describes the triangles they
are composed of.</p>

<p><b>Instancing</b></p>

<p>Some 3D rendering pipelines support <i>instancing</i>, which is a technique for rendering multiple versions of a mesh buffer with a single draw call. Instancing involves the use of a second mesh buffer (an <i>instance buffer</i>); rather than holding vertex data, the instance buffer holds <i>instance data</i>, that is, data to be used when rendering each instance of the first mesh buffer. Besides this, however, instance buffers are largely similar to vertex buffers as far as the <code>MeshBuffer</code> class is concerned; any reference to vertices in the documentation applies analogously to instances in instance buffers. However, instance buffers should use the primitive type <code>MeshBuffer.POINTS</code>; it makes little sense to have instance buffers describe triangles or line segments.</p>

<h3 id="members">Members</h3>

<ul>
  <li><a href="#MeshBuffer.LINES">LINES</a><br />Indicates that a mesh buffer contains line segments; the mesh
buffer stores each line segment using two consecutive vertices.</li>
  <li><a href="#MeshBuffer.POINTS">POINTS</a><br />Indicates that a mesh buffer contains points; the mesh
buffer stores each point using one vertex.</li>
  <li><a href="#MeshBuffer.TRIANGLES">TRIANGLES</a><br />Indicates that a mesh buffer contains triangles; the mesh
buffer stores each triangle using three consecutive vertices.</li>
</ul>

<h3 id="methods">Methods</h3>

<ul>
  <li><a href="#MeshBuffer.fromPositions">fromPositions</a><br />Creates a new mesh buffer with the given array of vertex positions.</li>
  <li><a href="#MeshBuffer.fromPositionsColors">fromPositionsColors</a><br />Creates a new mesh buffer with the given array of vertex positions
and vertex colors.</li>
  <li><a href="#MeshBuffer.fromPositionsNormals">fromPositionsNormals</a><br />Creates a new mesh buffer with the given array of vertex positions
and vertex normals.</li>
  <li><a href="#MeshBuffer.fromPositionsNormalsColors">fromPositionsNormalsColors</a><br />Creates a new mesh buffer with the given array of vertex positions,
vertex normals, and vertex colors.</li>
  <li><a href="#MeshBuffer.fromPositionsNormalsUV">fromPositionsNormalsUV</a><br />Creates a new mesh buffer with the given array of vertex positions,
vertex normals, and texture coordinates.</li>
  <li><a href="#MeshBuffer.fromPositionsUV">fromPositionsUV</a><br />Creates a new mesh buffer with the given array of vertex positions
and texture coordinates.</li>
  <li><a href="#MeshBuffer_getPositions">getPositions</a><br />Gets an array of vertex positions held by this mesh buffer,
arranged by primitive.</li>
  <li><a href="#MeshBuffer_primitiveCount">primitiveCount</a><br />Gets the number of primitives (triangles, lines,
and points) composed by all shapes in this mesh.</li>
</ul>

<p><a name="MeshBuffer.LINES"></a>
### MeshBuffer.LINES (constant)</p>

<p>Indicates that a mesh buffer contains line segments; the mesh
buffer stores each line segment using two consecutive vertices.</p>

<p>Default Value: <code>1</code></p>

<p><a name="MeshBuffer.POINTS"></a>
### MeshBuffer.POINTS (constant)</p>

<p>Indicates that a mesh buffer contains points; the mesh
buffer stores each point using one vertex.</p>

<p>Default Value: <code>0</code></p>

<p><a name="MeshBuffer.TRIANGLES"></a>
### MeshBuffer.TRIANGLES (constant)</p>

<p>Indicates that a mesh buffer contains triangles; the mesh
buffer stores each triangle using three consecutive vertices.</p>

<p>Default Value: <code>4</code></p>

<p><a name="MeshBuffer.fromPositions"></a>
### (static) MeshBuffer.fromPositions(vertices, [indices])</p>

<p>Creates a new mesh buffer with the given array of vertex positions.</p>

<h4 id="parameters">Parameters</h4>

<ul>
  <li>
    <table>
      <tbody>
        <tr>
          <td><code>vertices</code> (Type: Array.&lt;number&gt;</td>
          <td>Float32Array)<br />An array of vertex positions. This array’s length must be divisible by 3; every 3 elements are the X, Y, and Z coordinates, in that order, of one vertex.</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <table>
      <tbody>
        <tr>
          <td><code>indices</code> (Type: Array.&lt;number&gt;</td>
          <td>Uint16Array</td>
          <td>Uint32Array</td>
          <td>Uint8Array</td>
          <td>null</td>
          <td>undefined) (optional)<br />Array of vertex indices that the mesh buffer will use. Each index (n) is a number referring to the (n+1)th vertex. If you are defining a set of triangles, there should be 3 indices for each triangle; for line segments, 2 indices for each segment; and for points, 1 index for each point. Can be null, undefined, or omitted, in which case no index array is used and primitives in the mesh buffer are marked by consecutive vertices.</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<h4 id="return-value">Return Value</h4>

<p>A new mesh buffer. (Type: <a href="MeshBuffer.html">MeshBuffer</a>)</p>

<h4 id="examples">Examples</h4>

<p>The following example shows how to define a mesh
buffer from a predefined array of vertex positions.</p>

<pre>// First, create an array of numbers giving the X, Y, and
// Z coordinate for each vertex position. Here, three vertices
// are defined.
var vertices = [x1, y1, z1, x2, y2, z2, x3, y3, z3 ];
// Second -- and this is optional -- create a second array of numbers
// giving the indices to vertices defined in the previous step.
// Each index refers to the (n+1)th vertex; since 3 vertices
// were defined, the highest index is 2.
var indices = [0, 1, 2];
// Finally, create the mesh buffer. (If there are no indices,
// leave out the "indices" argument.)
var meshBuffer=MeshBuffer.fromPositions(vertices, indices);
</pre>

<p>The following example generates a mesh buffer
consisting of a 10 × 10 × 3 grid of points. This mesh buffer can serve, for
example, as instance data to draw multiple instances
of a 3-D cube in different positions.</p>

<pre>var vertices=[]
for(var x=0;x&lt;10;x++)
for(var y=0;y&lt;10;y++)
for(var z=0;z&lt;10;z++)vertices.push(x,y,z);
var meshBuffer=MeshBuffer.fromPositions(vertices)
.setType(MeshBuffer.POINTS);
</pre>

<p><a name="MeshBuffer.fromPositionsColors"></a>
### (static) MeshBuffer.fromPositionsColors(vertices, [indices])</p>

<p>Creates a new mesh buffer with the given array of vertex positions
and vertex colors.</p>

<h4 id="parameters-1">Parameters</h4>

<ul>
  <li>
    <table>
      <tbody>
        <tr>
          <td><code>vertices</code> (Type: Array.&lt;number&gt;</td>
          <td>Float32Array)<br />An array of vertex data. This array’s length must be divisible by 6; every 6 elements describe one vertex and are in the following order:&lt;ol&gt; &lt;li&gt;X, Y, and Z coordinates, in that order, of the vertex position. &lt;li&gt;Red, green, and blue components, in that order, of the vertex color, where each component ranges from a low of 0 to a high of 1.&lt;/ol&gt;</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <table>
      <tbody>
        <tr>
          <td><code>indices</code> (Type: Array.&lt;number&gt;</td>
          <td>Uint16Array</td>
          <td>Uint32Array</td>
          <td>Uint8Array</td>
          <td>null</td>
          <td>undefined) (optional)<br />Array of vertex indices that the mesh buffer will use. Each index (n) is a number referring to the (n+1)th vertex. If you are defining a set of triangles, there should be 3 indices for each triangle; for line segments, 2 indices for each segment; and for points, 1 index for each point. Can be null, undefined, or omitted, in which case no index array is used and primitives in the mesh buffer are marked by consecutive vertices.</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<h4 id="return-value-1">Return Value</h4>

<p>A new mesh buffer. (Type: <a href="MeshBuffer.html">MeshBuffer</a>)</p>

<h4 id="examples-1">Examples</h4>

<p>The following example shows how to define a mesh
buffer from a predefined array of vertex positions, normals,
and texture cordinates.</p>

<pre>// First, create an array of numbers giving the X, Y, and
// Z coordinate for each vertex position and associated
// color components. Here, three vertices
// are defined. For each vertex, the position is given, followed by
// the color components.
var vertices = [
x1, y1, z1, r1, g1, b1,
x2, y2, z2, r2, g2, b2,
x3, y3, z3, r3, g3, b3 ];
// Second -- and this is optional -- create a second array of numbers
// giving the indices to vertices defined in the previous step.
// Each index refers to the (n+1)th vertex; since 3 vertices
// were defined, the highest index is 2.
var indices = [0, 1, 2];
// Finally, create the mesh buffer. (If there are no indices,
// leave out the "indices" argument.)
var meshBuffer=MeshBuffer.fromPositionsColors(vertices, indices);
</pre>

<p><a name="MeshBuffer.fromPositionsNormals"></a>
### (static) MeshBuffer.fromPositionsNormals(vertices, [indices])</p>

<p>Creates a new mesh buffer with the given array of vertex positions
and vertex normals.</p>

<h4 id="parameters-2">Parameters</h4>

<ul>
  <li>
    <table>
      <tbody>
        <tr>
          <td><code>vertices</code> (Type: Array.&lt;number&gt;</td>
          <td>Float32Array)<br />An array of vertex data. This array’s length must be divisible by 6; every 6 elements describe one vertex and are in the following order:&lt;ol&gt; &lt;li&gt;X, Y, and Z coordinates, in that order, of the vertex position. &lt;li&gt;X, Y, and Z components, in that order, of the vertex normal.&lt;/ol&gt;</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <table>
      <tbody>
        <tr>
          <td><code>indices</code> (Type: Array.&lt;number&gt;</td>
          <td>Uint16Array</td>
          <td>Uint32Array</td>
          <td>Uint8Array</td>
          <td>null</td>
          <td>undefined) (optional)<br />Array of vertex indices that the mesh buffer will use. Each index (n) is a number referring to the (n+1)th vertex. If you are defining a set of triangles, there should be 3 indices for each triangle; for line segments, 2 indices for each segment; and for points, 1 index for each point. Can be null, undefined, or omitted, in which case no index array is used and primitives in the mesh buffer are marked by consecutive vertices.</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<h4 id="return-value-2">Return Value</h4>

<p>A new mesh buffer. (Type: <a href="MeshBuffer.html">MeshBuffer</a>)</p>

<h4 id="examples-2">Examples</h4>

<p>The following example shows how to define a mesh
buffer from a predefined array of vertex positions and normals.</p>

<pre>// First, create an array of numbers giving the X, Y, and
// Z coordinate for each vertex position and normal. Here, three vertices
// are defined. For each vertex, the position is given, followed by
// the normal.
var vertices = [
x1, y1, z1, nx1, ny1, nz1,
x2, y2, z2, nx2, ny2, nz2,
x3, y3, z3, nx3, ny3, nz3 ];
// Second -- and this is optional -- create a second array of numbers
// giving the indices to vertices defined in the previous step.
// Each index refers to the (n+1)th vertex; since 3 vertices
// were defined, the highest index is 2.
var indices = [0, 1, 2];
// Finally, create the mesh buffer. (If there are no indices,
// leave out the "indices" argument.)
var meshBuffer=MeshBuffer.fromPositionsNormals(vertices, indices);
</pre>

<p><a name="MeshBuffer.fromPositionsNormalsColors"></a>
### (static) MeshBuffer.fromPositionsNormalsColors(vertices, [indices])</p>

<p>Creates a new mesh buffer with the given array of vertex positions,
vertex normals, and vertex colors.</p>

<h4 id="parameters-3">Parameters</h4>

<ul>
  <li>
    <table>
      <tbody>
        <tr>
          <td><code>vertices</code> (Type: Array.&lt;number&gt;</td>
          <td>Float32Array)<br />An array of vertex data. This array’s length must be divisible by 9; every 9 elements describe one vertex and are in the following order:&lt;ol&gt; &lt;li&gt;X, Y, and Z coordinates, in that order, of the vertex position. &lt;li&gt;X, Y, and Z components, in that order, of the vertex normal. &lt;li&gt;Red, green, and blue components, in that order, of the vertex color, where each component ranges from a low of 0 to a high of 1.&lt;/ol&gt;</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <table>
      <tbody>
        <tr>
          <td><code>indices</code> (Type: Array.&lt;number&gt;</td>
          <td>Uint16Array</td>
          <td>Uint32Array</td>
          <td>Uint8Array</td>
          <td>null</td>
          <td>undefined) (optional)<br />Array of vertex indices that the mesh buffer will use. Each index (n) is a number referring to the (n+1)th vertex. If you are defining a set of triangles, there should be 3 indices for each triangle; for line segments, 2 indices for each segment; and for points, 1 index for each point. Can be null, undefined, or omitted, in which case no index array is used and primitives in the mesh buffer are marked by consecutive vertices.</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<h4 id="return-value-3">Return Value</h4>

<p>A new mesh buffer. (Type: <a href="MeshBuffer.html">MeshBuffer</a>)</p>

<h4 id="examples-3">Examples</h4>

<p>The following example shows how to define a mesh
buffer from a predefined array of vertex positions, normals,
and texture cordinates.</p>

<pre>// First, create an array of numbers giving the X, Y, and
// Z coordinate for each vertex position and normal, and associated
// color components. Here, three vertices
// are defined. For each vertex, the position is given, followed by
// the normal, followed by the color components.
var vertices = [
x1, y1, z1, nx1, ny1, nz1, r1, g1, b1,
x2, y2, z2, nx2, ny2, nz2, r2, g2, b2,
x3, y3, z3, nx3, ny3, nz3, r3, g3, b3 ];
// Second -- and this is optional -- create a second array of numbers
// giving the indices to vertices defined in the previous step.
// Each index refers to the (n+1)th vertex; since 3 vertices
// were defined, the highest index is 2.
var indices = [0, 1, 2];
// Finally, create the mesh buffer. (If there are no indices,
// leave out the "indices" argument.)
var meshBuffer=MeshBuffer.fromPositionsNormalsColors(vertices, indices);
</pre>

<p><a name="MeshBuffer.fromPositionsNormalsUV"></a>
### (static) MeshBuffer.fromPositionsNormalsUV(vertices, [indices])</p>

<p>Creates a new mesh buffer with the given array of vertex positions,
vertex normals, and texture coordinates.</p>

<h4 id="parameters-4">Parameters</h4>

<ul>
  <li>
    <table>
      <tbody>
        <tr>
          <td><code>vertices</code> (Type: Array.&lt;number&gt;</td>
          <td>Float32Array)<br />An array of vertex data. This array’s length must be divisible by 8; every 8 elements describe one vertex and are in the following order:&lt;ol&gt; &lt;li&gt;X, Y, and Z coordinates, in that order, of the vertex position. &lt;li&gt;X, Y, and Z components, in that order, of the vertex normal. &lt;li&gt;U and V <a href="Semantic.html#Semantic.TEXCOORD">texture coordinates</a> in that order, of the vertex.&lt;/ol&gt;</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <table>
      <tbody>
        <tr>
          <td><code>indices</code> (Type: Array.&lt;number&gt;</td>
          <td>Uint16Array</td>
          <td>Uint32Array</td>
          <td>Uint8Array</td>
          <td>null</td>
          <td>undefined) (optional)<br />Array of vertex indices that the mesh buffer will use. Each index (n) is a number referring to the (n+1)th vertex. If you are defining a set of triangles, there should be 3 indices for each triangle; for line segments, 2 indices for each segment; and for points, 1 index for each point. Can be null, undefined, or omitted, in which case no index array is used and primitives in the mesh buffer are marked by consecutive vertices.</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<h4 id="return-value-4">Return Value</h4>

<p>A new mesh buffer. (Type: <a href="MeshBuffer.html">MeshBuffer</a>)</p>

<h4 id="examples-4">Examples</h4>

<p>The following example shows how to define a mesh
buffer from a predefined array of vertex positions, normals,
and texture cordinates.</p>

<pre>// First, create an array of numbers giving the X, Y, and
// Z coordinate for each vertex position and normal, and associated
// texture coordinates. Here, three vertices
// are defined. For each vertex, the position is given, followed by
// the normal, followed by the texture coordinates.
var vertices = [
x1, y1, z1, nx1, ny1, nz1, u1, v1,
x2, y2, z2, nx2, ny2, nz2, u2, v2,
x3, y3, z3, nx3, ny3, nz3, u3, v3 ];
// Second -- and this is optional -- create a second array of numbers
// giving the indices to vertices defined in the previous step.
// Each index refers to the (n+1)th vertex; since 3 vertices
// were defined, the highest index is 2.
var indices = [0, 1, 2];
// Finally, create the mesh buffer. (If there are no indices,
// leave out the "indices" argument.)
var meshBuffer=MeshBuffer.fromPositionsNormalsUV(vertices, indices);
</pre>

<p><a name="MeshBuffer.fromPositionsUV"></a>
### (static) MeshBuffer.fromPositionsUV(vertices, [indices])</p>

<p>Creates a new mesh buffer with the given array of vertex positions
and texture coordinates.</p>

<h4 id="parameters-5">Parameters</h4>

<ul>
  <li>
    <table>
      <tbody>
        <tr>
          <td><code>vertices</code> (Type: Array.&lt;number&gt;</td>
          <td>Float32Array)<br />An array of vertex data. This array’s length must be divisible by 5; every 5 elements describe one vertex and are in the following order:&lt;ol&gt; &lt;li&gt;X, Y, and Z coordinates, in that order, of the vertex position. &lt;li&gt;U and V <a href="Semantic.html#Semantic.TEXCOORD">texture coordinates</a> in that order, of the vertex.&lt;/ol&gt;</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <table>
      <tbody>
        <tr>
          <td><code>indices</code> (Type: Array.&lt;number&gt;</td>
          <td>Uint16Array</td>
          <td>Uint32Array</td>
          <td>Uint8Array</td>
          <td>null</td>
          <td>undefined) (optional)<br />Array of vertex indices that the mesh buffer will use. Each index (n) is a number referring to the (n+1)th vertex. If you are defining a set of triangles, there should be 3 indices for each triangle; for line segments, 2 indices for each segment; and for points, 1 index for each point. Can be null, undefined, or omitted, in which case no index array is used and primitives in the mesh buffer are marked by consecutive vertices.</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<h4 id="return-value-5">Return Value</h4>

<p>A new mesh buffer. (Type: <a href="MeshBuffer.html">MeshBuffer</a>)</p>

<h4 id="examples-5">Examples</h4>

<p>The following example shows how to define a mesh
buffer from a predefined array of vertex positions, normals,
and texture cordinates.</p>

<pre>// First, create an array of numbers giving the X, Y, and
// Z coordinate for each vertex position and associated
// texture coordinates. Here, three vertices
// are defined. For each vertex, the position is given, followed by
// the texture coordinates.
var vertices = [
x1, y1, z1, u1, v1,
x2, y2, z2, u2, v2,
x3, y3, z3, u3, v3 ];
// Second -- and this is optional -- create a second array of numbers
// giving the indices to vertices defined in the previous step.
// Each index refers to the (n+1)th vertex; since 3 vertices
// were defined, the highest index is 2.
var indices = [0, 1, 2];
// Finally, create the mesh buffer. (If there are no indices,
// leave out the "indices" argument.)
var meshBuffer=MeshBuffer.fromPositionsUV(vertices, indices);
</pre>

<p><a name="MeshBuffer_getPositions"></a>
### MeshBuffer#getPositions()</p>

<p>Gets an array of vertex positions held by this mesh buffer,
arranged by primitive.
Only values with the attribute semantic <code>POSITION_0</code> are returned.</p>

<h4 id="return-value-6">Return Value</h4>

<p>An array of primitives,
each of which holds the vertices that make up that primitive.
If this mesh holds triangles, each primitive will contain three
vertices; if lines, two; and if points, one. Each vertex is an array containing that vertex’s coordinates (for example, if the attribute holds 3 elements per value, the coordinates are X, Y, and Z coordinates, in that order). (Type: Array.&lt;Array.&lt;number»)</p>

<p><a name="MeshBuffer_primitiveCount"></a>
### MeshBuffer#primitiveCount()</p>

<p>Gets the number of primitives (triangles, lines,
and points) composed by all shapes in this mesh.</p>

<h4 id="return-value-7">Return Value</h4>

<p>Return value. (Type: number)</p>

<p><a href="index.html">Back to documentation index.</a></p>
</div><nav id="navigation"><ul>
<li><a href="/">Back to start site.</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io">This site's repository (source code)</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io/issues">Post an issue or comment</a></ul>

<div class="noprint">
<p>
<a href="//twitter.com/intent/tweet">Share via Twitter</a>, <a href="//www.facebook.com/sharer/sharer.php" id="sharer">Share via Facebook</a>
</p>
</div>
<h3 id="navigation">Navigation</h3>

<ul>
  <li><a href="BSplineCurve.html">BSplineCurve</a></li>
  <li><a href="BSplineSurface.html">BSplineSurface</a></li>
  <li><a href="BufferAccessor.html">BufferAccessor</a></li>
  <li><a href="Curve.html">Curve</a></li>
  <li><a href="CurveBuilder.html">CurveBuilder</a></li>
  <li><a href="GraphicsPath.html">GraphicsPath</a></li>
  <li><a href="H3DU.html">H3DU</a></li>
  <li><a href="MathUtil.html">MathUtil</a></li>
  <li><a href="MeshBuffer.html">MeshBuffer</a></li>
  <li><a href="Meshes.html">Meshes</a></li>
  <li><a href="PiecewiseCurve.html">PiecewiseCurve</a></li>
  <li><a href="Semantic.html">Semantic</a></li>
  <li><a href="ShapeGroup.html">ShapeGroup</a></li>
  <li><a href="Surface.html">Surface</a></li>
  <li><a href="SurfaceBuilder.html">SurfaceBuilder</a></li>
  <li><a href="Transform.html">Transform</a></li>
  <li><a href="extras_camera.html">module:extras/camera</a></li>
  <li><a href="extras_camera.Camera.html">module:extras/camera.Camera</a></li>
  <li><a href="extras_camera.InputTracker.html">module:extras/camera.InputTracker</a></li>
  <li><a href="extras_createwasher.html">module:extras/createwasher</a></li>
  <li><a href="extras_curvetube.html">module:extras/curvetube</a></li>
  <li><a href="extras_curvetube.CurveTube.html">module:extras/curvetube.CurveTube</a></li>
  <li><a href="extras_derivedcurves.html">module:extras/derivedcurves</a></li>
  <li><a href="extras_evaluators.html">module:extras/evaluators</a></li>
  <li><a href="extras_evaluators.Roulette.html">module:extras/evaluators.Roulette</a></li>
  <li><a href="extras_evaluators.SurfaceOfRevolution.html">module:extras/evaluators.SurfaceOfRevolution</a></li>
  <li><a href="extras_fourierknot.html">module:extras/fourierknot</a></li>
  <li><a href="extras_gradients.html">module:extras/gradients</a></li>
  <li><a href="extras_marbleshader2.html">module:extras/marbleshader2</a></li>
  <li><a href="extras_matrixstack.html">module:extras/matrixstack</a></li>
  <li><a href="extras_matrixstack.MatrixStack.html">module:extras/matrixstack.MatrixStack</a></li>
  <li><a href="extras_moresurfaces.html">module:extras/moresurfaces</a></li>
  <li><a href="extras_moresurfaces.KleinBottle.html">module:extras/moresurfaces.KleinBottle</a></li>
  <li><a href="extras_moresurfaces.MoebiusStrip.html">module:extras/moresurfaces.MoebiusStrip</a></li>
  <li><a href="extras_pathtomesh.html">module:extras/pathtomesh</a></li>
  <li><a href="extras_pathutil.html">module:extras/pathutil</a></li>
  <li><a href="extras_randompolygon.html">module:extras/randompolygon</a></li>
  <li><a href="extras_starpolygon.html">module:extras/starpolygon</a></li>
  <li><a href="extras_superellipsoid.html">module:extras/superellipsoid</a></li>
  <li><a href="extras_superellipsoid.Supershape.html">module:extras/superellipsoid.Supershape</a></li>
  <li><a href="extras_superellipsoid.Supertoroid.html">module:extras/superellipsoid.Supertoroid</a></li>
  <li><a href="extras_tga.html">module:extras/tga</a></li>
  <li><a href="extras_torusknot.html">module:extras/torusknot</a></li>
  <li><a href="extras_torusknot.TorusKnot.html">module:extras/torusknot.TorusKnot</a></li>
</ul>
</nav></body></html>
