<head>
<meta charset=utf-8>
<style>
body { margin: 0px; }
canvas { width:100%; height:100%; overflow: hidden; }
</style>
<script type="text/javascript" src="../glutil_min.js"></script>
<script type="text/javascript" src="implicit.js"></script>
<script type="text/javascript" src="../camera.js"></script>
<script type="text/javascript" src="../frame.js"></script>
<script type="text/javascript" src="demoutil.js"></script>
</head>
<body>
<div style="position:absolute;left:0;top:1em">
<a href="javascript:link1()">Ellipsoid</a>,
<a href="javascript:link2()">Hyperboloid of One Sheet</a>,
<a href="javascript:link3()">Cylinder</a>,
<a href="javascript:link4()">Union: Cylinder and Sphere</a>,
<a href="javascript:link5()">Intersection: Cylinder and Sphere</a>,
<a href="javascript:link6()">Cylinder Minus Sphere</a>,
</div>
<div id="settings" style="position:absolute;left:0;top:3em"></div>
<canvas id=canvas></canvas>
<script id="demo">
//<!--
/*
Written by Peter O. in 2015.

Any copyright is dedicated to the Public Domain.
http://creativecommons.org/publicdomain/zero/1.0/
If you like this, you should donate to Peter O.
at: http://upokecenter.dreamhosters.com/articles/donate-now-2/
*/
if(typeof Math.sign=="undefined"){
 Math.sign=function(x){
  return (x<0) ? -1 : (x==0 ? 0 : 1);
 }
};

function addRange(label,min,max,step,defvalue,func){
 var div=document.createElement("div")
 var lbl=document.createElement("span")
 lbl.innerHTML=label
 var defvaluelbl=document.createElement("span")
 defvaluelbl.innerHTML=defvalue
 var input=document.createElement("input")
 input.setAttribute("type","range")
 input.setAttribute("value",""+defvalue)
 input.setAttribute("min",""+min)
 input.setAttribute("max",""+max)
 input.setAttribute("step",""+step)
 var oldvalue=[defvalue];
 input.addEventListener("input",function(e){
  var val=e.target.value*1.0
  if(oldvalue[0]!=val){
   defvaluelbl.innerHTML=val+""
   if(func)func(val);
   oldvalue[0]=val
  }
 })
 div.appendChild(lbl)
 div.appendChild(input)
 div.appendChild(defvaluelbl)
 return div
}

function setRanges(ranges){
 var settings=document.getElementById("settings")
 settings.innerHTML=""
 for(var i=0;i<ranges.length;i++){
  settings.appendChild(ranges[i]);
 }
}

   function makeMesh(func,resolution){
    // Default resolution is 50
    if(resolution==null)resolution=50
     // create a new mesh
     var mesh=new Mesh();
     // define a color gradient evaluator for
     // demonstration purposes.  Instead of X, Y, and Z,
     // generate a Red/Green/Blue color based on
     // the same parameters U and V as the surface
     // function for 3D points.
     var colorGradient={
      "evaluate":function(u,v){ return [1-u,v,u]; }
     }
     // generate the parametric surface.

     var ev=new SurfaceEval()
      .vertex(func)
    // Specify the color gradient evaluator defined above
      .color(colorGradient)
    // Generate normals for the parametric surface,
    // which is required for lighting to work correctly
      .setAutoNormal(true)
    // Evaluate the surface and generate a triangle
    // mesh, using resolution+1 different U-coordinates ranging
    // from 0 to 1, and resolution+1
    // different V-coordinates ranging from 0 to 1
    // Instead of Mesh.TRIANGLES, we could use
    // Mesh.LINES to create a wireframe mesh,
    // or Mesh.POINTS to create a point mesh.
      .evalSurface(mesh,Mesh.TRIANGLES,resolution,resolution);
    // Surface generated, return the mesh
    return mesh;
  }

function Cylinder(radius){
 this.c=radius*radius;
 this.sample=function(x,y,z){
  return (x*x)+(z*z)-this.c;
 }
}

function Ellipsoid(a,b,c){
 this.a=a*a;
 this.b=b*b;
 this.c=c*c;
 this.sample=function(x,y,z){
  return (x*x/this.a)+(y*y/this.b)+(z*z/this.c)-1;
 }
}

function HyperboloidOneSheet(a,b,c){
 this.a=a*a;
 this.b=b*b;
 this.c=c*c;
 this.sample=function(x,y,z){
  return (x*x/this.a)+(z*z/this.c)-(y*y/this.b)-1;
 }
}

function makeImplicit(func){
 var surf=new ImplicitSurface(func);
 var mesh=new Mesh();
 mesh.color3("blue");
 surf.evalSurface(mesh,48,48,48,-5,5,-5,5,-5,5);
 return mesh;
}

var shapeGroup=new ShapeGroup();
var allsettings={}

function updateMesh(){
 switch(allsettings["current"]){
  case 1:
   return makeImplicit(
    new Ellipsoid(
      allsettings["superel-x"],
      allsettings["superel-y"],
      allsettings["superel-z"]
    ));
  case 2:
   return makeImplicit(
    new HyperboloidOneSheet(
      allsettings["hyp1-x"],
      allsettings["hyp1-y"],
      allsettings["hyp1-z"]
    ));
  case 3:{
   var cyl=new Cylinder(
      allsettings["cylinder-rad"]
   )
   return makeImplicit(cyl);
  }
  case 4:{
   var cyl=new Cylinder(
      allsettings["cylinder-rad"]
   )
   var erad=allsettings["sphere-rad"]
   var ell=new Ellipsoid(erad,erad,erad)
   return makeImplicit(
     ImplicitSurface.union(cyl,ell));
  }
  case 5:{
   var cyl=new Cylinder(
      allsettings["cylinder-rad"]
   )
   var erad=allsettings["sphere-rad"]
   var ell=new Ellipsoid(erad,erad,erad)
   return makeImplicit(
     ImplicitSurface.intersection(cyl,ell));
  }
  case 6:{
   var cyl=new Cylinder(
      allsettings["cylinder-rad"]
   )
   var erad=allsettings["sphere-rad"]
   var ell=new Ellipsoid(erad,erad,erad)
   return makeImplicit(
     ImplicitSurface.difference(cyl,ell));
  }
  default:
   return new Mesh();
 }
}
function updateShape(){
  shapeGroup.removeShape(shapeGroup.shapes[0]);
  shapeGroup.addShape(scene.makeShape(updateMesh()).setMaterial(
    new Material().setParams({
     "diffuse":"black",
     "specular":"white",
     "shininess":10
    })))
}

function pushSetting(ranges,name,label,defvalue,min,max,step){
 if(typeof allsettings[name]=="undefined")
  allsettings[name]=defvalue;
 ranges.push(addRange(label,min,max,step,allsettings[name],function(val){
  allsettings[name]=val
  updateShape();
 }))
}

function link1(){
 allsettings["current"]=1
 var ranges=[]
 pushSetting(ranges,"superel-x","X radius",1,0.05,2.0,0.05);
 pushSetting(ranges,"superel-y","Y radius",1,0.05,2.0,0.05);
 pushSetting(ranges,"superel-z","Z radius",1,0.05,2.0,0.05);
 setRanges(ranges);
 updateShape();
}

function link2(){
 allsettings["current"]=2
 var ranges=[]
 pushSetting(ranges,"hyp1-x","X radius",1,0.05,2.0,0.05);
 pushSetting(ranges,"hyp1-y","Y radius",1,0.05,2.0,0.05);
 pushSetting(ranges,"hyp1-z","Z radius",1,0.05,2.0,0.05);
 setRanges(ranges);
 updateShape();
}

function link3(){
 allsettings["current"]=3
 var ranges=[]
 pushSetting(ranges,"cylinder-rad","Radius",1,0.05,2.0,0.05);
 setRanges(ranges);
 updateShape();
}

function link4(){
 allsettings["current"]=4
 var ranges=[]
 pushSetting(ranges,"cylinder-rad","Cylinder radius",1,0.05,2.0,0.05);
 pushSetting(ranges,"sphere-rad","Sphere radius",1.3,0.05,2.0,0.05);
 setRanges(ranges);
 updateShape();
}
function link5(){
 allsettings["current"]=5
 var ranges=[]
 pushSetting(ranges,"cylinder-rad","Cylinder radius",1,0.05,2.0,0.05);
 pushSetting(ranges,"sphere-rad","Sphere radius",1.3,0.05,2.0,0.05);
 setRanges(ranges);
 updateShape();
}
function link6(){
 allsettings["current"]=6
 var ranges=[]
 pushSetting(ranges,"cylinder-rad","Cylinder radius",1,0.05,2.0,0.05);
 pushSetting(ranges,"sphere-rad","Sphere radius",1.3,0.05,2.0,0.05);
 setRanges(ranges);
 updateShape();
}

  // Create the 3D scene; find the HTML canvas and pass it
  // to Scene3D.
  var scene=new Scene3D(document.getElementById("canvas"));
  scene.setClearColor("white")
  var camera=new Camera(scene,45,1,100);
  camera.setDistance(5);
  var pc=new PrimitiveCounter(scene)
  link1();
  scene.addShape(shapeGroup);
  GLUtil.renderLoop(function(){
   pc.update();
   camera.update();
   scene.render();
  });
//-->
</script>
</body>
