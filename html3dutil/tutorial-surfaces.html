<!DOCTYPE html><html xmlns:dc="http://purl.org/dc/terms/"><head><meta http-equiv=Content-Type content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width"><link rel=stylesheet type="text/css" href="/style.css">
            <script type="text/x-mathjax-config"> MathJax.Hub.Config({"HTML-CSS": { availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, preferredFont: "TeX" },
                    tex2jax: { displayMath: [ ["$$","$$"], ["\\[", "\\]"] ], inlineMath: [ ["$", "$"], ["\\\\(","\\\\)"] ], processEscapes: true } });
            </script><script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"></script></head><body>  <div class="header">
<nav><p><a href="#navigation">Menu</a> - <a href="#top">Top</a> - <a href="/">Home</a></nav></div>
<div class="mainarea" id="top">
<h1 id="parametric-curves-and-parametric-surfaces">Parametric Curves and Parametric Surfaces</h1>

<p><a href="index.html">Back to documentation index.</a></p>

<p><a id="Introduction"></a></p>

<h2 id="introduction">Introduction</h2>

<p>This page describes parametric curves and surfaces and how to generate them using my
public-domain <a href="http://peteroupc.github.io/html3dutil"><strong>Geometry Utilities Library</strong></a>.</p>

<p><strong>Source code for the latest version of the library is available at the</strong> <a href="https://github.com/peteroupc/html3dutil"><strong>Geometry Utilities Library’s project page</strong></a><strong>.</strong></p>

<p><a id="Contents"></a></p>

<h2 id="contents">Contents</h2>

<ul>
  <li><a href="#Introduction"><strong>Introduction</strong></a></li>
  <li><a href="#Contents"><strong>Contents</strong></a></li>
  <li><a href="#What_Is_a_Parametric_Surface"><strong>What Is a Parametric Surface?</strong></a>
    <ul>
      <li><a href="#Why_two_variables"><strong>Why two variables?</strong></a></li>
    </ul>
  </li>
  <li><a href="#Parametric_Surfaces_in_the_Geometry_Utilities_Library"><strong>Parametric Surfaces in the Geometry Utilities Library</strong></a></li>
  <li><a href="#Chaining_Surface_Functions"><strong>Chaining Surface Functions</strong></a></li>
  <li><a href="#Parametric_Curves"><strong>Parametric Curves</strong></a>
    <ul>
      <li><a href="#Generating_Parametric_Curves"><strong>Generating Parametric Curves</strong></a></li>
    </ul>
  </li>
  <li><a href="#Curve_and_Surface_Evaluators_in_the_Geometry_Utilities_Library"><strong>Curve and Surface Evaluators in the Geometry Utilities Library</strong></a></li>
  <li><a href="#Other_Pages"><strong>Other Pages</strong></a></li>
</ul>

<p><a id="What_Is_a_Parametric_Surface"></a></p>

<h2 id="what-is-a-parametric-surface">What Is a Parametric Surface?</h2>

<p>A <em>parametric surface</em> is a surface generated by evaluating the results of a <em>vector function</em>. This vector function takes two numbers, U and V, and returns a 3D point, X, Y, and Z. Each (U, V) point corresponds to an (X, Y, Z)
point that lies on the surface.</p>

<p>A <em>vector function</em> in 3D is a combination of three functions, one for each dimension:</p>

<ul>
  <li><strong>F</strong>(u, v) = [ <em>x</em>(u, v), <em>y</em>(u, v), <em>z</em>(u, v) ];</li>
</ul>

<p>The <em>x</em> function returns an x-coordinate given u and v, and likewise for <em>y</em> and <em>z</em>.
Since the <em>z</em> function returns a z-coordinate, the surface will be in 2D if <em>z</em> always returns
the same value.</p>

<p>For example, if we have a parametric surface defined by the following functions:</p>

<ul>
  <li><em>x</em>(u, v) = u * v</li>
  <li><em>y</em>(u, v) = -u</li>
  <li><em>z</em>(u, v) = u * sqrt(v)</li>
</ul>

<p>and we evaluate the UV point (2, 4), then we have:</p>

<ul>
  <li><strong>F</strong>(2, 4) = [ 2 * 4, -2, 2 * sqrt(4) ];</li>
  <li><strong>F</strong>(2, 4) = [ 8, -2, 4 ];</li>
</ul>

<p>So (8, -2, 4) is one point that lies on this parametric surface, and any other point on the surface can be found by evaluating different UV points. By the way, the surface looks like this:</p>

<p><img src="surfaces1.png" alt="**The parametric surface.**" /></p>

<p><a id="Why_two_variables"></a></p>

<h3 id="why-two-variables">Why two variables?</h3>

<p>The surface functions take two variables, <em>u</em>, and <em>v</em>, because a parametric
surface can be a seen as a “warped” version of a rectangular grid. The vector
function “warps” this grid into a three-dimensional surface.</p>

<p><a id="Parametric_Surfaces_in_the_Geometry_Utilities_Library"></a></p>

<h2 id="parametric-surfaces-in-the-geometry-utilities-library">Parametric Surfaces in the Geometry Utilities Library</h2>

<p>The Geometry Utilities Library supports parametric surfaces using a class named
<a href="http://peteroupc.github.io/html3dutil/H3DU.SurfaceBuilder.html"><strong><code>SurfaceBuilder</code></strong></a>. It helps
generate vertex coordinates and other attributes using a parametric surface
function. The following helper function, <code>makeMesh</code>, generates a parametric surface mesh.
The comments explain how <code>makeMesh</code> works in detail.</p>

<pre>function makeMesh(func,resolutionU, resolutionV){
   "use strict";
   if(typeof resolutionV === "undefined" || resolutionV === null)resolutionV = resolutionU;
   if(typeof resolutionU === "undefined" || resolutionU === null)resolutionU = 50;
   if(typeof resolutionV === "undefined" || resolutionV === null)resolutionV = 50;
      // define a color gradient evaluator for
      // demonstration purposes. Instead of X, Y, and Z,
      // generate a Red/Green/Blue color based on
      // the same parameters U and V as the surface
      // function for 3D points.
   var colorGradient = {
     "evaluate":function(u, v) {
       return [1 - u, v, u];
     }
   };
   return new H3DU.SurfaceBuilder()
      .positionNormal(func)
      .attribute(colorGradient, H3DU.Semantic.COLOR)
     // Evaluate the surface and generate a triangle
     // mesh, using resolution+1 different u-coordinates,
     // and resolution+1 different v-coordinates.
     // Instead of H3DU.Mesh.TRIANGLES, we could use
     // H3DU.Mesh.LINES to create a wireframe mesh,
     // or H3DU.Mesh.POINTS to create a point mesh.
      .evalSurface(H3DU.Mesh.TRIANGLES, resolutionU, resolutionV)
      .toMeshBuffer();
}
</pre>

<p>In the Geometry Utilities Library, surface evaluator objects define a method, <code>evaluate</code>,
which returns a 3D point given a U parameter and a V parameter. (By default, U and
V each range from 0 through 1.)</p>

<p>The following code is a very simple surface evaluator object.</p>

<pre>var evaluator = {
  "evaluate":function(u, v){
    // Take the U parameter as the x-coordinate,
    // the V parameter as the y-coordinate, and 0 as
    // the z-coordinate.
    return [u, v, 0];
  }
};
</pre>

<p>That evaluator simply generates a square at the upper-right quadrant:</p>

<p><img src="surfaces2.png" alt="**The parametric surface.**" /></p>

<p>And the following evaluator generates a circular disc:</p>

<pre>var evaluator = {
  "evaluate":function(u, v){
     // Return disc coordinates.
     return [u*Math.cos(v),u*Math.sin(v),0];
  },
  // Declare the usual range of the coordinates
  "endPoints":function(){ return [0,1,0,Math.PI*2]; }
};
</pre>

<p><img src="surfaces3.png" alt="**The parametric surface.**" /></p>

<p>Now here’s the interesting part: This evaluator returns not a disc,
but a <em>cone</em>, whose length runs along the negative z-axis:</p>

<pre>var evaluator = {
  "evaluate":function(u, v){
     // Return cone coordinates, using the u
     // parameter as the z-axis.
     return [u*Math.cos(v),u*Math.sin(v),-u];
  },
  // Declare the usual range of the coordinates
  "endPoints":function(){ return [0,1,0,Math.PI*2]; }
};
</pre>

<p>The following shape was rotated to show the z-axis; the rotation isn’t perfect.</p>

<p><img src="surfaces4.png" alt="**The parametric surface.**" /></p>

<p>Note that all three examples above use a value named <code>evaluator</code>. A mesh buffer for the surface evaluator can be generated using something like the following:</p>

<pre>var meshBuffer = SurfaceBuilder.surfaceToBuffer(evaluator);
</pre>

<p>The generated 3D mesh buffer from a parametric surface is just like any
other mesh buffer, and the same functions and methods you use for other mesh buffers
can be used on this mesh buffer as well. For more information, see the API references for the <a href="http://peteroupc.github.io/html3dutil/H3DU.MeshBuffer.html"><strong><code>H3DU.MeshBuffer</code></strong></a> and
<a href="http://peteroupc.github.io/html3dutil/H3DU.Shape.html"><strong><code>Shape</code></strong></a> classes.</p>

<p><a id="Chaining_Surface_Functions"></a></p>

<h2 id="chaining-surface-functions">Chaining Surface Functions</h2>

<p>The technique of using surface evaluator objects is very flexible. In fact, you can chain evaluators, using the output of one evaluator as the input of another evaluator. This can be used to transform the surface’s points to new positions.</p>

<p>As an example, we’ll define a new evaluator that shifts the position
of a parametric surface. It takes an existing surface evaluator and the X, Y, and
Z of how many units to shift the surface. Note that this class includes its
own <code>evaluate</code> method, allowing itself to be passed to the <code>H3DU.SurfaceBuilder</code> class’s method
or the makeMesh method above.</p>

<pre>function SurfaceShifter(evaluator, x, y, z) {
 // Shift the surface by X units.
 this.x = x;
 // Shift the surface by Y units.
 this.y = y;
 // Shift the surface by Z units.
 this.z = z;
 this.evaluator = evaluator;
 // Define the surface shifter function
 this.evaluate = function(u, v){
  // Get the coordinates from the source evaluator
  var retval = this.evaluator.evaluate(u, v);
  // Shift the coordinates
  retval[0]+=this.x;
  retval[1]+=this.y;
  retval[2]+=this.z;
  // And return the new coordinates.
  return retval;
 }
 this.endPoints=function(){
  return this.evaluator.endPoints()
 }
}
</pre>

<p>And here’s an example of its use. We’ll take the disc surface given earlier,
and create a SurfaceShifter object that shifts the disc by 3 units horizontally
and vertically (by default, the disc will be centered at the origin (0, 0, 0)).</p>

<pre>// This is the disc surface from before
var evaluator = {
  "evaluate":function(u, v){
     // Extend the range of v
     v*=Math.PI*2;
     // Return circle coordinates.
     return [u*Math.cos(v),u*Math.sin(v),0];
  },
  "endPoints":function() { return [0,Math.PI*2] }
}
// Create a shifter that results in the circle being moved 3 units
// up and 3 units to the right
evaluator = new SurfaceShifter(evaluator, 3, 3, 0);
</pre>

<p><a id="Parametric_Curves"></a></p>

<h2 id="parametric-curves">Parametric Curves</h2>

<p>The Geometry Utilities Library also includes support for generating parametric curves.
A <em>parametric curve</em> is a curve generated by a vector function, like a parametric
surface, except now, the function only uses a single variable, as shown below:</p>

<ul>
  <li><strong>C</strong>(u) = [ <em>x</em>(u), <em>y</em>(u), <em>z</em>(u) ];</li>
</ul>

<p>As before, the <em>x</em>, <em>y</em>, and <em>z</em> functions return the corresponding
coordinates of the curve.
And each (U) point corresponds to an (X, Y, Z) point that lies on the curve.</p>

<p>The curve function takes a single <em>u</em> variable because a parametric
curve can be a seen as a “warped” version of a line.</p>

<p>One simple example of a parametric curve is a circle. In fact, the same source
code for the disc surface given above can also serve as the parametric curve
function for the circle, since it only uses the variable <em>u</em>, not <em>v</em>.</p>

<p>Note that any surface evaluator that only uses <em>u</em> can easily serve as a
parametric curve evaluator, and so can any surface in which the <em>v</em> parameter is
kept to the same value, such as 0, 1, or any other constant number.</p>

<p><a id="Generating_Parametric_Curves"></a></p>

<h3 id="generating-parametric-curves">Generating Parametric Curves</h3>

<p>The Geometry Utilities Library’s <code>CurveBuilder</code> class generates vertices for
a parametric curve.</p>

<p>Use code like the following to generate a mesh describing a parametric
curve. It assumes that <code>evaluator</code> is a parametric curve object, just like
the circle example above.</p>

<pre>var meshBuffer = CurveBuilder.curveToBuffer(evaluator);
</pre>

<p><a id="Curve_and_Surface_Evaluators_in_the_Geometry_Utilities_Library"></a></p>

<h2 id="curve-and-surface-evaluators-in-the-geometry-utilities-library">Curve and Surface Evaluators in the Geometry Utilities Library</h2>

<p>The Geometry Utilities Library distribution includes the following evaluators of
curves and surfaces. All the classes named below include an <code>evaluate</code>
method that returns 3D points lying on the curve or surface.</p>

<p>General-purpose curves include:</p>

<ul>
  <li><strong>B-spline curves.</strong> These curves consist of control points (which control
the shape of the curve but don’t necessarily lie on the curve), and a
<em>knot vector</em>, which controls the behavior of the control points. B-spline
curves include <strong>NURBS</strong> curves (nonuniform and rational B-spline curves,
with weights and non-uniform knots), making them a powerful way of setting the
behavior of a curve. B-Spline curves are created using the
 <a href="BSplineCurve.html">BSplineCurve</a> class.</li>
  <li><strong>Bézier curves.</strong> These are curves in which the first and last
control point are the curve’s end points. Bézier curves are a subset of B-spline
curves and are created using the <a href="BSplineCurve.html#BSplineCurve.fromBezierCurve">BSplineCurve.fromBezierCurve</a>
method.</li>
  <li><strong>Piecewise curves.</strong> These are curves made up of one or more other curves.
Piecewise curves are created using the <a href="PiecewiseCurve.html">PiecewiseCurve</a> class.</li>
</ul>

<p>General-purpose surfaces include:</p>

<ul>
  <li><strong>Bézier surfaces.</strong> 3D surfaces where each grid line is a Bézier
curve. Bézier surfaces are created using the <a href="BSplineSurface.html#BSplineSurface.fromBezierSurface">BSplineSurface.fromBezierSurface</a> method.</li>
  <li><strong>B-Spline surfaces.</strong> 3D surfaces where each grid line is a B-Spline or NURBS
curve. B-Spline surfaces are created using the <a href="BSplineSurface.html">BSplineSurface</a> class.</li>
</ul>

<p>Special surfaces include:</p>

<ul>
  <li><strong>Tubes.</strong> 3D surfaces in the form of a “thickened” 3D curve.
Tubes are created using the CurveTube class,
a supplemental extra in the Geometry Utilities Library.</li>
  <li><strong>Surfaces of revolution.</strong> Surfaces generated by rotating a 2D curve.
Surfaces of revolution are created using the SurfaceOfRevolution class,
a supplemental extra in the Geometry Utilities Library.</li>
</ul>

<p><a id="Other_Pages"></a></p>

<h2 id="other-pages">Other Pages</h2>

<p>The following pages of mine on CodeProject also discuss the Geometry Utilities Library, formerly the Public-Domain HTML 3D Library:</p>

<ul>
  <li><a href="http://www.codeproject.com/Tips/896839/Public-Domain-HTML-ThreeD-Library"><strong><em>Public-Domain HTML 3D Library</em></strong></a></li>
  <li><a href="http://www.codeproject.com/Tips/987914/Creating-shapes-using-the-Public-Domain-HTML-D-Lib"><strong><em>Creating shapes using the Public Domain HTML 3D Library</em></strong></a></li>
  <li><a href="http://www.codeproject.com/Tips/989978/The-Camera-and-the-Projection-and-View-Transforms"><strong><em>The “Camera” and the Projection and View Transforms</em></strong></a></li>
  <li><a href="http://www.codeproject.com/Articles/993433/Graphics-Filters-for-the-HTML-D-Canvas"><strong><em>Graphics Filters for the HTML 3D Canvas</em></strong></a></li>
</ul>

<p><a href="index.html">Back to documentation index.</a></p>
</div><nav id="navigation"><ul>
<li><a href="/">Back to start site.</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io">This site's repository (source code)</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io/issues">Post an issue or comment</a></ul>

<div class="noprint">
<p>
<a href="//twitter.com/intent/tweet">Share via Twitter</a>, <a href="//www.facebook.com/sharer/sharer.php" id="sharer">Share via Facebook</a>
</p>
</div>
<h3 id="navigation">Navigation</h3>

<ul>
  <li><a href="BSplineCurve.html">BSplineCurve</a></li>
  <li><a href="BSplineSurface.html">BSplineSurface</a></li>
  <li><a href="BufferAccessor.html">BufferAccessor</a></li>
  <li><a href="Curve.html">Curve</a></li>
  <li><a href="CurveBuilder.html">CurveBuilder</a></li>
  <li><a href="GraphicsPath.html">GraphicsPath</a></li>
  <li><a href="H3DU.html">H3DU</a></li>
  <li><a href="MathUtil.html">MathUtil</a></li>
  <li><a href="MeshBuffer.html">MeshBuffer</a></li>
  <li><a href="Meshes.html">Meshes</a></li>
  <li><a href="PiecewiseCurve.html">PiecewiseCurve</a></li>
  <li><a href="Semantic.html">Semantic</a></li>
  <li><a href="ShapeGroup.html">ShapeGroup</a></li>
  <li><a href="Surface.html">Surface</a></li>
  <li><a href="SurfaceBuilder.html">SurfaceBuilder</a></li>
  <li><a href="Transform.html">Transform</a></li>
  <li><a href="extras_camera.html">module:extras/camera</a></li>
  <li><a href="extras_camera.Camera.html">module:extras/camera.Camera</a></li>
  <li><a href="extras_camera.InputTracker.html">module:extras/camera.InputTracker</a></li>
  <li><a href="extras_createwasher.html">module:extras/createwasher</a></li>
  <li><a href="extras_curvetube.html">module:extras/curvetube</a></li>
  <li><a href="extras_curvetube.CurveTube.html">module:extras/curvetube.CurveTube</a></li>
  <li><a href="extras_derivedcurves.html">module:extras/derivedcurves</a></li>
  <li><a href="extras_evaluators.html">module:extras/evaluators</a></li>
  <li><a href="extras_evaluators.Roulette.html">module:extras/evaluators.Roulette</a></li>
  <li><a href="extras_evaluators.SurfaceOfRevolution.html">module:extras/evaluators.SurfaceOfRevolution</a></li>
  <li><a href="extras_fourierknot.html">module:extras/fourierknot</a></li>
  <li><a href="extras_gradients.html">module:extras/gradients</a></li>
  <li><a href="extras_marbleshader2.html">module:extras/marbleshader2</a></li>
  <li><a href="extras_matrixstack.html">module:extras/matrixstack</a></li>
  <li><a href="extras_matrixstack.MatrixStack.html">module:extras/matrixstack.MatrixStack</a></li>
  <li><a href="extras_moresurfaces.html">module:extras/moresurfaces</a></li>
  <li><a href="extras_moresurfaces.KleinBottle.html">module:extras/moresurfaces.KleinBottle</a></li>
  <li><a href="extras_moresurfaces.MoebiusStrip.html">module:extras/moresurfaces.MoebiusStrip</a></li>
  <li><a href="extras_pathtomesh.html">module:extras/pathtomesh</a></li>
  <li><a href="extras_pathutil.html">module:extras/pathutil</a></li>
  <li><a href="extras_randompolygon.html">module:extras/randompolygon</a></li>
  <li><a href="extras_starpolygon.html">module:extras/starpolygon</a></li>
  <li><a href="extras_superellipsoid.html">module:extras/superellipsoid</a></li>
  <li><a href="extras_superellipsoid.Supershape.html">module:extras/superellipsoid.Supershape</a></li>
  <li><a href="extras_superellipsoid.Supertoroid.html">module:extras/superellipsoid.Supertoroid</a></li>
  <li><a href="extras_tga.html">module:extras/tga</a></li>
  <li><a href="extras_torusknot.html">module:extras/torusknot</a></li>
  <li><a href="extras_torusknot.TorusKnot.html">module:extras/torusknot.TorusKnot</a></li>
</ul>
</nav></body></html>
