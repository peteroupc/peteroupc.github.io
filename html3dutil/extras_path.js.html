<!DOCTYPE html>
<html lang="en">
<head><meta charset="utf-8"><title>JSDoc: Source: extras/path.js</title>
<script src="mathml.js"></script>
<link rel=stylesheet type="text/css" href="/style.css">
</head>
<body style="margin-top:0px">
<div style="width:75%;float:left;">
    <h1>Source: extras/path.js</h1>

    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*
Written by Peter O. in 2015.

Any copyright is dedicated to the Public Domain.
http://creativecommons.org/publicdomain/zero/1.0/
If you like this, you should donate to Peter O.
at: http://upokecenter.dreamhosters.com/articles/donate-now-2/
*/
/**
* Represents a two-dimensional path.
* &lt;p>This class is considered a supplementary class to the
* Public Domain HTML 3D Library and is not considered part of that
* library. &lt;p>
* To use this class, you must include the script "extras/path.js"; the
 * class is not included in the "glutil_min.js" file which makes up
 * the HTML 3D Library.  Example:&lt;pre>
 * &amp;lt;script type="text/javascript" src="extras/path.js">&amp;lt;/script>&lt;/pre>
* @class
*/
function GraphicsPath(){
 this.segments=[]
 this.incomplete=false
 this.startPos=[0,0]
 this.endPos=[0,0]
}
GraphicsPath.CLOSE=0
GraphicsPath.LINE=1
GraphicsPath.QUAD=2
GraphicsPath.CUBIC=3
GraphicsPath.ARC=4
/**
* Returns whether the curve path is incomplete
* because of an error in parsing the curve string.
* This flag will be reset if a moveTo command,
* closePath command, or another path segment
* is added to the path.
* @return {boolean} Return value.*/
GraphicsPath.prototype.isIncomplete=function(){
 return this.incomplete
}
GraphicsPath._startPoint=function(a){
 if(a[0]==GraphicsPath.CLOSE){
  return [0,0]
 } else {
  return [a[1],a[2]]
 }
}
GraphicsPath._endPoint=function(a){
 if(a[0]==GraphicsPath.CLOSE){
  return [0,0]
 } else if(a[0]==GraphicsPath.ARC){
  return [a[8],a[9]]
 } else {
  return [a[a.length-2],a[a.length-1]]
 }
}
GraphicsPath._point=function(seg,t){
 if(seg[0]==GraphicsPath.CLOSE){
  return [0,0]
 } else if(seg[0]==GraphicsPath.LINE){
  return [
   seg[1]+(seg[3]-seg[1])*t,
   seg[2]+(seg[4]-seg[2])*t
  ]
 } else if(seg[0]==GraphicsPath.QUAD){
  var mt=1-t;
  var mtsq=mt*mt;
  var mt2=(mt+mt);
  var a,b;
  a=seg[1]*mtsq;
  b=seg[3]*mt2;
  var x=a+t*(b+t*seg[5]);
  a=seg[2]*mtsq;
  b=seg[4]*mt2
  var y=a+t*(b+t*seg[6]);
  return [x,y];
 } else if(seg[0]==GraphicsPath.CUBIC){
  var a=(seg[3]-seg[1])*3;
  var b=(seg[5]-seg[3])*3-a;
  var c=seg[7]-a-b-seg[1];
  var x=seg[1]+t*(a+t*(b+t*c));
  a=(seg[4]-seg[2])*3;
  b=(seg[6]-seg[4])*3-a;
  c=seg[8]-a-b-seg[2];
  var y=seg[2]+t*(a+t*(b+t*c));
  return [x,y];
 } else if(seg[0]==GraphicsPath.ARC){
  if(t==0)return [seg[1],seg[2]]
  if(t==1)return [seg[8],seg[9]]
  var rx=seg[3]
  var ry=seg[4]
  var cx=seg[10]
  var cy=seg[11]
  var theta=seg[12]
  var delta=(seg[13]-seg[12])
  var rot=seg[5]
  var angle=theta+delta*t
  var cr = Math.cos(rot);
  var sr = (rot>=0 &amp;&amp; rot&lt;6.283185307179586) ? (rot&lt;=3.141592653589793 ? Math.sqrt(1.0-cr*cr) : -Math.sqrt(1.0-cr*cr)) : Math.sin(rot);
  var ca = Math.cos(angle);
  var sa = (angle>=0 &amp;&amp; angle&lt;6.283185307179586) ? (angle&lt;=3.141592653589793 ? Math.sqrt(1.0-ca*ca) : -Math.sqrt(1.0-ca*ca)) : Math.sin(angle);
  return [
   cr*ca*rx-sr*sa*ry+cx,
   sr*ca*rx+cr*sa*ry+cy]
 } else {
  return [0,0]
 }
}

GraphicsPath._flattenCubic=function(a1,a2,a3,a4,a5,a6,a7,a8,t1,t2,list,flatness,mode,depth){
 if(depth==null)depth=0
 if(depth>=20 || Math.abs(a1-a3-a3+a5)+Math.abs(a3-a5-a5+a7)+
    Math.abs(a2-a4-a4+a6)+Math.abs(a4-a6-a6+a8)&lt;=flatness){
  if(mode==0){
   list.push([a1,a2,a7,a8])
  } else {
   var dx=a7-a1
   var dy=a8-a2
   var length=Math.sqrt(dx*dx+dy*dy)
   list.push(t1,t2,length)
  }
 } else {
  var x1=(a1+a3)*0.5
  var x2=(a3+a5)*0.5
  var xc1=(x1+x2)*0.5
  var x3=(a5+a7)*0.5
  var xc2=(x2+x3)*0.5
  var xd=(xc1+xc2)*0.5
  var y1=(a2+a4)*0.5
  var y2=(a4+a6)*0.5
  var yc1=(y1+y2)*0.5
  var y3=(a6+a8)*0.5
  var yc2=(y2+y3)*0.5
  var yd=(yc1+yc2)*0.5
  var tmid=(t1+t2)*0.5
  GraphicsPath._flattenCubic(a1,a2,x1,y1,xc1,yc1,xd,yd,t1,tmid,list,flatness,mode,depth+1)
  GraphicsPath._flattenCubic(xd,yd,xc2,yc2,x3,y3,a7,a8,tmid,t2,list,flatness,mode,depth+1)
 }
}

GraphicsPath._flattenQuad=function(a1,a2,a3,a4,a5,a6,t1,t2,list,flatness,mode,depth){
 if(depth==null)depth=0
 if(depth>=20 || Math.abs(a1-a3-a3+a5)+Math.abs(a2-a4-a4+a6)&lt;=flatness){
  if(mode==0){
   list.push([a1,a2,a5,a6])
  } else {
   var dx=a5-a1
   var dy=a6-a2
   var length=Math.sqrt(dx*dx+dy*dy)
   list.push(t1,t2,length)
  }
 } else {
  var x1=(a1+a3)*0.5
  var x2=(a3+a5)*0.5
  var xc=(x1+x2)*0.5
  var y1=(a2+a4)*0.5
  var y2=(a4+a6)*0.5
  var yc=(y1+y2)*0.5
  var tmid=(t1+t2)*0.5
  GraphicsPath._flattenQuad(a1,a2,x1,y1,xc,yc,t1,tmid,list,flatness,mode,depth+1)
  GraphicsPath._flattenQuad(xc,yc,x2,y2,a5,a6,tmid,t2,list,flatness,mode,depth+1)
 }
}

GraphicsPath._flattenArc=function(a,t1,t2,list,flatness,mode,depth){
 var rot=a[5]
 var crot=Math.cos(rot)
 var srot=Math.sin(rot)
 var ellipseInfo=[a[3],a[4],a[10],a[11],crot,srot]
 GraphicsPath._flattenArcInternal(ellipseInfo,a[1],a[2],a[8],a[9],a[12],a[13],t1,t2,list,flatness,mode,depth);
}
GraphicsPath._flattenArcInternal=function(ellipseInfo,x1,y1,x2,y2,theta1,theta2,t1,t2,list,flatness,mode,depth){
 if(depth==null)depth=0
 var thetaMid=(theta1+theta2)*0.5
 var tmid=(t1+t2)*0.5
 var ca = Math.cos(thetaMid);
 var sa = (thetaMid>=0 &amp;&amp; thetaMid&lt;6.283185307179586) ? (thetaMid&lt;=3.141592653589793 ? Math.sqrt(1.0-ca*ca) : -Math.sqrt(1.0-ca*ca)) : Math.sin(thetaMid);
 var xmid = ellipseInfo[4]*ca*ellipseInfo[0]-ellipseInfo[5]*sa*ellipseInfo[1]+ellipseInfo[2]
 var ymid = ellipseInfo[5]*ca*ellipseInfo[0]+ellipseInfo[4]*sa*ellipseInfo[1]+ellipseInfo[3]
 if(depth>=20 || Math.abs(x1-xmid-xmid+x2)+Math.abs(y1-ymid-ymid+y2)&lt;=flatness){
  if(mode==0){
   list.push([x1,y1,xmid,ymid])
   list.push([xmid,ymid,x2,y2])
  } else {
   var dx=xmid-x1
   var dy=ymid-y1
   var length=Math.sqrt(dx*dx+dy*dy)
   list.push(t1,tmid,length)
   dx=x2-xmid
   dy=y2-ymid
   length=Math.sqrt(dx*dx+dy*dy)
   list.push(tmid,t2,length)
  }
 } else {
  GraphicsPath._flattenArcInternal(ellipseInfo,x1,y1,xmid,ymid,theta1,thetaMid,t1,tmid,list,flatness,mode,depth+1)
  GraphicsPath._flattenArcInternal(ellipseInfo,xmid,ymid,x2,y2,thetaMid,theta2,tmid,t2,list,flatness,mode,depth+1)
 }
}
/** @private */
GraphicsPath.prototype._start=function(){
 for(var i=0;i&lt;this.segments.length;i++){
  var s=this.segments[i]
  if(s[0]!=GraphicsPath.CLOSE)return GraphicsPath._startPoint(s)
 }
 return [0,0]
}
/** @private */
GraphicsPath.prototype._end=function(){
 for(var i=this.segments.length-1;i>=0;i--){
  var s=this.segments[i]
  if(s[0]!=GraphicsPath.CLOSE)return GraphicsPath._endPoint(s)
 }
 return [0,0]
}
/**
 * Returns this path in the form of a string in SVG path format.
 * @return {string} Return value. */
GraphicsPath.prototype.toString=function(){
 var oldpos=null
 var ret=""
 for(var i=0;i&lt;this.segments.length;i++){
  var a=this.segments[i]
  if(a[0]==GraphicsPath.CLOSE){
   ret+="Z"
  } else {
   var start=GraphicsPath._startPoint(a)
   if(!oldpos || oldpos[0]!=start[0] || oldpos[1]!=start[1]){
    ret+="M"+start[0]+","+start[1]
   }
   if(a[0]==GraphicsPath.LINE){
    ret+="L"+a[3]+","+a[4]
   }
   if(a[0]==GraphicsPath.QUAD){
    ret+="Q"+a[3]+","+a[4]+","+a[5]+","+a[6]
   }
   if(a[0]==GraphicsPath.CUBIC){
    ret+="C"+a[3]+","+a[4]+","+a[5]+","+a[6]+","+a[7]+","+a[8]
   }
   if(a[0]==GraphicsPath.ARC){
    ret+="A"+a[3]+","+a[4]+","+(a[5]*180/Math.PI)+","+
      (a[6] ? "1" : "0")+(a[7] ? "1" : "0")+a[8]+","+a[9]
   }
  }
 }
 return ret
}
GraphicsPath._length=function(a,flatness){
 if(a[0]==GraphicsPath.LINE){
  var dx=a[3]-a[1]
  var dy=a[4]-a[2]
  return Math.sqrt(dx*dx+dy*dy)
 } else if(a[0]==GraphicsPath.QUAD){
   var flat=[]
   var len=0
   GraphicsPath._flattenQuad(a[1],a[2],a[3],a[4],
     a[5],a[6],0.0,1.0,flat,flatness*2,1)
   for(var j=0;j&lt;flat.length;j+=3){
    len+=flat[j+2]
   }
   return len
  } else if(a[0]==GraphicsPath.CUBIC){
   var flat=[]
   var len=0
   GraphicsPath._flattenCubic(a[1],a[2],a[3],a[4],
     a[5],a[6],a[7],a[8],0.0,1.0,flat,flatness*4,1)
   for(var j=0;j&lt;flat.length;j+=3){
    len+=flat[j+2]
   }
   return len
 } else if(a[0]==GraphicsPath.ARC){
  var rx=a[3]
  var ry=a[4]
  var theta=a[12]
  var theta2=a[13]
  return GraphicsPath._ellipticArcLength(rx,ry,theta,theta2)
 } else {
  return 0
 }
}

/**
 * Finds the approximate length of this path.
* @param {number} [flatness] When quadratic and cubic
* curves are decomposed to
* line segments for the purpose of calculating their length, the
* segments will generally be close to the true path of the curve by
* up to this value, given in units.  If null or omitted, default is 1.
 * @return {number} Approximate length of this path
 * in units.
 */
GraphicsPath.prototype.pathLength=function(flatness){
 if(this.segments.length==0)return 0;
 var totalLength=0
 if(flatness==null)flatness=1.0
 for(var i=0;i&lt;this.segments.length;i++){
  var s=this.segments[i]
  var len=GraphicsPath._length(s,flatness)
  totalLength+=len
 }
 return totalLength;
}
/**
* Gets an array of line segments approximating
* the path.
* @param {number} [flatness] When curves and arc
* segments are decomposed to line segments, the
* segments will be close to the true path of the curve by this
* value, given in units.  If null or omitted, default is 1.
* @return {Array&lt;Array&lt;number>>} Array of line segments.
* Each line segment is an array of four numbers: the X and
* Y coordinates of the start point, respectively, then the X and
* Y coordinates of the end point, respectively.
*/
GraphicsPath.prototype.getLines=function(flatness){
 var ret=[]
 if(flatness==null)flatness=1.0
 for(var i=0;i&lt;this.segments.length;i++){
  var s=this.segments[i]
  var len=0
  if(s[0]==GraphicsPath.QUAD){
   GraphicsPath._flattenQuad(s[1],s[2],s[3],s[4],
     s[5],s[6],0.0,1.0,ret,flatness*2,0)
  } else if(s[0]==GraphicsPath.CUBIC){
   GraphicsPath._flattenCubic(s[1],s[2],s[3],s[4],
     s[5],s[6],s[7],s[8],0.0,1.0,ret,flatness*4,0)
  } else if(s[0]==GraphicsPath.ARC){
   GraphicsPath._flattenArc(s,0.0,1.0,ret,flatness*4,0)
  } else if(s[0]!=GraphicsPath.CLOSE){
   ret.push([s[1],s[2],s[3],s[4]])
  }
 }
 return ret
}
/** @private */
GraphicsPath.prototype._getSubpaths=function(flatness){
 var tmp=[]
 var subpaths=[]
 if(flatness==null)flatness=1.0
 var lastptx=0
 var lastpty=0
 var first=true
 var curPath=null
 for(var i=0;i&lt;this.segments.length;i++){
  var s=this.segments[i]
  var len=0
  var startpt=GraphicsPath._startPoint(s)
  var endpt=GraphicsPath._endPoint(s)
  tmp.length=0
  if(s[0]!=GraphicsPath.CLOSE){
   if(first || lastptx!=startpt[0] || lastpty!=startpt[1]){
    curPath=startpt
    subpaths.push(curPath)
    first=false
   }
   lastptx=endpt[0]
   lastpty=endpt[1]
  }
  if(s[0]==GraphicsPath.QUAD){
   GraphicsPath._flattenQuad(s[1],s[2],s[3],s[4],
     s[5],s[6],0.0,1.0,tmp,flatness*2,0)
   for(var j=0;j&lt;tmp.length;j++){
    curPath.push(tmp[j][2])
    curPath.push(tmp[j][3])
   }
  } else if(s[0]==GraphicsPath.CUBIC){
   GraphicsPath._flattenCubic(s[1],s[2],s[3],s[4],
     s[5],s[6],s[7],s[8],0.0,1.0,tmp,flatness*4,0)
   for(var j=0;j&lt;tmp.length;j++){
    curPath.push(tmp[j][2])
    curPath.push(tmp[j][3])
   }
  } else if(s[0]==GraphicsPath.ARC){
   GraphicsPath._flattenArc(s,0.0,1.0,tmp,flatness*4,0)
   for(var j=0;j&lt;tmp.length;j++){
    curPath.push(tmp[j][2])
    curPath.push(tmp[j][3])
   }
  } else if(s[0]!=GraphicsPath.CLOSE){
   curPath.push(s[3])
   curPath.push(s[4])
  }
 }
 return subpaths
}

/**
* Converts the subpaths in this path to triangles.
* Treats each subpath as a polygon even if it isn't closed.
* Each subpath should currently be a simple polygon (one without
* self-intersections, duplicate vertices, or holes), except if the
* subpath contains duplicate vertices that appear at the start and end.
* @param {number} [flatness] When curves and arcs
* are decomposed to line segments, the
* segments will be close to the true path of the curve by this
* value, given in units.  If null or omitted, default is 1.
* @return {Array&lt;Array&lt;number>>} Array of six-element
* arrays describing a single triangle.  For each six-element
* array, the first two, next two, and last two numbers each
* describe a vertex position of that triangle (X and Y coordinates
* in that order.
*/
GraphicsPath.prototype.getTriangles=function(flatness){
 var subpaths=this._getSubpaths(flatness)
 var tris=[]
 for(var i=0;i&lt;subpaths.length;i++){
  Triangulate._triangulate(subpaths[i],tris)
 }
 return tris
}

/**
* Gets an array of points evenly spaced across the length
* of the path.
* @param {number} numPoints Number of points to return.
* @param {number} [flatness] When curves and arcs
* are decomposed to line segments for the purpose of
* calculating their length, the
* segments will be close to the true path of the curve by this
* value, given in units.  If null or omitted, default is 1.
* @return {Array&lt;Array&lt;number>>} Array of points lying on
* the path and evenly spaced across the length of the path,
* starting and ending with the path's endpoints.  Returns
* an empty array if &lt;i>numPoints&lt;/i> is less than 1.  Returns
* an array consisting of the start point if &lt;i>numPoints&lt;/i>
* is 1.
*/
GraphicsPath.prototype.getPoints=function(numPoints,flatness){
 if(numPoints&lt;1)return []
 if(numPoints==1){
  return [this._start()]
 }
 if(numPoints==2){
  return [this._start(),this._end()]
 }
 if(flatness==null)flatness=1.0
 var steps=numPoints-1
 var lengths=[]
 var flattenedCurves=[]
 var curFlat=0
 var totalLength=0
 var curLength=0
 for(var i=0;i&lt;this.segments.length;i++){
  var s=this.segments[i]
  var len=0
  if(s[0]==GraphicsPath.QUAD){
   var flat=[]
   GraphicsPath._flattenQuad(s[1],s[2],s[3],s[4],
     s[5],s[6],0.0,1.0,flat,flatness*2,1)
   for(var j=0;j&lt;flat.length;j+=3){
    len+=flat[j+2]
   }
   flattenedCurves.push(flat)
  } else if(s[0]==GraphicsPath.CUBIC){
   var flat=[]
   GraphicsPath._flattenCubic(s[1],s[2],s[3],s[4],
     s[5],s[6],s[7],s[8],0.0,1.0,flat,flatness*4,1)
   for(var j=0;j&lt;flat.length;j+=3){
    len+=flat[j+2]
   }
   flattenedCurves.push(flat)
  } else if(s[0]==GraphicsPath.ARC){
   var flat=[]
   GraphicsPath._flattenArc(s,0.0,1.0,flat,flatness*4,1)
   for(var j=0;j&lt;flat.length;j+=3){
    len+=flat[j+2]
   }
   flattenedCurves.push(flat)
  } else {
   len=GraphicsPath._length(s,0)
  }
  lengths.push(len)
  totalLength+=len
 }
 var stepLength=totalLength/(numPoints-1);
 var nextStep=stepLength
 var count=1
 var ret=[this._start()]
 for(var i=0;i&lt;this.segments.length;i++){
  var s=this.segments[i]
  var segLength=lengths[i]
  if(s[0]==GraphicsPath.QUAD || s[0]==GraphicsPath.CUBIC ||
     s[0]==GraphicsPath.ARC){
   var flatCurve=flattenedCurves[curFlat]
   if(segLength>0){
    for(var j=0;j&lt;flatCurve.length;j+=3){
     var flatSegLength=flatCurve[j+2]
     if(flatSegLength>0){
      var endLen=curLength+flatSegLength;
      while(endLen>=nextStep &amp;&amp; count&lt;numPoints-1){
       var t=(flatSegLength-(endLen-nextStep))/flatSegLength
       t=flatCurve[j]+(flatCurve[j+1]-flatCurve[j])*t;
       ret.push(GraphicsPath._point(s,t));
       count++
       nextStep+=stepLength
       if(count>=numPoints-1)
        break;
      }
     }
     curLength+=flatSegLength
    }
   }
   curFlat++;
  } else if(s[0]==GraphicsPath.LINE &amp;&amp; segLength>0){
   var endLen=curLength+segLength;
   while(endLen>=nextStep &amp;&amp; count&lt;numPoints-1){
    var t=(segLength-(endLen-nextStep))/segLength
    ret.push(GraphicsPath._point(s,t));
    count++
    nextStep+=stepLength
    if(count>=numPoints-1)
     break;
   }
   curLength+=segLength
  }
 }
 while(ret.length&lt;numPoints-1){
  ret.push(ret[ret.length-1])
 }
 ret.push(this._end())
 return ret
}
/**
 * Makes this path closed.  Adds a line segment to the
 * path's start position, if necessary.
 * @return {GraphicsPath} This object.
 */
GraphicsPath.prototype.closePath=function(){
 if(this.startPos[0]!=this.endPos[0] ||
   this.startPos[1]!=this.endPos[1]){
  this.lineTo(this.startPos[0],this.startPos[1])
 }
 if(this.segments.length>0){
  this.segments.push([GraphicsPath.CLOSE])
 }
 this.incomplete=false
 return this;
}
/**
 * Moves the current start position and end position.
 * @param {number} x
 * @param {number} y
 * @return {GraphicsPath} This object.
 */
GraphicsPath.prototype.moveTo=function(x,y){
 this.startPos[0]=x
 this.startPos[1]=y
 this.endPos[0]=x
 this.endPos[1]=y
 this.incomplete=false
 return this
}
/**
 * Adds a line segment to the path, starting
 * at the path's end position, then
 * sets the end position to the end of the segment.
 * @param {number} x X-coordinate of the end of the line segment.
 * @param {number} y Y-coordinate of the end of the line segment.
 * @return {GraphicsPath} This object.
 */
GraphicsPath.prototype.lineTo=function(x,y){
 this.segments.push([GraphicsPath.LINE,
  this.endPos[0],this.endPos[1],x,y])
 this.endPos[0]=x
 this.endPos[1]=y
 this.incomplete=false
 return this
}

GraphicsPath._areCollinear=function(x0,y0,x1,y1,x2,y2){
  var t1 = x1 - x0;
  var t2 = y1 - y0;
  var t3 = [x2 - x0, y2 - y0];
  var denom=((t1 * t1) + t2 * t2);
  if(denom==0){
   return true; // first two points are the same
  }
  var t4 = (((t1 * t3[0]) + t2 * t3[1]) / denom);
  var t5 = [(x0 + t4 * t1), (y0 + t4 * t2)];
  var t6 = [x2 - t5[0], y2 - t5[1]];
  return ((t6[0] * t6[0]) + t6[1] * t6[1])==0;
}
/**
 * Adds path segments in the form of a circular arc to this path,
 * using the parameterization specified in the "arcTo" method of the
 * HTML Canvas 2D Context.
 * @param {number} x1 X-coordinate of a point that, along with the
 * current end point, forms a tangent line.  The point where the
 * circle touches this tangent line is the start point of the arc, and if the
 * point isn't the same as the current end point, this method adds
 * a line segment connecting the two points.
 * @param {number} y1 Y-coordinate of the point described above.
 * @param {number} x2 X-coordinate of a point that, along with the
 * point (x1, y1), forms a tangent line.  The point where the
 * circle touches this tangent line is the end point of the arc.
 * @param {number} y2 Y-coordinate of the point described above.
 * @param {number} radius Radius of the circle the arc forms a part of.
 * @return {GraphicsPath} This object.
 */
GraphicsPath.prototype.arcTo=function(x1,y1,x2,y2,radius){
 if(radius&lt;0){
  throw new Error("IndexSizeError")
 }
 var x0=this.endPos[0]
 var y0=this.endPos[1]
 if(radius==0 || (x0==x1 &amp;&amp; y0==y1) || (x1==x2 &amp;&amp; y1==y2) ||
   GraphicsPath._areCollinear(x0,y0,x1,y1,x2,y2)){
  return this.lineTo(x1,y1)
 }
  var t1 = [x0 - x1, y0 - y1];
  var t2 = 1.0/Math.sqrt(((t1[0] * t1[0]) + t1[1] * t1[1]));
  var t3 = [t1[0] * t2, t1[1] * t2]; // tangent vector from p1 to p0
  var t4 = [x2 - x1, y2 - y1];
  var t5 = 1.0/Math.sqrt(((t4[0] * t4[0]) + t4[1] * t4[1]));
  var t6 = [t4[0] * t5, t4[1] * t5]; // tangent vector from p2 to p1
  var cross = t3[0] * t6[1] - t3[1] * t6[0];
  var t7 = (((1.0 + ((t3[0] * t6[0]) + t3[1] * t6[1]))) * radius / Math.abs(cross));
  var t8 = [t3[0] * t7, t3[1] * t7];
  var t10 = [t6[0] * t7, t6[1] * t7];
  var startTangent = [x1 + t8[0], y1 + t8[1]];
  var endTangent = [x1 + t10[0], y1 + t10[1]];
  this.lineTo(startTangent[0],startTangent[1]);
  var sweep=(cross&lt;0);
  return this.arcSvgTo(radius,radius,0,false,sweep,endTangent[0],endTangent[1]);
}
/**
 * Adds path segments in the form of a circular arc to this path,
 * using the parameterization specified in the "arc" method of the
 * HTML Canvas 2D Context.
 * @return {GraphicsPath} This object.
 * @param {number} x X-coordinate of the center of the circle that the arc forms a part of.
 * @param {number} y Y-coordinate of the circle's center.
 * @param {number} radius Radius of the circle's center.
 * @param {number} startAngle Starting angle of the arc, in radius.
 * @param {number} endAngle Ending angle of the arc, in radius.
 * @param {boolean} ccw Whether the arc runs counterclockwise.
 * @return {GraphicsPath} This object.
 */
GraphicsPath.prototype.arc=function(x,y,radius,startAngle,endAngle,ccw){
 if(radius&lt;0){
  throw new Error("IndexSizeError")
 }
 var x0=this.endPos[0]
 var y0=this.endPos[1]
 var twopi=GLMath.PiTimes2;
 var startX=x+radius*Math.cos(startAngle);
 var startY=y+radius*Math.sin(startAngle);
 var endX=x+radius*Math.cos(endAngle);
 var endY=y+radius*Math.sin(endAngle);
 if((startX==endX &amp;&amp; startY==endY) || radius==0){
    return this.lineTo(startX,startY).lineTo(endX,endY);
 }
 if((!ccw &amp;&amp; (endAngle-startAngle)>=twopi) ||
   (ccw &amp;&amp; (startAngle-endAngle)>=twopi)){
    return this.lineTo(startX,startY)
       .arc(x,y,radius,startAngle,startAngle+Math.PI,ccw)
       .arc(x,y,radius,startAngle+Math.PI,startAngle+GLMath.PiTimes2,ccw)
       .lineTo(startX,startY)
} else {
 var delta=endAngle-startAngle;
 if(delta>=twopi || delta&lt;0){
 var d=delta%twopi
 if(d==0 &amp;&amp; delta!=0){
  return this.lineTo(startX,startY)
       .arc(x,y,radius,startAngle,startAngle+Math.PI,ccw)
       .arc(x,y,radius,startAngle+Math.PI,startAngle+GLMath.PiTimes2,ccw)
       .lineTo(startX,startY)
 }
 delta=d
}
var largeArc=(Math.abs(delta)>Math.PI)^(ccw)^(startAngle>endAngle)
var sweep=(delta>0)^(ccw)^(startAngle>endAngle)
return this.lineTo(startX,startY)
      .arcSvgTo(radius,radius,0,largeArc,sweep,endX,endY);
 }
}

/**
 * Not documented yet.
 * @param {number} x
 * @param {number} y
 * @param {number} x2
 * @param {number} y2
 * @return {GraphicsPath} This object.
 */
GraphicsPath.prototype.quadraticCurveTo=function(x,y,x2,y2){
 this.segments.push([GraphicsPath.QUAD,
  this.endPos[0],this.endPos[1],x,y,x2,y2])
 this.endPos[0]=x2
 this.endPos[1]=y2
 this.incomplete=false
 return this
}
/**
 * Not documented yet.
 * @param {number} x
 * @param {number} y
 * @param {number} x2
 * @param {number} y2
 * @param {number} x3
 * @param {number} y3
 * @return {GraphicsPath} This object.
 */
GraphicsPath.prototype.bezierCurveTo=function(x,y,x2,y2,x3,y3){
 this.segments.push([GraphicsPath.CUBIC,
  this.endPos[0],this.endPos[1],x,y,x2,y2,x3,y3])
 this.endPos[0]=x3
 this.endPos[1]=y3
 this.incomplete=false
 return this
}
/**
* Estimates the integral of a function.  The integral
* is the area between the function's graph and the X-axis,
* where areas above the X axis add to the integral, and areas
* below the X axis subtract from it.
* @private
* @param {Function} func A function that takes one number
* and returns a number.  For best results,
* the function should be continuous (informally, this means
* its graph between &lt;code>xmin&lt;/code> and
* &lt;code>xmax&lt;/code> can be drawn without lifting the pen).
* @param {Number} xmin Smallest input to the function,
* or the lower limit to integration.
* @param {Number} xmax Largest input to the function,
* or the upper limit to integration.  If xmax is less than xmin,
* this results in a negative integral.
* @param {Number} [maxIter] Maximum iterations.
* If null or undefined, does 8 iterations.
* @returns The approximate integral of _func_ between
* _xmin_ and _xmax_.
*/
GraphicsPath._numIntegrate=function(func, xmin, xmax, maxIter){
 if(xmax==xmin)return 0;
 if(xmax&lt;xmin){
  return GraphicsPath._numIntegrate(func,xmax,xmin,maxIter)
 }
 if(maxIter==null)maxIter=8
 if(maxIter&lt;=0)return 0;
 // Romberg integration
 var matrix=[0]
 var hk=(xmax-xmin)
 var lasthk=hk
 var klimit=0
 for(var k=1;k&lt;=maxIter;k++){
  if(k==1){
   matrix[k]=hk*0.5*(func(xmin)+func(xmax))
   klimit=1
  } else {
   var tmp=0
   for(var j=1;j&lt;=klimit;j++){
    tmp+=func(xmin+(j-0.5)*lasthk)
   }
   tmp*=lasthk
   matrix[k]=(matrix[k-1]+tmp)*0.5
   klimit&lt;&lt;=1
  }
  lasthk=hk
  hk*=0.5
 }
 var mxi=maxIter+1
 var pj1=4
 for(var j=2;j&lt;=maxIter;j++){
  var prev=matrix[j-1]
  var recipPj1m1=1.0/(pj1-1);
  for(var i=j;i&lt;=maxIter;i++){
   var cur=matrix[i]
   matrix[i]=(cur*pj1-prev)*recipPj1m1
   prev=cur
  }
  pj1*=4
 }
 return matrix[matrix.length-1]
}
GraphicsPath._ellipticArcLength=function(xRadius,yRadius,startAngle,endAngle){
 if(startAngle==endAngle || xRadius&lt;=0 || yRadius&lt;=0)return 0
 if(xRadius==yRadius){
  // for circular arc length this is extremely simple
  return Math.abs((endAngle-startAngle)*xRadius);
 }
 var mn=Math.min(xRadius,yRadius)
 var mx=Math.max(xRadius,yRadius)
 var eccSq=1-(mn*mn)/(mx*mx)
 var ellipticIntegrand=function(x){
  var s=Math.sin(x)
  return Math.sqrt(1-s*s*eccSq);
 }
 return Math.abs(mx*GraphicsPath._numIntegrate(
   ellipticIntegrand,startAngle,endAngle,10))
}
GraphicsPath._vecangle=function(a,b,c,d){
 var dot=a*c+b*d
 var denom=Math.sqrt(a*a+b*b)*Math.sqrt(c*c+d*d)
 dot/=denom
 var sgn=a*d-b*c
 // avoid NaN when dot is just slightly out of range
 // for acos
 if(dot&lt;-1)dot=-1
 else if(dot>1)dot=1
 var ret=Math.acos(dot)
 if(sgn&lt;0)ret=-ret
 return ret
}
GraphicsPath._arcSvgToCenterParam=function(a){
 var x1=a[1]
 var y1=a[2]
 var x2=a[8]
 var y2=a[9]
 var rx=a[3]
 var ry=a[4]
 var rot=a[5]
 var xmid=(x1-x2)*0.5
 var ymid=(y1-y2)*0.5
 var xpmid=(x1+x2)*0.5
 var ypmid=(y1+y2)*0.5
 var crot = Math.cos(rot);
 var srot = (rot>=0 &amp;&amp; rot&lt;6.283185307179586) ? (rot&lt;=3.141592653589793 ? Math.sqrt(1.0-crot*crot) : -Math.sqrt(1.0-crot*crot)) : Math.sin(rot);
 var x1p=crot*xmid+srot*ymid
 var y1p=crot*ymid-srot*xmid
 var rxsq=rx*rx
 var rysq=ry*ry
 var x1psq=x1p*x1p
 var y1psq=y1p*y1p
 var rx_xy=rxsq*y1psq+rysq*x1psq
 var cxsqrt=Math.sqrt(Math.max(0,(rxsq*rysq-rx_xy)/rx_xy))
 var cxp=(rx*y1p)*cxsqrt/ry
 var cyp=(ry*x1p)*cxsqrt/rx
 if(a[6]==a[7]){
  cxp=-cxp
 } else {
  cyp=-cyp
 }
 var cx=crot*cxp-srot*cyp+xpmid
 var cy=srot*cxp+crot*cyp+ypmid
 var vecx=(x1p-cxp)/rx
 var vecy=(y1p-cyp)/ry
 var nvecx=(-x1p-cxp)/rx
 var nvecy=(-y1p-cyp)/ry
 var cosTheta1=vecx/Math.sqrt(vecx*vecx+vecy*vecy)
 // avoid NaN when cosTheta1 is just slightly out of range
 // for acos
 if(cosTheta1&lt;-1)cosTheta1=-1
 else if(cosTheta1>1)cosTheta1=1
 var theta1=Math.acos(cosTheta1)
 if(vecy&lt;0)theta1=-theta1
 var delta=GraphicsPath._vecangle(vecx,vecy,nvecx,nvecy)
 delta=(delta&lt;0) ? GLMath.PiTimes2+delta : delta;
 if(!a[7] &amp;&amp; delta>0){
  delta-=GLMath.PiTimes2
 } else if(a[7] &amp;&amp; delta&lt;0){
  delta+=GLMath.PiTimes2
 }
 delta+=theta1
 return [cx,cy,theta1,delta]
}

/**
 * Adds path segments in the form of a circular arc to this path,
 * using the parameterization used by the SVG specification.
 * @param {*} rx
 * @param {*} ry
 * @param {*} rot Rotation of the ellipse in degrees.
 * @param {*} largeArc
 * @param {*} sweep
 * @param {number} x2
 * @param {number} y2
 * @return {GraphicsPath} This object.
 */
GraphicsPath.prototype.arcSvgTo=function(rx,ry,rot,largeArc,sweep,x2,y2){
 if(rx==0 || ry==0){
  return this.lineTo(x2,y2);
 }
 var x1=this.endPos[0]
 var y1=this.endPos[1]
 if(x1==x2 &amp;&amp; y1==y2){
  return this;
 }
 rot*=Math.PI/180;
 rx=Math.abs(rx);
 ry=Math.abs(ry);
 var xmid=(x1-x2)*0.5
 var ymid=(y1-y2)*0.5
 var crot = Math.cos(rot);
 var srot = (rot>=0 &amp;&amp; rot&lt;6.283185307179586) ? (rot&lt;=3.141592653589793 ? Math.sqrt(1.0-crot*crot) : -Math.sqrt(1.0-crot*crot)) : Math.sin(rot);
 var x1p=crot*xmid+srot*ymid
 var y1p=crot*ymid-srot*xmid
 var lam=(x1p*x1p)/(rx*rx)+(y1p*y1p)/(ry*ry);
 if(lam>1){
  lam=Math.sqrt(lam)
  rx*=lam
  ry*=lam
 }
 var arc=[GraphicsPath.ARC,
  x1,y1,rx,ry,rot,!!largeArc,!!sweep,x2,y2]
 var cp=GraphicsPath._arcSvgToCenterParam(arc)
 arc[10]=cp[0]
 arc[11]=cp[1]
 arc[12]=cp[2]
 arc[13]=cp[3]
 this.segments.push(arc)
 this.endPos[0]=x2
 this.endPos[1]=y2
 this.incomplete=false
 return this
}
GraphicsPath._nextAfterWs=function(str,index){
 while(index[0]&lt;str.length){
  var c=str.charCodeAt(index[0])
  index[0]++
  if(c==0x20 || c==0x0d || c==0x09 || c==0x0a || c==0x0c)
   continue;
  return c
 }
 return -1
}
GraphicsPath._nextAfterSepReq=function(str,index){
 var comma=false
 var havesep=false
 while(index[0]&lt;str.length){
  var c=str.charCodeAt(index[0])
  index[0]++
  if(c==0x20 || c==0x0d || c==0x09 || c==0x0a || c==0x0c){
   havesep=true
   continue;
  }
  if(!comma &amp;&amp; c==0x2c){
   havesep=true
   comma=true
   continue;
  }
  return (!havesep) ? -1 : c
 }
 return -1
}
GraphicsPath._nextAfterSep=function(str,index){
 var comma=false
 while(index[0]&lt;str.length){
  var c=str.charCodeAt(index[0])
  index[0]++
  if(c==0x20 || c==0x0d || c==0x09 || c==0x0a || c==0x0c)
   continue;
  if(!comma &amp;&amp; c==0x2c){
   comma=true
   continue;
  }
  return c
 }
 return -1
}
GraphicsPath._peekNextNumber=function(str,index){
 var oldindex=index[0]
 var ret=GraphicsPath._nextNumber(str,index,true)!=null
 index[0]=oldindex
 return ret
}
GraphicsPath._notFinite=function(n){
 return isNaN(n) || n==Number.POSITIVE_INFINITY ||
   n==Number.NEGATIVE_INFINITY
}
GraphicsPath._nextNumber=function(str,index,afterSep){
 var oldindex=index[0]
 var c=(afterSep) ?
   GraphicsPath._nextAfterSep(str,index) :
   GraphicsPath._nextAfterWs(str,index)
 var startIndex=index[0]-1
 var dot=false
 var digit=false
 var exponent=false
 var ret;
 if(c==0x2e)dot=true
 else if(c>=0x30 &amp;&amp; c&lt;=0x39)digit=true
 else if(c!=0x2d &amp;&amp; c!=0x2b){
    index[0]=oldindex
    return null
   }
 while(index[0]&lt;str.length){
  var c=str.charCodeAt(index[0])
  index[0]++
  if(c==0x2e){
   if(dot){
    index[0]=oldindex
    return null
   }
   dot=true
  } else if(c>=0x30 &amp;&amp; c&lt;=0x39){
   digit=true
  } else if(c==0x45 || c==0x65){
   if(!digit){
    index[0]=oldindex
    return null
   }
   exponent=true
   break
  } else {
   if(!digit){
    index[0]=oldindex
    return null
   }
   index[0]--
   ret=parseFloat(str.substr(startIndex,index[0]-startIndex))
   if(GraphicsPath._notFinite(ret)){
    index[0]=oldindex
    return null
   }
   return ret
  }
 }
 if(exponent){
  var c=str.charCodeAt(index[0])
  if(c&lt;0){
    index[0]=oldindex
    return null
   }
  index[0]++
  digit=false
  if(c>=0x30 &amp;&amp; c&lt;=0x39)digit=true
  else if(c!=0x2d &amp;&amp; c!=0x2b){
    index[0]=oldindex
    return null
   }
  while(index[0]&lt;str.length){
   var c=str.charCodeAt(index[0])
   index[0]++
   if(c>=0x30 &amp;&amp; c&lt;=0x39){
    digit=true
   } else {
    if(!digit){
    index[0]=oldindex
    return null
    }
    index[0]--
    ret=parseFloat(str.substr(startIndex,index[0]-startIndex))
    if(GraphicsPath._notFinite(ret)){
     index[0]=oldindex
     return null
    }
    return ret
   }
  }
  if(!digit){
    index[0]=oldindex
    return null
  }
 } else {
  if(!digit){
    index[0]=oldindex
    return null
  }
 }
 ret=parseFloat(str.substr(startIndex,str.length-startIndex))
 if(GraphicsPath._notFinite(ret)){
  index[0]=oldindex
  return null
 }
 return ret
}
/**
 * Not documented yet.
 * @param {number} x
 * @param {number} y
 * @param {number} width
 * @param {number} height
 * @return {GraphicsPath} This object.
 */
GraphicsPath.prototype.rect=function(x,y,w,h){
 return this.moveTo(x,y).lineTo(x+width,y).lineTo(x+width,y+height)
   .lineTo(x,y+height).closePath().moveTo(x,y)
}

/**
*
* @param {string} A string, in the SVG path format, representing
* a two-dimensional path.
* @return {GraphicsPath} Return value.*/
GraphicsPath.fromString=function(str){
 var index=[0]
 var started=false
 var ret=new GraphicsPath()
 var failed=false;
 while(!failed &amp;&amp; index[0]&lt;str.length){
  var c=GraphicsPath._nextAfterWs(str,index)
  if(!started &amp;&amp; c!=0x4d &amp;&amp; c!=0x6d){
   // not a move-to command when path
   // started
    failed=true;break;
  }
  // NOTE: Doesn't implement SVG2 meaning of Z
  // command yet because it's not yet fully specified
  switch(c){
   case 0x5a:case 0x7a:{ // 'Z', 'z'
    ret.closePath()
    break;
   }
   case 0x4d:case 0x6d:{ // 'M', 'm'
    var sep=false
    while(true){
     var curx=(c==0x6d) ? ret.endPos[0] : 0
     var cury=(c==0x6d) ? ret.endPos[1] : 0
     var x=GraphicsPath._nextNumber(str,index,sep)
     if(x==null){ if(!sep)failed=true;break; }
     var y=GraphicsPath._nextNumber(str,index,true)
     if(y==null){ failed=true;break; }
     if(sep)ret.lineTo(curx+x,cury+y)
     else ret.moveTo(curx+x,cury+y);
     sep=true;
    }
    started=true
    break;
   }
   case 0x4c:case 0x6c:{ // 'L', 'l'
    var sep=false
    while(true){
     var curx=(c==0x6c) ? ret.endPos[0] : 0
     var cury=(c==0x6c) ? ret.endPos[1] : 0
     var x=GraphicsPath._nextNumber(str,index,sep)
     if(x==null){ if(!sep)failed=true;break; }
     var y=GraphicsPath._nextNumber(str,index,true)
     if(y==null){ failed=true;break; }
     ret.lineTo(curx+x,cury+y);
     sep=true;
    }
    break;
   }
   case 0x48:case 0x68:{ // 'H', 'h'
    var sep=false
    while(true){
     var curpt=(c==0x68) ? ret.endPos[0] : 0
     var x=GraphicsPath._nextNumber(str,index,sep)
     if(x==null){ if(!sep)failed=true;break; }
     ret.lineTo(curpt+x,ret.endPos[1]);
     sep=true;
    }
    break;
   }
   case 0x56:case 0x76:{ // 'V', 'v'
    var sep=false
    while(true){
     var curpt=(c==0x76) ? ret.endPos[1] : 0
     var x=GraphicsPath._nextNumber(str,index,sep)
     if(x==null){ if(!sep)failed=true;break; }
     ret.lineTo(ret.endPos[0],curpt+x);
     sep=true;
    }
    break;
   }
   case 0x43:case 0x63:{ // 'C', 'c'
    var sep=false
    while(true){
     var curx=(c==0x63) ? ret.endPos[0] : 0
     var cury=(c==0x63) ? ret.endPos[1] : 0
     var x=GraphicsPath._nextNumber(str,index,sep)
     if(x==null){ if(!sep)failed=true;break; }
     var y=GraphicsPath._nextNumber(str,index,true)
     if(y==null){ failed=true;break; }
     var x2=GraphicsPath._nextNumber(str,index,true)
     if(x2==null){ failed=true;break; }
     var y2=GraphicsPath._nextNumber(str,index,true)
     if(y2==null){ failed=true;break; }
     var x3=GraphicsPath._nextNumber(str,index,true)
     if(x3==null){ failed=true;break; }
     var y3=GraphicsPath._nextNumber(str,index,true)
     if(y3==null){ failed=true;break; }
     ret.bezierCurveTo(curx+x,cury+y,curx+x2,cury+y2,
       curx+x3,cury+y3);
     sep=true;
    }
    break;
   }
   case 0x51:case 0x71:{ // 'Q', 'q'
    var sep=false
    while(true){
     var curx=(c==0x71) ? ret.endPos[0] : 0
     var cury=(c==0x71) ? ret.endPos[1] : 0
     var x=GraphicsPath._nextNumber(str,index,sep)
     if(x==null){ if(!sep)failed=true;break; }
     var y=GraphicsPath._nextNumber(str,index,true)
     if(y==null){ failed=true;break; }
     var x2=GraphicsPath._nextNumber(str,index,true)
     if(x2==null){ failed=true;break; }
     var y2=GraphicsPath._nextNumber(str,index,true)
     if(y2==null){ failed=true;break; }
     ret.quadraticCurveTo(curx+x,cury+y,curx+x2,cury+y2);
     sep=true;
    }
    break;
   }
   case 0x41:case 0x61:{ // 'A', 'a'
    var sep=false
    while(true){
     var curx=(c==0x61) ? ret.endPos[0] : 0
     var cury=(c==0x61) ? ret.endPos[1] : 0
     var x=GraphicsPath._nextNumber(str,index,sep)
     if(x==null){ if(!sep)failed=true;break; }
     var y=GraphicsPath._nextNumber(str,index,true)
     if(y==null){ failed=true;break; }
     var rot=GraphicsPath._nextNumber(str,index,true)
     if(rot==null){ failed=true;break; }
     var largeArc=GraphicsPath._nextAfterSepReq(str,index)
     var sweep=GraphicsPath._nextAfterSep(str,index)
     if(largeArc==-1 || sweep==-1){ failed=true;break; }
     var x2=GraphicsPath._nextNumber(str,index,true)
     if(x2==null){ failed=true;break; }
     var y2=GraphicsPath._nextNumber(str,index,true)
     if(y2==null){ failed=true;break; }
     ret.arcSvgTo(x+curx,y+cury,rot,largeArc!=0x30,
       sweep!=0x30,x2+curx,y2+cury);
     sep=true;
    }
    break;
   }
   case 0x53:case 0x73:{ // 'S', 's'
    var sep=false
    while(true){
     var curx=(c==0x73) ? ret.endPos[0] : 0
     var cury=(c==0x73) ? ret.endPos[1] : 0
     var x=GraphicsPath._nextNumber(str,index,sep)
     if(x==null){ if(!sep)failed=true;break; }
     var y=GraphicsPath._nextNumber(str,index,true)
     if(y==null){ failed=true;break; }
     var x2=GraphicsPath._nextNumber(str,index,true)
     if(x2==null){ failed=true;break; }
     var y2=GraphicsPath._nextNumber(str,index,true)
     if(y2==null){ failed=true;break; }
     var xcp=curx
     var ycp=cury
     if(ret.segments.length>0 &amp;&amp;
        ret.segments[ret.segments.length-1][0]==GraphicsPath.CUBIC){
        xcp=ret.segments[ret.segments.length-1][5]
        ycp=ret.segments[ret.segments.length-1][6]
     }
     ret.bezierCurveTo(2*curx-xcp,2*cury-ycp,x+curx,y+cury,x2+curx,y2+cury);
     sep=true;
    }
    break;
   }
   case 0x54:case 0x74:{ // 'T', 't'
    var sep=false
    while(true){
     var curx=(c==0x74) ? ret.endPos[0] : 0
     var cury=(c==0x74) ? ret.endPos[1] : 0
     var x=GraphicsPath._nextNumber(str,index,sep)
     if(x==null){ if(!sep)failed=true;break; }
     var y=GraphicsPath._nextNumber(str,index,true)
     if(y==null){ failed=true;break; }
     var xcp=curx
     var ycp=cury
     if(ret.segments.length>0 &amp;&amp;
        ret.segments[ret.segments.length-1][0]==GraphicsPath.QUAD){
        xcp=ret.segments[ret.segments.length-1][3]
        ycp=ret.segments[ret.segments.length-1][4]
     }
     x+=curx
     y+=cury
     ret.quadraticCurveTo(2*curx-xcp,2*cury-ycp,x+curx,y+cury);
     sep=true;
    }
    break;
   }
   default:
    ret.incomplete=true;
    return ret
  }
 }
 if(failed)ret.incomplete=true
 return ret
}

var Triangulate={}
Triangulate._LinkedList=function(){
 this.items=[]
 this.firstItem=-1
 this.lastItem=-1
 this.lastRemovedIndex=-1
}
Triangulate._LinkedList.prototype.list=function(list){
 var index=this.firstItem
 var listidx=0
 while(index>=0){
  list[listidx++]=this.items[index]
  index=this.items[index+2]
 }
 return listidx
}
Triangulate._LinkedList.prototype.contains=function(item){
 var index=this.firstItem
 while(index>=0){
  if(item==this.items[index])return true
  index=this.items[index+2]
 }
 return false
}
Triangulate._LinkedList.prototype.remove=function(item){
 var index=this.firstItem
 while(index>=0){
  if(this.items[index]==item){
   this.lastRemovedIndex=index
   var prevItem=this.items[index+1]
   var nextItem=this.items[index+2]
   if(prevItem>=0){
    this.items[prevItem+2]=nextItem
   } else {
    this.firstItem=nextItem
   }
   if(nextItem>=0){
    this.items[nextItem+1]=prevItem
   } else {
    this.lastItem=prevItem
   }
   return
  }
  index=this.items[index+2]
 }
}
Triangulate._LinkedList.prototype.addIfMissing=function(item){
 if(!this.contains(item)){
  this.add(item)
 }
}
Triangulate._LinkedList.prototype.add=function(item){
 var itemIndex=(this.lastRemovedIndex==-1) ?
   this.items.length : this.lastRemovedIndex
 this.lastRemovedIndex=-1
 this.items[itemIndex]=item
 if(this.lastItem>=0)
  this.items[this.lastItem+2]=itemIndex // prev's next
 this.items[itemIndex+1]=this.lastItem // current's prev
 this.items[itemIndex+2]=-1 // current's next
 this.lastItem=itemIndex
 if(this.firstItem&lt;0)this.firstItem=itemIndex
}

Triangulate._CONVEX=1
Triangulate._EAR=2
Triangulate._REFLEX=3
Triangulate._PREV=2
Triangulate._NEXT=3
Triangulate._pointInTri=function(vertices,i1,i2,i3,pt){
  var t1 = Math.min (vertices[i3+0], vertices[i1+0]);
  var t2 = Math.min (vertices[i3+1], vertices[i1+1]);
  var t=(((vertices[i1+0] &lt; vertices[pt+0]) == (vertices[pt+0] &lt;= vertices[i3+0])) &amp;&amp;
  (((vertices[pt+1] - t2) * (Math.max (vertices[i3+0], vertices[i1+0]) - t1)) &lt; ((Math.max (vertices[i3+1], vertices[i1+1]) - t2) * (vertices[pt+0] - t1))));
  var t4 = Math.min (vertices[i1+0], vertices[i2+0]);
  var t5 = Math.min (vertices[i1+1], vertices[i2+1]);
  t^=(((vertices[i2+0] &lt; vertices[pt+0]) == (vertices[pt+0] &lt;= vertices[i1+0])) &amp;&amp;
   (((vertices[pt+1] - t5) * (Math.max (vertices[i1+0], vertices[i2+0]) - t4)) &lt; ((Math.max (vertices[i1+1], vertices[i2+1]) - t5) * (vertices[pt+0] - t4))));
  var t7 = Math.min (vertices[i2+0], vertices[i3+0]);
  var t8 = Math.min (vertices[i2+1], vertices[i3+1]);
  t^=(((vertices[i3+0] &lt; vertices[pt+0]) == (vertices[pt+0] &lt;= vertices[i2+0])) &amp;&amp;
   (((vertices[pt+1] - t8) * (Math.max (vertices[i2+0], vertices[i3+0]) - t7)) &lt; ((Math.max (vertices[i2+1], vertices[i3+1]) - t8) * (vertices[pt+0] - t7))));
  return t
}

Triangulate._vertClass=function(verts,index,ori){
 var prevVert=verts[index+2]
 var nextVert=verts[index+3]
 var curori=Triangulate._triOrient(verts,prevVert,index,nextVert)
 if(curori==0 || curori==-1){
  // This is a convex vertex, find out whether this
  // is an ear
  var prevVert=verts[index+2]
  var nextVert=verts[index+3]
  for(var i=0;i&lt;verts.length;i+=4){
   if(i!=prevVert &amp;&amp; i!=nextVert &amp;&amp; i!=index){
    if(Triangulate._pointInTri(verts,prevVert,index,nextVert,i)){
     return Triangulate._CONVEX
    }
   }
  }
  return Triangulate._EAR
 } else {
  return Triangulate._REFLEX;
 }
}
Triangulate._triOrient=function(vertices,i1,i2,i3){
 var acx=vertices[i1]-vertices[i3]
 var acy=vertices[i1+1]-vertices[i3+1]
 var bcx=vertices[i2]-vertices[i3]
 var bcy=vertices[i2+1]-vertices[i3+1]
 var cross=acx*bcy-acy*bcx
 return cross==0 ? 0 : (cross&lt;0 ? -1 : 1)
}
Triangulate._triangulate=function(vertices,tris){
 if(vertices.length&lt;6){
  // too few vertices for a triangulation
  return
 }
 var vertLength=vertices.length
 // For convenience, eliminate the last
 // vertex if it matches the first vertex
 if(vertLength>=4 &amp;&amp;
    vertices[0]==vertices[vertLength-2] &amp;&amp;
    vertices[1]==vertices[vertLength-1]){
  vertLength-=2
 }
 if(vertLength==6){
  // just one triangle
  tris.push(vertices.slice(0))
  return
 }
 // Find the prevailing orientation of the polygon
 var ori=0
 for(var i=0;i&lt;vertices.length-2;i+=2){
  ori+=vertices[0]*vertices[3]-vertices[1]*vertices[2];
 }
 ori=(ori==0) ? 0 : (ori&lt;0 ? -1 : 1);
 if(ori==0){
  // Zero area or even a certain self-intersecting
  // polygon
  return
 }
 var verts=[]
 var tmp=[]
 var reflex=new Triangulate._LinkedList()
 var ears=new Triangulate._LinkedList()
 var lastX=-1
 var lastY=-1
 for(var i=0;i&lt;vertLength;i+=2){
  var x=vertices[i]
  var y=vertices[i+1]
  if(i>0 &amp;&amp; x==lastX &amp;&amp; y==lastY){
   // skip consecutive duplicate points
   continue;
  }
  lastX=x
  lastY=y
  verts.push(x,y,0,0)
 }
 for(var index=0;index&lt;verts.length;index+=4){
  var prevVert=(index==0) ? verts.length-4 : index-4
  var nextVert=(index==verts.length-4) ? 0 : index+4
  verts[index+Triangulate._PREV]=prevVert
  verts[index+Triangulate._NEXT]=nextVert
 }
 for(var index=0;index&lt;verts.length;index+=4){
  var vertexClass=Triangulate._vertClass(verts,index,ori)
  if(vertexClass==Triangulate._EAR)
   ears.add(index)
  else if(vertexClass==Triangulate._REFLEX)
   reflex.add(index)
 }
 while(true){
  var earLength=ears.list(tmp)
  if(earLength&lt;=0)break;
  for(var i=0;i&lt;earLength;i++){
   var ear=tmp[i]
   //console.log("processing "+[ear/4,prevVert/4,nextVert/4])
   var prevVert=verts[ear+Triangulate._PREV]
   var nextVert=verts[ear+Triangulate._NEXT]
   if(ear==prevVert || ear==nextVert || prevVert==nextVert){
    ears.remove(ear)
    continue;
   }
   // remove the ear from the linked list
   verts[prevVert+Triangulate._NEXT]=nextVert
   verts[nextVert+Triangulate._PREV]=prevVert
   tris.push([
    verts[prevVert],verts[prevVert+1],
    verts[ear],verts[ear+1],
    verts[nextVert],verts[nextVert+1]])
   ears.remove(ear)
   // reclassify vertices
   var prevClass=Triangulate._vertClass(verts,prevVert,ori)
   var nextClass=Triangulate._vertClass(verts,nextVert,ori)
   if(prevClass!=Triangulate._REFLEX){
    reflex.remove(prevVert)
   } else {
    reflex.addIfMissing(prevVert)
   }
   if(prevClass!=Triangulate._EAR){
    ears.remove(prevVert)
   } else {
    ears.addIfMissing(prevVert)
   }
   if(nextClass!=Triangulate._REFLEX){
    reflex.remove(nextVert)
   } else {
    reflex.addIfMissing(nextVert)
   }
   if(nextClass!=Triangulate._EAR){
    ears.remove(nextVert)
   } else {
    ears.addIfMissing(nextVert)
   }
  }
 }
}
</code></pre>
        </article>
    </section>

</div>
<nav style="float: right;width: 25%;border-left: 1px solid;margin-top:0px;box-sizing: border-box;padding-left: 1em;">
<p>
If you like this software, you should consider donating to me, Peter O., at the link below:</p>
<form action="https://www.paypal.com/cgi-bin/webscr" method="post" target="_top">
<input type="hidden" name="cmd" value="_s-xclick">
<input type="hidden" name="encrypted" value="-----BEGIN PKCS7-----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-----END PKCS7-----">
<input type="image" src="https://www.paypalobjects.com/en_US/i/btn/btn_donateCC_LG.gif"
name="submit" border="2" alt="PayPal - The safer, easier way to pay online!">
<img alt="" src="https://www.paypalobjects.com/en_US/i/scr/pixel.gif" width="1" height="1">
</form>
<p>
<a href="http://twitter.com/share" class="twitter-share-button" data-count="horizontal" data-lang="en">Share via Twitter</a>
<script type="text/javascript" charset="UTF-8" src="http://platform.twitter.com/widgets.js"></script>
<span><g:plusone size="medium"></g:plusone></span><br/>
<span><fb:like send="true" width="300" show_faces="true"></fb:like></span>
</p>
<h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-glmath.html">glmath</a></li><li><a href="module-glutil.html">glutil</a></li></ul><h3>Classes</h3><ul><li><a href="BezierCurve.html">BezierCurve</a></li><li><a href="BezierSurface.html">BezierSurface</a></li><li><a href="BSplineCurve.html">BSplineCurve</a></li><li><a href="BSplineSurface.html">BSplineSurface</a></li><li><a href="Camera.html">Camera</a></li><li><a href="CurveEval.html">CurveEval</a></li><li><a href="CurveTube.html">CurveTube</a></li><li><a href="Epitrochoid.html">Epitrochoid</a></li><li><a href="glmath.GLMath.html">GLMath</a></li><li><a href="glutil.GLUtil.html">GLUtil</a></li><li><a href="glutil.Lights.html">Lights</a></li><li><a href="glutil.LightSource.html">LightSource</a></li><li><a href="glutil.Material.html">Material</a></li><li><a href="glutil.Mesh.html">Mesh</a></li><li><a href="glutil.Meshes.html">Meshes</a></li><li><a href="glutil.Scene3D.html">Scene3D</a></li><li><a href="glutil.ShaderProgram.html">ShaderProgram</a></li><li><a href="glutil.Shape.html">Shape</a></li><li><a href="glutil.ShapeGroup.html">ShapeGroup</a></li><li><a href="glutil.SurfaceEval.html">SurfaceEval</a></li><li><a href="glutil.Texture.html">Texture</a></li><li><a href="glutil.Transform.html">Transform</a></li><li><a href="GraphicsPath.html">GraphicsPath</a></li><li><a href="Hypotrochoid.html">Hypotrochoid</a></li><li><a href="MatrixStack.html">MatrixStack</a></li><li><a href="ObjData.html">ObjData</a></li><li><a href="Promise.html">Promise</a></li><li><a href="SurfaceOfRevolution.html">SurfaceOfRevolution</a></li><li><a href="Trochoid.html">Trochoid</a></li></ul><h3>Tutorials</h3><ul><li><a href="tutorial-camera_.html">The "Camera" and the Projection and View Transforms</a></li><li><a href="tutorial-filters.html">Graphics Filters</a></li><li><a href="tutorial-glmath.html">GLMath Math Library</a></li><li><a href="tutorial-matrixdetails.html">Matrix Details</a></li><li><a href="tutorial-meshexamples.html">Examples of Creating Meshes on the Fly</a></li><li><a href="tutorial-overview.html">Library Overview</a></li><li><a href="tutorial-shapes.html">Creating Shapes</a></li><li><a href="tutorial-surfaces.html">Parametric Curves and Parametric Surfaces</a></li><li><a href="tutorial-textures.html">Texture Examples</a></li></ul>
</nav>
<script>
if(document.location.href.indexOf("file://")!=0){
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = '//apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/all.js#xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
}
</script>
</body>
</html>
