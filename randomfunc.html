<!DOCTYPE html><html xmlns:dc="http://purl.org/dc/terms/" itemscope itemtype="http://schema.org/Article"><head><meta http-equiv=Content-Type content="text/html; charset=utf-8"><title>Randomization and Sampling Methods</title><meta name="citation_title" content="Randomization and Sampling Methods"><meta name="citation_pdf_url" content="https://peteroupc.github.io/randomfunc.pdf"><meta name="citation_url" content="https://peteroupc.github.io/randomfunc.html"><meta name="citation_date" content="2022/04/29"><meta name="citation_online_date" content="2022/04/29"><meta name="og:title" content="Randomization and Sampling Methods"><meta name="og:description" content="This page discusses many ways applications can sample randomized content by transforming the numbers produced by an underlying source of random numbers, such as numbers produced by a pseudorandom number generator, and offers pseudocode and Python sample code for many of these methods."><meta name="description" content="This page discusses many ways applications can sample randomized content by transforming the numbers produced by an underlying source of random numbers, such as numbers produced by a pseudorandom number generator, and offers pseudocode and Python sample code for many of these methods."><meta name="twitter:description" content="This page discusses many ways applications can sample randomized content by transforming the numbers produced by an underlying source of random numbers, such as numbers produced by a pseudorandom number generator, and offers pseudocode and Python sample code for many of these ..."><meta name="og:type" content="article"><meta name="og:url" content="https://peteroupc.github.io/randomfunc.html"><meta name="og:site_name" content="peteroupc.github.io"><meta name="twitter:title" content="Randomization and Sampling Methods"><meta name="author" content="Peter Occil"/><meta name="citation_author" content="Peter Occil"/><meta name="viewport" content="width=device-width"><link rel=stylesheet type="text/css" href="/style.css">
            <script type="text/x-mathjax-config"> MathJax.Hub.Config({"HTML-CSS": { availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, preferredFont: "TeX" },
                    tex2jax: { displayMath: [ ["$$","$$"], ["\\[", "\\]"] ], inlineMath: [ ["$", "$"], ["\\\\(","\\\\)"] ], processEscapes: true } });
            </script><script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"></script></head><body>  <div class="header">
<nav><p><a href="#navigation">Menu</a> - <a href="#top">Top</a> - <a href="/">Home</a></nav></div>
<div class="mainarea" id="top">
<h1>Randomization and Sampling Methods</h1>

<p><a href="mailto:poccil14@gmail.com"><strong>Peter Occil</strong></a></p>

<p><strong>Abstract:</strong> This page discusses many ways applications can sample randomized content by transforming the numbers produced by an underlying source of random numbers, such as numbers produced by a pseudorandom number generator, and offers pseudocode and Python sample code for many of these methods.</p>

<p><strong>2020 Mathematics Subject Classification:</strong> 68W20.</p>

<p><a id=Introduction></a></p>

<h2>Introduction</h2>

<p>This page catalogs <em>randomization methods</em> and <em>sampling methods</em>.  A randomization or sampling method is driven by a &quot;source of random numbers&quot; and produces numbers or other values called <strong><em>random variates</em></strong>.  These variates are the result of the randomization.  (The &quot;source of random numbers&quot; is often simulated in practice by so-called pseudorandom number generators, or PRNGs.)  This document covers many methods, including&mdash;</p>

<ul>
<li>ways to sample integers or real numbers from a uniform distribution (such as the <a href="#RNDINT_Random_Integers_in_0_N"><strong>core method, <code>RNDINT(N)</code></strong></a>),</li>
<li>ways to generate randomized content and conditions, such as <a href="#Boolean_True_False_Conditions"><strong>true/false conditions</strong></a>, <a href="#Shuffling"><strong>shuffling</strong></a>, and <a href="#Sampling_Without_Replacement_Choosing_Several_Unique_Items"><strong>sampling unique items from a list</strong></a>, and</li>
<li>non-uniform distributions, including <a href="#Weighted_Choice"><strong>weighted choice</strong></a>, the <a href="#Poisson_Distribution"><strong>Poisson distribution</strong></a>, and <a href="#Index_of_Non_Uniform_Distributions"><strong>other probability distributions</strong></a>.</li>
</ul>

<p>This page is focused on randomization and sampling methods that <em>exactly</em> sample from the distribution described, without introducing additional errors beyond those already present in the inputs (and assuming that an ideal &quot;source of random numbers&quot; is available).  This will be the case if there is a finite number of values to choose from.  But for the normal distribution and other distributions that take on an infinite number of values, there will always be some level of approximation involved; in this case, the focus of this page is on methods that <em>minimize</em> the error they introduce.</p>

<p>This document shows pseudocode for many of the methods, and <a href="https://peteroupc.github.io/randomgen.zip"><strong>sample Python code</strong></a> that implements many of the methods in this document is available, together with <a href="https://peteroupc.github.io/randomgendoc.html"><strong>documentation for the code</strong></a>.</p>

<p>The randomization methods presented on this page assume we have an endless source of numbers chosen independently at random and with a uniform distribution.  For more information, see &quot;<a href="#Sources_of_Random_Numbers"><strong>Sources of Random Numbers</strong></a>&quot; in the appendix.</p>

<p><strong>In general, the following are outside the scope of this document:</strong></p>

<ul>
<li>This document does not cover how to choose an underlying PRNG (or device or program that simulates a &quot;source of random numbers&quot;) for a particular application, including in terms of security, performance, and quality.  I have written more on  recommendations in <a href="https://peteroupc.github.io/random.html"><strong>another document</strong></a>.</li>
<li>This document does not include algorithms for specific PRNGs, such as Mersenne Twister, PCG, xorshift, linear congruential generators, or generators based on hash functions.</li>
<li>This document does not cover how to test PRNGs for correctness or adequacy, and the same applies to other devices and programs that simulate a &quot;source of random numbers&quot;.  Testing is covered, for example, in &quot;<a href="https://peteroupc.github.io/randomtest.html"><strong>Testing PRNGs for High-Quality Randomness</strong></a>&quot;.</li>
<li>This document does not explain how to specify or generate &quot;seeds&quot; for use in PRNGs.  This is <a href="https://peteroupc.github.io/random.html#Nondeterministic_Sources_and_Seed_Generation"><strong>covered in detail</strong></a> elsewhere.</li>
<li>This document does not show how to generate random security parameters such as encryption keys.</li>
<li>This document does not cover randomness extraction (also known as <em>unbiasing</em>, <em>deskewing</em>, or <em>whitening</em>).  See my <a href="https://peteroupc.github.io/randextract.html"><strong>Note on Randomness Extraction</strong></a>.</li>
<li>&quot;Variance reduction&quot; methods, such as importance sampling or common random numbers, are outside the scope of this document.</li>
</ul>

<p>In addition, this page is not focused on sampling methods used for computer graphics rendering (such as Poisson disk sampling, multiple importance sampling, blue noise, and gradient noise), because this application tends to give performance and visual acceptability a greater weight than accuracy and exact sampling.  In particular, <a href="#Rejection_Sampling"><strong>rejection sampling</strong></a> is hardly used in graphics rendering.</p>

<p><a id=About_This_Document></a></p>

<h3>About This Document</h3>

<p><strong>This is an open-source document; for an updated version, see the</strong> <a href="https://github.com/peteroupc/peteroupc.github.io/raw/master/randomfunc.md"><strong>source code</strong></a> <strong>or its</strong> <a href="https://github.com/peteroupc/peteroupc.github.io/blob/master/randomfunc.md"><strong>rendering on GitHub</strong></a><strong>.  You can send comments on this document either on</strong> <a href="https://www.codeproject.com/Articles/1190459/Random-Number-Generation-and-Sampling-Methods"><strong>CodeProject</strong></a> <strong>or on the</strong> <a href="https://github.com/peteroupc/peteroupc.github.io/issues"><strong>GitHub issues page</strong></a><strong>.</strong></p>

<p><strong>Comments on any aspect of this document are welcome.</strong></p>

<p><a id=Contents></a></p>

<h2>Contents</h2>

<ul>
<li><a href="#Introduction"><strong>Introduction</strong></a>

<ul>
<li><a href="#About_This_Document"><strong>About This Document</strong></a></li>
</ul></li>
<li><a href="#Contents"><strong>Contents</strong></a></li>
<li><a href="#Notation"><strong>Notation</strong></a></li>
<li><a href="#Uniform_Random_Integers"><strong>Uniform Random Integers</strong></a>

<ul>
<li><a href="#RNDINT_Random_Integers_in_0_N"><code>RNDINT</code>: Random Integers in [0, N]</a></li>
<li><a href="#RNDINTRANGE_Random_Integers_in_N_M"><code>RNDINTRANGE</code>: Random Integers in [N, M]</a></li>
<li><a href="#RNDINTEXC_Random_Integers_in_0_N"><strong><code>RNDINTEXC</code>: Random Integers in [0, N)</strong></a></li>
<li><a href="#RNDINTEXCRANGE_Random_Integers_in_N_M"><strong><code>RNDINTEXCRANGE</code>: Random Integers in [N, M)</strong></a></li>
<li><a href="#Uniform_Random_Bits"><strong>Uniform Random Bits</strong></a></li>
<li><a href="#Examples_of_Using_the_RNDINT_Family"><strong>Examples of Using the <code>RNDINT</code> Family</strong></a></li>
</ul></li>
<li><a href="#Randomization_Techniques"><strong>Randomization Techniques</strong></a>

<ul>
<li><a href="#Boolean_True_False_Conditions"><strong>Boolean (True/False) Conditions</strong></a></li>
<li><a href="#Random_Sampling"><strong>Random Sampling</strong></a>

<ul>
<li><a href="#Sampling_With_Replacement_Choosing_a_Random_Item_from_a_List"><strong>Sampling With Replacement: Choosing a Random Item from a List</strong></a></li>
<li><a href="#Sampling_Without_Replacement_Choosing_Several_Unique_Items"><strong>Sampling Without Replacement: Choosing Several Unique Items</strong></a></li>
<li><a href="#Shuffling"><strong>Shuffling</strong></a></li>
<li><a href="#Random_Character_Strings"><strong>Random Character Strings</strong></a></li>
<li><a href="#Pseudocode_for_Random_Sampling"><strong>Pseudocode for Random Sampling</strong></a></li>
</ul></li>
<li><a href="#Rejection_Sampling"><strong>Rejection Sampling</strong></a></li>
<li><a href="#Random_Walks"><strong>Random Walks</strong></a></li>
<li><a href="#Random_Dates_and_Times"><strong>Random Dates and Times</strong></a></li>
<li><a href="#Randomization_in_Statistical_Testing"><strong>Randomization in Statistical Testing</strong></a></li>
<li><a href="#Markov_Chains"><strong>Markov Chains</strong></a></li>
<li><a href="#Random_Graphs"><strong>Random Graphs</strong></a></li>
<li><a href="#A_Note_on_Sorting_Random_Variates"><strong>A Note on Sorting Random Variates</strong></a></li>
</ul></li>
<li><a href="#General_Non_Uniform_Distributions"><strong>General Non-Uniform Distributions</strong></a>

<ul>
<li><a href="#Weighted_Choice"><strong>Weighted Choice</strong></a>

<ul>
<li><a href="#Weighted_Choice_With_Replacement"><strong>Weighted Choice With Replacement</strong></a></li>
<li><a href="#Weighted_Choice_Without_Replacement_Multiple_Copies"><strong>Weighted Choice Without Replacement (Multiple Copies)</strong></a></li>
<li><a href="#Weighted_Choice_Without_Replacement_Single_Copies"><strong>Weighted Choice Without Replacement (Single Copies)</strong></a></li>
<li><a href="#Weighted_Choice_Without_Replacement_List_of_Unknown_Size"><strong>Weighted Choice Without Replacement (List of Unknown Size)</strong></a></li>
<li><a href="#Weighted_Choice_with_Inclusion_Probabilities"><strong>Weighted Choice with Inclusion Probabilities</strong></a></li>
</ul></li>
<li><a href="#Mixtures_of_Distributions"><strong>Mixtures of Distributions</strong></a></li>
<li><a href="#Transformations_of_Random_Variates"><strong>Transformations of Random Variates</strong></a></li>
</ul></li>
<li><a href="#Specific_Non_Uniform_Distributions"><strong>Specific Non-Uniform Distributions</strong></a>

<ul>
<li><a href="#Dice"><strong>Dice</strong></a></li>
<li><a href="#Binomial_Distribution"><strong>Binomial Distribution</strong></a></li>
<li><a href="#Negative_Binomial_Distribution"><strong>Negative Binomial Distribution</strong></a></li>
<li><a href="#Geometric_Distribution"><strong>Geometric Distribution</strong></a></li>
<li><a href="#Exponential_Distribution"><strong>Exponential Distribution</strong></a></li>
<li><a href="#Poisson_Distribution"><strong>Poisson Distribution</strong></a></li>
<li><a href="#P_lya_ndash_Eggenberger_Distribution"><strong>Pólya&ndash;Eggenberger Distribution</strong></a></li>
<li><a href="#Random_Integers_with_a_Given_Positive_Sum"><strong>Random Integers with a Given Positive Sum</strong></a></li>
<li><a href="#Multinomial_Distribution"><strong>Multinomial Distribution</strong></a></li>
</ul></li>
<li><a href="#Randomization_with_Real_Numbers"><strong>Randomization with Real Numbers</strong></a>

<ul>
<li><a href="#Uniform_Random_Real_Numbers"><strong>Uniform Random Real Numbers</strong></a>

<ul>
<li><a href="#For_Fixed_Point_Number_Formats"><strong>For Fixed-Point Number Formats</strong></a></li>
<li><a href="#For_Rational_Number_Formats"><strong>For Rational Number Formats</strong></a></li>
<li><a href="#For_Floating_Point_Number_Formats"><strong>For Floating-Point Number Formats</strong></a></li>
</ul></li>
<li><a href="#Monte_Carlo_Sampling_Expected_Values_Integration_and_Optimization"><strong>Monte Carlo Sampling: Expected Values, Integration, and Optimization</strong></a></li>
<li><a href="#Point_Sample_Selection"><strong>Point Sample Selection</strong></a></li>
<li><a href="#Notes_on_Randomization_Involving_Real_Numbers"><strong>Notes on Randomization Involving Real Numbers</strong></a>

<ul>
<li><a href="#Random_Walks_Additional_Examples"><strong>Random Walks: Additional Examples</strong></a></li>
<li><a href="#Transformations_Additional_Examples"><strong>Transformations: Additional Examples</strong></a></li>
</ul></li>
<li><a href="#Sampling_from_a_Distribution_of_Data_Points"><strong>Sampling from a Distribution of Data Points</strong></a></li>
<li><a href="#Sampling_from_an_Arbitrary_Distribution"><strong>Sampling from an Arbitrary Distribution</strong></a>

<ul>
<li><a href="#Sampling_for_Discrete_Distributions"><strong>Sampling for Discrete Distributions</strong></a></li>
<li><a href="#Inverse_Transform_Sampling"><strong>Inverse Transform Sampling</strong></a></li>
<li><a href="#Rejection_Sampling_with_a_PDF_Like_Function"><strong>Rejection Sampling with a PDF-Like Function</strong></a></li>
<li><a href="#Alternating_Series"><strong>Alternating Series</strong></a></li>
<li><a href="#Markov_Chain_Monte_Carlo"><strong>Markov-Chain Monte Carlo</strong></a></li>
</ul></li>
<li><a href="#Piecewise_Linear_Distribution"><strong>Piecewise Linear Distribution</strong></a></li>
<li><a href="#Specific_Distributions"><strong>Specific Distributions</strong></a></li>
<li><a href="#Index_of_Non_Uniform_Distributions"><strong>Index of Non-Uniform Distributions</strong></a></li>
<li><a href="#Geometric_Sampling"><strong>Geometric Sampling</strong></a>

<ul>
<li><a href="#Random_Points_Inside_a_Simplex"><strong>Random Points Inside a Simplex</strong></a></li>
<li><a href="#Random_Points_on_the_Surface_of_a_Hypersphere"><strong>Random Points on the Surface of a Hypersphere</strong></a></li>
<li><a href="#Random_Points_Inside_a_Box_Ball_Shell_or_Cone"><strong>Random Points Inside a Box, Ball, Shell, or Cone</strong></a></li>
<li><a href="#Random_Latitude_and_Longitude"><strong>Random Latitude and Longitude</strong></a></li>
</ul></li>
</ul></li>
<li><a href="#Acknowledgments"><strong>Acknowledgments</strong></a></li>
<li><a href="#Other_Documents"><strong>Other Documents</strong></a></li>
<li><a href="#Notes"><strong>Notes</strong></a></li>
<li><a href="#Appendix"><strong>Appendix</strong></a>

<ul>
<li><a href="#Sources_of_Random_Numbers"><strong>Sources of Random Numbers</strong></a></li>
<li><a href="#Norm_Calculation"><strong>Norm Calculation</strong></a></li>
<li><a href="#Implementation_Considerations"><strong>Implementation Considerations</strong></a></li>
<li><a href="#Security_Considerations"><strong>Security Considerations</strong></a></li>
</ul></li>
<li><a href="#License"><strong>License</strong></a></li>
</ul>

<p><a id=Notation></a></p>

<h2>Notation</h2>

<p>In this document:</p>

<ul>
<li>The <a href="https://peteroupc.github.io/pseudocode.html"><strong>pseudocode conventions</strong></a> apply to this document.</li>
<li>The following notation for intervals is used: [<code>a</code>, <code>b</code>) means &quot;<code>a</code> or greater, but less than <code>b</code>&quot;.  (<code>a</code>, <code>b</code>) means &quot;greater than <code>a</code>, but less than <code>b</code>&quot;.  (<code>a</code>, <code>b</code>] means &quot;greater than <code>a</code> and less than or equal to <code>b</code>&quot;. [<code>a</code>, <code>b</code>] means &quot;<code>a</code> or greater and <code>b</code> or less&quot;.</li>
<li><code>log1p(x)</code> is equivalent to <code>ln(1 + x)</code> and is a &quot;robust&quot; alternative to <code>ln(1 + x)</code> where <code>x</code> is a floating-point number (Pedersen 2018)[^1].</li>
<li><code>MakeRatio(n, d)</code> creates a rational number with the given numerator <code>n</code> and denominator <code>d</code>.</li>
<li><code>Sum(list)</code> calculates the sum of the numbers in the given list of integers or rational numbers.  (Summing floating-point numbers naïvely can introduce round-off errors.)</li>
</ul>

<p><a id=Uniform_Random_Integers></a></p>

<h2>Uniform Random Integers</h2>

<p>This section shows how to derive independent uniform random integers with the help of a &quot;source of random numbers&quot; (or a device or program that simulates that source).</p>

<p>This section describes four methods: <code>RNDINT</code>, <code>RNDINTEXC</code>, <code>RNDINTRANGE</code>, <code>RNDINTEXCRANGE</code>.  Of these, <code>RNDINT</code>, described next, can serve as the basis for the remaining methods.</p>

<p><a id=RNDINT_Random_Integers_in_0_N></a></p>

<h3><code>RNDINT</code>: Random Integers in [0, N]</h3>

<p>In this document, <strong><code>RNDINT(maxInclusive)</code></strong> is the core method in this document; it derives independent uniform integers <strong>in the interval [0, <code>maxInclusive</code>]</strong> from a &quot;source of random numbers&quot;[^2].  In the pseudocode below, which implements <code>RNDINT</code>:</p>

<ul>
<li><code>NEXTRAND()</code> reads the next number generated by a &quot;source of (uniform) random numbers&quot; as defined in the appendix (an endless source of numbers, each of which is chosen independently of any other choice and with a uniform distribution).  As noted in the appendix, a pseudorandom number generator can simulate this source in practice.  For this method, the source can have a non-uniform instead of uniform distribution.</li>
<li><code>MODULUS</code> is the number of different outcomes possible with that source.</li>
</ul>

<p>Specifically:</p>

<table><thead>
<tr>
<th>If the underlying source produces:</th>
<th>Then <code>NEXTRAND()</code> is:</th>
<th>And <code>MODULUS</code> is:</th>
</tr>
</thead><tbody>
<tr>
<td>Non-uniform numbers[^3].</td>
<td>The next bit from a new source formed by taking the underlying source&#39;s outputs as input to a <a href="https://peteroupc.github.io/randextract.html"><strong><em>randomness extraction</em></strong></a> technique to produce independent unbiased random bits (zeros or ones).</td>
<td>2.</td>
</tr>
<tr>
<td>Uniform numbers not described below.</td>
<td>Same as above.</td>
<td>2<sup><em>n</em></sup>.</td>
</tr>
<tr>
<td>Uniform 32-bit non-negative integers.</td>
<td>The next number from the source.</td>
<td>2<sup>32</sup>.</td>
</tr>
<tr>
<td>Uniform 64-bit non-negative integers.</td>
<td>The next number from the source.</td>
<td>2<sup>64</sup>.</td>
</tr>
<tr>
<td>Uniform integers in the interval [0, <em>n</em>).</td>
<td>The next number from the source.</td>
<td><em>n</em>.</td>
</tr>
<tr>
<td>Uniform numbers in the interval [0, 1) known to be evenly spaced by a number <em>p</em> (for example, dSFMT).</td>
<td>The next number from the source, multiplied by <em>p</em>.</td>
<td>1/<em>p</em>.</td>
</tr>
<tr>
<td>Uniform numbers in the interval [0, 1), where numbers in [0, 0.5) and those in [0.5, 1) are known to occur with equal probability (for example, Java&#39;s <code>Math.random()</code>).</td>
<td>0 if the source outputs a number less than 0.5, or 1 otherwise.</td>
<td>2.</td>
</tr>
</tbody></table>

<pre>METHOD RndIntHelperNonPowerOfTwo(maxInclusive)
  if maxInclusive &lt;= MODULUS - 1:
    // NOTE: If the programming language implements
    // division with two integers by discarding the result&#39;s
    // fractional part, the division can be used as is without
    // using a &quot;floor&quot; function.
    nPlusOne = maxInclusive + 1
    maxexc = floor((MODULUS - 1) / nPlusOne) * nPlusOne
    while true // until a value is returned
      ret = NEXTRAND()
      if ret &lt; nPlusOne: return ret
      if ret &lt; maxexc: return rem(ret, nPlusOne)
    end
  else
    cx = floor(maxInclusive / MODULUS) + 1
    while true // until a value is returned
       ret = cx * NEXTRAND()
       // NOTE: The addition operation below should
       // check for integer overflow and should reject the
       // number if overflow would result.
       ret = ret + RNDINT(cx - 1)
       if ret &lt;= maxInclusive: return ret
    end
  end
END METHOD

METHOD RndIntHelperPowerOfTwo(maxInclusive)
  // NOTE: Finds the number of bits minus 1 needed
  // to represent MODULUS (in other words, the number
  // of random bits returned by NEXTRAND() ). This will
  // be a constant here, though.
  modBits = ln(MODULUS)/ln(2)
  // Lumbroso&#39;s Fast Dice Roller.
  x = 1
  y = 0
  nextBit = modBits
  rngv = 0
  while true // until a value is returned
    if nextBit &gt;= modBits
      nextBit = 0
      rngv = NEXTRAND()
    end
    x = x * 2
    y = y * 2 + rem(rngv, 2)
    rngv = floor(rngv / 2)
    nextBit = nextBit + 1
    if x &gt; maxInclusive
      if y &lt;= maxInclusive: return y
      x = x - maxInclusive - 1
      y = y - maxInclusive - 1
    end
  end
END METHOD

METHOD RNDINT(maxInclusive)
  // maxInclusive must be 0 or greater
  if maxInclusive &lt; 0: return error
  if maxInclusive == 0: return 0
  if maxInclusive == MODULUS - 1: return NEXTRAND()
  // NOTE: Finds the number of bits minus 1 needed
  // to represent MODULUS (if it&#39;s a power of 2).
  // This will be a constant here, though.
  modBits=ln(MODULUS)/ln(2)
  if floor(modBits) == modBits // Is an integer
    return RndIntHelperPowerOfTwo(maxInclusive)
  else
    return RndIntHelperNonPowerOfTwo(maxInclusive)
  end
END METHOD
</pre>

<p>The table below shows algorithms that have been proposed for choosing an integer uniformly at random.  Some are <em>unbiased</em> (exact) and others are biased, but in general, the algorithm can be unbiased only if it runs forever in the worst case.  The algorithms listed take <code>n</code> as a parameter, where <code>n = maxInclusive + 1</code>, and thus sample from the interval [0, <code>n</code>). (The column &quot;Unbiased?&quot; means whether the algorithm generates random integers without bias, even if <code>n</code> is not a power of 2.)</p>

<table><thead>
<tr>
<th>Algorithm</th>
<th>Optimal?</th>
<th>Unbiased?</th>
<th>Time Complexity</th>
</tr>
</thead><tbody>
<tr>
<td><em>Rejection sampling</em>: Sample in a bigger range until a sampled number fits the smaller range.</td>
<td>Not always</td>
<td>Yes</td>
<td>Runs forever in worst case</td>
</tr>
<tr>
<td><em>Multiply-and-shift reduction</em>: Generate <code>bignumber</code>, an integer made of <code>k</code> unbiased bits, where <code>k</code> is much greater than <code>n</code>, then find <code>(bignumber * n) &gt;&gt; k</code> (see (Lemire 2016)[^4], (Lemire 2018)[^5], and the &quot;Integer Multiplication&quot; algorithm surveyed by M. O&#39;Neill).</td>
<td>No</td>
<td>No</td>
<td>Constant</td>
</tr>
<tr>
<td><em>Modulo reduction</em>: Generate <code>bignumber</code> as above, then find <code>rem(bignumber, n)</code>.</td>
<td>No</td>
<td>No</td>
<td>Constant</td>
</tr>
<tr>
<td><em>Fast Dice Roller</em> (Lumbroso 2013)[^6] (see pseudocode above).</td>
<td>Yes</td>
<td>Yes</td>
<td>Runs forever in worst case</td>
</tr>
<tr>
<td>Math Forum (2004)[^7] or (Mennucci 2018)[^8] (batching/recycling random bits).</td>
<td>Yes</td>
<td>Yes</td>
<td>Runs forever in worst case</td>
</tr>
<tr>
<td>&quot;FP Multiply&quot; surveyed by <a href="https://www.pcg-random.org/posts/bounded-rands.html"><strong>M. O&#39;Neill</strong></a>.</td>
<td>No</td>
<td>No</td>
<td>Constant</td>
</tr>
<tr>
<td>Algorithm in &quot;Conclusion&quot; section by O&#39;Neill.</td>
<td>No</td>
<td>Yes</td>
<td>Runs forever in worst case</td>
</tr>
<tr>
<td>&quot;Debiased&quot; and &quot;Bitmask with Rejection&quot; surveyed by M. O&#39;Neill.</td>
<td>No</td>
<td>Yes</td>
<td>Runs forever in worst case</td>
</tr>
</tbody></table>

<blockquote>
<p><strong>Notes:</strong></p>

<ol>
<li><strong><code>RNDINT</code> as a binary tree walker.</strong> Donald E. Knuth and Andrew C. Yao (1976)[^9] showed that any algorithm that generates random integers using random unbiased bits (each bit is 0 or 1 with equal probability) can be described as a <em>binary tree</em> (also known as a <em>DDG tree</em> or <em>discrete distribution generating tree</em>).  (This also applies to <code>RNDINT</code> algorithms.)  Random unbiased bits trace a path in this tree, and each leaf (terminal node) in the tree represents an outcome.  In the case of <code>RNDINT(maxInclusive)</code>, there are <code>n = maxInclusive + 1</code> outcomes that each occur with probability <code>1/n</code>.<br/>Knuth and Yao showed that any <em>optimal</em> DDG tree algorithm needs at least <code>log2(n)</code> and at most <code>log2(n) + 2</code> bits on average (where <code>log2(x) = ln(x)/ln(2)</code>).[^10]  But as they also showed, for the algorithm to be <em>unbiased (exact)</em>, it must run forever in the worst case, even if it uses few random bits on average (that is, there is no way in general to &quot;fix&quot; this worst case while remaining unbiased).  This is because <code>1/n</code> will have an infinite run of base-2 digits except when <code>n</code> is a power of 2, so that the resulting DDG tree will have to either be infinitely deep, or include &quot;rejection leaves&quot; at the end of the tree.<br/>For instance, the <em>modulo reduction</em> method can be represented by a DDG tree in which rejection leaves are replaced with labeled outcomes, but the method is biased because only some outcomes can replace rejection leaves this way.  For the same reason, stopping the <em>rejection sampler</em> after a fixed number of tries likewise leads to bias. However, which outcomes are biased this way depends on the algorithm.</li>
<li><strong>Reducing &quot;bit waste&quot;.</strong> Any implementation of <code>RNDINT</code> needs at least <code>log2(n)</code> bits per chosen integer on average, as noted above, but most of them use many more.  There are various ways to bring an algorithm closer to <code>log2(n)</code>.  They include batching, bit recycling, and randomness extraction, and they are discussed, for example, in the Math Forum page and the Lumbroso and Mennucci papers referenced above, and in Devroye and Gravel (2020, section 2.3)[^11].  <em>Batching example</em>: To generate three digits from 0 through 9, we can call <code>RNDINT(999)</code> to generate an integer in [0, 999], then break the number it returns into three digits.</li>
<li><strong>Simulating dice.</strong> If we have a (virtual) fair <em>p</em>-sided die, how can we use it to simulate rolls of a <em>k</em>-sided die?  This can&#39;t be done without &quot;wasting&quot; randomness, unless &quot;every prime number dividing <em>k</em> also divides <em>p</em>&quot; (see &quot;<a href="https://perso.math.u-pem.fr/kloeckner.benoit/papiers/DiceSimulation.pdf"><strong>Simulating a dice with a dice</strong></a>&quot; by B. Kloeckner, 2008).  However, <em>randomness extraction</em> (see my <a href="https://peteroupc.github.io/randextract.html"><strong>Note on Randomness Extraction</strong></a>) can turn die rolls into unbiased bits, so that the discussion earlier in this section applies.</li>
</ol>
</blockquote>

<p><a id=RNDINTRANGE_Random_Integers_in_N_M></a></p>

<h3><code>RNDINTRANGE</code>: Random Integers in [N, M]</h3>

<p>The na&iuml;ve way of generating a <strong>random integer in the interval [<code>minInclusive</code>, <code>maxInclusive</code>]</strong>, shown below, works well for nonnegative integers and arbitrary-precision integers.</p>

<pre> METHOD RNDINTRANGE(minInclusive, maxInclusive)
   // minInclusive must not be greater than maxInclusive
   if minInclusive &gt; maxInclusive: return error
   return minInclusive + RNDINT(maxInclusive - minInclusive)
 END METHOD
</pre>

<p>The na&iuml;ve approach won&#39;t work as well, though, if the integer format can express negative and nonnegative integers and the difference between <code>maxInclusive</code> and <code>minInclusive</code> exceeds the highest possible integer for the format.  For integer formats that can express&mdash;</p>

<ol>
<li>every integer in the interval [-1 - <code>MAXINT</code>, <code>MAXINT</code>] (for example, Java <code>int</code>, <code>short</code>, or <code>long</code>), or</li>
<li>every integer in the interval [-<code>MAXINT</code>, <code>MAXINT</code>] (for example, Java <code>float</code> and <code>double</code> and .NET&#39;s implementation of <code>System.Decimal</code>),</li>
</ol>

<p>where <code>MAXINT</code> is an integer greater than 0, the following pseudocode for <code>RNDINTRANGE</code> can be used.</p>

<pre>METHOD RNDINTRANGE(minInclusive, maxInclusive)
   // minInclusive must not be greater than maxInclusive
   if minInclusive &gt; maxInclusive: return error
   if minInclusive == maxInclusive: return minInclusive
   if minInclusive==0: return RNDINT(maxInclusive)
   // Difference does not exceed maxInclusive
   if minInclusive &gt; 0 or minInclusive + MAXINT &gt;= maxInclusive
       return minInclusive + RNDINT(maxInclusive - minInclusive)
   end
   while true // until a value is returned
     ret = RNDINT(MAXINT)
     // NOTE: For case 1, use the following line:
     if RNDINT(1) == 0: ret = -1 - ret
     // NOTE: For case 2, use the following three lines
     // instead of the preceding line; these lines
     // avoid negative zero
     // negative = RNDINT(1) == 0
     // if negative: ret = 0 - ret
     // if negative and ret == 0: continue
     if ret &gt;= minInclusive and ret &lt;= maxInclusive: return ret
   end
END METHOD
</pre>

<p><a id=RNDINTEXC_Random_Integers_in_0_N></a></p>

<h3><code>RNDINTEXC</code>: Random Integers in [0, N)</h3>

<p><code>RNDINTEXC(maxExclusive)</code>, which generates a <strong>random integer in the interval</strong> <strong>[0, <code>maxExclusive</code>)</strong>, can be implemented as follows[^12]:</p>

<pre> METHOD RNDINTEXC(maxExclusive)
    if maxExclusive &lt;= 0: return error
    return RNDINT(maxExclusive - 1)
 END METHOD
</pre>

<blockquote>
<p><strong>Note:</strong> <code>RNDINTEXC</code> is not given as the core random generation method because it&#39;s harder to fill integers in popular integer formats with random bits with this method.</p>
</blockquote>

<p><a id=RNDINTEXCRANGE_Random_Integers_in_N_M></a></p>

<h3><code>RNDINTEXCRANGE</code>: Random Integers in [N, M)</h3>

<p><strong><code>RNDINTEXCRANGE</code></strong> returns a <strong>random integer in the interval</strong> <strong>[<code>minInclusive</code>, <code>maxExclusive</code>)</strong>.  It can be implemented using <a href="#RNDINTRANGE_Random_Integers_in_N_M"><strong><code>RNDINTRANGE</code></strong></a>, as the following pseudocode demonstrates.</p>

<pre>METHOD RNDINTEXCRANGE(minInclusive, maxExclusive)
   if minInclusive &gt;= maxExclusive: return error
   if minInclusive &gt;=0: return RNDINTRANGE(
      minInclusive, maxExclusive - 1)
   while true // until a value is returned
     ret = RNDINTRANGE(minInclusive, maxExclusive)
     if ret &lt; maxExclusive: return ret
   end
END METHOD
</pre>

<p><a id=Uniform_Random_Bits></a></p>

<h3>Uniform Random Bits</h3>

<p>The idiom <code>RNDINT((1 &lt;&lt; b) - 1)</code> is a na&iuml;ve way of generating a <strong>uniform random <code>b</code>-bit integer</strong> (with maximum 2<sup><code>b</code></sup> - 1).</p>

<p>In practice, memory is usually divided into <em>bytes</em>, or 8-bit integers in the interval [0, 255].  In this case, a block of memory can be filled with random bits&mdash;</p>

<ul>
<li>by setting each byte in the block to <code>RNDINT(255)</code>, or</li>
<li>via a PRNG (or another device or program that simulates a &quot;source of random numbers&quot;), if it outputs one or more 8-bit chunks at a time.</li>
</ul>

<p><a id=Examples_of_Using_the_RNDINT_Family></a></p>

<h3>Examples of Using the <code>RNDINT</code> Family</h3>

<ol>
<li>To choose either &minus;1 or 1 with equal probability (the <em>Rademacher distribution</em>), one of the following idioms can be used: <code>(RNDINT(1) * 2 - 1)</code> or <code>(RNDINTEXC(2) * 2 - 1)</code>.</li>
<li>To generate a random integer that&#39;s divisible by a positive integer (<code>DIV</code>), generate the integer with any method (such as <code>RNDINT</code>), let <code>X</code> be that integer, then generate <code>X - rem(X, DIV)</code> if <code>X &gt;= 0</code>, or <code>X - (DIV - rem(abs(X), DIV))</code> otherwise. (Depending on the method, the resulting integer may be out of range, in which case this procedure is to be repeated.)</li>
<li>A random 2-dimensional point on an N&times;M grid can be expressed as a single integer as follows:

<ul>
<li>To generate a random N&times;M point <code>P</code>, generate <code>P = RNDINT(N * M - 1)</code> (<code>P</code> is thus in the interval [0, <code>N * M</code>)).</li>
<li>To convert a point <code>P</code> to its 2D coordinates, generate <code>[rem(P, N), floor(P / N)]</code>. (Each coordinate starts at 0.)</li>
<li>To convert 2D coordinates <code>coord</code> to an N&times;M point, generate <code>P = coord[1] * N + coord[0]</code>.</li>
</ul></li>
<li>To simulate rolling an N-sided die (N greater than 1): <code>RNDINTRANGE(1, N)</code>, which chooses a number in the interval [1, N] with equal probability.</li>
<li>To generate a random integer with one base-10 digit: <code>RNDINTRANGE(0, 9)</code>.</li>
<li>To generate a random integer with N base-10 digits (where N is 2 or greater), where the first digit can&#39;t be 0: <code>RNDINTRANGE(pow(10, N-1), pow(10, N) - 1)</code>.</li>
<li>To choose a number in the interval [<code>mn</code>, <code>mx</code>), with equal probability, in increments equal to <code>step</code>: <code>mn+step*RNDINTEXC(ceil((mx-mn)/(1.0*step)))</code>.</li>
<li>To choose an integer in the interval [0, <code>X</code>) at random:

<ul>
<li>And favor numbers in the middle:  <code>floor((RNDINTEXC(X) + RNDINTEXC(X)) / 2)</code>.</li>
<li>And favor high numbers:  <code>max(RNDINTEXC(X), RNDINTEXC(X))</code>.</li>
<li>And favor low numbers:  <code>min(RNDINTEXC(X), RNDINTEXC(X))</code>.</li>
<li>And strongly favor high numbers:  <code>max(RNDINTEXC(X), RNDINTEXC(X), RNDINTEXC(X))</code>.</li>
<li>And strongly favor low numbers:  <code>min(RNDINTEXC(X), RNDINTEXC(X), RNDINTEXC(X))</code>.</li>
</ul></li>
</ol>

<p><a id=Randomization_Techniques></a></p>

<h2>Randomization Techniques</h2>

<p>This section describes commonly used randomization techniques, such as shuffling, selection of several unique items, and creating random strings of text.</p>

<p><a id=Boolean_True_False_Conditions></a></p>

<h3>Boolean (True/False) Conditions</h3>

<p>To generate a condition that is true at the specified probabilities, use
the following idioms in an <code>if</code> condition:</p>

<ul>
<li>True or false with equal probability: <code>RNDINT(1) == 0</code>.</li>
<li>True with X percent probability: <code>RNDINTEXC(100) &lt; X</code>.</li>
<li>True with probability X/Y (a <em>Bernoulli trial</em>): <code>RNDINTEXC(Y) &lt; X</code>.</li>
<li>True with odds of X to Y: <code>RNDINTEXC(X + Y) &lt; X</code>.</li>
</ul>

<p>The following helper method generates 1 with probability <code>x</code>/<code>y</code> and 0 otherwise:</p>

<pre>METHOD ZeroOrOne(x,y)
  if RNDINTEXC(y)&lt;x: return 1
  return 0
END METHOD
</pre>

<p>The method can also be implemented in the following way (as pointed out by Lumbroso (2013, Appendix B)[^6]):</p>

<pre>// NOTE: Modified from Lumbroso
// Appendix B to add &#39;z==0&#39; and error checks
METHOD ZeroOrOne(x,y)
  if y &lt;= 0: return error
  if x==y: return 1
  z = x
  while true // until a value is returned
    z = z * 2
    if z &gt;= y
      if RNDINT(1) == 0: return 1
      z = z - y
    else if z == 0 or RNDINT(1) == 0: return 0
  end
END METHOD
</pre>

<blockquote>
<p><strong>Note:</strong> Probabilities can be rational or irrational numbers.  Rational probabilities are of the form <code>n</code>/<code>d</code> and can be simulated with <code>ZeroOrOne</code> above.  Irrational probabilities (such as <code>exp(-x/y)</code> or <code>ln(2)</code>) have an infinite digit expansion (<code>0.ddddd....</code>), and they require special algorithms to simulate; see &quot;<a href="https://peteroupc.github.io/bernoulli.html#Algorithms_for_Irrational_Constants"><strong>Algorithms for Irrational Constants</strong></a>&quot; in my page on Bernoulli Factory algorithms.</p>

<p><strong>Examples</strong>:</p>

<ul>
<li>True with probability 3/8: <code>RNDINTEXC(8) &lt; 3</code>.</li>
<li>True with odds of 100 to 1: <code>RNDINTEXC(101) &lt; 1</code>.</li>
<li>True with 20% probability: <code>RNDINTEXC(100) &lt; 20</code>.</li>
<li>To generate a random integer in [0, <code>y</code>), or -1 instead if that number would be less than <code>x</code>, using fewer random bits than the naïve approach: <code>if ZeroOrOne(x, y) == 1: return -1; else: return RNDINTEXCRANGE(x, y)</code>.</li>
</ul>
</blockquote>

<p><a id=Random_Sampling></a></p>

<h3>Random Sampling</h3>

<p>This section contains ways to choose one or more items from among a collection of them, where each item in the collection has the same chance to be chosen as any other.  This is called <em>random sampling</em> and can be done <em>with replacement</em> or <em>without replacement</em>.</p>

<p><a id=Sampling_With_Replacement_Choosing_a_Random_Item_from_a_List></a></p>

<h4>Sampling With Replacement: Choosing a Random Item from a List</h4>

<p><em>Sampling with replacement</em>  essentially means taking a random item and putting it back.  To choose a random item from a list&mdash;</p>

<ul>
<li>whose size is known in advance, use the idiom <code>list[RNDINTEXC(size(list))]</code>; or</li>
<li>whose size is not known in advance, generate <code>RandomKItemsFromFile(file, 1)</code>, in <a href="#Pseudocode_for_Random_Sampling"><strong>pseudocode given later</strong></a> (the result will be a 1-item list or be an empty list if there are no items).</li>
</ul>

<p><a id=Sampling_Without_Replacement_Choosing_Several_Unique_Items></a></p>

<h4>Sampling Without Replacement: Choosing Several Unique Items</h4>

<p><em>Sampling without replacement</em>  essentially means taking a random item <em>without</em> putting it back.   There are several approaches for doing a uniform random choice of <code>k</code> unique items or values from among <code>n</code> available items or values, depending on such things as whether <code>n</code> is known and how big <code>n</code> and <code>k</code> are.</p>

<ol>
<li><strong>If <code>n</code> is not known in advance:</strong> Use the <em>reservoir sampling</em> method; see the <code>RandomKItemsFromFile</code> method, in <a href="#Pseudocode_for_Random_Sampling"><strong>pseudocode given later</strong></a>.</li>
<li><strong>If <code>n</code> is relatively small (for example, if there are 200 available items, or there is a range of numbers from 0 through 200 to choose from):</strong>

<ul>
<li>If items have to be chosen from a list <strong>in relative (index) order</strong>, or if <code>n</code> is 1, then use <code>RandomKItemsInOrder</code> (given later).</li>
<li>Otherwise, if the order of the sampled items is unimportant, and each item can be derived from its <em>index</em> (the item&#39;s position as an integer starting at 0) without looking it up in a list: Use the <code>RandomKItemsFromFile</code> method.[^13]</li>
<li>Otherwise, if <code>k</code> is much smaller than <code>n</code>, proceed as in item 3 instead.</li>
<li>Otherwise, any of the following will choose <code>k</code> items in random order:

<ul>
<li>Store all the items in a list, <a href="#Shuffling"><strong>shuffle</strong></a> that list, then choose the first <code>k</code> items from that list.</li>
<li>If the items are already stored in a list and the list&#39;s order can be changed, then shuffle that list and choose the first <code>k</code> items from the shuffled list.</li>
<li>If the items are already stored in a list and the list&#39;s order can&#39;t be changed, then store the indices to those items in another list, shuffle the latter list, then choose the first <code>k</code> indices (or the items corresponding to those indices) from the latter list.</li>
</ul></li>
</ul></li>
<li><strong>If <code>k</code> is much smaller than <code>n</code> and the order of the items must be random or is unimportant:</strong>

<ol>
<li><strong>If the items are stored in a list whose order can be changed:</strong> Do a <em>partial shuffle</em> of that list, then choose the <em>last</em> <code>k</code> items from that list.  A <em>partial shuffle</em> proceeds as given in the section &quot;<a href="#Shuffling"><strong>Shuffling</strong></a>&quot;, except the partial shuffle stops after <code>k</code> swaps have been made (where swapping one item with itself counts as a swap).</li>
<li><strong>Otherwise</strong>: Create another empty list <code>newlist</code>, and create a key/value data structure such as a hash table. Then, for each integer <code>i</code> in the interval [0, <em>k</em>&minus;1], do <code>j = RNDINTEXC(n-i); AddItem(newlist, HGET(j,j)); HSET(j,HGET(n-i-1,n-i-1))</code>, where <code>HSET(k,v)</code> sets the item with key <code>k</code> in the hash table to <code>v</code>, and <code>HGET(k,v)</code> gets the item with key <code>k</code> in that table, or returns <code>v</code> if there is no such item (Ting 2021)[^14].  The new list stores the indices to the chosen items, in random order.</li>
</ol></li>
<li><strong>If <code>n - k</code> is much smaller than <code>n</code>, the items are stored in a list, and the order of the sampled items is unimportant:</strong>

<ol>
<li><strong>If the list&#39;s order can be changed:</strong> Do a <em>partial shuffle</em> of that list, except that <code>n-k</code> rather than <code>k</code> swaps are done, then choose the <em>first</em> <code>k</code> items from that list. (Note 5 in &quot;Shuffling&quot; can&#39;t be used.)</li>
<li>Otherwise, <strong>if <code>n</code> is not very large (for example, less than 5000):</strong> Store the indices to those items in another list, do a <em>partial shuffle</em> of the latter list, except that <code>n-k</code> rather than <code>k</code> swaps are done, then choose the <em>first</em> <code>k</code> indices (or the items corresponding to those indices) from the latter list. (Note 5 in &quot;Shuffling&quot; can&#39;t be used.)</li>
<li><strong>Otherwise</strong>: Proceed as in item 5 instead.</li>
</ol></li>
<li><p><strong>Otherwise (for example, if 32-bit or larger integers will be chosen so that <code>n</code> is 2<sup>32</sup>, or if <code>n</code> is otherwise very large):</strong></p>

<ul>
<li>If the items have to be chosen <strong>in relative (index) order</strong>: Let <code>n2 = floor(n/2)</code>.  Generate <code>h = PolyaEggenberger(k, n2, n, -1)</code>.  Sample <code>h</code> integers in relative order from the list <code>[0, 1, ..., n2 - 1]</code> by doing a recursive run of this algorithm (items 1 to 5), then sample <code>k - h</code> integers in relative order from the list <code>[n2, n2 + 1, ..., n - 1]</code> by running this algorithm recursively.  The integers chosen this way are the indices to the desired items in relative (index) order (Sanders et al. 2019)[^15].</li>
<li><p>Otherwise, create a data structure to store the indices to items already chosen.  When a new index to an item is randomly chosen, add it to the data structure if it&#39;s not already there, or if it is, choose a new random index.  Repeat this process until <code>k</code> indices were added to the data structure this way.  Examples of suitable data structures are&mdash;</p>

<ul>
<li>a <a href="https://en.wikipedia.org/wiki/Hash_table"><strong>hash table</strong></a>,</li>
<li>a compressed bit set (e.g, &quot;roaring bitmap&quot;, EWAH), and</li>
<li>a self-sorting data structure such as a <a href="https://en.wikipedia.org/wiki/Red%E2%80%93black_tree"><strong>red&ndash;black tree</strong></a>, if the random items are to be retrieved in sorted order or in index order.</li>
</ul>

<p>Many applications require generating &quot;unique random&quot; values to identify database records or other shared resources, among other reasons.  For ways to generate such values, see my <a href="https://peteroupc.github.io/random.html#Unique_Random_Identifiers"><strong>recommendation document</strong></a>.</p></li>
</ul></li>
</ol>

<p><a id=Shuffling></a></p>

<h4>Shuffling</h4>

<p>The <a href="https://en.wikipedia.org/wiki/Fisher-Yates_shuffle"><strong>Fisher&ndash;Yates shuffle method</strong></a> shuffles a list (puts its items in a random order) such that all permutations (arrangements) of that list are equally likely to occur.  However, that method is also easy to write incorrectly &mdash; see also (Atwood 2007)[^16].  The following pseudocode is designed to shuffle a list&#39;s contents.</p>

<pre>METHOD Shuffle(list)
   // NOTE: Check size of the list early to prevent
   // `i` from being less than 0 if the list&#39;s size is 0 and
   // `i` is implemented using an nonnegative integer
   // type available in certain programming languages.
   if size(list) &gt;= 2
      // Set i to the last item&#39;s index
      i = size(list) - 1
      while i &gt; 0
         // Choose an item ranging from the first item
         // up to the item given in `i`. Observe that the item
         // at i+1 is excluded.
         j = RNDINTEXC(i + 1)
         // Swap item at index i with item at index j;
         // in this case, i and j may be the same
         tmp = list[i]
         list[i] = list[k]
         list[k] = tmp
         // Move i so it points to the previous item
         i = i - 1
      end
   end
   // NOTE: An implementation can return the
   // shuffled list, as is done here, but this is not required.
   return list
END METHOD
</pre>

<blockquote>
<p><strong>Notes:</strong></p>

<ol>
<li><code>j = RNDINTEXC(i + 1)</code> can&#39;t be replaced with <code>j = RNDINTEXC(size(list))</code> since it introduces biases.  If that line is replaced with <code>j = RNDINTEXC(i)</code>, the result is Sattolo&#39;s algorithm (which chooses from among permutations with cycles), rather than a Fisher&ndash;Yates shuffle.</li>
<li>When it comes to shuffling, the choice of pseudorandom number generator (or whatever is simulating a &quot;source of random numbers&quot;) is important; see my <a href="https://peteroupc.github.io/random.html#Shuffling"><strong>recommendation document on shuffling</strong></a>.</li>
<li>A shuffling algorithm that can be carried out in parallel is described in (Bacher et al., 2015)[^17].</li>
<li>A <em>derangement</em> is a permutation where every item moves to a different position.  A random derangement can be generated as follows (Merlini et al. 2007)[^18]: (1) modify <code>Shuffle</code> by adding the following line after <code>j = RNDINTEXC(i + 1)</code>: <code>if i == list[j]: return nothing</code>, and changing <code>while i &gt; 0</code> to <code>while i &gt;= 0</code>; (2) use the following pseudocode with the modified <code>Shuffle</code> method: <code>while True; list = []; for i in 0...n: AddItem(list, i); s=Shuffle(list); if s!=nothing: return s; end</code>.</li>
<li>Ting (2021)[^14] showed how to reduce the space complexity of shuffling via a <em>hash table</em>: Modify <code>Shuffle</code> as follows: (1) Create a hash table at the start of the method; (2) instead of the swap <code>tmp = list[i]; list[i] = list[j]; list[j] = tmp</code>, use the following: <code>list[i] = HGET(j,j); HSET(k,HGET(i,i)); if k==i: HDEL(i)</code>, where <code>HSET(k,v)</code> sets the item with key <code>k</code> in the hash table to <code>v</code>; <code>HGET(k,v)</code> gets the item with key <code>k</code> in that table, or returns <code>v</code> if there is no such item; and <code>HDEL(k)</code> deletes the item with key <code>k</code> from that table. (The hash table can instead be any key/value map structure, including a red&ndash;black tree.  This can be combined with note 4 to generate derangements, except replace <code>list[j]</code> in note 4 with <code>HGET(j,j)</code>.)</li>
</ol>
</blockquote>

<p><a id=Random_Character_Strings></a></p>

<h4>Random Character Strings</h4>

<p>To generate a random string of characters:</p>

<ol>
<li>Prepare a list of the letters, digits, and/or other characters the string can have.  Examples are given later in this section.</li>
<li>Build a new string whose characters are chosen at random from that character list.  The method, shown in the pseudocode below, demonstrates this. The method samples characters at random with replacement, and returns a list of the sampled characters. (How to convert this list to a text string depends on the programming language and is outside the scope of this page.) The method takes two parameters: <code>characterList</code> is the list from step 1, and <code>stringSize</code> is the number of random characters.</li>
</ol>

<p>&nbsp;</p>

<pre>METHOD RandomString(characterList, stringSize)
  i = 0
  newString = NewList()
  while i &lt; stringSize
    // Choose a character from the list
    randomChar = characterList[RNDINTEXC(size(characterList))]
    // Add the character to the string
    AddItem(newString, randomChar)
    i = i + 1
  end
  return newString
END METHOD
</pre>

<p>The following are examples of character lists:</p>

<ol>
<li>For an <em>alphanumeric string</em>, or string of letters and digits, the characters can be the basic digits &quot;0&quot; to &quot;9&quot; (U+0030-U+0039, nos. 48-57), the basic upper case letters &quot;A&quot; to &quot;Z&quot; (U+0041-U+005A, nos. 65-90), and the basic lower case letters &quot;a&quot; to &quot;z&quot; (U+0061-U+007A, nos. 96-122), as given in the Unicode Standard.</li>
<li>For a base-10 digit string, the characters can be the basic digits only.</li>
<li>For a base-16 digit (hexadecimal) string, the characters can be the basic digits as well as the basic letters &quot;A&quot; to &quot;F&quot; or &quot;a&quot; to &quot;f&quot; (not both).</li>
</ol>

<blockquote>
<p><strong>Notes:</strong></p>

<ol>
<li>If the list of characters is fixed, the list can be created in advance at runtime or compile time, or (if every character takes up the same number of code units) a string type as provided in the programming language can be used to store the list as a string.</li>
<li><strong>Unique random strings:</strong> Generating character strings that are not only random, but also unique, can be done by storing a list (such as a hash table) of strings already generated and checking newly generated strings against that list.  However, if the unique values will identify something, such as database records or user accounts, an application may care about the choice of PRNG (or other device or program that simulates a &quot;source of random numbers&quot;), so that using <em>random</em> unique values might not be best; see my <a href="https://peteroupc.github.io/random.html#Unique_Random_Identifiers"><strong>recommendation document</strong></a>.</li>
<li><strong>Word generation:</strong> This technique could also be used to generate &quot;pronounceable&quot; words, but this is less flexible than other approaches; see also &quot;<a href="#Markov_Chains"><strong>Markov Chains</strong></a>&quot;.</li>
</ol>
</blockquote>

<p><a id=Pseudocode_for_Random_Sampling></a></p>

<h4>Pseudocode for Random Sampling</h4>

<p>The following pseudocode implements two methods:</p>

<ol>
<li><code>RandomKItemsFromFile</code> implements <a href="https://en.wikipedia.org/wiki/Reservoir_sampling"><strong><em>reservoir sampling</em></strong></a>; it chooses up to <code>k</code> random items from a file of indefinite size (<code>file</code>). Although the pseudocode refers to files and lines, the technique works whenever items are retrieved one at a time from a data set or list whose size is not known in advance.  In the pseudocode, <code>ITEM_OUTPUT(item, thisIndex)</code> is a placeholder for code that returns the item to store in the list; this can include the item&#39;s value, its index starting at 0, or both.</li>
<li><code>RandomKItemsInOrder</code> returns a list of up to <code>k</code> random items from the given list (<code>list</code>), in the order in which they appeared in the list.  It is based on a technique presented in (Devroye 1986)[^19], p. 620.</li>
</ol>

<p>&nbsp;</p>

<pre>METHOD RandomKItemsFromFile(file, k)
  list = NewList()
  j = 0
  index = 0
  while true // until a value is returned
    // Get the next line from the file
    item = GetNextLine(file)
    thisIndex = index
    index = index + 1
    // If the end of the file was reached, break
    if item == nothing: break
    // NOTE: The following line is OPTIONAL
    // and can be used to choose only random lines
    // in the file that meet certain criteria,
    // expressed as MEETS_CRITERIA below.
    // ------
    // if not MEETS_CRITERIA(item): continue
    // ------
    if j &lt; k // phase 1 (fewer than k items)
      AddItem(list, ITEM_OUTPUT(item, thisIndex))
      j = j + 1
    else // phase 2
      j = RNDINT(thisIndex)
      if j &lt; k: list[j] = ITEM_OUTPUT(item, thisIndex)
    end
  end
  // NOTE: Shuffle at the end in case k or
  // fewer lines were in the file, since in that
  // case the items would appear in the same
  // order as they appeared in the file
  // if the list weren&#39;t shuffled.  This line
  // can be removed, however, if the order of
  // the items in the list is unimportant.
  if size(list)&gt;=2: Shuffle(list)
  return list
end

METHOD RandomKItemsInOrder(list, k)
  n = size(list)
  // Special case if k is 1
  if k==1: return [list[RNDINTEXC(n)]]
  i = 0
  kk = k
  ret = NewList()
  while i &lt; n and size(ret) &lt; k
    u = RNDINTEXC(n - i)
    if u &lt;= kk
      AddItem(ret, list[i])
      kk = kk - 1
    end
    i = i + 1
  end
  return ret
END METHOD
</pre>

<blockquote>
<p><strong>Examples:</strong></p>

<ol>
<li>Removing <code>k</code> random items from a list of <code>n</code> items (<code>list</code>) is equivalent to generating a new
list by <code>RandomKItemsInOrder(list, n - k)</code>.</li>
<li><strong>Filtering:</strong> If an application needs to sample the same list (with or without replacement) repeatedly, but only from among a selection of that list&#39;s items, it can create a list of items it wants to sample from (or a list of indices to those items), and sample from the new list instead.[^20]  This won&#39;t work well, though, for lists of indefinite or very large size.</li>
</ol>
</blockquote>

<p><a id=Rejection_Sampling></a></p>

<h3>Rejection Sampling</h3>

<p><em>Rejection sampling</em> is a simple and flexible approach for generating random content that meets certain requirements.  To implement rejection sampling:</p>

<ol>
<li>Generate the random content (such as a number or text string) by any method and with any distribution and range.</li>
<li>If the content doesn&#39;t meet predetermined criteria, go to step 1.</li>
</ol>

<p>Example criteria include checking&mdash;</p>

<ul>
<li>whether a number generated this way&mdash;

<ul>
<li>is not less than a minimum threshold (<em>left-truncation</em>),</li>
<li>is not greater than a maximum threshold (<em>right-truncation</em>),</li>
<li>is prime,</li>
<li>is divisible or not by certain numbers,</li>
<li>is not among numbers chosen recently by the sampling method,</li>
<li>was not already chosen (with the aid of a hash table, red&ndash;black tree, or similar structure),</li>
<li>was not chosen more often in a row than desired, or</li>
<li>is not included in a &quot;blacklist&quot; of numbers,</li>
</ul></li>
<li>whether a point generated this way is sufficiently distant from previous random points (with the aid of a KD-tree or similar structure),</li>
<li>whether a point generated this way lies in a simple or complex shape,</li>
<li>whether a text string generated this way matches a regular expression, or</li>
<li>two or more of the foregoing criteria.</li>
</ul>

<p>(KD-trees, hash tables, red&ndash;black trees, prime-number testing algorithms, and regular expressions are outside the scope of this document.)</p>

<blockquote>
<p><strong>Notes:</strong></p>

<ol>
<li>The running time for rejection sampling depends on the acceptance rate, that is, how often the sampler accepts a sampled outcome rather than rejecting it.  In general, this rate is the number of acceptable outcomes divided by the total number of outcomes.</li>
<li>All rejection sampling strategies have a chance to reject data, so they all have a <em>variable running time</em> (in fact, they could run indefinitely).  But graphics processing units (GPUs) and other devices that run multiple tasks at once work better if all the tasks finish their work at the same time.  This is not possible if they all implement a rejection sampling technique because of its variable running time.  If each iteration of the rejection sampler has a low rejection rate, one solution is to have each task run one iteration of the sampler, with its own &quot;source of random numbers&quot; (such as numbers generated from its own PRNG), then to take the first sampled number that hasn&#39;t been rejected this way by a task (which can fail at a very low rate).[^21]</li>
</ol>
</blockquote>

<p><a id=Random_Walks></a></p>

<h3>Random Walks</h3>

<p>A <em>random walk</em> is a process with random behavior over time.  A simple form of random walk involves choosing, at random, a number that changes the state of the walk.  The pseudocode below generates a random walk with <em>n</em> steps, where <code>STATEJUMP()</code> is the next number to add to the current state (see examples later in this section).</p>

<pre>METHOD RandomWalk(n)
  // Create a new list with an initial state
  list=[0]
  // Add &#39;n&#39; new numbers to the list.
  for i in 0...n: AddItem(list, list[i] + STATEJUMP())
  return list
END METHOD
</pre>

<blockquote>
<p><strong>Notes:</strong></p>

<ol>
<li>A <strong>white noise process</strong> is simulated by creating a list of independent random variates generated in the same way.  Such a process generally models behavior over time that does not depend on the time or the current state.  One example is <code>ZeroOrOne(px,py)</code> (for modeling a <em>Bernoulli process</em>, where each number is either 1 with probability <code>px</code>/<code>py</code> or 0 otherwise).</li>
<li>A useful reference here is De Bruyne et al. (2021)[^22].</li>
</ol>

<p><strong>Examples:</strong></p>

<ol>
<li>If <code>STATEJUMP()</code> is <code>RNDINT(1) * 2 - 1</code>, the random walk generates numbers that each differ from the last by -1 or 1, chosen at random.</li>
<li>If <code>STATEJUMP()</code> is <code>ZeroOrOne(px,py) * 2 - 1</code>, the random walk generates numbers that each differ from the last by either 1 with probability <code>px</code>/<code>py</code> or &minus;1 otherwise.</li>
<li><strong>Binomial process:</strong> If <code>STATEJUMP()</code> is <code>ZeroOrOne(px,py)</code>, the random walk advances the state with probability <code>px</code>/<code>py</code>.</li>
</ol>
</blockquote>

<p><a id=Random_Dates_and_Times></a></p>

<h3>Random Dates and Times</h3>

<p>Pseudocode like the following can be used to choose a <strong>random date-and-time</strong> bounded by two dates-and-times (<code>date1</code>, <code>date2</code>): <code>dtnum1 = DATETIME_TO_NUMBER(date1); dtnum2 = DATETIME_TO_NUMBER(date2); num = RNDINTRANGE(date1, date2); result = NUMBER_TO_DATETIME(num)</code>.</p>

<p>In that pseudocode, <code>DATETIME_TO_NUMBER</code> and <code>NUMBER_TO_DATETIME</code> convert a date-and-time to or from a number, respectively, at the required granularity, for instance, month, day, or hour granularity (the details of such conversion depend on the date-and-time format and are outside the scope of this document).  Instead of <code>RNDINTRANGE(date1, date2)</code>, any other random selection strategy can be used.</p>

<p><a id=Randomization_in_Statistical_Testing></a></p>

<h3>Randomization in Statistical Testing</h3>

<p>Statistical testing uses shuffling and <em>bootstrapping</em> to help draw conclusions on data through randomization.</p>

<ul>
<li><a href="#Shuffling"><strong>Shuffling</strong></a> is used when each item in a data set belongs to one of several mutually exclusive groups.  Here, one or more <strong>simulated data sets</strong> are generated by shuffling the original data set and regrouping each item in the shuffled data set in order, such that the number of items in each group for the simulated data set is the same as for the original data set.</li>
<li><a href="https://en.wikipedia.org/wiki/Bootstrapping_%28statistics%29"><strong><em>Bootstrapping</em></strong></a> is a method of creating one or more random samples (simulated data sets) of an existing data set, where the items in each sample are chosen <a href="#Sampling_With_Replacement_Choosing_a_Random_Item_from_a_List"><strong>at random with replacement</strong></a>.  (Each random sample can contain duplicates this way.)  See also (Brownlee 2018)[^23].</li>
</ul>

<p>After creating the simulated data sets, one or more statistics, such as the mean, are calculated for each simulated data set as well as the original data set, then the statistics for the simulated data sets are compared with those of the original (such comparisons are outside the scope of this document).</p>

<p><a id=Markov_Chains></a></p>

<h3>Markov Chains</h3>

<p>A <a href="https://en.wikipedia.org/wiki/Markov_chain"><strong>Markov chain</strong></a> models one or more <em>states</em> (for example, individual letters or syllables), and stores the probabilities to transition from one state to another (for example, &quot;b&quot; to &quot;e&quot; with a chance of 20 percent, or &quot;b&quot; to &quot;b&quot; with a chance of 1 percent).  Thus, each state can be seen as having its own list of <em>weights</em> for each relevant state transition (see &quot;<a href="#Weighted_Choice_With_Replacement"><strong>Weighted Choice With Replacement</strong></a>).  For example, a Markov chain for generating <strong>&quot;pronounceable&quot; words</strong>, or words similar to natural-language words, can include &quot;start&quot; and &quot;stop&quot; states for the start and end of the word, respectively.</p>

<p>An algorithm called <em>coupling from the past</em> (Propp and Wilson 1996)[^24] can sample a state from a Markov chain&#39;s <em>stationary distribution</em>, that is, the chain&#39;s steady state, by starting multiple chains at different states and running them until they all reach the same state at the same time.  However, stopping the algorithm early can introduce bias unless precautions are taken (Fill 1998)[^25].  The algorithm works correctly if the chain has a finite number of states and is not periodic, and each state is reachable from every other.</p>

<p>The following pseudocode implements coupling from the past.  In the method, <code>StateCount</code> is the number of states in the Markov chain, <code>UPDATE(chain, state, random)</code> transitions the Markov chain to the next state given the current state and random variates, and <code>RANDOM()</code> generates one or more random variates needed by <code>UPDATE</code>.</p>

<pre>METHOD CFTP(chain)
   states=[]
   numstates=StateCount(chain)
   done=false
   randoms=[]
   while not done
      // Start multiple chains at different states.  NOTE:
      // If the chain is monotonic (meaning the states
      // are ordered and, whenever state A is less
      // than state B, A&#39;s next state is never higher than
      // B&#39;s next state), then just two chains can be
      // created instead, starting
      // at the first and last state, respectively.
      for i in 0...numstates: AddItem(states, i)
      // Update each chain with the same randomness
      AddItem(randoms, RANDOM())
      for k in 0...size(randoms):
         for i in 0...numstates: states[i]=
            UPDATE(chain, states[i], randoms[size(randoms)-1-k])
      end
      // Stop when all states are the same
      fs=states[0]
      done=true
      for i in 1...numstates: done=(done and states[i]==fs)
   end
   return states[0] // Return the steady state
END METHOD
</pre>

<blockquote>
<p><strong>Note:</strong> A <strong>discrete phase-type distribution</strong> consists of a Markov chain, a start state, and an end state.  It models the (random) number of steps, minus 1, needed for the Markov chain to move from the start state to the end state.</p>
</blockquote>

<p><a id=Random_Graphs></a></p>

<h3>Random Graphs</h3>

<p>A <em>graph</em> is a listing of points and the connections between them.  The points are called <em>vertices</em> and the connections, <em>edges</em>.</p>

<p>A convenient way to represent a graph is an <em>adjacency matrix</em>.  This is an <em>n</em>&times;<em>n</em> matrix with <em>n</em> rows and <em>n</em> columns (signifying <em>n</em> vertices in the graph).  For simple graphs, an adjacency matrix contains only 1s and 0s &mdash; for the cell at row <em>r</em> and column <em>c</em>, a 1 means there is an edge pointing from vertex <em>r</em> to vertex <em>c</em>, and a 0 means there are none.</p>

<p>In this section, <code>Zeros(n)</code> creates an <code>n</code>&times;<code>n</code> zero matrix (such as a list consisting of <code>n</code> lists, each of which contains <code>n</code> zeros).</p>

<p>The following method generates a random <code>n</code>-vertex graph that follows the model G(<em>n</em>, <em>p</em>) (also known as the <em>Gilbert model</em> (Gilbert 1959)[^26]), where each edge is drawn with probability <code>px</code>/<code>py</code> (Batagelj and Brandes 2005)[^27].</p>

<pre>METHOD GNPGraph(n, px, py)
    graph=Zeros(n)
    for i in 2...n
       j = i
       while j &gt; 0
          j = j - 1 - min(NegativeBinomialInt(1, px, py), j - 1)
          if j &gt; 0
             // Build an edge
             graph[i][j]=1
             graph[j][i]=1
          end
       end
    end
    return graph
END METHOD
</pre>

<p>Other kinds of graphs are possible, including <em>Erdős&ndash;Rényi graphs</em> (choose <code>m</code> random edges uniformly without replacement, given an <em>n</em>&times;<em>n</em> adjacency matrix), Chung&ndash;Lu graphs, preferential attachment graphs, and more.  For example, a <em>mesh graph</em> is a graph in the form of a rectangular mesh, where vertices are the corners and edges are the sides of the mesh&#39;s rectangles.  A random <em>maze</em> is a random spanning tree (Costantini 2020)[^28] of a mesh graph.  Penschuck et al. (2020)[^29] give a survey of random graph generation techniques.</p>

<p><a id=A_Note_on_Sorting_Random_Variates></a></p>

<h3>A Note on Sorting Random Variates</h3>

<p>In general, sorting random variates is no different from sorting any other data. (Sorting algorithms are outside this document&#39;s scope.)[^30]</p>

<p><a id=General_Non_Uniform_Distributions></a></p>

<h2>General Non-Uniform Distributions</h2>

<p>Some applications need to choose random values such that some of them are more likely to be chosen than others (a <em>non-uniform</em> distribution). Most of the techniques in this section show how to use the <a href="#Uniform_Random_Integers"><strong>uniform random integer methods</strong></a> to generate such random values.</p>

<p><a id=Weighted_Choice></a></p>

<h3>Weighted Choice</h3>

<p>The weighted choice method generates a random item or value from among a collection of them with separate probabilities of each item or value being chosen.  There are several kinds of weighted choice.</p>

<p><a id=Weighted_Choice_With_Replacement></a></p>

<h4>Weighted Choice With Replacement</h4>

<p>The first kind is called weighted choice <em>with replacement</em> (which can be thought of as drawing a ball, then putting it back) or a <em>categorical distribution</em>, where the probability of choosing each item doesn&#39;t change as items are chosen.  In the following pseudocode:</p>

<ul>
<li><code>WeightedChoice</code> takes a single list <code>weights</code> of weights (integers 0 or greater) and returns the <em>index</em> of a weight from that list.  The greater the weight, the more likely its index will be chosen.</li>
<li><code>CumulativeWeightedChoice</code> takes a single list <code>weights</code> of N <em>cumulative weights</em>; they start at 0 and the next weight is not less than the previous.  Returns a number in the interval [0, N - 1).</li>
<li><code>NormalizeRatios</code> calculates a list of integers with the same proportions as the given list of rational numbers (numbers of the form <code>x/y</code>).  This is useful for converting rational weights to integer weights for use in <code>WeightedChoice</code>.</li>
<li><code>gcd(a, b)</code> is the greatest common divisor between two numbers (where <code>gcd(0, a) = gcd(a, 0) = a</code> whenever <code>a &gt;= 0</code>).</li>
</ul>

<p>&nbsp;</p>

<pre>METHOD WChoose(weights, value)
    // Choose the index according to the given value
    runningValue = 0
    for i in 0...size(weights) - 1
       if weights[i] &gt; 0
          newValue = runningValue + weights[i]
          // NOTE: Includes start, excludes end
          if value &lt; newValue: break
          runningValue = newValue
       end
    end
    // Should not happen with integer weights
    return error
END METHOD

METHOD WeightedChoice(weights)
    return WChoose(weights,
        RNDINTEXC(Sum(weights)))
END METHOD

METHOD CumulativeWeightedChoice(weights)
    if size(weights)==0 or weights[0]!=0: return error
    value = RNDINTEXC(weights[size(weights) - 1])
    // Choose the index according to the given value
    for i in 0...size(weights) - 1
       // Choose only if difference is positive
       if weights[i] &lt; weights[i+1] and
           weights[i]&gt;=value: return i
    end
    return 0
END METHOD

METHOD NormalizeRatios(ratios)
  prod=1; gc=0
  for r in ratios: prod*=r[1] // Multiply denominators
  weights=[]
  for r in ratios
     rn = floor(r * prod)
     gc = gcd(rn, gc); AddItem(weights, rn)
  end
  if gc==0: return weights
  for i in 0...size(weights): weights[i]=floor(weights[i]/gc)
  return weights
END METHOD
</pre>

<p>The following are various ways to implement <code>WeightedChoice</code>. Many of them require using a special data structure.</p>

<table><thead>
<tr>
<th>Algorithm</th>
<th>Notes</th>
</tr>
</thead><tbody>
<tr>
<td>Linear search</td>
<td>See the pseudocode for <code>WeightedChoice</code> above.</td>
</tr>
<tr>
<td>Linear search with cumulative weights</td>
<td>Calculates a list of cumulative weights (also known as a <em>cumulative distribution table</em> or <em>CDT</em>), then generates, at random, a number less than the sum of (original) weights (which should be an integer if the weights are integers), then does a linear scan of the new list to find the first item whose cumulative weight exceeds the generated number.</td>
</tr>
<tr>
<td><em>Fast Loaded Dice Roller</em> (Saad et al., 2020a)[^31].</td>
<td>Uses integer weights only, and samples using random bits (&quot;fair coins&quot;). This sampler comes within 6 bits, on average, of the optimal number of random bits per sample.</td>
</tr>
<tr>
<td>Samplers described in (Saad et al., 2020b)[^32]</td>
<td>Uses integer weights only, and samples using random bits. The samplers come within 2 bits, on average, of the optimal number of random bits per sample as long as the sum of the weights is of the form 2<sup>k</sup> or 2<sup>k</sup> &minus; 2<sup>m</sup>.</td>
</tr>
<tr>
<td>Rejection sampling</td>
<td>Given a list (<code>weights</code>) of <code>n</code> weights: (1) find the highest weight and call it <em>max</em>; (2) set <em>i</em> to <code>RNDINT(n - 1)</code>; (3) With probability <code>weights[i]/max</code> (for example, if <code>ZeroOrOne(weights[i], max)==1</code> for integer weights), return <em>i</em>, and go to step 2 otherwise.  (See, for example, sec. 4 of the Fast Loaded Dice Roller paper, or the Tang or Klundert papers. <code>weights[i]</code> can also be a function that calculates the weight for <code>i</code> &quot;on the fly&quot;; in that case, <code>max</code> is the maximum value of <code>weights[i]</code> for every <code>i</code>.)<br/>If the weights are instead log-weights (that is, each weight is <code>ln(x)/ln(b)</code> where <code>x</code> is the original weight and <code>b</code> is the logarithm base), step 3 changes to: &quot;(3) If <code>Expo(ln(b)) &gt; max - weights[i]</code> (which happens with probability <code>pow(b, -(max - weights[i]))</code>), return <em>i</em>, and go to step 2 otherwise.&quot;<br/>If the weights are instead &quot;coins&quot;, each with a separate but unknown probability of heads, the algorithm is also called <em>Bernoulli race</em> (Dughmi et al. 2017)[^33]: (1) set <em>i</em> to <code>RNDINT(n - 1)</code>; (2) flip coin <em>i</em> (the first coin is 0, the second is 1, and so on), then return <em>i</em> if it returns 1 or heads, or go to step 1 otherwise.</td>
</tr>
<tr>
<td>Bringmann and Panagiotou (2012/2017)[^34].</td>
<td>Shows a sampler designed to work on a sorted list of weights.</td>
</tr>
<tr>
<td>Alias method (Walker 1977)[^35]</td>
<td>Michael Vose&#39;s version of the alias method (Vose 1991)[^36] is described in &quot;<a href="https://www.keithschwarz.com/darts-dice-coins/"><strong>Darts, Dice, and Coins: Sampling from a Discrete Distribution</strong></a>&quot;. Weights should be rational numbers.</td>
</tr>
<tr>
<td>(Klundert 2019)[^37]</td>
<td>Various data structures, with emphasis on how they can support changes in weights.</td>
</tr>
<tr>
<td>The Bringmann&ndash;Larsen succinct data structure (Bringmann and Larsen 2013)[^38]</td>
<td>Uses rejection sampling if the sum of weights is large, and a compressed structure otherwise.</td>
</tr>
<tr>
<td>Hübschle-Schneider and Sanders (2019)[^39].</td>
<td>Parallel weighted random samplers.</td>
</tr>
<tr>
<td>(Tang 2019)[^40].</td>
<td>Presents various algorithms, including two- and multi-level search, binary search (with cumulative weights), and a new &quot;flat&quot; method.</td>
</tr>
<tr>
<td>&quot;Loaded Die from Biased Coins&quot;</td>
<td>Given a list of probabilities <code>probs</code> that must sum to 1 and should be rational numbers: (1) Set <code>cumu</code> to 1 and <code>i</code> to 0; (2) with probability <code>probs[i]/cumu</code>, return <code>i</code>; (3) subtract <code>probs[i]</code> from <code>cumu</code>, then add 1 to <code>i</code>, then go to step 2.  For a correctness proof, see &quot;Darts, Dice, and Coins&quot;.  If each probability in <code>probs</code> is calculated &quot;on the fly&quot;, this is also called sequential search; see chapter 10 of Devroye (1986)[^19] (but this generally won&#39;t be exact unless all the probabilities involved are rational numbers).</td>
</tr>
<tr>
<td>Knuth and Yao (1976)[^9]</td>
<td>Generates a binary DDG tree from the binary expansions of the probabilities (that is, they have the base-2 form 0.bbbbbb... where b is 0 or 1). Comes within 2 bits, on average, of the optimal number of random bits per sample.  This is suggested in exercise 3.4.2 of chapter 15 of Devroye (1986)[^19], implemented in <em>randomgen.py</em> as the <code>discretegen</code> method, and also described in (Devroye and Gravel 2020)[^11].  <code>discretegen</code> can work with probabilities that are irrational numbers (which have infinite binary expansions) as long as there is a way to calculate the binary expansion &quot;on the fly&quot;.</td>
</tr>
<tr>
<td>Han and Hoshi (1997)[^41]</td>
<td>Uses cumulative probabilities as input and comes within 3 bits, on average, of the optimal number of random bits per sample.  Also described in (Devroye and Gravel 2020)[^11].</td>
</tr>
</tbody></table>

<blockquote>
<p><strong>Notes:</strong></p>

<ol>
<li><strong>Weighted choice algorithms as binary tree walkers.</strong> Just like <code>RNDINT</code> algorithms (see the <a href="#RNDINT_Random_Integers_in_0_N"><strong><code>RNDINT</code> section</strong></a>), weighted choice algorithms can all be described as random walks on a binary DDG tree.  In this case, though, the probabilities are not necessarily uniform, and on average, the algorithm needs at least as many unbiased random bits as the sum of <em>binary entropies</em> of all the probabilities involved.  For example, say we give the four integers 1, 2, 3, 4 the following weights: 3, 15, 1, 2.  The binary entropies of these weights add up to 0.4010... + 0.3467... + 0.2091... + 0.3230... = 1.2800... (because the sum of the weights is 21 and the binary entropy of 3/21 is <code>0 - (3/21) * log2(3/21) = 0.4010...</code>, where <code>log2(x) = ln(x)/ln(2)</code>, and so on for the other weights).  Thus, any weighted sampler will require at least 1.2800... bits on average to generate a number with probability proportional to these weights.[^10]  The note &quot;Reducing &#39;bit waste&#39;&quot; from the <code>RNDINT</code> section also applies here.</li>
<li>For best results, weights passed to the algorithms in the table above should first be <strong>converted to integers</strong> (for example, using <code>NormalizeRatios</code> in the pseudocode above), <strong>or rational numbers</strong> when indicated. (Obviously, if the weights were originally irrational numbers, this conversion will be lossy and the algorithm won&#39;t be exact, unless noted otherwise in the table.)  Also, using floating-point numbers in the algorithms can introduce unnecessary rounding errors, so such numbers should be avoided.</li>
<li>The <a href="https://peteroupc.github.io/randomgen.zip"><strong>Python sample code</strong></a> contains a variant of the <code>WeightedChoice</code> pseudocode for generating multiple random points in one call.</li>
</ol>

<p><strong>Examples:</strong></p>

<ol>
<li>Assume we have the following list: <code>[&quot;apples&quot;, &quot;oranges&quot;, &quot;bananas&quot;, &quot;grapes&quot;]</code>, and <code>weights</code> is the following: <code>[3, 15, 1, 2]</code>.  The weight for &quot;apples&quot; is 3, and the weight for &quot;oranges&quot; is 15.  Since &quot;oranges&quot; has a higher weight than &quot;apples&quot;, the index for &quot;oranges&quot; (1) is more likely to be chosen than the index for &quot;apples&quot; (0) with the <code>WeightedChoice</code> method.  The following idiom implements how to get a randomly chosen item from the list with that method: <code>item = list[WeightedChoice(weights)]</code>.</li>
<li>Example 1 can be implemented with <code>CumulativeWeightedChoice</code> instead of <code>WeightedChoice</code> if <code>weights</code> is the following list of cumulative weights: <code>[0, 3, 18, 19, 21]</code>.</li>
<li><strong>Piecewise constant distribution.</strong> Assume the weights from example 1 are used and the list contains the following: <code>[0, 5, 10, 11, 13]</code> (one more item than the weights).  This expresses four intervals: [0, 5), [5, 10), and so on.  Choose a random index (and thus interval) with <code>index = WeightedChoice(weights)</code>.  Then independently, choose a number in the chosen interval uniformly at random (for example, code like the following chooses a random integer this way: <code>number = RNDINTEXCRANGE(list[index], list[index + 1])</code>).</li>
</ol>
</blockquote>

<p><a id=Weighted_Choice_Without_Replacement_Multiple_Copies></a></p>

<h4>Weighted Choice Without Replacement (Multiple Copies)</h4>

<p>To implement weighted choice <em>without replacement</em> (which can be thought of as drawing a ball <em>without</em> putting it back) when each weight is an integer 0 or greater, generate an index by <code>WeightedChoice</code>, and then decrease the weight for the chosen index by 1.  In this way, <strong>each weight behaves like the number of &quot;copies&quot; of each item</strong>. The pseudocode below is an example of this.  It assumes &#39;weights&#39; is a list that can be modified.</p>

<pre>totalWeight = Sum(weights)
// Choose as many items as the sum of weights
i = 0
items = NewList()
while i &lt; totalWeight
    index = WeightedChoice(weights)
    // Decrease weight by 1 to implement selection
    // without replacement.
    weights[index] = weights[index] - 1
    // NOTE: Assumes the &#39;list&#39; of items was declared
    // earlier and has at least as many items as &#39;weights&#39;
    AddItem(items, list[index])
    i = i + 1
end
</pre>

<p>Alternatively, if all the weights are integers 0 or greater and their sum is relatively small, create a list with as many copies of each item as its weight, then <a href="#Shuffling"><strong>shuffle</strong></a> that list.  The resulting list will be ordered in a way that corresponds to a weighted random choice without replacement.</p>

<blockquote>
<p><strong>Note:</strong> Some applications (particularly some games) wish to control which random outcomes appear, to make those outcomes appear &quot;fairer&quot; to users (for example, to avoid long streaks of good outcomes or of bad outcomes).  When the weighted sampling in this section is used for this purpose, each item represents a separate outcome (for example, &quot;good&quot; or &quot;bad&quot;), and the lists are replenished once no further items can be chosen.  However, this kind of sampling should be avoided in applications that care about information security, including when a player or user would have a significant and unfair advantage if the outcomes were easy to guess.</p>
</blockquote>

<p><a id=Weighted_Choice_Without_Replacement_Single_Copies></a></p>

<h4>Weighted Choice Without Replacement (Single Copies)</h4>

<p>The following are ways to implement weighted choice without replacement, where each item <strong>can be chosen no more than once</strong> at random.  The weights have the property that higher-weighted items are more likely to appear first.</p>

<ul>
<li>Use <code>WeightedChoice</code> to choose random indices.  Each time an index is chosen, set the weight for the chosen index to 0 to keep it from being chosen again.  Or...</li>
<li>Assign each index a random exponentially-distributed number (with a rate equal to that index&#39;s weight, which must be an integer 1 or greater), make a list of pairs assigning each number to an index, then sort that list in ascending order by those numbers.  Example: <code>v=[]; for i in 0...size(weights): AddItem(v, [ExpoNew(weights[i]), i]); Sort(v)</code> (see the next section for <code>ExpoNew</code>).  The sorted list of indices will then correspond to a weighted choice without replacement.  See &quot;<a href="https://timvieira.github.io/blog/post/2019/09/16/algorithms-for-sampling-without-replacement/"><strong>Algorithms for sampling without replacement</strong></a>&quot;.</li>
</ul>

<p><a id=Weighted_Choice_Without_Replacement_List_of_Unknown_Size></a></p>

<h4>Weighted Choice Without Replacement (List of Unknown Size)</h4>

<p>If the number of items in a list is not known in advance, then the following pseudocode implements a <code>RandomKItemsFromFileWeighted</code> that selects up to <code>k</code> random items from a file (<code>file</code>) of indefinite size (similarly to <a href="#Pseudocode_for_Random_Sampling"><strong><code>RandomKItemsFromFile</code></strong></a>).  This is also known as <em>weighted reservoir sampling</em>.  See (Efraimidis and Spirakis 2005)[^42], and see also (Efraimidis 2015)[^43], (Vieira 2014)[^44], and (Vieira 2019)[^45].  In the pseudocode below:</p>

<ul>
<li><code>WEIGHT_OF_ITEM(item, thisIndex)</code> is a placeholder for arbitrary code that calculates the integer weight of an individual item based on its value and its index (starting at 0); the item is ignored if its weight is 0 or less.</li>
<li><code>ITEM_OUTPUT(item, thisIndex, key)</code> is a placeholder for code that returns the item to store in the list; this can include the item&#39;s value, its index starting at 0, the item&#39;s key, or any combination of these.</li>
<li> <code>ExpoNew(weight)</code> creates an &quot;empty&quot; exponential number with rate <code>weight</code>, whose bits are not yet determined (see &quot;<a href="https://peteroupc.github.io/exporand.html"><strong>Partially-Sampled Random Numbers</strong></a>&quot;), and <code>ExpoLess(a, b)</code> returns whether one exponential number (<code>a</code>) is less than another (<code>b</code>), building up the bits of both as necessary.  For a less exact algorithm, replace <code>ExpoNew(weight)</code> with <code>ExpoApprox(weight)</code> and <code>ExpoLess(a, b)</code> with <code>a &lt; b</code>, where <code>ExpoApprox</code> has the following pseudocode that uses von Neumann&#39;s (1951)[^46] algorithm: <code>METHOD ExpoApprox(w); b=1000000; count=0; while true; y1=RNDINTEXC(b); y=y1; accept=true; while true; z=RNDINTEXC(b); if y&lt;=z: break; if accept: accept=false; else: accept=true; y=z; end; if accept: count=count+y1; else: count=count+b; if accept: return MakeRatio(count, b*w); end; END METHOD</code>.</li>
<li>The items in the returned list are in no particular order.  A <code>Shuffle()</code> can be done to that list if desired.</li>
</ul>

<p>&nbsp;</p>

<pre>METHOD RandomKItemsFromFileWeighted(file, k)
  queue=[] // Initialize priority queue
  index = 0
  while true // until a value is returned
    // Get the next line from the file
    item = GetNextLine(file)
    // If the end of the file was reached, break
    if item == nothing: break
    thisIndex = index
    index = index + 1
    weight = WEIGHT_OF_ITEM(item, thisIndex)
    // Ignore if item&#39;s weight is 0 or less
    if weight &lt;= 0: continue
    // NOTE: Equivalent to Expo(weight)
    key = ExpoNew(weight)
    itemToStore = ITEM_OUTPUT(item, thisIndex, key)
    // Begin priority queue add operation.  Instead
    // of the item (&#39;item&#39;), the line number starting at one
    // (&#39;thisIndex&#39;) can be added to the queue.
    if size(queue) &lt; k // Fewer than k items
      AddItem(queue, [key, itemToStore])
      Sort(queue)
    else
      // Check whether this key is smaller
      // than the largest key in the queue
      if ExpoLess(key, queue[size(queue)-1][0])
          // Replace the item with the largest key
          queue[size(queue)-1]=[key, itemToStore]
          Sort(queue)
      end
    end
    // End priority queue add operation
  end
  list=[]
  for v in 0...size(queue): AddItem(list, queue[v][1])
  return list
end
</pre>

<blockquote>
<p><strong>Note:</strong> Weighted choice <em>with replacement</em> can be implemented by doing one or more concurrent runs of <code>RandomKItemsFromFileWeighted(file, 1)</code> (making sure each run traverses <code>file</code> the same way for multiple runs as for a single run) (Efraimidis 2015)[^43].</p>
</blockquote>

<p><a id=Weighted_Choice_with_Inclusion_Probabilities></a></p>

<h4>Weighted Choice with Inclusion Probabilities</h4>

<p>For the weighted-choice-without-replacement methods given earlier, the weights have the property that higher-weighted items are chosen first, but each item&#39;s weight is not necessarily the chance that a given sample of <code>n</code> items will include that item (an <em>inclusion probability</em>).  The following method chooses a random sample of <code>n</code> indices from a list of items (whose weights are integers stored in a list called <code>weights</code>), such that the chance that index <code>k</code> is in the sample is given as <code>weights[k]*n/Sum(weights)</code>.   The chosen indices will not necessarily be in random order. The method implements the &quot;<a href="https://www.eustat.eus/productosServicios/52.1_Unequal_prob_sampling.pdf#page=68"><strong>splitting method</strong></a>&quot; (Deville and Tillé 1998)[^47].</p>

<pre>METHOD InclusionSelect(weights, n)
  if n&gt;size(weights): return error
  if n==0: return []
  ws=Sum(weights)
  wts=[]
  items=[]
  // Calculate inclusion probabilities
  for i in 0...size(weights):
     AddItem(wts,[MakeRatio(weights[i],ws)*n, i])
  Sort(wts)
  // Check for invalid inclusion probabilities
  if wts[size(wts)-1][0]&gt;1: return error
  last=size(wts)-n
  if n==size(wts)
    for i in 0...n: AddItem(items,i)
    return items
  end
  while true // until a value is returned
    lamda=min(MakeRatio(1,1)-wts[last-1][0],wts[last][0])
    if lamda==0: return error
    if ZeroOrOne(lamda[0],lamda[1])
      for k in 0...size(wts)
        if k+1&gt;ntotal-n:AddItem(items,wts[k][1])
      end
      return items
    end
    newwts=[]
    for k in 0...size(wts)
      newwt=(k+1&lt;=last) ?
          wts[k][0]/(1-lamda) : (wts[k][0]-lamda)/(1-lamda)
      AddItem(newwts,[newwt,wts[k][1]])
    end
    wts=newwts
    Sort(wts)
  end
END METHOD
</pre>

<p><a id=Mixtures_of_Distributions></a></p>

<h3>Mixtures of Distributions</h3>

<p>A <em>mixture</em> consists of two or more probability distributions with separate probabilities of being sampled. To generate random content from a mixture&mdash;</p>

<ol>
<li>generate <code>index = WeightedChoice(weights)</code>, where <code>weights</code> is a list of relative probabilities that each distribution in the mixture will be sampled, then</li>
<li>based on the value of <code>index</code>, generate the random content from the corresponding distribution.</li>
</ol>

<blockquote>
<p><strong>Examples:</strong></p>

<ol>
<li>One mixture consists of the sum of three six-sided virtual die rolls and the result of one six-sided die roll, but there is an 80% chance to roll one six-sided virtual die rather than three.  The following pseudocode shows how this mixture can be sampled: <code>index = WeightedChoice([80, 20]); number = 0; if index==0: number = RNDINTRANGE(1,6); else: number = RNDINTRANGE(1,6) + RNDINTRANGE(1,6) + RNDINTRANGE(1,6)</code>.</li>
<li>Choosing an independent uniform random point, from a complex shape (in any number of dimensions) is equivalent to doing such sampling from a mixture of simpler shapes that make up the complex shape (here, the <code>weights</code> list holds the n-dimensional &quot;volume&quot; of each simpler shape).  For example, a simple closed 2D polygon can be <a href="https://en.wikipedia.org/wiki/Polygon_triangulation"><strong><em>triangulated</em></strong></a>, or decomposed into <a href="#Random_Points_Inside_a_Simplex"><strong>triangles</strong></a>, and a mixture of those triangles can be sampled.[^48]</li>
<li><p>Take a set of nonoverlapping integer ranges (for example, [0, 5], [7, 8], [20, 25]).  To choose an independent uniform random integer from those ranges:</p>

<ul>
<li>Create a list (<code>weights</code>) of weights for each range.  Each range is given a weight of <code>(mx - mn) + 1</code>, where <code>mn</code> is that range&#39;s minimum and <code>mx</code> is its maximum.</li>
<li>Choose an index using <code>WeightedChoice(weights)</code>, then generate <code>RNDINTRANGE(mn, mx)</code>, where <code>mn</code> is the corresponding range&#39;s minimum and <code>mx</code> is its maximum.</li>
</ul>

<p>This method can be adapted for rational numbers with a common denominator by treating the integers involved as the numerators for such numbers.  For example, [0/100, 5/100], [7/100, 8/100], [20/100, 25/100], where the numerators are the same as in the previous example.</p></li>
<li>In the pseudocode <code>index = WeightedChoice([80, 20]); list = [[0, 5], [5, 10]]; number = RNDINTEXCRANGE(list[index][0], list[index][1])</code>, a random integer in [0, 5) is chosen at an 80% chance, and a random integer in [5, 10) at a 20% chance.</li>
<li>A <strong>hyperexponential distribution</strong> is a mixture of <a href="#Exponential_Distribution"><strong>exponential distributions</strong></a>, each one with a separate weight and separate rate parameter.</li>
</ol>
</blockquote>

<p><a id=Transformations_of_Random_Variates></a></p>

<h3>Transformations of Random Variates</h3>

<p>Random variates can be generated by combining and/or transforming one or more random variates and/or discarding some of them.</p>

<p>As an example, <a href="http://www.redblobgames.com/articles/probability/damage-rolls.html"><strong>&quot;Probability and Games: Damage Rolls&quot;</strong></a> by Red Blob Games includes interactive graphics showing score distributions for lowest-of, highest-of, drop-the-lowest, and reroll game mechanics.[^49]  These and similar distributions can be generalized as follows.</p>

<p>Generate one or more random variates (numbers), each with a separate probability distribution, then:</p>

<ol>
<li><strong>Highest-of:</strong>  Choose the highest generated variate.</li>
<li><strong>Drop-the-lowest:</strong>  Add all generated variates except the lowest.</li>
<li><strong>Reroll-the-lowest:</strong>  Add all generated variates except the lowest, then add a number generated randomly by a separate probability distribution.</li>
<li><strong>Lowest-of:</strong>  Choose the lowest generated number.</li>
<li><strong>Drop-the-highest:</strong>  Add all generated variates except the highest.</li>
<li><strong>Reroll-the-highest:</strong>  Add all generated variates except the highest, then add a number generated randomly by a separate probability distribution.</li>
<li><strong>Sum:</strong> Add all generated variates.</li>
<li><strong>Mean:</strong> Add all generated variates, then divide the sum by the number of variates.</li>
<li><strong>Geometric transformation:</strong> Treat the variates as an <em>n</em>-dimensional point, then apply a geometric transformation, such as a rotation or other <em>affine transformation</em>[^50], to that point.</li>
</ol>

<p>If the probability distributions are the same, then strategies 1 to 3 make higher numbers more likely, and strategies 4 to 6, lower numbers.</p>

<blockquote>
<p><strong>Note:</strong> Variants of strategy 4 &mdash; for example, choosing the second-, third-, or nth-lowest number &mdash; are formally called second-, third-, or nth-<strong>order statistics distributions</strong>, respectively.</p>

<p><strong>Examples:</strong></p>

<ol>
<li>The idiom <code>min(RNDINTRANGE(1, 6), RNDINTRANGE(1, 6))</code> takes the lowest of two six-sided die results (strategy 4).  Due to this approach, 1 is more likely to occur than 6.</li>
<li>The idiom <code>RNDINTRANGE(1, 6) + RNDINTRANGE(1, 6)</code> takes the result of two six-sided dice (see also &quot;<a href="#Dice"><strong>Dice</strong></a>&quot;) (strategy 7).</li>
<li>A <strong>binomial distribution</strong> models the sum of <code>n</code> numbers each generated by <code>ZeroOrOne(px,py)</code> (strategy 7) (see &quot;<a href="#Binomial_Distribution"><strong>Binomial Distribution</strong></a>&quot;).</li>
<li>A <a href="https://en.wikipedia.org/wiki/Poisson_binomial_distribution"><strong>Poisson binomial distribution</strong></a> models the sum of <code>n</code> numbers each with a separate probability of being 1 as opposed to 0 (strategy 7). Given <code>probs</code>, a list of the <code>n</code> probabilities as rational numbers, the pseudocode is: <code>for i in 0...n: x=x+ZeroOrOne(probs[i][0],probs[i][1]); return x</code>.</li>
<li><p><strong>Clamped random variates.</strong>  These are one example of transformed random variates.  To generate a clamped random variate, generate a number at random as usual, then&mdash;</p>

<ul>
<li>if that number is less than a minimum threshold, use the minimum threshold instead (<em>left-censoring</em>), and/or</li>
<li>if that number is greater than a maximum threshold, use the maximum threshold instead (<em>right-censoring</em>).</li>
</ul>

<p>An example of a clamped random variate is <code>min(200, RNDINT(255))</code>.</p></li>
<li>A <strong>compound Poisson distribution</strong> models the sum of <em>n</em> numbers each chosen at random in the same way, where <em>n</em> follows a <a href="#Poisson_Distribution"><strong>Poisson distribution</strong></a> (for example, <code>n = PoissonInt(10, 1)</code> for an average of 10 numbers) (strategy 7, sum).</li>
<li>A <strong>P&oacute;lya&ndash;Aeppli distribution</strong> is a compound Poisson distribution in which the numbers are generated by <code>NegativeBinomial(1, 1-p)+1</code> for a fixed <code>p</code>.</li>
</ol>
</blockquote>

<p><a id=Specific_Non_Uniform_Distributions></a></p>

<h2>Specific Non-Uniform Distributions</h2>

<p>This section contains information on some of the most common non-uniform probability distributions.</p>

<p><a id=Dice></a></p>

<h3>Dice</h3>

<p>The following method generates a random result of rolling virtual dice. It takes three parameters: the number of dice (<code>dice</code>), the number of sides in each die (<code>sides</code>), and a number to add to the result (<code>bonus</code>) (which can be negative, but the result of the method is 0 if that result is greater).  See also Red Blob Games, <a href="http://www.redblobgames.com/articles/probability/damage-rolls.html"><strong>&quot;Probability and Games: Damage Rolls&quot;</strong></a>.</p>

<pre>METHOD DiceRoll(dice, sides, bonus)
    if dice &lt; 0 or sides &lt; 1: return error
    ret = 0
    for i in 0...dice: ret=ret+RNDINTRANGE(1, sides)
    return max(0, ret + bonus)
END METHOD
</pre>

<blockquote>
<p><strong>Examples:</strong> The result of rolling&mdash;</p>

<ul>
<li>four six-sided virtual dice (&quot;4d6&quot;) is <code>DiceRoll(4,6,0)</code>,</li>
<li>three ten-sided virtual dice, with 4 added (&quot;3d10 + 4&quot;), is <code>DiceRoll(3,10,4)</code>, and</li>
<li>two six-sided virtual dice, with 2 subtracted (&quot;2d6 - 2&quot;), is <code>DiceRoll(2,6,-2)</code>.</li>
</ul>
</blockquote>

<p><a id=Binomial_Distribution></a></p>

<h3>Binomial Distribution</h3>

<p>The <em>binomial distribution</em> uses two parameters: <code>trials</code> and <code>p</code>.  This distribution models the number of successes in a fixed number of independent trials (equal to <code>trials</code>), each with the same probability of success (equal to <code>p</code>, where <code>p &lt;= 0</code> means never, <code>p &gt;= 1</code> means always, and <code>p = 1/2</code> means an equal chance of success or failure).  In this document, <code>Binomial(trials, p)</code> is a binomial random variate with the given parameters.</p>

<p>This distribution has a simple implementation: <code>count = 0; for i in 0...trials: count=count+ZeroOrOne(px, py)</code>.  But for large numbers of trials, this can be very slow.</p>

<p>The pseudocode below implements an exact sampler of this distribution, with certain optimizations based on (Farach-Colton and Tsai 2015)[^51].  (Another exact sampler is given in (Bringmann et al. 2014)[^52] and described in my &quot;<a href="https://peteroupc.github.io/randmisc.html"><strong>Miscellaneous Observations on Randomization</strong></a>&quot;.) Here, the parameter <code>p</code> is expressed as a ratio <code>px</code>/<code>py</code>.</p>

<p>&nbsp;</p>

<pre>METHOD BinomialInt(trials, px, py)
  if trials &lt; 0: return error
  if trials == 0: return 0
  // Always succeeds
  if mx: return trials
  // Always fails
  if p &lt;= 0.0: return 0
  count = 0
  ret = 0
  recursed = false
  if py*2 == px // Is half
    if i &gt; 200
      // Divide and conquer
      half = floor(trials / 2)
      return BinomialInt(half, 1, 2) + BinomialInt(trials - half, 1, 2)
    else
      if rem(trials,2)==1
        count=count+RNDINT(1)
        trials=trials-1
      end
      // NOTE: This step can be made faster
      // by precalculating an alias table
      // based on a list of n + 1 binomial(1/2)
      // weights, which consist of n-choose-i
      // for every i in [0, n], and sampling based on
      // that table (see Farach-Colton and Tsai).
      for i in 0...trials: count=count+RNDINT(1)
    end
  else
    // Based on proof of Theorem 2 in Farach-Colton and Tsai.
    // Decompose px/py into its base-2 digits.
    pw = MakeRatio(px, py)
    pt = MakeRatio(1, 2)
    while trials&gt;0 and pw&gt;0
      c=BinomialInt(trials, 1, 2)
      if pw&gt;=pt
        count=count+c
        trials=trials-c
        pw=pw-pt
      else
        trials=c
      end
      pt=pt/2 // NOTE: Not rounded
    end
  end
  if recursed: return count+ret
  return count
END METHOD
</pre>

<blockquote>
<p><strong>Note:</strong> If <code>px</code>/<code>py</code> is <code>1</code>/<code>2</code>, the binomial distribution models the task &quot;Flip N coins, then count the number of heads&quot;, and the random sum is known as <a href="https://en.wikipedia.org/wiki/Hamming_distance"><strong><em>Hamming distance</em></strong></a> (treating each trial as a &quot;bit&quot; that&#39;s set to 1 for a success and 0 for a failure).  If <code>px</code> is <code>1</code>, then this distribution models the task &quot;Roll <code>n</code> <code>py</code>-sided dice, then count the number of dice that show the number 1.&quot;</p>
</blockquote>

<p><a id=Negative_Binomial_Distribution></a></p>

<h3>Negative Binomial Distribution</h3>

<p>In this document, the <em>negative binomial distribution</em> models the number of failing trials that happen before a fixed number of successful trials (<code>successes</code>). Each trial is independent and has a success probability of <code>px/py</code> (where 0 means never and 1 means always). The following is a naïve implementation; see also the notes for the geometric distribution, a special case of this one.</p>

<pre>METHOD NegativeBinomialInt(successes, px, py)
    // Needs to be 0 or greater; px must not be 0
    if successes &lt; 0 or px == 0: return error
    if successes == 0 or px &gt;= py: return 0
    total = 0
    count = 0
    while total &lt; successes
        if ZeroOrOne(px, py) == 1: total = total + 1
        else: count = count + 1
    end
    return count
END METHOD
</pre>

<p>If <code>successes</code> is a non-integer, the distribution is often called a <em>Pólya distribution</em>.  In that case, it can be sampled using the following pseudocode (Heaukulani and Roy 2019)[^53]:</p>

<pre>METHOD PolyaInt(sx, sy, px, py)
   isinteger=rem(sx,sy)==0
   sxceil=ceil(sx/sy)
   while true // until a value is returned
      w=NegativeBinomialInt(sxceil, px, py)
      if isinteger or w==0: return w
      tmp=MakeRatio(sx,sy)
      anum=tmp
      for i in 1...w: anum=anum*(tmp+i)
      tmp=sxceil
      aden=tmp
      for i in 1...w: aden=aden*(tmp+i)
      a=anum/aden
      if ZeroOrOne(a[0], a[1])==1: return w
   end
END METHOD
</pre>

<p><a id=Geometric_Distribution></a></p>

<h3>Geometric Distribution</h3>

<p>The geometric distribution is a negative binomial distribution with <code>successes = 1</code>.  In this document, a geometric random variate is the number of failures that have happened before one success happens.  For example, if <code>p</code> is 1/2, the geometric distribution models the task &quot;Flip a coin until you get tails, then count the number of heads.&quot;  As a unique property of the geometric distribution, given that <code>n</code> trials have failed, the number of new failing trials has the same distribution (where <code>n</code> is an integer greater than 0).</p>

<blockquote>
<p><strong>Notes:</strong></p>

<ol>
<li>The negative binomial and geometric distributions are defined differently in different works.  For example, <em>Mathematica</em>&#39;s definition excludes the last success, but the definition in (Devroye 1986, p. 498)[^19] includes it.  And some works may define a negative binomial number as the number of successes before N failures, rather than vice versa.</li>
<li>A <em>bounded geometric</em> random variate is either <em>n</em> (an integer greater than 0) or a geometric random variate, whichever is less.   Exact and efficient samplers for the geometric and bounded geometric distributions are given in (Bringmann and Friedrich 2013)[^54] and described in my &quot;<a href="https://peteroupc.github.io/randmisc.html"><strong>Miscellaneous Observations on Randomization</strong></a>&quot;.)</li>
</ol>
</blockquote>

<p><a id=Exponential_Distribution></a></p>

<h3>Exponential Distribution</h3>

<p>The <em>exponential distribution</em> uses a parameter known as &lambda;, the rate, or the inverse scale.  Usually, &lambda; is the probability that an independent event of a given kind will occur in a given span of time (such as in a given day or year), and the random result is the number of spans of time until that event happens.  Usually, &lambda; is equal to 1, or 1/1.  1/&lambda; is the scale (mean), which is usually the average waiting time between two independent events of the same kind.</p>

<p>In this document, <code>Expo(lamda)</code> is an exponentially-distributed random variate with the rate <code>lamda</code>.  For algorithms to sample exponential random variates to arbitrary precision, see &quot;<a href="https://peteroupc.github.io/exporand.html"><strong>Partially-Sampled Random Numbers</strong></a>&quot;.</p>

<p><a id=Poisson_Distribution></a></p>

<h3>Poisson Distribution</h3>

<p>The <em>Poisson distribution</em> uses a parameter <code>mean</code> (also known as &lambda;). &lambda; is the average number of independent events of a certain kind per fixed unit of time or space (for example, per day, hour, or square kilometer).  A Poisson-distributed number is the number of such events within one such unit.</p>

<p>In this document, <code>Poisson(mean)</code> is a Poisson-distributed number if <code>mean</code> is greater than 0, or 0 if <code>mean</code> is 0.</p>

<p>The method <code>PoissonInt</code> generates a Poisson random variate with mean <code>mx</code>/<code>my</code>, with the <code>Poisson1</code> method using an algorithm by Duchon and Duvignau (2016)[^55],</p>

<pre>METHOD Poisson1()
  ret=1; a=1; b=0
  while true // until this method returns
    j=RNDINT(a)
    if j&lt;a and j&lt;b: return ret
    if j==a: ret=ret+1
    else
      ret=ret-1; b=a+1
    end
    a=a+1
  end
END METHOD

METHOD PoissonInt(mx, my)
  if my == 0: return error
  if mx == 0 or (mx &lt; 0 and my &lt; 0) or (mx &gt; 0 and my &lt; 0): return 0
  r=0
  while mx&gt;=my
     r=r+Poisson1(); mx=mx-my
  end
  if mx&gt;0
    // At this point, mx/my &lt; 1, so sum a Poisson number
    // of coin flips with heads prob. mx/my; see Devroye 1986, p. 487
    r=r+BinomialInt(Poisson1(), mx, my)
  end
  return r
END METHOD
</pre>

<blockquote>
<p><strong>Note:</strong> To generate a sum of <code>n</code> independent Poisson random variates with separate means, generate a Poisson random variate whose mean is the sum of those means (see (Devroye 1986)[^19], p. 501).  For example, to generate a sum of 1000 independent Poisson random variates with a mean of 1/1000000, simply generate <code>PoissonInt(1, 1000)</code> (because 1/1000000 * 1000 = 1/1000).</p>
</blockquote>

<p><a id=P_lya_ndash_Eggenberger_Distribution></a></p>

<h3>Pólya&ndash;Eggenberger Distribution</h3>

<p>Suppose items are drawn at random from a collection of items each labeled either <code>1</code> or <code>0</code>, and after drawing an item, it&#39;s put back and <code>m</code> more items of the same label are added.  Then:</p>

<ul>
<li>The <em>Pólya&ndash;Eggenberger distribution</em> models the number of items drawn this way that are labeled <code>1</code>.</li>
<li>The <em>inverse Pólya&ndash;Eggenberger distribution</em> models the number of <code>0</code>-labeled items drawn before <code>successes</code> many <code>1</code>-labeled items are drawn.</li>
</ul>

<p>(Johnson and Kotz 1969)[^56].  In the methods below, <code>trials</code> is the number of items drawn at random, <code>ones</code> is the number of items labeled <code>1</code> in the collection, <code>count</code> is the number of items labeled <code>1</code> or <code>0</code> in that collection, <code>m</code> is the number of items added after each draw (or &minus;1 for sampling <em>without replacement</em>), and <code>successes</code> is the number of <code>1</code>-labeled items drawn.</p>

<pre>METHOD PolyaEggenberger(trials, ones, count, m)
    if ones &lt; 0 or count &lt; 0 or trials &lt; 0 or
       ones &gt; count or trials &gt; count
      return error
    end
    if ones == 0: return 0
    zeros=count-ones
    ret=0
    for i in 0...trials
       if zeros==0 or ZeroOrOne(ones,zeros)==1
          ones=ones+m
          ret=ret+1
       else: zeros=zeros+m
    end
    return ret
END METHOD

METHOD InversePolyaEggenberger(successes, ones, count, m)
    if ones &lt;= 0 or count &lt; 0 or successes &lt; 0 or
       ones &gt; count or successes &gt; count
      return error
    end
    zeros=count-ones
    ret=0; trials=0
    while ret&lt;successes
       if zeros==0 or ZeroOrOne(ones,zeros)==1
          ones=ones+m
          ret=ret+1
       else: zeros=zeros+m
       trials=trials+1
    end
    return trials-successes
END METHOD
</pre>

<blockquote>
<p><strong>Notes:</strong></p>

<ol>
<li>A <strong>hypergeometric distribution</strong> is a Pólya&ndash;Eggenberger distribution with <code>m=-1</code>.  For example, in a 52-card deck of Anglo-American playing cards, 12 of the cards are face cards (jacks, queens, or kings).  After the deck is shuffled and seven cards are drawn, the number of face cards drawn this way follows a hypergeometric distribution where <code>trials</code> is 7, <code>ones</code> is 12, <code>count</code> is 52, and <code>m</code> is &minus;1.</li>
<li>A <strong>negative hypergeometric distribution</strong> is an inverse Pólya&ndash;Eggenberger distribution with <code>m=-1</code>.</li>
</ol>
</blockquote>

<p><a id=Random_Integers_with_a_Given_Positive_Sum></a></p>

<h3>Random Integers with a Given Positive Sum</h3>

<p>The following pseudocode shows how to generate <code>n</code> random integers with a given positive sum, in random order (specifically, a uniformly chosen random partition of that sum into <code>n</code> parts with repetition and in random order). (The algorithm for this was presented in (Smith and Tromble 2004)[^57].)  In the pseudocode below&mdash;</p>

<ul>
<li>the method <code>PositiveIntegersWithSum</code> returns <code>n</code> integers greater than 0 that sum to <code>total</code>, in random order,</li>
<li>the method <code>IntegersWithSum</code> returns <code>n</code> integers 0 or greater that sum to <code>total</code>, in random order, and</li>
<li><code>Sort(list)</code> sorts the items in <code>list</code> in ascending order (however, sort algorithms are outside the scope of this document).</li>
</ul>

<p>&nbsp;</p>

<pre>METHOD PositiveIntegersWithSum(n, total)
    if n &lt;= 0 or total &lt;=0: return error
    ls = [0]
    ret = NewList()
    while size(ls) &lt; n
      c = RNDINTEXCRANGE(1, total)
      found = false
      for j in 1...size(ls)
        if ls[j] == c
          found = true
          break
        end
      end
      if found == false: AddItem(ls, c)
    end
    Sort(ls)
    AddItem(ls, total)
    for i in 1...size(ls): AddItem(ret,
        ls[i] - ls[i - 1])
    return ret
END METHOD

METHOD IntegersWithSum(n, total)
  if n &lt;= 0 or total &lt;=0: return error
  ret = PositiveIntegersWithSum(n, total + n)
  for i in 0...size(ret): ret[i] = ret[i] - 1
  return ret
END METHOD
</pre>

<blockquote>
<p><strong>Notes:</strong></p>

<ol>
<li>To generate <code>N</code> random integers with a given positive average <code>avg</code> (an integer), in random order, generate <code>IntegersWithSum(N, N * avg)</code>.</li>
<li>To generate <code>N</code> random integers <code>min</code> or greater and with a given positive sum <code>sum</code> (an integer), in random order, generate <code>IntegersWithSum(N, sum - N * min)</code>, then add <code>min</code> to each number generated this way.  The <a href="https://peteroupc.github.io/randomgen.zip"><strong>Python sample code</strong></a> implements an efficient way to generate such integers if each one can&#39;t exceed a given maximum; the algorithm is thanks to a <em>Stack Overflow</em> answer (<code>questions/61393463</code>) by John McClane.</li>
<li>To generate <code>N</code> rational numbers that sum to <code>tx</code>/<code>ty</code>, call <code>IntegersWithSum(N, tx * ty * x)</code> or <code>PositiveIntegersWithSum(N, tx * ty * x)</code> as appropriate (where <code>x</code> is the desired accuracy as an integer, such as <code>pow(2, 32)</code> or <code>pow(2, 53)</code>, so that the results are accurate to <code>1/x</code> or less), then for each number <code>c</code> in the result, convert it to <code>MakeRatio(c, tx * ty * x) * MakeRatio(tx, ty)</code>.</li>
</ol>
</blockquote>

<p><a id=Multinomial_Distribution></a></p>

<h3>Multinomial Distribution</h3>

<p>The <em>multinomial distribution</em> uses two parameters: <code>trials</code> and <code>weights</code>.  It models the number of times each of several mutually exclusive events happens among a given number of trials (<code>trials</code>), where each event can have a separate probability of happening (given as a list of <code>weights</code>).</p>

<p>A trivial implementation is to fill a list with as many zeros as <code>weights</code>, then for each trial, choose <code>index = WeightedChoice(weights)</code> and add 1 to the item in the list at the chosen <code>index</code>.  The resulting list follows a multinomial distribution.  The pseudocode below shows an optimization suggested in (Durfee et al., 2018, Corollary 45)[^58], but assumes all weights are integers.</p>

<pre>METHOD Multinomial(trials, weights)
    if trials &lt; 0: return error
    // create a list of successes
    list = []
    ratios = []
    sum=Sum(weights)
    for i in 0...size(weights): AddItem(ratios,
           MakeRatio(weights[i], sum))
    end
    for i in 0...size(weights)
        r=ratios[i]
        b=BinomialInt(t,r[0],r[1])
        AddItem(list, b)
        trials=trials-b
        if trials&gt;0: for j in range(i+1,
            len(weights)): ratios[j]=ratios[j]/(1-r)
    end
    return list
END METHOD
</pre>

<p><a id=Randomization_with_Real_Numbers></a></p>

<h2>Randomization with Real Numbers</h2>

<p>This section describes randomization methods that use random real numbers, not just random integers.  These include random rational numbers, fixed-point numbers, and floating-point numbers.</p>

<p>But whenever possible, <strong>applications should work with random integers</strong>, rather than other random real numbers.  This is because:</p>

<ul>
<li>No computer can choose from among all real numbers between two others, since there are infinitely many of them.</li>
<li>Algorithms that work with integers are more portable than those that work with other real numbers, especially floating-point numbers.[^59]  Integer algorithms are easier to control for their level of accuracy.</li>
<li>For applications that may care about reproducible &quot;random&quot; numbers (unit tests, simulations, machine learning, and so on), using non-integer numbers (especially floating-point numbers) can complicate the task of making a method reproducible from run to run or across computers.</li>
</ul>

<p>The methods in this section should not be used to sample at random for information security purposes, even if a secure &quot;source of random numbers&quot; is available.  See &quot;Security Considerations&quot; in the appendix.</p>

<p><a id=Uniform_Random_Real_Numbers></a></p>

<h3>Uniform Random Real Numbers</h3>

<p>This section defines a method, namely <code>RNDRANGEMinMaxExc(a, b)</code>, to generate independent &quot;uniform&quot; random real numbers in the open interval (<code>a</code>, <code>b</code>).[^60]</p>

<p>The section shows how this method can be implemented for fixed-point, rational, and floating-point numbers.  However, all three formats use a predetermined and fixed precision. Other formats for random real numbers don&#39;t have this limitation and include <a href="https://peteroupc.github.io/exporand.html"><strong>partially-sampled random numbers</strong></a> and &quot;constructive reals&quot; or &quot;recursive reals&quot; (Boehm 2020)[^61].</p>

<p><a id=For_Fixed_Point_Number_Formats></a></p>

<h4>For Fixed-Point Number Formats</h4>

<p>For fixed-point number formats representing multiples of 1/<code>n</code>, this method is trivial.  The following returns an integer that represents a fixed-point number.  In the method below (and in the note), <code>fpa</code> and <code>fpb</code> are the bounds of the fixed-point number generated and are integers that represent fixed-point numbers (such that <code>fpa = a * n</code> and <code>fpb = b * n</code>).  For example, if <code>n</code> is 100, to generate a number in the open interval (6.35, 9.96), generate <code>RNDRANGEMinMaxExc(6.35, 9.96)</code> or <code>RNDINTRANGE(635 + 1, 996 - 1)</code>.</p>

<ul>
<li><code>RNDRANGEMinMaxExc(a, b)</code>: <code>RNDINTRANGE(fpa + 1, fpb - 1)</code>, or an error if <code>fpa &gt;= fpb or a == fpb - 1</code>.  But if <code>a</code> is 0 and <code>b</code> is 1: <code>(RNDINT(n - 2) + 1)</code> or <code>(RNDINTEXC(n - 1) + 1)</code>.</li>
</ul>

<blockquote>
<p><strong>Note:</strong> Additional methods to sample fixed-point numbers in a different interval are given below, but are not used in the rest of this article.</p>

<ul>
<li><code>RNDRANGE(a, b)</code>, interval [<code>a</code>, <code>b</code>]: <code>RNDINTRANGE(fpa, fpb)</code>.  But if <code>a</code> is 0 and <code>b</code> is 1: <code>RNDINT(n)</code>.</li>
<li><code>RNDRANGEMinExc(a, b)</code>, interval (<code>a</code>, <code>b</code>]: <code>RNDINTRANGE(fpa + 1, fpb)</code>, or an error if <code>fpa &gt;= fpb</code>.  But if <code>a</code> is 0 and <code>b</code> is 1: <code>(RNDINT(n - 1) + 1)</code> or <code>(RNDINTEXC(n) + 1)</code>.</li>
<li><code>RNDRANGEMaxExc(a, b)</code>, interval [<code>a</code>, <code>b</code>): <code>RNDINTEXCRANGE(fpa, fpb)</code>.  But if <code>a</code> is 0 and <code>b</code> is 1: <code>RNDINTEXC(n)</code> or <code>RNDINT(n - 1)</code>.</li>
</ul>
</blockquote>

<p><a id=For_Rational_Number_Formats></a></p>

<h4>For Rational Number Formats</h4>

<p>A <em>rational number</em> is a ratio of integers.  If the rational number&#39;s denominator is <code>n</code> (which must be 1 or greater), use the previous section to generate its numerator, so that the rational number is a multiple of 1/<code>n</code>.</p>

<p><a id=For_Floating_Point_Number_Formats></a></p>

<h4>For Floating-Point Number Formats</h4>

<p>For floating-point number formats representing numbers of the form <code>FPSign</code> * <code>s</code> * <code>FPRADIX</code><sup><code>e</code></sup> [^62], the following pseudocode implements <code>RNDRANGEMinMaxExc(lo, hi)</code>.  In the pseudocode:</p>

<ul>
<li><code>MINEXP</code> is the lowest exponent a number can have in the floating-point format.  For the IEEE 754 binary64 format (Java <code>double</code>), <code>MINEXP = -1074</code>.  For the IEEE 754 binary32 format (Java <code>float</code>), <code>MINEXP = -149</code>.</li>
<li><code>FPPRECISION</code> is the number of significant digits in the floating-point format, whether the format stores them as such or not. Equals 53 for binary64, or 24 for binary32.</li>
<li><code>FPRADIX</code> is the digit base of the floating-point format.  Equals 2 for binary64 and binary32.</li>
<li><code>FPExponent(x)</code> returns the value of <code>e</code> for the number <code>x</code> such that the number of digits in <code>s</code> equals <code>FPPRECISION</code>.  Returns <code>MINEXP</code> if <code>x = 0</code> or if <code>e</code> would be less than <code>MINEXP</code>.</li>
<li><code>FPSignificand(x)</code> returns <code>s</code>, the significand of the number <code>x</code>.  Returns 0 if <code>x = 0</code>. Has <code>FPPRECISION</code> digits unless <code>FPExponent(x) == MINEXP</code>.</li>
<li><code>FPSign(x)</code> returns either -1 or 1 indicating whether the number is positive or negative.  Can be &minus;1 even if <code>s</code> is 0.</li>
</ul>

<p>See also (Downey 2007)[^63] and the <a href="https://gitlab.com/christoph-conrads/rademacher-fpl"><strong>Rademacher Floating-Point Library</strong></a>.</p>

<pre>METHOD RNDRANGEMinMaxExc(lo, hi)
   if mn &gt;= mx: return error
   return RNDRANGEHelper(lo, hi)
END METHOD

METHOD RNDRANGEHelper(lo, hi)
  losgn = FPSign(lo)
  hisgn = FPSign(hi)
  loexp = FPExponent(lo)
  hiexp = FPExponent(hi)
  losig = FPSignificand(lo)
  hisig = FPSignificand(hi)
  if lo &gt; hi: return error
  if losgn == 1 and hisgn == -1: return error
  if losgn == -1 and hisgn == 1
    // Straddles negative and positive ranges
    // NOTE: Changes negative zero to positive
    mabs = max(abs(lo),abs(hi))
    while true // until a value is returned
       ret=RNDRANGEHelper(0, mabs)
       neg=RNDINT(1)
       if neg==0: ret=-ret
       if ret&gt;=lo and ret&lt;=hi: return ret
    end
  end
  if lo == hi: return lo
  if losgn == -1
    // Negative range
    return -RNDRANGEHelper(abs(lo), abs(hi))
  end
  // Positive range
  expdiff=hiexp-loexp
  if loexp==hiexp
    // Exponents are the same
    // NOTE: Automatically handles
    // subnormals
    s=RNDINTRANGE(losig, hisig)
    return s*1.0*pow(FPRADIX, loexp)
  end
  while true // until a value is returned
    ex=hiexp
    while ex&gt;MINEXP
      v=RNDINTEXC(FPRADIX)
      if v==0: ex=ex-1
      else: break
    end
    s=0
    if ex==MINEXP
      // Has FPPRECISION or fewer digits
      // and so can be normal or subnormal
      s=RNDINTEXC(pow(FPRADIX,FPPRECISION))
    else if FPRADIX != 2
      // Has FPPRECISION digits
      s=RNDINTEXCRANGE(
        pow(FPRADIX,FPPRECISION-1),
        pow(FPRADIX,FPPRECISION))
    else
      // Has FPPRECISION digits (bits), the highest
      // of which is always 1 because it&#39;s the
      // only nonzero bit
      sm=pow(FPRADIX,FPPRECISION-1)
      s=RNDINTEXC(sm)+sm
    end
    ret=s*1.0*pow(FPRADIX, ex)
    if ret&gt;=lo and ret&lt;=hi: return ret
  end
END METHOD
</pre>

<blockquote>
<p><strong>Notes:</strong></p>

<ol>
<li><p>Additional methods to sample &quot;uniform&quot; floating-point numbers in a different interval are given below, but are not used in the rest of this article.</p>

<ul>
<li><code>RNDRANGE(mn, mx)</code>, interval [<code>mn</code>, <code>mx</code>]: Generate <code>RNDRANGEHelper(mn, mx)</code>.</li>
<li><code>RNDRANGEMaxExc(mn, mx)</code>, interval [<code>mx</code>, <code>mx</code>): If <code>mn &gt;= mx</code>, return an error.  Otherwise, generate <code>RNDRANGEHelper(mn, mx)</code> in a loop until a number other than <code>mx</code> is generated this way.</li>
<li><code>RNDRANGEMinExc(mn, mx)</code>, interval (<code>mn</code>, <code>mx</code>]: If <code>mn &gt;= mx</code>, return an error.  Otherwise, generate <code>RNDRANGEHelper(mn, mx)</code> in a loop until a number other than <code>mn</code> is generated this way.</li>
</ul></li>
<li><p>Many software libraries sample &quot;uniform&quot; real numbers by multiplying or dividing a uniform random integer by a constant.  For example, a method to sample &quot;uniformly&quot; at random from the half-open interval [0, 1) is often implemented like <code>RNDINTEXC(X) * (1.0/X)</code> or <code>RNDINTEXC(X) / X</code>, where X varies based on the software library.[^64] The disadvantage here is that doing so does not necessarily cover all numbers a floating-point format can represent in the range (Goualard 2020)[^65].  As another example, a method to sample &quot;uniformly&quot; at random from the half-open interval [<code>a</code>, <code>b</code>) is often implemented like <code>a + Math.random() * (b - a)</code>, where <code>Math.random()</code> is a &quot;uniform&quot; random floating-point number in [0, 1); however, this not only has the same disadvantage, but has many other issues where floating-point numbers are involved (Monahan 1985)[^66].</p></li>
</ol>
</blockquote>

<p><a id=Monte_Carlo_Sampling_Expected_Values_Integration_and_Optimization></a></p>

<h3>Monte Carlo Sampling: Expected Values, Integration, and Optimization</h3>

<p><strong>Requires random real numbers.</strong></p>

<p>Randomization is the core of <strong>Monte Carlo sampling</strong>.  There are three main uses of Monte Carlo sampling: estimation, integration, and optimization.</p>

<ol>
<li><p><strong>Estimating expected values.</strong> Monte Carlo sampling can help estimate the <strong>expected value</strong> (mean or &quot;long-run average&quot;) of a sampling distribution, or of a <em>function</em> of values sampled from that distribution.  This function is called <code>EFUNC(x)</code> in this section, where <code>x</code> is one of the values in the sample.  Algorithms to estimate expected values are called <em>estimators</em>.  One such estimator is to sample <code>n</code> values, apply <code>EFUNC(x)</code> to each sampled value <code>x</code>, add the values, and divide by <code>n</code> (see note below).  However, this estimator won&#39;t work for all distributions, since they may have an infinite expected value, and it also doesn&#39;t allow controlling for the estimate&#39;s error.  This estimator is called:</p>

<ul>
<li>The <strong><code>n</code>th sample raw moment</strong> (a raw moment is a mean of <code>n</code>th powers) if <code>EFUNC(x)</code> is <code>pow(x, n)</code>.</li>
<li>The <strong>sample mean</strong>, if <code>EFUNC(x)</code> is <code>x</code> or <code>pow(x, 1)</code>.</li>
<li>The <strong><code>n</code>th sample central moment</strong> (a central moment is a moment about the mean) if <code>EFUNC(x)</code> is <code>pow(x-m, n)</code>, where <code>m</code> is the sample mean.</li>
<li>The (biased) <strong>sample variance</strong>, the second sample central moment.</li>
<li>The <strong>sample probability</strong>, if <code>EFUNC(x)</code> is <code>1</code> if some condition is met or <code>0</code> otherwise.</li>
</ul>

<p>There are two sources of error in Monte Carlo estimators: bias and variance. An estimator is <em>unbiased</em> (has bias 0) if its expected value equals the distribution&#39;s expected value.  For example, any <code>n</code>th sample <em>raw</em> moment is an unbiased estimator provided the sample size is at least <code>n</code>, but the sample variance is not unbiased, and neither is one for any sample <em>central</em> moment other than the first (Halmos 1946)[^67]. (&quot;Variance reduction&quot; methods are outside the scope of this document.) An estimator&#39;s <em>mean squared error</em> equals variance plus square of bias.</p>

<p>For Monte Carlo estimators with accuracy guarantees, see &quot;<a href="https://peteroupc.github.io/estimation.html"><strong>Randomized Estimation Algorithms</strong></a>&quot;.</p></li>
<li><p><a href="https://en.wikipedia.org/wiki/Monte_Carlo_integration"><strong>Monte Carlo integration</strong></a>.  This is usually a special case of Monte Carlo estimation that approximates a multidimensional integral over a sampling domain; here, <code>EFUNC(z)</code> is the function to find the integral of, where <code>z</code> is a randomly chosen point in the sampling domain (such as 1 if the point is in the true volume and 0 if not).</p></li>
<li><p><a href="http://mathworld.wolfram.com/StochasticOptimization.html"><strong>Stochastic optimization</strong></a>. This uses randomness to help find the minimum or maximum value of a function with one or more variables; examples include <a href="https://en.wikipedia.org/wiki/Simulated_annealing"><strong><em>simulated annealing</em></strong></a> and <a href="https://en.wikipedia.org/wiki/Simultaneous_perturbation_stochastic_approximation"><strong><em>simultaneous perturbation stochastic approximation</em></strong></a> (see also (Spall 1998)[^68]).</p></li>
</ol>

<blockquote>
<p><strong>Note:</strong> Assuming the true population has a finite mean and variance, the <em>sample mean</em> is an unbiased estimator of the mean, but the <em>sample variance</em> is generally a biased estimator of variance for any sample smaller than the whole population.  The following pseudocode returns a two-item list containing the sample mean and an <a href="http://mathworld.wolfram.com/Variance.html"><strong>unbiased estimator of the variance</strong></a>, in that order, of a list of real numbers (<code>list</code>), using the <a href="https://www.johndcook.com/blog/standard_deviation/"><strong>Welford method</strong></a> presented by J. D. Cook.  The square root of the variance calculated here is what many APIs call a standard deviation (for example, Python&#39;s <code>statistics.stdev</code>).  For the usual (biased) sample variance, replace <code>(size(list)-1)</code> with <code>size(list)</code> in the pseudocode shown next.  The pseudocode follows: <code>if size(list)==0: return [0, 0]; if size(list)==1: return [list[0], 0]; xm=list[0]; xs=0; i=1; while i &lt; size(list); c = list[i]; i = i + 1; cxm = (c - xm); xm = xm + cxm *1.0/ i; xs = xs + cxm * (c - xm); end; return [xm, xs*1.0/(size(list)-1)]</code>.</p>
</blockquote>

<p><a id=Point_Sample_Selection></a></p>

<h3>Point Sample Selection</h3>

<p><strong>Requires random real numbers.</strong></p>

<p>Various methods have been developed for selecting a uniform-behaving sample of points, especially for Monte Carlo methods.</p>

<p>Among these methods, a <a href="https://en.wikipedia.org/wiki/Low-discrepancy_sequence"><strong><em>low-discrepancy sequence</em></strong></a> (or <em>quasirandom sequence</em>) is a sequence of numbers that behave like uniformly distributed numbers in the interval [0, 1], but are <em>dependent</em> on each other, in that they are less likely to form &quot;clumps&quot; than if they were independent.  The following are examples:</p>

<ul>
<li>A base-N <em>van der Corput sequence</em> is generated as follows:  For each non-negative integer index in the sequence, take the index as a base-N number, then divide the least significant base-N digit by N, the next digit by N<sup>2</sup>, the next by N<sup>3</sup>, and so on, and add together these results of division.</li>
<li>A <em>Halton sequence</em> is a set of two or more van der Corput sequences with different prime bases; a Halton point at a given index has coordinates equal to the points for that index in the van der Corput sequences.</li>
<li>Roberts, M., in &quot;<a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/"><strong>The Unreasonable Effectiveness of Quasirandom Sequences</strong></a>&quot;, presents a low-discrepancy sequence based on a &quot;generalized&quot; version of the golden ratio.</li>
<li>Sobol sequences are explained in &quot;<a href="https://web.maths.unsw.edu.au/%7Efkuo/sobol/"><strong>Sobol sequence generator</strong></a>&quot; by S. Joe and F. Kuo.</li>
</ul>

<p>The points of a low-discrepancy sequence can be &quot;scrambled&quot; with the help of a pseudorandom number generator (or another device or program that simulates a &quot;source of random numbers&quot;).  In Monte Carlo sampling, low-discrepancy sequences are often used to achieve more efficient &quot;random&quot; sampling, but in general, they can be safely used this way only if none of their points is skipped (Owen 2020)[^69].</p>

<p>Other methods that likewise produce a uniform-behaving point sample include the following.</p>

<ul>
<li><em>Stratified sampling</em> divides an N-dimensional box into smaller boxes of the same size and chooses one or more points uniformly at random in each box.</li>
<li><em>Latin hypercube sampling</em> can be implemented using the following pseudocode for an <code>n</code>-number sequence: <code>lhs = []; for i in 0...n: AddItem(RNDRANGEMinMaxExc(i*1.0/n,(i+1)*1.0/n)); lhs = Shuffle(lhs)</code>.</li>
<li>Linear congruential generators with modulus <code>m</code>, a full period, and &quot;good lattice structure&quot;; a sequence of <code>n</code>-dimensional points is then <code>[MLCG(i), MLCG(i+1), ..., MLCG(i+n-1)]</code> for each integer <code>i</code> in the interval [1, <code>m</code>] (L&#39;Ecuyer 1999)[^70].  One example is <code>MLCG(seed)</code>: <code>rem(92717*seed,262139)/262139.0</code>.</li>
<li>Linear feedback shift register generators with good &quot;uniformity&quot; for Monte Carlo sampling (for example, (Harase 2020)[^71]).</li>
<li>If a low-discrepancy sequence outputs numbers in the interval [0, 1], the <a href="http://en.wikipedia.org/wiki/Baker&#x27;s_map"><strong>Baker&#39;s map</strong></a> of the sequence is <code>2 * (MakeRatio(1,2)-abs(x - MakeRatio(1,2)))</code>, where <code>x</code> is each number in the sequence.</li>
</ul>

<p><a id=Notes_on_Randomization_Involving_Real_Numbers></a></p>

<h3>Notes on Randomization Involving Real Numbers</h3>

<p><strong>Requires random real numbers.</strong></p>

<p><a id=Random_Walks_Additional_Examples></a></p>

<h4>Random Walks: Additional Examples</h4>

<ul>
<li>One example of a white noise process is a list of <code>Normal(0, 1)</code> numbers (<em>Gaussian white noise</em>).</li>
<li>If <code>STATEJUMP()</code> is <code>RNDRANGEMinMaxExc(-1, 1)</code>, the random state is advanced by a random real number in the interval (-1, 1).</li>
<li>A <strong>continuous-time process</strong> models random behavior at every moment, not just at discrete times.  There are two popular examples:

<ul>
<li>A <em>Wiener process</em> (also known as <em>Brownian motion</em>) has random states and jumps that are normally distributed. For a random walk that follows a Wiener process, <code>STATEJUMP()</code> is <code>Normal(mu * timediff, sigma * sqrt(timediff))</code>, where  <code>mu</code> is the drift (or average value per time unit), <code>sigma</code> is the volatility, and <code>timediff</code> is the time difference between samples.  A <em>Brownian bridge</em> (Revuz and Yor 1999)[^72] modifies a Wiener process as follows: For each time X, calculate <code>W(X) - W(E) * (X - S) / (E - S)</code>, where <code>S</code> and <code>E</code> are the starting and ending times of the process, respectively, and <code>W(X)</code> and <code>W(E)</code> are the state at times X and E, respectively.</li>
<li>In a <em>Poisson point process</em>, the time between each event is its own exponential random variate with its own rate parameter (for example, <code>Expo(rate)</code>) (see &quot;<a href="#Exponential_Distribution"><strong>Exponential Distribution</strong></a>&quot;), and sorting N random <code>RNDRANGEMinMaxExc(x, y)</code> expresses N arrival times in the interval <code>[x, y]</code>. The process is <em>homogeneous</em> if all the rates are the same, and <em>inhomogeneous</em> if the rate is a function of the &quot;timestamp&quot; before each event jump (the <em>hazard rate function</em>); to generate arrival times here, potential arrival times are generated at the maximum possible rate (<code>maxrate</code>) and each one is accepted if <code>RNDRANGEMinMaxExc(0, maxrate) &lt; thisrate</code>, where <code>thisrate</code> is the rate for the given arrival time (Lewis and Shedler 1979)[^73].</li>
</ul></li>
</ul>

<p><a id=Transformations_Additional_Examples></a></p>

<h4>Transformations: Additional Examples</h4>

<ol>
<li><strong>Bates distribution</strong>: Find the mean of <em>n</em> uniform random variates in a given range (such as variates generated by <code>RNDRANGEMinMaxExc(minimum, maximum)</code>) (strategy 8, mean).</li>
<li>A random point (<code>x</code>, <code>y</code>) can be transformed (strategy 9, geometric transformation) to derive a point with <strong>correlated random</strong> coordinates (old <code>x</code>, new <code>x</code>) as follows (see (Saucier 2000)[^74], sec. 3.8): <code>[x, y*sqrt(1 - rho * rho) + rho * x]</code>, where <code>x</code> and <code>y</code> are independent numbers chosen at random in the same way, and <code>rho</code> is a <em>correlation coefficient</em> in the interval [-1, 1] (if <code>rho</code> is 0, <code>x</code> and <code>y</code> are uncorrelated).</li>
<li>It is reasonable to talk about sampling the sum or mean of N random variates, where N has a fractional part.  In this case, <code>ceil(N)</code> random variates are generated and the last variate is multiplied by that fractional part.  For example, to sample the sum of 2.5 random variates, generate three random variates, multiply the last by 0.5 (the fractional part of 2.5), then add together all three variates.</li>
<li>A <strong>hypoexponential distribution</strong> models the sum of <em>n</em> random variates that follow an exponential distribution and each have a separate rate parameter (see &quot;<a href="#Exponential_Distribution"><strong>Exponential Distribution</strong></a>&quot;).</li>
<li>The <strong>maximal coupling</strong> method mentioned by <a href="https://statisfaction.wordpress.com/2017/09/06/sampling-from-a-maximal-coupling/"><strong>P. Jacob</strong></a> generates correlated random variates from two distributions, <em>P</em> and <em>Q</em>, with known probability density functions or PDFs (<code>PPDF</code> and <code>QPDF</code>, respectively); this works only if the area under each PDF is 1: Sample a number <code>x</code> at random from distribution <em>P</em>, and if <code>RNDRANGEMinMaxExc(0, PPDF(x)) &lt; QPDF(x)</code>, return <code>[x, x]</code>.  Otherwise, sample a number <code>y</code> at random from distribution <em>Q</em> until <code>PPDF(y) &lt; RNDRANGEMinMaxExc(0, QPDF(y))</code>, then return <code>[x, y]</code>.</li>
</ol>

<p><a id=Sampling_from_a_Distribution_of_Data_Points></a></p>

<h3>Sampling from a Distribution of Data Points</h3>

<p><strong>Requires random real numbers.</strong></p>

<p>Generating random data points based on how a list of data points is distributed involves the field of <strong>machine learning</strong>: <em>fit a data model</em> to the data points, then <em>predict</em> a new data point based on that model, with randomness added to the mix.  Three kinds of data models, described below, serve this purpose. (How fitting works is outside the scope of this page.)</p>

<ol>
<li><p><strong>Density estimation models.</strong> <a href="http://scikit-learn.org/stable/modules/density.html"><strong>Density estimation</strong></a> models seek to describe the distribution of data points in a given data set, where areas with more points are more likely to be sampled.[^75] The following are examples.</p>

<ul>
<li><strong>Histograms</strong> are sets of one or more non-overlapping <em>bins</em>, which are generally of equal size.  Histograms are <a href="#Mixtures_of_Distributions"><strong><em>mixtures</em></strong></a>, where each bin&#39;s weight is the number of data points in that bin.  After a bin is randomly chosen, a random data point that could fit in that bin is generated (that point need not be an existing data point).</li>
<li><strong>Gaussian</strong> <a href="https://en.wikipedia.org/wiki/Mixture_model"><strong>mixture models</strong></a> are also mixtures, in this case, mixtures of one or more <a href="#Normal_Gaussian_Distribution"><strong>Gaussian (normal) distributions</strong></a>.</li>
<li><strong>Kernel distributions</strong> are mixtures of sampling distributions, one for each data point. Estimating a kernel distribution is called <a href="https://en.wikipedia.org/wiki/Kernel_density_estimation"><strong><em>kernel density estimation</em></strong></a>.  To sample from a kernel distribution:

<ol>
<li>Choose one of the numbers or points in the list uniformly at random <a href="#Sampling_With_Replacement_Choosing_a_Random_Item_from_a_List"><strong>with replacement</strong></a>.</li>
<li>Add a randomized &quot;jitter&quot; to the chosen number or point; for example, add a separately generated <code>Normal(0, sigma)</code> to the chosen number or each component of the chosen point, where <code>sigma</code> is the <em>bandwidth</em>[^76].</li>
</ol></li>
<li><strong>Stochastic interpolation</strong> is described in (Saucier 2000)[^74], sec. 5.3.4.</li>
<li><strong>Fitting a known distribution</strong> (such as the normal distribution), with unknown parameters, to data can be done by <a href="https://en.wikipedia.org/wiki/Maximum_likelihood_estimation"><strong>maximum likelihood estimation</strong></a>, among other ways.</li>
</ul></li>
<li><p><strong>Regression models.</strong> A <em>regression model</em> is a model that summarizes data as a formula and an error term.  If an application has data in the form of inputs and outputs (for example, monthly sales figures) and wants to sample a random but plausible output given a known input point (for example, sales for a future month), then the application can fit and sample a regression model for that data.  For example, a <em>linear regression model</em>, which simulates the value of <code>y</code> given known inputs <code>a</code> and <code>b</code>, can be sampled as follows: <code>y = c1 * a + c2 * b + c3 + Normal(0, sqrt(mse))</code>, where <code>mse</code> is the mean squared error and <code>c1</code>, <code>c2</code>, and <code>c3</code> are the coefficients of the model.  (Here, <code>Normal(0, sqrt(mse))</code> is the error term.)</p></li>
<li><p><strong>Generative and discriminative models.</strong> These are machine learning models that take random variates as input and generate outputs (such as images or sounds) that are similar to examples they have already seen.  One example, <a href="https://en.wikipedia.org/wiki/Generative_adversarial_network"><strong><em>generative adversarial networks</em></strong></a>, employs both kinds of model.</p></li>
</ol>

<blockquote>
<p><strong>Notes:</strong></p>

<ol>
<li>Usually, more than one kind of data model and/or machine learning model is a possible choice to fit to a given data set (for example, multiple kinds of density estimation models, regression models, parametric distributions, and/or decision trees).  If several kinds of model are fitting choices, then the simplest kind that shows an acceptable <em>predictive accuracy</em> for the data set (for example, information criterion, precision, recall) should be chosen.</li>
<li>If the existing data points each belong in one of several <em>categories</em>, choosing a random category could be done by choosing a number at random with probability proportional to the number of data points in each category (see &quot;<a href="#Weighted_Choice"><strong>Weighted Choice</strong></a>&quot;).</li>
<li>If the existing data points each belong in one of several <em>categories</em>, choosing a random data point <em>and</em> its category could be done&mdash;

<ol>
<li>by choosing a random data point based on all the existing data points, then finding its category (for example, via machine learning models known as <em>classification models</em>), or</li>
<li>by choosing a random category as given above, then by choosing a random data point based only on the existing data points of that category.</li>
</ol></li>
</ol>
</blockquote>

<p><a id=Sampling_from_an_Arbitrary_Distribution></a></p>

<h3>Sampling from an Arbitrary Distribution</h3>

<p><strong>Requires random real numbers.</strong></p>

<p>Many probability distributions can be defined in terms of any of the following:</p>

<ul>
<li>The <a href="https://en.wikipedia.org/wiki/Cumulative_distribution_function"><strong><em>cumulative distribution function</em></strong></a>, or <em>CDF</em>, <code>CDF(x)</code>, is the probability of choosing a number less than or equal to <code>x</code> at random.  The probabilities are in the interval [0, 1].</li>
<li><em>Discrete distributions</em>[^77] have a <em>probability mass function</em>, or <em>PMF</em>, which gives the probability that each number is randomly chosen.</li>
<li><em>Absolutely continuous distributions</em> have a <a href="https://en.wikipedia.org/wiki/Probability_density_function"><strong><em>probability density function</em></strong></a>, or <em>PDF</em>, <code>PDF(x)</code>, which is the &quot;slope&quot; function of the CDF, or the relative probability of choosing a number &quot;close&quot; to <code>x</code> at random. The relative probabilities are 0 or greater, and the area under the PDF is 1.</li>
<li>The <em>quantile function</em> (also known as <em>inverse cumulative distribution function</em> or <em>inverse CDF</em>) maps numbers in the interval (0, 1) to numbers in the distribution, from low to high.</li>
</ul>

<p>In this section, a <strong>PDF-like function</strong> is the PDF, the PMF, or either function times a (possibly unknown) positive constant.</p>

<p>The following sections show different ways to generate random variates based on a distribution, depending on what is known about that distribution.</p>

<blockquote>
<p><strong>Note:</strong> Lists of CDFs, PDF-like functions, or quantile functions are outside the scope of this page.</p>
</blockquote>

<p><a id=Sampling_for_Discrete_Distributions></a></p>

<h4>Sampling for Discrete Distributions</h4>

<p>If the distribution <strong>is discrete</strong>, numbers that closely follow it can be sampled by choosing points that cover all or almost all of the distribution, finding their weights or cumulative weights, and choosing a random point based on those weights.</p>

<p>If&mdash;</p>

<ul>
<li>the discrete distribution has a <strong>known PDF-like function</strong> <code>PDF(x)</code>, where <code>x</code> must be an integer,</li>
<li>the interval [<code>mini</code>, <code>maxi</code>] covers all the distribution, and</li>
<li>the function&#39;s values are all rational numbers (numbers of the form <code>y/z</code> where <code>y</code> and <code>z</code> are integers),</li>
</ul>

<p>the following method samples exactly from that distribution:</p>

<pre>METHOD SampleDiscrete(mini, maxi)
      // Setup
      ratios=[]
      for i in mini..maxi: AddItem(ratios, PDF(i))
      ratios=NormalizeRatios(ratios)
      // Sampling
      return mini + WeightedChoice(ratios)
END METHOD
</pre>

<p>If&mdash;</p>

<ul>
<li>the discrete distribution has a <strong>known CDF</strong> <code>CDF(x)</code>, where <code>x</code> must be an integer,</li>
<li>the interval [<code>mini</code>, <code>maxi</code>] covers all the distribution, and</li>
<li>the CDF&#39;s values are all rational numbers,</li>
</ul>

<p>the following method samples exactly from that distribution:</p>

<pre>METHOD SampleDiscreteCDF(mini, maxi)
  // Setup
  ratios=[MakeRatio(0,1)]
  for i in mini..maxi: AddItem(ratios, CDF(i))
  ratios=NormalizeRatios(ratios)
  // Sampling
  value=ratios[size(ratios) - 1]
  for i in 0...size(ratios) - 1
         if ratios[i] &lt; ratios[i+1] and
             ratios[i]&gt;=value: return mini + i
  end
  return mini
END METHOD
</pre>

<p>In other cases, the discrete distribution can still be approximately sampled.  The following cases will lead to an approximate sampler unless the values of the CDF or PDF-like function cover all the distribution and are calculated exactly (without error).</p>

<ul>
<li>If the values of the CDF or PDF-like function are calculated as <strong>floating-point numbers</strong> of the form  <code>FPSignificand</code> * <code>FPRadix</code><sup><code>FPExponent</code></sup> (which include Java&#39;s <code>double</code> and <code>float</code>)[^78], there are various ways to turn these numbers to rational numbers or integers.

<ol>
<li>One way is to use <code>FPRatio(x)</code> (in the pseudocode below), which is lossless and calculates the rational number for the given floating-point number <code>x</code>.</li>
<li>Another way is to scale and round the values to integers (for example, <code>floor(x * mult)</code> if <code>floor(x * mult) &lt; 0.5</code> and <code>ceil(x * mult)</code> otherwise, where <code>mult</code> is a large integer); this is not lossless.</li>
<li>A third way is to approximate the values of the PDF-like function to integers in a way that bounds the error, such as given in (Saad et al., 2020)[^79]; this is not lossless and works only for PDF-like functions.</li>
</ol></li>
<li>If the values of the CDF or PDF-like function are calculated as <strong>rational numbers</strong>, these numbers can be turned into integer weights using either <code>NormalizeRatios</code>, which is lossless, or (2) or (3) above, which are not.</li>
<li>If the distribution takes on an <strong>infinite number of values</strong>, an appropriate interval [<code>mini</code>, <code>maxi</code>] can be chosen that covers almost all of the distribution.</li>
</ul>

<pre>METHOD FPRatio(fp)
  expo=FPExponent(fp)
  sig=FPSignificand(fp)
  radix=FPRadix(fp)
  if expo&gt;=0: return MakeRatio(sig * pow(radix, expo), 1)
  return MakeRatio(sig, pow(radix, abs(expo)))
END METHOD
</pre>

<blockquote>
<p><strong>Note:</strong> In addition, some distributions are known only through an <em>oracle</em> (or &quot;black box&quot;) that produces random variates that follow that distribution.  Algorithms can use this oracle to produce new random variates that follow a different distribution.  When the mean (&quot;long-run average&quot;) of the new variates equals the oracle&#39;s, the algorithm is called an <em>unbiased estimator</em> (because in a way, it &quot;estimates&quot; some aspect of the oracle&#39;s numbers).  One example is the Bernoulli factory (see my article &quot;<a href="https://peteroupc.github.io/bernoulli.html"><strong>Bernoulli Factory Algorithms</strong></a>&quot;), which takes flips of a coin with one probability of heads (the oracle) and produces the flip of a new &quot;coin&quot; with a different probability of heads.  Another example is the &quot;Bernoulli race&quot; described in <a href="#Weighted_Choice"><strong>Weighted Choice</strong></a>.</p>
</blockquote>

<p><a id=Inverse_Transform_Sampling></a></p>

<h4>Inverse Transform Sampling</h4>

<p><a href="https://en.wikipedia.org/wiki/Inverse_transform_sampling"><strong><em>Inverse transform sampling</em></strong></a> (or simply <em>inversion</em>) is the most generic way to sample a number from a probability distribution.</p>

<p>If the distribution <strong>has a known quantile function</strong>, generate a uniform random variate in (0, 1) if that number wasn&#39;t already pregenerated, and take the quantile of that number.  However:</p>

<ul>
<li>In most cases, the quantile function is not available.  Thus, it has to be approximated.</li>
<li>Even if the quantile function is available, a na&iuml;ve quantile calculation (for example, <code>ICDF(RNDRANGEMinMaxExc(0, 1))</code>) may mean that small changes in the uniform number lead to huge changes in the quantile, leading to gaps in sampling coverage (Monahan 1985, sec. 4 and 6)[^66].</li>
</ul>

<p>The following method samples from a distribution via inversion, with an accuracy of 1/<code>BASE</code><sup><code>precision</code></sup> ((Devroye and Gravel 2020)[^11], but extended for any base; see also (Bringmann and Friedrich 2013, Appendix A)[^54]).  In the method, <code>ICDF(u, ubits, prec)</code> returns a two-item list containing upper and lower bounds, respectively, of a number that is within 1/<code>BASE</code><sup><code>prec</code></sup> of the true quantile of <code>u</code>/<code>BASE</code><sup><code>ubits</code></sup>, and <code>BASE</code> is the digit base (for example, 2 for binary or 10 for decimal).</p>

<pre>METHOD Inversion(precision)
   u=0
   ubits=0
   threshold=MakeRatio(1,pow(BASE, precision))*2
   incr=8
   while true // until a value is returned
      incr=8
      if ubits==0: incr=precision
      // NOTE: If a uniform number (`n`) is already pregenerated,
      // use the following instead:
      // u = rem(floor(n*pow(BASE, ubits+incr)), pow(BASE, incr))
      u=u*pow(BASE,incr)+RNDINTEXC(pow(BASE,incr))
      ubits=ubits+incr
      // Get upper and lower bound
      bounds=ICDF(u,ubits,precision)
      if lower&gt;upper: return error
      diff=bounds[1]-bounds[0]
      if diff&lt;=threshold: return bounds[1]+diff/2
   end
end
</pre>

<p>Some applications need to convert a pregenerated number in [0, 1] (usually a number sampled from a uniform distribution), called <code>u01</code> below, to a non-uniform distribution via quantiles. Notable cases include copula methods, order statistics, and Monte Carlo methods involving low-discrepancy sequences. The following way to compute quantiles is exact in theory:</p>

<ul>
<li>Distribution is <strong>discrete, with known PMF</strong> (and the distribution takes on integers): Sequential search (Devroye 1986, p. 85)[^19]: <code>i = 0; p = PMF(i); while u01 &gt; p; u01 = u01 - p; i = i + 1; p = PMF(i); end; return p</code>, but this is not always fast. (This works only if <code>PMF</code>&#39;s values sum to 1, which is why a PMF and not a PDF-like function is allowed here.)</li>
</ul>

<p>In addition, the following methods approximate the quantile:</p>

<ul>
<li>Distribution is <strong>discrete, with known PDF-like function</strong> (and the distribution takes on integers): If the interval [a, b] covers all or almost all the distribution, then the application can store the PDF-like function&#39;s values in that interval in a list and call <code>WChoose</code>: <code>wsum = 0; for i in a..b: wsum=wsum+PDF(i); for i in a..b: AddItem(weights, PDF(i)); return a + WChoose(weights, u01 * wsum)</code>.  However, finding the quantile based on the <strong>CDF</strong> instead of a PDF-like function can introduce more error (Walter 2019)[^80].  See also <code>integers_from_u01</code> in the <a href="https://peteroupc.github.io/randomgen.zip"><strong>Python sample code</strong></a>.</li>
<li>Distribution is <strong>absolutely continuous, with known PDF-like function</strong>: <code>ICDFFromContPDF(u01, mini, maxi, step)</code>, below, finds an approximate quantile based on a piecewise linear approximation of the PDF-like function in [<code>mini</code>, <code>maxi</code>], with pieces up to <code>step</code> wide. (Devroye and Gravel 2020)[^11]. See also <code>DensityInversionSampler</code>, <code>numbers_from_u01</code>, and <code>numbers_from_dist_inversion</code> (Derflinger et al. 2010)[^81], (Devroye and Gravel 2020)[^11] in the Python sample code [^82].</li>
<li>Distribution is <strong>absolutely continuous, with known CDF</strong>: See <code>numbers_from_u01</code> in the Python sample code.</li>
</ul>

<p>&nbsp;</p>

<pre>METHOD ICDFFromContPDF(u01, mini, maxi, step)
  pieces=[]
  areas=[]
  // Setup
  lastvalue=i
  lastweight=PDF(i)
  cumuarea=0
  i = mini+step; while i &lt;= maxi
     weight=i; value=PDF(i)
     cumuarea=cumuarea+abs((weight + lastweight) * 0.5 *
            (value - lastvalue))
     AddItem(pieces,[lastweight,weight,lastvalue,value])
     AddItem(areas,cumuarea)
     lastweight=weight;lastvalue=value
     if i==maxi: break
     i = min(i + step, maxi)
  end
  for i in 0...size(areas): areas[i]=areas[i]/cumuarea
  // Sampling
  prevarea=0
  for i in 0...size(areas)
     cu=areas[i]
     if u01&lt;=cu
         p=pieces[i]; u01=(u01-prevarea)/(cu-prevarea)
         s=p[0]; t=p[1]; v=u01
         if s!=t: v=(s-sqrt(t*t*u01-s*s*u01+s*s))/(s-t)
         return p[2]+(p[3]-p[2])*v
     end
     prevarea=cu
  end
  return error
END METHOD
</pre>

<blockquote>
<p><strong>Notes:</strong></p>

<ol>
<li>If only percentiles of data (such as the median or 50th percentile, the minimum or 0th percentile, or the maximum or 100th percentile) are available, the quantile function can be approximated via those percentiles.  The Nth percentile corresponds to the quantile for <code>N/100.0</code>.  Missing values for the quantile function can then be filled in by interpolation (such as spline fitting).  If the raw data points are available, see &quot;<a href="#Sampling_from_a_Distribution_of_Data_Points"><strong>Sampling from a Distribution of Data Points</strong></a>&quot; instead.</li>
<li>Taking the <code>k</code>th smallest of <code>n</code> random variates distributed the same way is the same as taking the <code>k</code>th smallest of <code>n</code> <em>uniform</em> random variates in the interval [0, 1) (also known as the <code>k</code>th <em>order statistic</em>; for example, <code>BetaDist(k, n+1-k)</code>) and finding its quantile (Devroye 2006)[^83]; (Devroye 1986, p. 30)[^19].</li>
</ol>
</blockquote>

<p><a id=Rejection_Sampling_with_a_PDF_Like_Function></a></p>

<h4>Rejection Sampling with a PDF-Like Function</h4>

<p>If the distribution <strong>has a known PDF-like function</strong> (<code>PDF</code>), and that function can be more easily sampled by another distribution with its own PDF-like function (<code>PDF2</code>) that &quot;dominates&quot; <code>PDF</code> in the sense that <code>PDF2(x) &gt;= PDF(x)</code> at every valid <code>x</code>, then generate random variates with the latter distribution until a variate (call it <code>n</code>) that satisfies <code>r &lt; PDF(n)</code>, where <code>r = RNDRANGEMinMaxExc(0, PDF2(n))</code>, is generated this way (that is, sample points in <code>PDF2</code> until a point falls within <code>PDF</code>).</p>

<p>A variant of rejection sampling is the <em>squeeze principle</em>, in which a third PDF-like function (<code>PDF3</code>) is chosen that is &quot;dominated&quot; by the first one (<code>PDF</code>) and easier to sample than <code>PDF</code>.  Here, a number is accepted if <code>r &lt; PDF3(n)</code> or <code>r &lt; PDF(n)</code> , where <code>r = RNDRANGEMinMaxExc(0, PDF2(n))</code> (Devroye 1986, p. 53)[^19].</p>

<p>See also (von Neumann 1951)[^46]; (Devroye 1986)[^19], pp. 41-43; &quot;<a href="#Rejection_Sampling"><strong>Rejection Sampling</strong></a>&quot;; and &quot;<a href="https://mathworks.com/help/stats/generating-random-data.html"><strong>Generating Pseudorandom Numbers</strong></a>&quot;.</p>

<blockquote>
<p><strong>Examples:</strong></p>

<ol>
<li>To sample a random variate in the interval [<code>low</code>, <code>high</code>) from a PDF-like function with a positive maximum value no greater than <code>peak</code> at that interval, generate <code>x = RNDRANGEMinMaxExc(low, high)</code> and <code>y = RNDRANGEMinMaxExc(0, peak)</code> until <code>y &lt; PDF(x)</code>, then take the last <code>x</code> generated this way. (See also Saucier 2000, pp. 6-7.)  If the distribution <strong>is discrete</strong> and integer-valued, generate <code>x</code> with <code>x = RNDINTEXCRANGE(low, high)</code> instead.</li>
<li>A PDF-like function for a custom distribution, <code>PDF</code>, is <code>exp(-abs(x*x*x))</code>, and the exponential distribution&#39;s, <code>PDF2</code>, is <code>exp(-x)</code>.  The exponential PDF-like function <code>PDF2</code> &quot;dominates&quot; <code>PDF</code> (at every <code>x</code> 0 or greater) if we multiply it by 1.5, so that <code>PDF2</code> is now <code>1.5 * exp(-x)</code>.  Now we can generate numbers from our custom distribution by sampling exponential points until a point falls within <code>PDF</code>.  This is done by generating <code>n = Expo(1)</code> until <code>RNDRANGEMinMaxExc(0, PDF2(n)) &lt; PDF(n)</code>.</li>
<li>The normal distribution&#39;s upside-down bell curve has the PDF-like function <code>1-exp(-(x*x))</code>, and the highest point for this function is <code>peak = max(1-exp(-(low*low)), 1-exp(-(high*high)))</code>. Sampling this distribution then uses the algorithm in example 1.</li>
</ol>

<p><strong>Note:</strong> In the Python sample code, <a href="https://github.com/peteroupc/peteroupc.github.io/blob/master/moore.py"><strong>moore.py</strong></a> and <code>numbers_from_dist</code> sample from a distribution via rejection sampling (Devroye and Gravel 2020)[^11], (Sainudiin and York 2013)[^84].</p>
</blockquote>

<p><a id=Alternating_Series></a></p>

<h4>Alternating Series</h4>

<p>If a PDF-like function for the target distribution is not known exactly, but can be approximated from above and below by two series expansions that converge to that function as more terms are added, the  <em>alternating series method</em> can be used.  This still requires a &quot;dominating&quot; PDF-like function (<code>PDF2(x)</code>) to serve as the &quot;easy-to-sample&quot; distribution.  Call the series expansions <code>UPDF(x, n)</code> and <code>LPDF(x, n)</code>, respectively, where <code>n</code> is the number of terms in the series to add.  To sample the distribution using this method (Devroye 2006)[^83]: (1) Sample from the &quot;dominating&quot; distribution, and let <code>x</code> be the sampled number; (2) set <code>n</code> to 0; (3) accept <code>x</code> if <code>r &lt; LPDF(x, n)</code>, or go to step 1 if <code>r &gt;= UPDF(x, n)</code>, or repeat this step with <code>n</code> increased by 1 if neither is the case, where <code>r = RNDRANGEMinMaxExc(0, PDF2(n))</code>.</p>

<p><a id=Markov_Chain_Monte_Carlo></a></p>

<h4>Markov-Chain Monte Carlo</h4>

<p><a href="https://en.wikipedia.org/wiki/Markov_chain_Monte_Carlo"><strong>Markov-chain Monte Carlo</strong></a> (MCMC) is a family of algorithms for sampling many random variates from a probability distribution by building a <em>Markov chain</em> of random values that build on each other until they converge to the given distribution.  In general, however, a given chain&#39;s random values will have a statistical <em>dependence</em> on each other, and it takes an unknown time for the chain to converge (which is why techniques such as &quot;thinning&quot; &mdash; keeping only every Nth sample &mdash; or &quot;burn-in&quot; &mdash; skipping iterations before sampling &mdash; are often employed). MCMC can also estimate the distribution&#39;s sampling domain for other samplers, such as rejection sampling (above).</p>

<p>MCMC algorithms[^85] include <em>Metropolis&ndash;Hastings</em>, <em>slice sampling</em>, and <em>Gibbs sampling</em> (see also the <a href="https://peteroupc.github.io/randomgen.zip"><strong>Python sample code</strong></a>).  The latter is special in that it uses not a PDF-like function, but two or more distributions, each of which uses a number sampled at random from the previous distribution (<em>conditional distributions</em>), that converge to a <em>joint distribution</em>.</p>

<blockquote>
<p><strong>Example:</strong> In one Gibbs sampler, an initial value for <code>y</code> is chosen, then multiple <code>x</code>, <code>y</code> pairs of random variates are generated, where <code>x = BetaDist(y, 5)</code> then <code>y = Poisson(x * 10)</code>.</p>
</blockquote>

<p><a id=Piecewise_Linear_Distribution></a></p>

<h3>Piecewise Linear Distribution</h3>

<p><strong>Requires random real numbers.</strong></p>

<p>A <a href="http://en.cppreference.com/w/cpp/numeric/random/piecewise_linear_distribution"><strong><em>piecewise linear distribution</em></strong></a> describes an absolutely continuous distribution with weights at known points and other weights determined by linear interpolation (smoothing).  The <code>PiecewiseLinear</code> method (in the pseudocode below) takes two lists as follows (see also (Kscischang 2019)[^86]):</p>

<ul>
<li><code>values</code> is a list of rational numbers. If the numbers are arranged in ascending order, which they should, the first number in this list can be returned exactly, but not the last number.</li>
<li><code>weights</code> is a list of rational-valued weights for the given numbers (where each number and its weight have the same index in both lists).   The greater a number&#39;s weight, the more likely it is that a number close to that number will be chosen.  Each weight should be 0 or greater.</li>
</ul>

<p>&nbsp;</p>

<pre>METHOD PiecewiseLinear(values, weights)
  if size(values)!=size(weights) or size(values)==0: return error
  if size(values)==1: return values[0]
  areas=[]
  for i in 1...size(values)
     area=abs((weights[i] + weights[i-1]) *
         (values[i] - values[i-1]) / 2) // NOTE: Not rounded
     AddItem(areas,area)
  end
  // NOTE: If values and weights are rational
  // numbers, use `areas=NormalizeRatios(areas)` instead
  // of finding `areas` as given below.
  ratios=[]
  for w in areas: AddItem(ratios, FPRatio(w))
  areas=NormalizeRatios(ratios)
  index=WeightedChoice(areas)
  w=values[index+1]-values[index]
  if w==0: return values[index]
  m=(weights[index+1]-weights[index])/w
  h2=(weights[index+1]+weights[index])
  ww=w/2.0; hh=h2/2.0
  x=RNDRANGEMinMaxExc(-ww, ww)
  if RNDRANGEMinMaxExc(-hh, hh)&gt;x*m: x=-x
  return values[index]+x+ww
END METHOD
</pre>

<blockquote>
<p><strong>Note:</strong> The <a href="https://peteroupc.github.io/randomgen.zip"><strong>Python sample code</strong></a> contains a variant to the method
above for returning more than one random variate in one call.</p>

<p><strong>Example</strong>: Assume <code>values</code> is the following: <code>[0, 1, 2, 2.5, 3]</code>, and <code>weights</code> is the following: <code>[0.2, 0.8, 0.5, 0.3, 0.1]</code>.  The weight for 2 is 0.5, and that for 2.5 is 0.3.  Since 2 has a higher weight than 2.5, numbers near 2 are more likely to be chosen than numbers near 2.5 with the <code>PiecewiseLinear</code> method.</p>
</blockquote>

<p><a id=Specific_Distributions></a></p>

<h3>Specific Distributions</h3>

<p>Methods to sample additional distributions are given in a <a href="https://peteroupc.github.io/randomnotes.html"><strong>separate page</strong></a>. They cover the normal, gamma, beta, von Mises, stable, and multivariate normal distributions as well as copulas.</p>

<p><a id=Index_of_Non_Uniform_Distributions></a></p>

<h3>Index of Non-Uniform Distributions</h3>

<p><strong>Many distributions here require random real numbers.</strong></p>

<p>A &dagger; symbol next to a distribution means that a sample from the distribution can be shifted by a location parameter (<code>mu</code>) then scaled by a scale parameter greater than 0 (<code>sigma</code>).  Example: <code>num * sigma + mu</code>.</p>

<p>A &#x2b26; symbol next to a distribution means the sample can be scaled to any range, which is given with the minimum and maximum values <code>mini</code> and <code>maxi</code>.  Example: <code>mini + (maxi - mini) * num</code>.</p>

<p>For further examples and distributions, see (Devroye 1996)[^87] and (Crooks 2019)[^88].</p>

<p>Most commonly used:
<small></p>

<ul>
<li><strong>Beta distribution</strong>&#x2b26;: See <a href="https://peteroupc.github.io/randomnotes.html#Beta_Distribution"><strong>Beta Distribution</strong></a>.</li>
<li><strong>Binomial distribution</strong>: See <a href="#Binomial_Distribution"><strong>Binomial Distribution</strong></a>.</li>
<li><strong>Binormal distribution</strong>: See <a href="https://peteroupc.github.io/randomnotes.html#Multivariate_Normal_Multinormal_Distribution"><strong>Multivariate Normal (Multinormal) Distribution</strong></a>.</li>
<li><strong>Cauchy (Lorentz) distribution</strong>&dagger;:  <code>Stable(1, 0)</code>.  This distribution is similar to the normal distribution, but with &quot;fatter&quot; tails. Alternative algorithm based on one mentioned in (McGrath and Irving 1975)[^89]: Generate <code>x = RNDRANGEMinMaxExc(0,1)</code> and <code>y = RNDRANGEMinMaxExc(0,1)</code> until <code>x * x + y * y &lt;= 1</code>, then generate <code>(RNDINT(1) * 2 - 1) * y / x</code>.</li>
<li><strong>Chi-squared distribution</strong>: <code>GammaDist(df * 0.5 + Poisson(sms * 0.5))*2</code>, where <code>df</code> is the number of degrees of freedom and <code>sms</code> is the sum of mean squares (where <code>sms</code> other than 0 indicates a <em>noncentral</em> distribution).</li>
<li><strong>Dice</strong>: See <a href="#Dice"><strong>Dice</strong></a>.</li>
<li><strong>Exponential distribution</strong>: See <a href="#Exponential_Distribution"><strong>Exponential Distribution</strong></a>.  The na&iuml;ve implementation <code>-ln(1-RNDRANGEMinMaxExc(0, 1)) / lamda</code> has several problems, such as being ill-conditioned at large values because of the distribution&#39;s right-sided tail (Pedersen 2018) [^1]. An application can reduce some of these problems by applying Pedersen&#39;s suggestion of using either <code>-ln(RNDRANGEMinMaxExc(0, 0.5))</code> or <code>-log1p(-RNDRANGEMinMaxExc(0, 0.5))</code> (rather than <code>-ln(1-RNDRANGEMinMaxExc(0, 1))</code>), chosen uniformly at random each time; an alternative is <code>ln(1/RNDRANGEMinMaxExc(0,1))</code> mentioned in (Devroye 2006)[^83].</li>
<li><strong>Extreme value distribution</strong>: See generalized extreme value distribution.</li>
<li><strong>Gamma distribution</strong>: See <a href="https://peteroupc.github.io/randomnotes.html#Gamma_Distribution"><strong>Gamma Distribution</strong></a>. Generalized gamma distributions include the <strong>Stacy distribution</strong> (<code>pow(GammaDist(a), 1.0 / c) * b</code>, where <code>c</code> is another shape parameter) and the <strong>Amoroso distribution</strong> (Crooks 2015)[^90], (<code>pow(GammaDist(a), 1.0 / c) * b + d</code>, where <code>d</code> is the minimum value).</li>
<li><strong>Gaussian distribution</strong>: See <a href="https://peteroupc.github.io/randomnotes.html#Normal_Gaussian_Distribution"><strong>Normal (Gaussian) Distribution</strong></a>.</li>
<li><strong>Geometric distribution</strong>: See <a href="#Geometric_Distribution"><strong>Geometric Distribution</strong></a>.  The following is &quot;exact&quot; assuming computers can operate &quot;exactly&quot; on real numbers: <code>floor(-Expo(1)/ln(1-p))</code> (Devroye 1986, p. 500)[^19] (ceil replaced with floor because this page defines geometric distribution differently).</li>
<li><strong>Gumbel distribution</strong>: See generalized extreme value distribution.</li>
<li><strong>Inverse gamma distribution</strong>: <code>b / GammaDist(a)</code>, where <code>a</code> and <code>b</code> have the
same meaning as in the gamma distribution.  Alternatively, <code>1.0 / (pow(GammaDist(a), 1.0 / c) / b + d)</code>, where <code>c</code> and <code>d</code> are shape and location parameters, respectively.</li>
<li><strong>Laplace (double exponential) distribution</strong>&dagger;: <code>(Expo(1) - Expo(1))</code>.  Also, <code>Normal(0,1) * Normal(0, 1) - Normal(0, 1) * Normal(0, 1)</code> (Kotz et al. 2012)[^91].</li>
<li><strong>Logarithmic distribution</strong>&#x2b26;: <code>RNDRANGEMinMaxExc(0, 1) * RNDRANGEMinMaxExc(0, 1)</code> (Saucier 2000, p. 26).  In this distribution, lower numbers are exponentially more likely than higher numbers.</li>
<li><strong>Logarithmic normal distribution</strong>: <code>exp(Normal(mu, sigma))</code>, where <code>mu</code> and <code>sigma</code> are the underlying normal distribution&#39;s parameters.</li>
<li><strong>Multinormal distribution</strong>: See multivariate normal distribution.</li>
<li><strong>Multivariate normal distribution</strong>: See <a href="https://peteroupc.github.io/randomnotes.html#Multivariate_Normal_Multinormal_Distribution"><strong>Multivariate Normal (Multinormal) Distribution</strong></a>.</li>
<li><strong>Normal distribution</strong>: See <a href="https://peteroupc.github.io/randomnotes.html#Normal_Gaussian_Distribution"><strong>Normal (Gaussian) Distribution</strong></a>.</li>
<li><strong>Poisson distribution</strong>: See &quot;<a href="#Poisson_Distribution"><strong>Poisson Distribution</strong></a>&quot;. The following is &quot;exact&quot; assuming computers can operate &quot;exactly&quot; on real numbers (Devroye 1986, p. 504)[^19]: <code>c = 0; s = 0; while true; sum = sum + Expo(1); if sum&gt;=mean: return c; else: c = c + 1; end</code>; and in addition the following optimization from (Devroye 1991)[^92] can be used: <code>while mean &gt; 20; n=ceil(mean-pow(mean,0.7)); g=GammaDist(n); if g&gt;=mean: return c+(n-1-Binomial(n-1,(g-mean)/g)); mean = mean - g; c = c + n; end</code>.  For <code>mean</code> greater than 50, the following <em>approximation</em> was suggested in (Giammatteo and Di Mascio 2020)[^92]: <code>floor(1.0/3 + pow(max(0, Normal(0, 1)*pow(mean,1/6.0)*2/3 + pow(mean, 2.0/3)), 3.0/2))</code>.</li>
<li><strong>Pareto distribution</strong>: <code>pow(RNDRANGEMinMaxExc(0, 1), -1.0 / alpha) * minimum</code>, where <code>alpha</code>  is the shape and <code>minimum</code> is the minimum.</li>
<li><strong>Rayleigh distribution</strong>&dagger;: <code>sqrt(Expo(0.5))</code>.  If the scale parameter (<code>sigma</code>) follows a logarithmic normal distribution, the result is a <em>Suzuki distribution</em>.</li>
<li><strong>Standard normal distribution</strong>&dagger;: <code>Normal(0, 1)</code>.  See also <a href="https://peteroupc.github.io/randomnotes.html#Normal_Gaussian_Distribution"><strong>Normal (Gaussian) Distribution</strong></a>.</li>
<li><strong>Student&#39;s <em>t</em>-distribution</strong>: <code>Normal(cent, 1) / sqrt(GammaDist(df * 0.5)*2 / df)</code>, where <code>df</code> is the number of degrees of freedom, and <em>cent</em> is the mean of the normally-distributed random variate.  A <code>cent</code> other than 0 indicates a <em>noncentral</em> distribution.  Alternatively, <code>cos(RNDRANGEMinMaxExc(0, pi * 2)) * sqrt((pow(RNDRANGEMinMaxExc(0, 1),-2.0/df)-1) * df)</code> (Bailey 1994)[^93].</li>
<li><strong>Triangular distribution</strong>&dagger; (Stein and Keblis 2009)[^94]: <code>(1-alpha) * min(a, b) + alpha * max(a, b)</code>, where <code>alpha</code> is in [0, 1], <code>a = RNDRANGEMinMaxExc(0, 1)</code>, and <code>b = RNDRANGEMinMaxExc(0, 1)</code>.</li>
<li><strong>Weibull distribution</strong>: See generalized extreme value distribution.</li>
</ul>

<p></small></p>

<p>Miscellaneous:</p>

<p><small></p>

<ul>
<li><strong>Archimedean copulas</strong>: See <a href="https://peteroupc.github.io/randomnotes.html#Gaussian_and_Other_Copulas"><strong>Gaussian and Other Copulas</strong></a>.</li>
<li><strong>Arcsine distribution</strong>&#x2b26;: <code>BetaDist(0.5, 0.5)</code> (Saucier 2000, p. 14).</li>
<li><strong>Bates distribution</strong>: See <a href="https://peteroupc.github.io/randomnotes.html#Transformations_of_Random_Numbers_Additional_Examples"><strong>Transformations of Random Variates: Additional Examples</strong></a>.</li>
<li><strong>Beckmann distribution</strong>: See <a href="https://peteroupc.github.io/randomnotes.html#Multivariate_Normal_Multinormal_Distribution"><strong>Multivariate Normal (Multinormal) Distribution</strong></a>.</li>
<li><strong>Beta binomial distribution</strong>: <code>Binomial(trials, BetaDist(a, b))</code>, where <code>a</code> and <code>b</code> are
the two parameters of the beta distribution, and <code>trials</code> is a parameter of the binomial distribution.</li>
<li><strong>Beta negative binomial distribution</strong>: <code>NegativeBinomial(successes, BetaDist(a, b))</code>, where <code>a</code> and <code>b</code> are the two parameters of the beta distribution, and <code>successes</code> is a parameter of the negative binomial distribution. If <em>successes</em> is 1, the result is a <em>Waring&ndash;Yule distribution</em>. A <em>Yule&ndash;Simon distribution</em> results if <em>successes</em> and <em>b</em> are both 1 (for example, in <em>Mathematica</em>) or if <em>successes</em> and <em>a</em> are both 1 (in other works).</li>
<li><strong>Beta-PERT distribution</strong>: <code>startpt + size * BetaDist(1.0 + (midpt - startpt) * shape / size, 1.0 + (endpt - midpt) * shape / size)</code>. The distribution starts  at <code>startpt</code>, peaks at <code>midpt</code>, and ends at <code>endpt</code>, <code>size</code> is <code>endpt - startpt</code>, and <code>shape</code> is a shape parameter that&#39;s 0 or greater, but usually 4.  If the mean (<code>mean</code>) is known rather than the peak, <code>midpt = 3 * mean / 2 - (startpt + endpt) / 4</code>.</li>
<li><strong>Beta prime distribution</strong>&dagger;: <code>pow(GammaDist(a), 1.0 / alpha) / pow(GammaDist(b), 1.0 / alpha)</code>, where <code>a</code>, <code>b</code>, and <code>alpha</code> are shape parameters. If <em>a</em> is 1, the result is a <em>Singh&ndash;Maddala distribution</em>; if <em>b</em> is 1, a <em>Dagum distribution</em>; if <em>a</em> and <em>b</em> are both 1, a <em>logarithmic logistic distribution</em>.</li>
<li><strong>Birnbaum&ndash;Saunders distribution</strong>: <code>pow(sqrt(4+x*x)+x,2)/(4.0*lamda)</code>, where <code>x = Normal(0,gamma)</code>, <code>gamma</code> is a shape parameter, and <code>lamda</code> is a scale parameter.</li>
<li><strong>Borel distribution</strong> (Borel 1942)[^108]: <code>r=0; q=1; while q&gt;=1; q+=Poisson(la); q-=1; r+=1; end; return r</code>.  <code>la</code>, the mean number of arrivals, should be in the interval (0, 1).</li>
<li><strong>Chi distribution</strong>: Square root of a chi-squared random variate.  See chi-squared distribution.</li>
<li><strong>Compound Poisson distribution</strong>: See <a href="#Transformations_of_Random_Numbers_Additional_Examples"><strong>Transformations of Random Variates: Additional Examples</strong></a>.</li>
<li><strong>Cosine distribution</strong>&#x2b26;: <code>atan2(x, sqrt(1 - x * x)) / pi</code>, where <code>x = (RNDINT(1) * 2 - 1) * RNDRANGEMinMaxExc(0, 1)</code> (Saucier 2000, p. 17; inverse sine replaced with <code>atan2</code> equivalent).</li>
<li><strong>CUB distribution</strong> (Piccolo 2003)[^107]: <code>if ZeroOrOne(px,py)==1: return 1+BinomialInt(m-1, zy-zx, zy); else: return RNDINTRANGE(1, m)</code>, where <code>m&gt;3</code>, <code>px/py</code> is in [0, 1], and <code>zx/zy</code> is in [0, 1].</li>
<li><strong>Dagum distribution</strong>: See beta prime distribution.</li>
<li><strong>Dirichlet distribution</strong>: Suppose we (1) generate <em>n</em>+1 random <a href="https://peteroupc.github.io/randomnotes.md#Gamma_Distribution"><strong>gamma-distributed</strong></a> variates, each with separate parameters; (2) take their sum; (3) divide each of them by that sum; then (4) multiply each of them by a real number <code>x</code> greater than 0.  Then:

<ul>
<li>After step (4), if <code>x</code> was 1, the <a href="https://en.wikipedia.org/wiki/Dirichlet_distribution"><strong>Dirichlet distribution</strong></a> (for example, (Devroye 1986)[^23], p. 593-594) models the first <em>n</em> of those numbers.</li>
<li>If the numbers at step (1) were each generated as <code>Expo(1)</code> (a special case of the gamma distribution), the result after step (4) is a uniformly distributed sum of <em>n</em>+1 numbers that sum to <code>x</code> (see also linked article above).</li>
</ul></li>
<li><strong>Double logarithmic distribution</strong>&#x2b26;: <code>(0.5 + (RNDINT(1) * 2 - 1) * RNDRANGEMinMaxExc(0, 0.5) * RNDRANGEMinMaxExc(0, 1))</code> (see also Saucier 2000, p. 15, which shows the wrong X axes).</li>
<li><strong>Erlang distribution</strong>: <code>GammaDist(n)/lamda</code>, where <code>n</code> is an integer greater than 0.  Returns a number that simulates a sum of <code>n</code> exponential random variates with the given <code>lamda</code> parameter.</li>
<li><strong>Estoup distribution</strong>: See zeta distribution.</li>
<li><strong>Exponential power distribution</strong> (generalized normal distribution version 1): <code>(RNDINT(1) * 2 - 1) * pow(GammaDist(1.0/a), a)</code>, where <code>a</code> is a shape parameter.</li>
<li><strong>Fr&eacute;chet distribution</strong>: See generalized extreme value distribution.</li>
<li><strong>Fr&eacute;chet&ndash;Hoeffding lower bound copula</strong>: See <a href="#Gaussian_and_Other_Copulas"><strong>Gaussian and Other Copulas</strong></a>.</li>
<li><strong>Fr&eacute;chet&ndash;Hoeffding upper bound copula</strong>: See <a href="#Gaussian_and_Other_Copulas"><strong>Gaussian and Other Copulas</strong></a>.</li>
<li><strong>Gaussian copula</strong>: See <a href="#Gaussian_and_Other_Copulas"><strong>Gaussian and Other Copulas</strong></a>.</li>
<li><strong>Generalized extreme value (Fisher&ndash;Tippett or generalized maximum value) distribution (<code>GEV(c)</code>)</strong>&dagger;: <code>(pow(Expo(1), -c) - 1) / c</code> if <code>c != 0</code>, or <code>-ln(Expo(1))</code> otherwise, where <code>c</code> is a shape parameter. Special cases:

<ul>
<li>The negative of the result expresses a generalized minimum value.  In this case, a parameter of <code>c = 0</code> results in a <em>Gumbel distribution</em>.</li>
<li>A parameter of <code>c = 0</code> results in an <em>extreme value distribution</em>.</li>
<li><strong>Weibull distribution</strong>: <code>1 - 1.0/a * GEV(-1.0/a)</code> (or <code>pow(Expo(1), 1.0/a)</code>), where <code>a</code> is a shape parameter.</li>
<li><strong>Fr&eacute;chet distribution</strong>: <code>1 + 1.0/a * GEV(1.0/a)</code> (or <code>pow(Expo(1), -1.0/a)</code>), where <code>a</code> is a shape parameter.</li>
</ul></li>
<li><strong>Generalized Tukey lambda distribution</strong>: <code>(s1 * (pow(x, lamda1)-1.0)/lamda1 - s2 * (pow(1.0-x, lamda2)-1.0)/lamda2) + loc</code>, where <code>x</code> is <code>RNDRANGEMinMaxExc(0, 1)</code>, <code>lamda1</code> and <code>lamda2</code> are shape parameters, <code>s1</code> and <code>s2</code> are scale parameters, and <code>loc</code> is a location parameter.</li>
<li><strong>Half-normal distribution</strong>. Parameterizations include:

<ul>
<li><em>Mathematica</em>: <code>abs(Normal(0, sqrt(pi * 0.5) / invscale)))</code>, where <code>invscale</code> is a parameter of the half-normal distribution.</li>
<li>MATLAB: <code>abs(Normal(mu, sigma)))</code>, where <code>mu</code> and <code>sigma</code> are the underlying normal distribution&#39;s parameters.</li>
</ul></li>
<li><strong>Hyperexponential distribution</strong>: See <a href="#Mixtures_of_Distributions"><strong>Mixtures of Distributions</strong></a>.</li>
<li><strong>Hypergeometric distribution</strong>: See <a href="#Polya_ndash_Eggenberger_Distribution"><strong>Polya&ndash;Eggenberger Distribution</strong></a>.</li>
<li><strong>Hypoexponential distribution</strong>: See <a href="#Transformations_of_Random_Numbers"><strong>Transformations of Random Variates</strong></a>.</li>
<li><strong>Inverse chi-squared distribution</strong>&dagger;: <code>df / (GammaDist(df * 0.5)*2)</code>, where <code>df</code> is the number of degrees of freedom.  The scale parameter (<code>sigma</code>) is usually <code>1.0 / df</code>.</li>
<li><strong>Inverse Gaussian distribution (Wald distribution)</strong>: Generate <code>n = mu + (mu*mu*y/(2*lamda)) - mu * sqrt(4 * mu * lamda * y + mu * mu * y * y) / (2 * lamda)</code>, where <code>y = pow(Normal(0, 1), 2)</code>, then return <code>n</code> with probability <code>mu / (mu + n)</code> (for example, if <code>RNDRANGEMinMaxExc(0, 1) &lt;= mu / (mu + n)</code>), or <code>mu * mu / n</code> otherwise. <code>mu</code> is the mean and <code>lamda</code> is the scale; both parameters are greater than 0. Based on method published in (Devroye 1986)[^19].</li>
<li><strong><code>k</code>th-order statistic</strong>: <code>BetaDist(k, n+1-k)</code>. Returns the <code>k</code>th smallest out of <code>n</code> uniform random variates in [**0, 1). See also (Devroye 1986, p. 210)[^19].</li>
<li><strong>Kumaraswamy distribution</strong>&#x2b26;: <code>pow(BetaDist(1, b), 1.0 / a)</code>, where <code>a</code> and <code>b</code> are shape parameters.</li>
<li><strong>Landau distribution</strong>: See stable distribution.</li>
<li><strong>L&eacute;vy distribution</strong>&dagger;: <code>0.5 / GammaDist(0.5)</code>.  The scale parameter (<code>sigma</code>) is also called dispersion.</li>
<li><strong>Logarithmic logistic distribution</strong>: See beta prime distribution.</li>
<li><strong>Logarithmic series distribution</strong>: Generate <code>n = NegativeBinomialInt(1, py - px, py)+1</code> (where <code>px</code>/<code>py</code> is a parameter in (0,1)), then return <code>n</code> if <code>ZeroOrOne(1, n) == 1</code>, or repeat this process otherwise (Flajolet et al., 2010)[^95].  The following is &quot;exact&quot; assuming computers can operate &quot;exactly&quot; on real numbers: <code>floor(1.0 - Expo(log1p(-pow(1.0 - p, RNDRANGEMinMaxExc(0, 1)))))</code>, where <code>p</code> is the parameter in (0, 1); see (Devroye 1986)[^19].</li>
<li><strong>Logistic distribution</strong>&dagger;: <code>(ln(x)-log1p(-x))</code> (<a href="http://timvieira.github.io/blog/post/2016/07/04/fast-sigmoid-sampling/"><strong><em>logit function</em></strong></a>), where <code>x</code> is <code>RNDRANGEMinMaxExc(0, 1)</code>.</li>
<li><strong>Log-multinormal distribution</strong>: See <a href="#Multivariate_Normal_Multinormal_Distribution"><strong>Multivariate Normal (Multinormal) Distribution</strong></a>.</li>
<li><strong>Max-of-uniform distribution</strong>: <code>BetaDist(n, 1)</code>.  Returns a number that simulates the largest out of <code>n</code> uniform random variates in [**0, 1).  See also (Devroye 1986, p. 675)[^19].</li>
<li><strong>Maxwell distribution</strong>&dagger;: <code>sqrt(GammaDist(1.5)*2)</code>.</li>
<li><strong>Min-of-uniform distribution</strong>: <code>BetaDist(1, n)</code>.  Returns a number that simulates the smallest out of <code>n</code> uniform random variates in [**0, 1).  See also (Devroye 1986, p. 210)[^19].</li>
<li><strong>Moyal distribution</strong>: See the <a href="https://peteroupc.github.io/randomgen.zip"><strong>Python sample code</strong></a>.</li>
<li><strong>Multinomial distribution</strong>: See <a href="#Multinomial_Distribution"><strong>Multinomial Distribution</strong></a>.</li>
<li><strong>Multivariate Poisson distribution</strong>: See the <a href="https://peteroupc.github.io/randomgen.zip"><strong>Python sample code</strong></a>.</li>
<li><strong>Multivariate <em>t</em>-copula</strong>: See the <a href="https://peteroupc.github.io/randomgen.zip"><strong>Python sample code</strong></a>.</li>
<li><strong>Multivariate <em>t</em>-distribution</strong>: See the <a href="https://peteroupc.github.io/randomgen.zip"><strong>Python sample code</strong></a>.</li>
<li><strong>Negative binomial distribution</strong> (<code>NegativeBinomial(successes, p)</code>): See <a href="#Negative_Binomial_Distribution"><strong>Negative Binomial Distribution</strong></a>.  The following is &quot;exact&quot; assuming computers can operate &quot;exactly&quot; on real numbers: <code>Poisson(GammaDist(successes)*(1 - p) / p)</code> (works even if <code>successes</code> is not an integer).</li>
<li><strong>Negative multinomial distribution</strong>: See the <a href="https://peteroupc.github.io/randomgen.zip"><strong>Python sample code</strong></a>.</li>
<li><strong>Noncentral beta distribution</strong>&#x2b26;: <code>BetaDist(a + Poisson(nc), b)</code>, where <code>nc</code> (a noncentrality), <code>a</code>, and <code>b</code> are greater than 0.</li>
<li><strong>Parabolic distribution</strong>&#x2b26;: <code>BetaDist(2, 2)</code> (Saucier 2000, p. 30).</li>
<li><strong>Pascal distribution</strong>: <code>NegativeBinomial(successes, p) + successes</code>, where <code>successes</code> and <code>p</code> have the same meaning as in the negative binomial distribution, except <code>successes</code> is always an integer.</li>
<li><strong>Pearson VI distribution</strong>: <code>GammaDist(v) / GammaDist(w)</code>, where <code>v</code> and <code>w</code> are shape parameters greater than 0 (Saucier 2000, p. 33; there, an additional <code>b</code> parameter is defined, but that parameter is canceled out in the source code).</li>
<li><strong>Piecewise constant distribution</strong>: See <a href="#Weighted_Choice_With_Replacement"><strong>Weighted Choice With Replacement</strong></a>.</li>
<li><strong>Piecewise linear distribution</strong>: See <a href="#Piecewise_Linear_Distribution"><strong>Piecewise Linear Distribution</strong></a>.</li>
<li><strong>P&oacute;lya&ndash;Aeppli distribution</strong>: See <a href="#Transformations_of_Random_Numbers_Additional_Examples"><strong>Transformations of Random Variates: Additional Examples</strong></a>.</li>
<li><strong>Power distribution</strong>: <code>BetaDist(alpha, 1) / b</code>, where <code>alpha</code>  is the shape and <code>b</code> is the domain.  Nominally in the interval (0, 1).</li>
<li><strong>Power law distribution</strong>: <code>pow(RNDRANGEMinMaxExc(pow(mn,n+1),pow(mx,n+1)), 1.0 / (n+1))</code>, where <code>n</code>  is the exponent, <code>mn</code> is the minimum, and <code>mx</code> is the maximum.  <a href="http://mathworld.wolfram.com/RandomNumber.html"><strong>Reference</strong></a>.</li>
<li><strong>Power lognormal distribution</strong>: See the <a href="https://peteroupc.github.io/randomgen.zip"><strong>Python sample code</strong></a>.</li>
<li><strong>Power normal distribution</strong>: See the <a href="https://peteroupc.github.io/randomgen.zip"><strong>Python sample code</strong></a>.</li>
<li><strong>Product copula</strong>: See <a href="https://peteroupc.github.io/randomnotes.html#Gaussian_and_Other_Copulas"><strong>Gaussian and Other Copulas</strong></a>.</li>
<li><strong>Rice distribution</strong>: See <a href="https://peteroupc.github.io/randomnotes.html#Multivariate_Normal_Multinormal_Distribution"><strong>Multivariate Normal (Multinormal) Distribution</strong></a>.</li>
<li><strong>Rice&ndash;Norton distribution</strong>: See <a href="https://peteroupc.github.io/randomnotes.html#Multivariate_Normal_Multinormal_Distribution"><strong>Multivariate Normal (Multinormal) Distribution</strong></a>.</li>
<li><strong>Singh&ndash;Maddala distribution</strong>: See beta prime distribution.</li>
<li><strong>sin^k distribution</strong>: Generate <code>x = BetaDist(k+1, k+1) * pi</code>, then return <code>x</code> if <code>0-Expo(k) &lt;= ln(pi*pi*sin(x) / ((4*x*(pi - x)))</code>, or repeat this process otherwise (Makalic and Schmidt 2018)[^96].</li>
<li><strong>Skellam distribution</strong>: <code>Poisson(mean1) - Poisson(mean2)</code>, where <code>mean1</code> and <code>mean2</code> are the means used in the <code>Poisson</code> method.</li>
<li><strong>Skew normal distribution</strong>&dagger; (Ghorbanzadeh et al. 2014)[^97]: Generate <code>c*max(a, b) + (1-c)*min(a, b)</code>, where a = <code>Normal(0, 1)</code> and independently, <code>b = Normal(0, 1)</code>, and <code>c = (1+th)/sqrt(2.0*(1+th))</code>, and <code>th</code> is a real number in [0, 1].  Special cases: If <code>th=0</code>, generate <code>Normal(0, 1)</code>; if <code>th=1</code>, generate <code>max(a, b)</code>; if <code>th=1</code>, generate <code>min(a, b)</code>.</li>
<li><strong>Snedecor&#39;s (Fisher&#39;s) <em>F</em>-distribution</strong>: <code>GammaDist(m * 0.5)*n / (GammaDist(n * 0.5 + Poisson(sms * 0.5)) * m)</code>, where <code>m</code> and <code>n</code> are the numbers of degrees of freedom of two random variates with a chi-squared distribution, and if <code>sms</code> is other than 0, one of those distributions is <em>noncentral</em> with sum of mean squares equal to <code>sms</code>.</li>
<li><strong>Stable distribution</strong>: See <a href="https://peteroupc.github.io/randomnotes.html#Stable_Distribution"><strong>Stable Distribution</strong></a>. <em>Four-parameter stable distribution</em>: <code>Stable(alpha, beta) * sigma + mu</code>, where <code>mu</code> is the mean and <code>sigma</code> is the scale; if <code>alpha</code> and <code>beta</code> are 1, the result is a <em>Landau distribution</em>.  <em>&quot;Type 0&quot; stable distribution</em>: <code>Stable(alpha, beta) * sigma + (mu - sigma * beta * x)</code>, where <code>x</code> is <code>ln(sigma)*2.0/pi</code> if <code>alpha</code> is 1, and <code>tan(pi*0.5*alpha)</code> otherwise.</li>
<li><strong>Standard complex normal distribution</strong>: See <a href="https://peteroupc.github.io/randomnotes.html#Multivariate_Normal_Multinormal_Distribution"><strong>Multivariate Normal (Multinormal) Distribution</strong></a>.</li>
<li><strong>Suzuki distribution</strong>: See Rayleigh distribution.</li>
<li><strong>Tukey lambda distribution</strong>: <code>(pow(x, lamda)-pow(1.0-x,lamda))/lamda</code>, where <code>x</code> is <code>RNDRANGEMinMaxExc(0, 1)</code> and <code>lamda</code> is a shape parameter.</li>
<li><strong>Twin-<em>t</em> distribution</strong> (Baker and Jackson 2018)[^98]: Generate <code>x</code>, a random Student&#39;s <em>t</em>-distributed number (not a noncentral one).  Accept <code>x</code> with probability <code>z = pow((1 + y) / ((1 + y * y) + y), (df + 1) * 0.5)</code> (for example, if <code>RNDRANGEMinMaxExc(0, 1) &lt; z</code>), where <code>y = x * x / df</code> and <code>df</code> is the degrees of freedom used to generate the number; repeat this process otherwise.</li>
<li><strong>von Mises distribution</strong>: See <a href="https://peteroupc.github.io/randomnotes.html#von_Mises_Distribution"><strong>von Mises Distribution</strong></a>.</li>
<li><strong>Waring&ndash;Yule distribution</strong>: See beta negative binomial distribution.</li>
<li><strong>Wigner (semicircle) distribution</strong>&dagger;: <code>(BetaDist(1.5, 1.5)*2-1)</code>.  The scale parameter (<code>sigma</code>) is the semicircular radius.</li>
<li><strong>Yule&ndash;Simon distribution</strong>: See beta negative binomial distribution.</li>
<li><strong>Zeta distribution</strong>: Generate <code>n = floor(pow(RNDRANGEMinMaxExc(0, 1), -1.0 / r))</code>, and if <code>d / pow(2, r) &lt; RNDRANGEMinMaxExc((d - 1) * n / (pow(2, r) - 1.0))</code>, where <code>d = pow((1.0 / n) + 1, r)</code>, repeat this process. The parameter <code>r</code> is greater than 0. Based on method described in (Devroye 1986)[^19]. A zeta distribution <a href="#Rejection_Sampling"><strong>truncated</strong></a> by rejecting random values greater than some integer greater than 0 is called a <em>Zipf distribution</em> or <em>Estoup distribution</em>. (Devroye uses &quot;Zipf distribution&quot; to refer to the untruncated zeta distribution.)</li>
<li><strong>Zipf distribution</strong>: See zeta distribution.</li>
</ul>

<p></small></p>

<p><a id=Geometric_Sampling></a></p>

<h3>Geometric Sampling</h3>

<p><strong>Requires random real numbers.</strong></p>

<p>This section contains ways to choose independent uniform random points in or on geometric shapes.</p>

<p><a id=Random_Points_Inside_a_Simplex></a></p>

<h4>Random Points Inside a Simplex</h4>

<p>The following pseudocode generates a random point inside an <em>n</em>-dimensional simplex (simplest convex figure, such as a line segment, triangle, or tetrahedron).  It takes one parameter, <em>points</em>, a list consisting of the <em>n</em> plus one vertices of the simplex, all of a single dimension <em>n</em> or greater. The special case of 3 points came from Osada et al. (2002)[^99].</p>

<pre>METHOD VecAddProd(a, b, c)
  for j in 0...size(a): a[j]=a[j]+b[j]*c
END METHOD

METHOD RandomPointInSimplex(points):
   ret=NewList()
   if size(points) &gt; size(points[0])+1: return error
   if size(points)==1 // Return a copy of the point
     for i in 0...size(points[0]): AddItem(ret,points[0][i])
     return ret
   end
   if size(points)==3
      // Equivalent to sqrt(RNDRANGEMinMaxExc(0, 1))
     rs=max(RNDRANGEMinMaxExc(0, 1), RNDRANGEMinMaxExc(0, 1))
     r2=RNDRANGEMinMaxExc(0, 1)
     ret=[0,0,0]
     VecAddProd(ret,points[0],1.0-rs)
     VecAddProd(ret,points[1],(1.0-r2)*rs)
     VecAddProd(ret,points[2],r2*rs)
     return ret
   end
   gammas=NewList()
   // Sample from the simplex
   for i in 0...size(points): AddItem(gammas, Expo(1))
   tsum=0 // Will store sum of all gammas
   for i in 0...size(gammas): tsum=tsum+gammas[i]
   for i in 0...size(gammas): gammas[i] = gammas[i] / tsum
   gammas[size(gammas)-1]=0 // To omit last gamma in sum
   tot = 1.0 // Will store 1 minus the sum of all gammas
   for i in 0...size(gammas): tot=tot - gammas[i]
   // Build the final point
   for i in 0...size(points[0]): AddItem(ret, points[0][i]*tot)
   for i in 1...size(points): VecAddProd(
      ret, points[i], gammas[i-1])
   return ret
END METHOD
</pre>

<p><a id=Random_Points_on_the_Surface_of_a_Hypersphere></a></p>

<h4>Random Points on the Surface of a Hypersphere</h4>

<p>The following pseudocode shows how to generate a random N-dimensional point on the surface of an N-dimensional hypersphere, centered at the origin, of radius <code>radius</code> (if <code>radius</code> is 1, the result can also serve as a unit vector in N-dimensional space).  Here, <code>Norm</code> is given in the appendix.  See also (Weisstein)[^100].</p>

<pre>METHOD RandomPointInHypersphere(dims, radius)
  x=0
  while x==0
    ret=[]
    for i in 0...dims: AddItem(ret, Normal(0, 1))
    x=Norm(ret)
  end
  invnorm=radius/x
  for i in 0...dims: ret[i]=ret[i]*invnorm
  return ret
END METHOD
</pre>

<blockquote>
<p><strong>Note:</strong> The <a href="https://peteroupc.github.io/randomgen.zip"><strong>Python sample code</strong></a> contains an optimized method for points on the edge of a circle.</p>

<p><strong>Example:</strong> To generate a random point on the surface of a cylinder running along the Z axis, generate random X and Y coordinates on the edge of a circle (2-dimensional hypersphere) and generate a random Z coordinate by <code>RNDRANGEMinMaxExc(mn, mx)</code>, where <code>mn</code> and <code>mx</code> are the highest and lowest Z coordinates possible.</p>
</blockquote>

<p><a id=Random_Points_Inside_a_Box_Ball_Shell_or_Cone></a></p>

<h4>Random Points Inside a Box, Ball, Shell, or Cone</h4>

<p>To generate a random point on or inside&mdash;</p>

<ul>
<li>an <strong>N-dimensional box</strong>, generate <code>RNDRANGEMinMaxExc(mn, mx)</code> for each coordinate, where <code>mn</code> and <code>mx</code> are the lower and upper bounds for that coordinate.  For example&mdash;

<ul>
<li>to generate a random point inside a rectangle bounded in [0, 2) along the X axis and [3, 6) along the Y axis, generate <code>[RNDRANGEMinMaxExc(0,2), RNDRANGEMinMaxExc(3,6)]</code>, and</li>
<li>to generate a <em>complex number</em> with real and imaginary parts bounded in [0, 1], generate <code>[RNDRANGEMinMaxExc(0, 1), RNDRANGEMinMaxExc(0, 1)]</code>.</li>
</ul></li>
<li>an <strong>N-dimensional ball</strong>, centered at the origin, of radius R, either&mdash;

<ul>
<li>generate a random (N+2)-dimensional point on the surface of an (N+2)-dimensional hypersphere with that radius (for example, using <code>RandomPointInHypersphere</code>), then discard the last two coordinates (Voelker et al., 2017)[^101], or</li>
<li>follow the pseudocode in <code>RandomPointInHypersphere</code>, except replace <code>Norm(ret)</code> with <code>sqrt(S + Expo(1))</code>, where <code>S</code> is the sum of squares of the numbers in <code>ret</code>.</li>
</ul></li>
<li>an <strong>N-dimensional spherical shell</strong> (a hollow ball), centered at the origin, with inner radius A and outer radius B (where A is less than B), generate a random point on the surface of an N-dimensional hypersphere with radius equal to <code>pow(RNDRANGEMinMaxExc(pow(A, N), pow(B, N)), 1.0 / N)</code>[^102].</li>
<li>a <strong>cone</strong> with height <code>H</code> and radius <code>R</code> at its base, running along the Z axis, generate a random Z coordinate by <code>Z = max(max(RNDRANGEMinMaxExc(0, H), RNDRANGEMinMaxExc(0, H)), RNDRANGEMinMaxExc(0, H))</code>, then generate random X and Y coordinates inside a disc (2-dimensional ball) with radius equal to <code>max(RNDRANGEMinMaxExc(0,Z*(R/H)), RNDRANGEMinMaxExc(0,Z*(R/H)))</code>[^103].</li>
</ul>

<blockquote>
<p><strong>Example:</strong> To generate a random point inside a cylinder running along the Z axis, generate random X and Y coordinates inside a disc (2-dimensional ball) and generate a random Z coordinate by <code>RNDRANGEMinMaxExc(mn, mx)</code>, where <code>mn</code> and <code>mx</code> are the highest and lowest Z coordinates possible.</p>

<p><strong>Notes:</strong></p>

<ol>
<li>The <a href="https://peteroupc.github.io/randomgen.zip"><strong>Python sample code</strong></a> contains a method for generating a random point on the surface of an ellipsoid modeling the Earth.</li>
<li>Sampling a half-ball, half-shell, or half-hypersphere can be done by sampling a full ball, shell, or hypersphere and replacing one of the dimensions of the result with its absolute value.</li>
</ol>
</blockquote>

<p><a id=Random_Latitude_and_Longitude></a></p>

<h4>Random Latitude and Longitude</h4>

<p>To generate a random point on the surface of a sphere in the form of a latitude and longitude (in radians with west and south coordinates negative)[^104]&mdash;</p>

<ul>
<li>generate the longitude <code>RNDRANGEMinMaxExc(-pi, pi)</code>, where the longitude is in the interval [-&pi;, &pi;), and</li>
<li>generate the latitude <code>atan2(sqrt(1 - x * x), x) - pi / 2</code>, where <code>x = RNDRANGEMinMaxExc(-1, 1)</code> and the latitude is in the interval [-&pi;/2, &pi;/2] (the interval excludes the poles, which have many equivalent forms; if poles are not desired, generate <code>x</code> until neither -1 nor 1 is generated this way).</li>
</ul>

<p><a id=Acknowledgments></a></p>

<h2>Acknowledgments</h2>

<p>I acknowledge the commenters to the CodeProject version of this page, including George Swan, who referred me to the reservoir sampling method.</p>

<p>I also acknowledge Christoph Conrads, who gave suggestions in parts of this article.</p>

<p><a id=Other_Documents></a></p>

<h2>Other Documents</h2>

<p>The following are some additional articles I have written on the topic of randomization and pseudorandom variate generation.  All of them are open-source.</p>

<ul>
<li><a href="https://peteroupc.github.io/random.html"><strong>Random Number Generator Recommendations for Applications</strong></a></li>
<li><a href="https://peteroupc.github.io/randomnotes.html"><strong>More Random Sampling Methods</strong></a></li>
<li><a href="https://peteroupc.github.io/autodist.html"><strong>Code Generator for Discrete Distributions</strong></a></li>
<li><a href="https://peteroupc.github.io/randomcommon.html"><strong>The Most Common Topics Involving Randomization</strong></a></li>
<li><a href="https://peteroupc.github.io/exporand.html"><strong>Partially-Sampled Random Numbers for Accurate Sampling of Continuous Distributions</strong></a></li>
<li><a href="https://peteroupc.github.io/bernoulli.html"><strong>Bernoulli Factory Algorithms</strong></a></li>
<li><a href="https://peteroupc.github.io/randomtest.html"><strong>Testing PRNGs for High-Quality Randomness</strong></a></li>
<li><a href="https://peteroupc.github.io/hqprng.html"><strong>Examples of High-Quality PRNGs</strong></a></li>
</ul>

<p><a id=Notes></a></p>

<h2>Notes</h2>

<p>[^1]: Pedersen, K., &quot;<a href="https://arxiv.org/abs/1704.07949"><strong>Reconditioning your quantile function</strong></a>&quot;, arXiv:1704.07949v3 [stat.CO], 2018.</p>

<p>[^2]: For an exercise solved by part of the <code>RNDINT</code> pseudocode, see A. Koenig and B. E. Moo, <em>Accelerated C++</em>, 2000; see also a <a href="http://mathalope.co.uk/2014/10/26/accelerated-c-solution-to-exercise-7-9/"><strong>blog post by Johnny Chan</strong></a>.</p>

<p>[^3]: An example of such a source is a Gaussian noise generator.  This kind of source is often called an <em>entropy source</em>.</p>

<p>[^4]: D. Lemire, &quot;A fast alternative to the modulo reduction&quot;, Daniel Lemire&#39;s blog, 2016.</p>

<p>[^5]: Lemire, D., &quot;<a href="https://arxiv.org/abs/1805.10941v4"><strong>Fast Random Integer Generation in an Interval</strong></a>&quot;, arXiv:1805.10941v4  [cs.DS], 2018.</p>

<p>[^6]: Lumbroso, J., &quot;<a href="https://arxiv.org/abs/1304.1916"><strong>Optimal Discrete Uniform Generation from Coin Flips, and Applications</strong></a>&quot;, arXiv:1304.1916 [cs.DS]</p>

<p>[^7]: &quot;<a href="http://mathforum.org/library/drmath/view/65653.html"><strong>Probability and Random Numbers</strong></a>&quot;, Feb. 29, 2004.</p>

<p>[^8]: Mennucci, A.C.G., &quot;<a href="https://arxiv.org/abs/1012.4290"><strong>Bit Recycling for Scaling Random Number Generators</strong></a>&quot;, arXiv:1012.4290 [cs.IT], 2018.</p>

<p>[^9]: Knuth, Donald E. and Andrew Chi-Chih Yao. &quot;The complexity of nonuniform random number generation&quot;, in <em>Algorithms and Complexity: New Directions and Recent Results</em>, 1976.</p>

<p>[^10]: This is because the <em>binary entropy</em> of <code>p = 1/n</code> is <code>p * log2(1/p) = log2(n) / n</code>, and the sum of <code>n</code> binary entropies (for <code>n</code> outcomes with probability <code>1/n</code> each) is <code>log2(n) = ln(n)/ln(2)</code>.</p>

<p>[^11]: Devroye, L., Gravel, C., &quot;<a href="https://arxiv.org/abs/1502.02539v6"><strong>Random variate generation using only finitely many unbiased, independently and identically distributed random bits</strong></a>&quot;, arXiv:1502.02539v6  [cs.IT], 2020.</p>

<p>[^12]: A na&iuml;ve <code>RNDINTEXC</code> implementation often seen in certain languages like JavaScript is the idiom <code>floor(Math.random() * maxExclusive)</code>, where <code>Math.random()</code> is any method that outputs a floating-point number that behaves like an independent uniform random variate in the interval [0, 1).  However, no implementation of <code>Math.random()</code> can choose from all real numbers in [0, 1), so this idiom can bias some results over others depending on the value of <code>maxExclusive</code>.  For example, if <code>Math.random()</code> is implemented as <code>RNDINT(X - 1)/X</code> and <code>X</code> is not divisible by <code>maxExclusive</code>, the result will be biased.  Also, an implementation might pre-round <code>Math.random() * maxExclusive</code> (before the <code>floor</code>) to the closest number it can represent; in rare cases, that might be <code>maxExclusive</code> for certain rounding modes. If an application is concerned about these issues, it should treat the <code>Math.random()</code> implementation as simulating the &quot;source of random numbers&quot; for <code>RNDINT</code> and implement <code>RNDINTEXC</code> through <code>RNDINT</code> instead.</p>

<p>[^13]: The user &quot;BVtp&quot; from the <em>Stack Overflow</em> community led me to this insight.</p>

<p>[^14]: Daniel Ting, &quot;<a href="https://arxiv.org/abs/2104.05091"><strong>Simple, Optimal Algorithms for Random Sampling Without Replacement</strong></a>&quot;, arXiv:2104.05091, 2021.</p>

<p>[^15]: Sanders, P., Lamm, S., et al., &quot;<a href="https://arxiv.org/abs/1610.0514v2"><strong>Efficient Parallel Random Sampling &ndash; Vectorized, Cache-Efficient, and Online</strong></a>&quot;, arXiv:1610.0514v2 [cs.DS], 2019.</p>

<p>[^16]: Jeff Atwood, &quot;<a href="https://blog.codinghorror.com/the-danger-of-naivete/"><strong>The danger of na&iuml;vet&eacute;</strong></a>&quot;, Dec. 7, 2007.</p>

<p>[^17]: Bacher, A., Bodini, O., et al., &quot;<a href="https://arxiv.org/abs/1508.03167"><strong>MergeShuffle: A Very Fast, Parallel Random Permutation Algorithm</strong></a>&quot;, arXiv:1508.03167 [cs.DS], 2015.</p>

<p>[^18]: Merlini, D., Sprugnoli, R., Verri, M.C., &quot;An Analysis of a Simple Algorithm for Random Derangements&quot;, 2007.</p>

<p>[^19]: Devroye, L., <a href="http://luc.devroye.org/rnbookindex.html"><strong><em>Non-Uniform Random Variate Generation</em></strong></a>, 1986.</p>

<p>[^20]: See also the <em>Stack Overflow</em> question &quot;Random index of a non zero value in a numpy array&quot;.</p>

<p>[^21]: S. Linderman, &quot;A Parallel Gamma Sampling Implementation&quot;, Laboratory for Independent Probabilistic Systems Blog, Feb. 21, 2013, illustrates one example, a GPU-implemented sampler of gamma-distributed random variates.</p>

<p>[^22]: De Bruyne, B., et al., &quot;Generating discrete-time constrained random walks and Lévy flights, arXiv:2104.06145 (2021).</p>

<p>[^23]: Brownlee, J. &quot;<a href="https://machinelearningmastery.com/a-gentle-introduction-to-the-bootstrap-method/"><strong>A Gentle Introduction to the Bootstrap Method</strong></a>&quot;, <em>Machine Learning Mastery</em>, May 25, 2018.</p>

<p>[^24]: Propp, J.G., Wilson, D.B., &quot;Exact sampling with coupled Markov chains and applications to statistical mechanics&quot;, 1996.</p>

<p>[^25]: Fill, J.A., &quot;<a href="https://projecteuclid.org/euclid.aoap/1027961037"><strong>An interruptible algorithm for perfect sampling via Markov chains</strong></a>&quot;, <em>Annals of Applied Probability</em> 8(1), 1998.</p>

<p>[^26]: E. N. Gilbert, &quot;Random Graphs&quot;, <em>Annals of Mathematical Statistics</em> 30(4), 1959.</p>

<p>[^27]: V. Batagelj and U. Brandes, &quot;Efficient generation of large random networks&quot;, Phys.Rev. E 71:036113, 2005.</p>

<p>[^28]: Costantini, Lucia. &quot;Algorithms for sampling spanning trees uniformly at random.&quot;
Master&#39;s thesis, Universitat Politècnica de Catalunya, 2020.
<a href="https://upcommons.upc.edu/bitstream/handle/2117/328169/memoria.pdf"><strong>https://upcommons.upc.edu/bitstream/handle/2117/328169/memoria.pdf</strong></a></p>

<p>[^29]: Penschuck, M., et al., &quot;<a href="https://arxiv.org/abs/2003.00736v1"><strong>Recent Advances in Scalable Network Generation</strong></a>&quot;, arXiv:2003.00736v1  [cs.DS], 2020.</p>

<p>[^30]: Jon Louis Bentley and James B. Saxe, &quot;Generating Sorted Lists of Random Numbers&quot;, <em>ACM Trans. Math. Softw.</em> 6 (1980), pp. 359-364, describes a way to generate certain kinds of random variates in sorted order, but it&#39;s not given here because it relies on generating real numbers in the interval [0, 1], which is inherently imperfect because computers can&#39;t choose among all real numbers between 0 and 1, and there are infinitely many of them.</p>

<p>[^31]: (2020a) Saad, F.A., Freer C.E., et al., &quot;<a href="https://arxiv.org/abs/2003.03830v2"><strong>The Fast Loaded Dice Roller: A Near-Optimal Exact Sampler for Discrete Probability Distributions</strong></a>&quot;, arXiv:2003.03830v2  [stat.CO], also in <em>AISTATS 2020: Proceedings of the 23rd International Conference on Artificial Intelligence and Statistics, Proceedings of Machine Learning Research</em> 108, Palermo, Sicily, Italy, 2020.</p>

<p>[^32]: Feras A. Saad, Cameron E. Freer, Martin C. Rinard, and Vikash K. Mansinghka, &quot;<a href="https://arxiv.org/abs/2001.04555v1"><strong>Optimal Approximate Sampling From Discrete Probability Distributions</strong></a>&quot;, arXiv:2001.04555v1 [cs.DS], also in Proc. ACM Program. Lang. 4, POPL, Article 36 (January 2020), 33 pages.</p>

<p>[^33]: Shaddin Dughmi, Jason D. Hartline, Robert Kleinberg, and Rad Niazadeh. 2017. Bernoulli Factories and Black-Box Reductions in Mechanism Design. In <em>Proceedings of 49th Annual ACM SIGACT Symposium on the Theory of Computing</em>, Montreal, Canada, June 2017 (STOC’17).</p>

<p>[^34]: K. Bringmann and K. Panagiotou, &quot;<a href="https://link.springer.com/article/10.1007/s00453-016-0205-0"><strong>Efficient Sampling Methods for Discrete Distributions</strong></a>.&quot; <em>Algorithmica</em> 79 (2007), also in Proc. 39th International Colloquium on Automata, Languages, and Programming (ICALP&#39;12), 2012.</p>

<p>[^35]: A.J. Walker, &quot;An efficient method for generating discrete random variables with general distributions&quot;, <em>ACM Transactions on Mathematical Software</em> 3, 1977.</p>

<p>[^36]: Vose, Michael D. &quot;A linear algorithm for generating random numbers with a given distribution.&quot; IEEE Transactions on software engineering 17, no. 9 (1991): 972-975.</p>

<p>[^37]: Klundert, B. van de, &quot;<a href="https://dspace.library.uu.nl/handle/1874/393383"><strong>Efficient Generation of Discrete Random Variates</strong></a>&quot;, Faculty of Science Theses, Universiteit Utrecht, 2019.</p>

<p>[^38]: K. Bringmann and K. G. Larsen, &quot;Succinct Sampling from Discrete Distributions&quot;, In: Proc. 45th Annual ACM Symposium on Theory of Computing (STOC&#39;13), 2013.</p>

<p>[^39]: L. Hübschle-Schneider and P. Sanders, &quot;<a href="https://arxiv.org/abs/1903.00227v2"><strong>Parallel Weighted Random Sampling</strong></a>&quot;, arXiv:1903.00227v2  [cs.DS], 2019.</p>

<p>[^40]: Y. Tang, &quot;An Empirical Study of Random Sampling Methods for Changing Discrete Distributions&quot;, Master&#39;s thesis, University of Alberta, 2019.</p>

<p>[^41]: T. S. Han and M. Hoshi, &quot;Interval algorithm for random number generation&quot;, <em>IEEE Transactions on Information Theory</em> 43(2), March 1997.</p>

<p>[^42]: Efraimidis, P. and Spirakis, P. &quot;<a href="http://utopia.duth.gr/%7Epefraimi/research/data/2007EncOfAlg.pdf"><strong>Weighted Random Sampling (2005; Efraimidis, Spirakis)</strong></a>&quot;, 2005.</p>

<p>[^43]: Efraimidis, P. &quot;<a href="https://arxiv.org/abs/1012.0256v2"><strong>Weighted Random Sampling over Data Streams</strong></a>&quot;, arXiv:1012.0256v2 [cs.DS], 2015.</p>

<p>[^44]: T. Vieira, &quot;<a href="http://timvieira.github.io/blog/post/2014/08/01/gumbel-max-trick-and-weighted-reservoir-sampling/"><strong>Gumbel-max trick and weighted reservoir sampling</strong></a>&quot;, 2014.</p>

<p>[^45]: T. Vieira, &quot;<a href="https://timvieira.github.io/blog/post/2019/06/11/faster-reservoir-sampling-by-waiting/"><strong>Faster reservoir sampling by waiting</strong></a>&quot;, 2019.</p>

<p>[^46]: von Neumann, J., &quot;Various techniques used in connection with random digits&quot;, 1951.</p>

<p>[^47]: Deville, J.-C. and Tillé, Y.  Unequal probability sampling without replacement through a splitting method. Biometrika 85 (1998).</p>

<p>[^48]: The <a href="https://peteroupc.github.io/randomgen.zip"><strong>Python sample code</strong></a> includes a <code>ConvexPolygonSampler</code> class that implements this kind of sampling for convex polygons; unlike other polygons, convex polygons are trivial to decompose into triangles.</p>

<p>[^49]: That article also mentions a critical-hit distribution, which is actually a <a href="#Mixtures_of_Distributions"><strong>mixture</strong></a> of two distributions: one roll of dice and the sum of two rolls of dice.</p>

<p>[^50]: An <em>affine transformation</em> is one that keeps straight lines straight and parallel lines parallel.</p>

<p>[^51]: Farach-Colton, M. and Tsai, M.T., 2015. Exact sublinear binomial sampling. <em>Algorithmica</em> 73(4), pp. 637-651.</p>

<p>[^52]: K. Bringmann, F. Kuhn, et al., “Internal DLA: Efficient Simulation of a Physical Growth Model.” In: <em>Proc. 41st International Colloquium on Automata, Languages, and Programming (ICALP&#39;14)</em>, 2014.</p>

<p>[^53]: Heaukulani, C., Roy, D.M., &quot;<a href="https://arxiv.org/abs/1908.06349v1"><strong>Black-box constructions for exchangeable sequences of random multisets</strong></a>&quot;, arXiv:1908.06349v1  [math.PR], 2019.  Note however that this reference defines a negative binomial distribution as the number of successes before N failures (not vice versa).</p>

<p>[^54]: Bringmann, K., and Friedrich, T., 2013, July. Exact and efficient generation of geometric random variates and random graphs, in <em>International Colloquium on Automata, Languages, and Programming</em> (pp. 267-278).</p>

<p>[^55]: Duchon, P., Duvignau, D., &quot;Preserving the number of cycles of length <em>k</em> in a growing uniform permutation&quot;, <em>Electronic Journal of Combinatorics</em> 23(4), 2016.</p>

<p>[^56]: Johnson and Kotz, &quot;Discrete Distributions&quot;, 1969.</p>

<p>[^57]: Smith, Noah A., and Roy W. Tromble. &quot;<a href="http://www.cs.cmu.edu/%7Enasmith/papers/smith+tromble.tr04.pdf"><strong>Sampling uniformly from the unit simplex</strong></a>.&quot; Johns Hopkins University, Tech. Rep 29 (2004).</p>

<p>[^58]: Durfee, et al., &quot;l1 Regression using Lewis Weights Preconditioning and Stochastic Gradient Descent&quot;, <em>Proceedings of Machine Learning Research</em> 75(1), 2018.</p>

<p>[^59]: The NVIDIA white paper &quot;<a href="https://docs.nvidia.com/cuda/floating-point/"><strong>Floating Point and IEEE 754 Compliance for NVIDIA GPUs</strong></a>&quot;,
and &quot;<a href="https://randomascii.wordpress.com/2013/07/16/floating-point-determinism/"><strong>Floating-Point Determinism</strong></a>&quot; by Bruce Dawson, discuss issues with floating-point numbers in much more detail.</p>

<p>[^60]: &quot;Uniform&quot; in quotes means, as close to the uniform distribution as possible for the number format.  Both bounds are excluded because mathematically, any specific real number from the uniform distribution occurs with probability 0.</p>

<p>[^61]: Boehm, Hans-J. &quot;Towards an API for the real numbers.&quot; In Proceedings of the 41st ACM SIGPLAN Conference on Programming Language Design and Implementation, pp. 562-576. 2020.</p>

<p>[^62]: This includes integers if <code>e</code> is limited to 0, and fixed-point numbers if <code>e</code> is limited to a single exponent less than 0.</p>

<p>[^63]: Downey, A. B. &quot;<a href="http://allendowney.com/research/rand/"><strong>Generating Pseudo-random Floating Point Values</strong></a>&quot;, 2007.</p>

<p>[^64]: Ideally, <code>X</code> is the highest integer <code>p</code> such that all multiples of <code>1/p</code> in the interval [0, 1] are representable in the number format in question.  For example, <code>X</code> is 2^53 (9007199254740992) for binary64, and 2^24 (16777216) for binary32.</p>

<p>[^65]: Goualard F. (2020) Generating Random Floating-Point Numbers by Dividing Integers: A Case Study. In: Krzhizhanovskaya V. et al. (eds) Computational Science – ICCS 2020. ICCS 2020. Lecture Notes in Computer Science, vol 12138. Springer, Cham. <a href="https://doi.org/10.1007/978-3-030-50417-5_2"><strong>https://doi.org/10.1007/978-3-030-50417-5_2</strong></a></p>

<p>[^66]: Monahan, J.F., &quot;Accuracy in Random Number Generation&quot;, <em>Mathematics of Computation</em> 45(172), 1985.</p>

<p>[^67]: Halmos, P.R., &quot;The theory of unbiased estimation&quot;, <em>Annals of Mathematical Statistics</em> 17(1), 1946.</p>

<p>[^68]: Spall, J.C., &quot;An Overview of the Simultaneous Perturbation Method for Efficient Optimization&quot;, <em>Johns Hopkins APL Technical Digest</em> 19(4), 1998, pp. 482-492.</p>

<p>[^69]: Owen, A.B., 2020. &quot;<a href="https://arxiv.org/abs/2008.08051"><strong>On dropping the first Sobol&#39; point</strong></a>&quot;, arXiv:2008.08051 [math-NA], 2020.</p>

<p>[^70]: P. L&#39;Ecuyer, &quot;Tables of Linear Congruential Generators of Different Sizes and Good Lattice Structure&quot;, <em>Mathematics of Computation</em> 68(225), January 1999, with <a href="http://www.iro.umontreal.ca/%7Elecuyer/myftp/papers/latrules99Errata.pdf"><strong>errata</strong></a>.</p>

<p>[^71]: Harase, S., &quot;<a href="https://arxiv.org/abs/2002.09006"><strong>A table of short-period Tausworthe generators for Markov chain quasi-Monte Carlo</strong></a>&quot;, arXiv:2002.09006 [math.NA], 2020.</p>

<p>[^72]: D. Revuz, M. Yor, &quot;Continuous Martingales and Brownian Motion&quot;, 1999.</p>

<p>[^73]: Lewis, P.W., Shedler, G.S., &quot;Simulation of nonhomogeneous Poisson processes by thinning&quot;, <em>Naval Research Logistics Quarterly</em> 26(3), 1979.</p>

<p>[^74]: Saucier, R. &quot;Computer Generation of Statistical Distributions&quot;, March 2000.</p>

<p>[^75]: Other references on density estimation include <a href="https://en.wikipedia.org/wiki/Multivariate_kernel_density_estimation"><strong>a Wikipedia article on multiple-variable kernel density estimation</strong></a>, and a <a href="https://web.archive.org/web/20160501200206/http://mark-kay.net/2013/12/24/kernel-density-estimation"><strong>blog post by M. Kay</strong></a>.</p>

<p>[^76]: &quot;Jitter&quot;, as used in this step, follows a distribution formally called a <em>kernel</em>, of which the normal distribution is one example.  <em>Bandwidth</em> should be set so that the estimated distribution fits the data and remains smooth.  A more complex kind of &quot;jitter&quot; (for multi-component data points) consists of a point generated from a <a href="https://en.wikipedia.org/wiki/Multivariate_normal_distribution"><strong>multinormal distribution</strong></a> with all the means equal to 0 and a <em>covariance matrix</em> that, in this context, serves as a <em>bandwidth matrix</em>.  &quot;Jitter&quot; and bandwidth are not further discussed in this document.</p>

<p>[^77]: A <em>discrete distribution</em> is a distribution that associates a countable number of items with a separate probability per item. These items are usually integers, but they need not be.  For example, the items can be non-integer values (for example, <code>x/y</code> with probability <code>x/(1+y)</code>) as long as the values can be converted to and from integers. Two examples:
    - A rational number in lowest terms can be converted to an integer by interleaving the bits of the numerator and denominator.
    - Integer-quantized numbers (popular in &quot;deep-learning&quot; neural networks) take a relatively small number of bits (usually 8 bits or even smaller).  An 8-bit quantized number format is effectively a &quot;look-up table&quot; that maps 256 integers to real numbers.</p>

<p>[^78]: This includes integers if <code>FPExponent</code> is limited to 0, and fixed-point numbers if <code>FPExponent</code> is limited to a single exponent less than 0.</p>

<p>[^79]: Saad, F.A., et al., &quot;<a href="https://arxiv.org/abs/2001.04555"><strong>Optimal Approximate Sampling from Discrete Probability Distributions</strong></a>&quot;, arXiv:2001.04555 [cs.DS], 2020.  See also the <a href="https://github.com/probcomp/optimal-approximate-sampling"><strong>associated source code</strong></a>.</p>

<p>[^80]: Walter, M., &quot;Sampling the Integers with Low Relative Error&quot;, in <em>International Conference on Cryptology in Africa</em>, Jul. 2019, pp. 157-180.</p>

<p>[^81]: Gerhard Derflinger, Wolfgang Hörmann, and Josef Leydold, &quot;Random variate generation by numerical inversion when only the density is known&quot;, ACM Transactions on Modeling and Computer Simulation 20(4) article 18, October 2010.</p>

<p>[^82]: Part of <code>numbers_from_u01</code> uses algorithms described in Arnas, D., Leake, C., Mortari, D., &quot;Random Sampling using k-vector&quot;, <em>Computing in Science &amp; Engineering</em> 21(1) pp. 94-107, 2019, and Mortari, D., Neta, B., &quot;k-Vector Range Searching Techniques&quot;.</p>

<p>[^83]: Devroye, L., &quot;Non-Uniform Random Variate Generation&quot;.  In <em>Handbooks in Operations Research and Management Science: Simulation</em>, Henderson, S.G., Nelson, B.L. (eds.), 2006, p.83.</p>

<p>[^84]: Sainudiin, Raazesh, and Thomas L. York. &quot;An Auto-Validating, Trans-Dimensional, Universal Rejection Sampler for Locally Lipschitz Arithmetical Expressions,&quot; <em>Reliable Computing</em> 18 (2013): 15-54.</p>

<p>[^85]: Tran, K.H., &quot;<a href="https://arxiv.org/abs/1607.01985v5"><strong>A Common Derivation for Markov Chain Monte Carlo Algorithms with Tractable and Intractable Targets</strong></a>&quot;, arXiv:1607.01985v5 [stat.CO], 2018, gives a common framework for describing many MCMC algorithms, including Metropolis&ndash;Hastings, slice sampling, and Gibbs sampling.</p>

<p>[^86]: Kschischang, Frank R. &quot;A Trapezoid-Ziggurat Algorithm for Generating Gaussian Pseudorandom Variates.&quot; (2019).</p>

<p>[^87]: Devroye, L., 1996, December, &quot;Random variate generation in one line of code&quot; In <em>Proceedings Winter Simulation Conference</em> (pp. 265-272). IEEE.</p>

<p>[^88]: Crooks, G.E., <a href="https://threeplusone.com/pubs/FieldGuide.pdf"><strong><em>Field Guide to Continuous Probability Distributions</em></strong></a>, 2019.</p>

<p>[^89]: McGrath, E.J., Irving, D.C., &quot;Techniques for Efficient Monte Carlo Simulation, Volume II&quot;, Oak Ridge National Laboratory, April 1975.</p>

<p>[^90]: Crooks, G.E., &quot;<a href="https://arxiv.org/abs/1005.3274v2"><strong>The Amoroso Distribution</strong></a>&quot;, arXiv:1005.3274v2 [math.ST], 2015.</p>

<p>[^91]: Kotz, Samuel, Tomasz Kozubowski, and Krzystof Podgorski. The Laplace distribution and generalizations: a revisit with applications to communications, economics, engineering, and finance. Springer Science &amp; Business Media, 2012.</p>

<p>[^92]: Devroye, L., &quot;Expected Time Analysis of a Simple Recursive Poisson Random Variate Generator&quot;, <em>Computing</em> 46, pp. 165-173, 1991.</p>

<p>[^93]: Bailey, R.W., &quot;Polar generation of random variates with the t distribution&quot;, <em>Mathematics of Computation</em> 62 (1994).</p>

<p>[^94]: Stein, W.E. and Keblis, M.F., &quot;A new method to simulate the triangular distribution&quot;, <em>Mathematical and Computer Modelling</em> 49(5-6), 2009, pp.1143-1147.</p>

<p>[^95]: Flajolet, P., Pelletier, M., Soria, M., &quot;<a href="https://arxiv.org/abs/0906.5560v2"><strong>On Buffon machines and numbers</strong></a>&quot;, arXiv:0906.5560v2  [math.PR], 2010.</p>

<p>[^96]: Makalic, E., Schmidt, D.F., &quot;<a href="https://arxiv.org/abs/1809.05212v2"><strong>An efficient algorithm for sampling from sin^k(x) for generating random correlation matrices</strong></a>&quot;, arXiv:1809.05212v2 [stat.CO], 2018.</p>

<p>[^97]: Ghorbanzadeh, D., Jaupi, L., Durand, P., &quot;<a href="https://www.scirp.org/html/24-7402277_47986.htm"><strong>A Method to Simulate the Skew Normal Distribution</strong></a>&quot;, <em>Applied Mathematics</em> 5(13), 2014.</p>

<p>[^98]: Baker, R., Jackson, D., &quot;<a href="https://arxiv.org/abs/1408.3237"><strong>A new distribution for robust least squares</strong></a>&quot;, arXiv:1408.3237 [stat.ME], 2018.</p>

<p>[^99]: Osada, R., Funkhouser, T., et al., &quot;Shape Distributions&quot;, _ACM Transactions on Graphics 21(4), Oct. 2002.</p>

<p>[^100]: Weisstein, Eric W.  &quot;<a href="http://mathworld.wolfram.com/HyperspherePointPicking.html"><strong>Hypersphere Point Picking</strong></a>&quot;.  From MathWorld&mdash;A Wolfram Web Resource.</p>

<p>[^101]: Voelker, A.R., Gosmann, J., Stewart, T.C., &quot;Efficiently sampling vectors and coordinates from the <em>n</em>-sphere and <em>n</em>-ball&quot;, Jan. 4, 2017.</p>

<p>[^102]: See the <em>Mathematics Stack Exchange</em> question titled &quot;Random multivariate in hyperannulus&quot;, <code>questions/1885630</code>.</p>

<p>[^103]: See the <em>Stack Overflow</em> question &quot;Uniform sampling (by volume) within a cone&quot;, <code>questions/41749411</code>. Square and cube roots replaced with maximums.</p>

<p>[^104]: Reference: <a href="http://mathworld.wolfram.com/SpherePointPicking.html"><strong>&quot;Sphere Point Picking&quot;</strong></a> in MathWorld (replacing inverse cosine with <code>atan2</code> equivalent).</p>

<p>[^105]: In the privacy context, see, for example, Awan, J. and Rao, V., 2021. &quot;<a href="https://arxiv.org/abs/2108.00965."><strong>Privacy-Aware Rejection Sampling</strong></a>&quot;, arXiv:2108.00965.</p>

<p>[^106]: For example, see Balcer, V., Vadhan, S., &quot;Differential Privacy on Finite Computers&quot;, Dec. 4, 2018; as well as Micciancio, D. and Walter, M., &quot;Gaussian sampling over the integers: Efficient, generic, constant-time&quot;, in Annual International Cryptology Conference, August 2017 (pp. 455-485).</p>

<p><a id=Appendix></a></p>

<h2>Appendix</h2>

<p>&nbsp;</p>

<p><a id=Sources_of_Random_Numbers></a></p>

<h3>Sources of Random Numbers</h3>

<p>All the randomization methods presented on this page assume that we have an endless source of numbers such that&mdash;</p>

<ul>
<li>the numbers follow a <em>uniform distribution</em>, and</li>
<li>each number is <em>chosen independently of any other choice</em>.</li>
</ul>

<p>That is, the methods assume we have a <strong>&quot;source of (uniform) random numbers&quot;</strong>. (Thus, none of these methods <em>generate</em> random numbers themselves, strictly speaking, but rather, they assume we have a source of them already.)</p>

<p>However, this is an ideal assumption which is hard if not impossible to achieve in practice.</p>

<p>Indeed, most applications make use of <em>pseudorandom number generators</em> (PRNGs), which are algorithms that produce <em>random-behaving</em> numbers, that is, numbers that simulate the ideal &quot;source of random numbers&quot; mentioned above. As a result, the performance and quality of the methods on this page will depend in practice on the quality of the PRNG (or other generator of random-behaving numbers) even if they don&#39;t in theory.</p>

<p>The &quot;source of random numbers&quot; can be simulated by a wide range of devices and programs, including PRNGs, so-called &quot;true random number generators&quot;, and application programming interfaces (APIs) that provide uniform random-behaving numbers to applications.  An application ought to choose devices or programs that simulate the &quot;source of random numbers&quot; well enough for its purposes, including in terms of their statistical quality,  &quot;unguessability&quot;, or both. However, it is outside this document&#39;s scope to give further advice on this choice.</p>

<p>The randomization methods in this document are deterministic (that is, they produce the same values given the same state and input), regardless of what simulates the &quot;source of random numbers&quot; (such as a PRNG or a &quot;true random number generator&quot;).  The exceptions are as follows:</p>

<ul>
<li>The methods do not &quot;know&quot; what numbers will be produced next by the &quot;source of random numbers&quot; (or by whatever is simulating that source).</li>
<li>A few methods read lines from files of unknown size; they won&#39;t &quot;know&quot; the contents of those lines before reading them.</li>
</ul>

<p><a id=Norm_Calculation></a></p>

<h3>Norm Calculation</h3>

<p>The following method calculates the norm of a vector (list of numbers), more specifically the &#x2113;<sub>2</sub> norm of that vector.</p>

<pre>METHOD Norm(vec)
  ret=0
  rc=0
  for i in 0...size(vec)
    rc=vec[i]*vec[i]-rc
    rt=rc+ret
    rc=(rt-ret)-rc
    ret=rt
  end
  return sqrt(ret)
END METHOD
</pre>

<p>There are other kinds of norms besides the &#x2113;<sub>2</sub> norm.  More generally, the &#x2113;<sub><em>p</em></sub> norm, where <em>p</em> is 1 or greater or is &infin; (infinity), is the <em>p</em><sup>th</sup> root of the sum of <em>p</em><sup>th</sup> powers of a vector&#39;s components&#39; absolute values (or, if <em>p</em> is &infin;, the highest absolute value among those components).  An &#x2113;<sub><em>p</em></sub> ball or sphere of a given radius is a ball or sphere that is bounded by or traces, respectively, all points with an &#x2113;<sub><em>p</em></sub> norm equal to that radius.  (An &#x2113;<sub>&infin;</sub> ball or sphere is box-shaped.)</p>

<p><a id=Implementation_Considerations></a></p>

<h3>Implementation Considerations</h3>

<ol>
<li><strong>Shell scripts and Microsoft Windows batch files</strong> are designed for running other programs, rather than general-purpose programming.  However, batch files and <code>bash</code> (a shell script interpreter) might support a variable which returns a uniformly distributed &quot;random&quot; integer in the interval [0, 32767] (called <code>%RANDOM%</code> or <code>$RANDOM</code>, respectively); neither variable is designed for information security. Whenever possible, the methods in this document should not be implemented in shell scripts or batch files, especially if information security is a goal.</li>
<li><strong>Query languages such as SQL</strong> have no procedural elements such as loops and branches.  Moreover, standard SQL has no way to choose a number at random, but popular SQL dialects often do &mdash; with idiosyncratic behavior &mdash; and describing differences between SQL dialects is outside the scope of this document. Whenever possible, the methods in this document should not be implemented in SQL, especially if information security is a goal.</li>
<li><strong>Stateless PRNGs.</strong> Most designs of pseudorandom number generators (PRNGs) in common use maintain an internal state and update that state each time they generate a pseudorandom number.  But for <a href="https://peteroupc.github.io/random.html#Designs_for_PRNGs"><strong><em>stateless</em> PRNG designs</strong></a> (including so-called &quot;splittable&quot; PRNGs), <code>RNDINT()</code>, <code>NEXTRAND()</code>, and other random sampling methods in this document may have to be adjusted accordingly (usually by adding an additional parameter).</li>
<li><strong>Multithreading.</strong> Multithreading can serve as a fast way to generate multiple random variates at once; it is not reflected in the pseudocode given in this page.  In general, this involves dividing a block of memory into chunks, assigning each chunk to a thread, giving each thread its own instance of a pseudorandom number generator (or another program that simulates a &quot;source of random numbers&quot;), and letting each thread fill its assigned chunk with random variates.  For an example, see &quot;<a href="https://docs.scipy.org/doc/numpy/reference/random/multithreading.html"><strong>Multithreaded Generation</strong></a>&quot;.</li>
<li><strong>Fixed amount of &quot;randomness&quot;.</strong> Given a <em>k</em>-bit integer <em>n</em> (which lies in the interval [0, 2<sup><em>k</em></sup>) and is chosen uniformly at random), values that approximate a probability distribution (for example, <code>Poisson</code>, <code>Normal</code>) can be generated with the integer <em>n</em> either by <a href="#Inverse_Transform_Sampling"><strong>finding the quantile for (<em>n</em>+1)/2<sup><em>k</em>+2</sup></strong></a> or by using <em>n</em> to help initialize a local PRNG and using the PRNG to generate a sample from that distribution. An application should use this suggestion only if it wants to ensure a fixed amount of &quot;randomness&quot; per sampled outcome is ultimately drawn, because the sampling method can return one of only 2<sup><em>k</em></sup> different outcomes this way. (In general, <em>n</em> can&#39;t be chosen uniformly at random with a <em>fixed</em> number of randomly chosen bits, unless the number of different outcomes for <em>n</em> is a power of 2.)</li>
</ol>

<p><a id=Security_Considerations></a></p>

<h3>Security Considerations</h3>

<p>If an application samples at random for information security purposes, such as to generate passwords or encryption keys at random, the following applies:</p>

<ol>
<li><strong>&quot;Cryptographic generators&quot;.</strong> The application has to use a device or program that generates random-behaving numbers that are hard to guess for information security purposes (a so-called &quot;cryptographic generator&quot;).  Choosing such a device or program is outside the scope of this document.</li>
<li><strong>Timing attacks.</strong>  Certain security and privacy attacks have exploited timing and other differences to recover cleartext, encryption keys, or other secret or private data.  Thus, security algorithms have been developed to have no timing differences, including memory access patterns, that reveal anything about any secret or private inputs, such as keys, passwords, or &quot;seeds&quot; for pseudorandom number generators.  (Such algorithms include so-called &quot;constant-time&quot; algorithms.)  But even if an algorithm has variable running time (for example, <a href="#Rejection_Sampling"><strong>rejection sampling</strong></a>), it may or may not have security-relevant timing differences, especially if it does not reuse secrets[^105].</li>
<li><strong>Security algorithms out of scope.</strong> Security algorithms that take random secrets to generate random security parameters, such as encryption keys, public/private key pairs, elliptic curves, or points on an elliptic curve, are outside this document&#39;s scope.</li>
<li><strong>Floating-point numbers.</strong>  Numbers chosen at random for security purposes are almost always integers (and, in very rare cases, fixed-point numbers). Even in the few security applications where those numbers are floating-point numbers (notably differential privacy and lattice-based cryptography), there are ways to avoid such floating-point numbers[^106].</li>
</ol>

<p><a id=License></a></p>

<h2>License</h2>

<p>Any copyright to this page is released to the Public Domain.  In case this is not possible, this page is also licensed under <a href="https://creativecommons.org/publicdomain/zero/1.0/"><strong>Creative Commons Zero</strong></a>.</p>
</div><nav id="navigation"><ul>
<li><a href="/">Back to start site.</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io">This site's repository (source code)</a>
<li><a href="https://github.com/peteroupc/peteroupc.github.io/issues">Post an issue or comment</a></ul>

<div class="noprint">
<p>
<a href="//twitter.com/intent/tweet">Share via Twitter</a>, <a href="//www.facebook.com/sharer/sharer.php" id="sharer">Share via Facebook</a>
</p>
</div>
</nav><script>
if("share" in navigator){
 document.getElementById("sharer").href="javascript:void(null)";
 document.getElementById("sharer").innerHTML="Share This Page";
 navigator.share({title:document.title,url:document.location.href}).then(
   function(){});
} else {
 document.getElementById("sharer").href="//www.facebook.com/sharer/sharer.php?u="+
    encodeURIComponent(document.location.href)
}
</script>
</body></html>
